lib str = <string.ssz>;
lib consts = <consts.ssz>;
lib mes = <alpha/mesdialog.ssz>;
lib m = <math.ssz>;
lib tbl = <table.ssz>;
lib sdl = <alpha/sdlplugin.ssz>;
lib soc = <socket.ssz>;
lib th = <thread.ssz>;
lib se = <alpha/sdlevent.ssz>;
lib file = <file.ssz>;
lib cfg = "../save/config.ssz";
lib com = "common.ssz";
lib al = <alert.ssz>;

public int max(int x, int y)
{
  ret x > y ? x : y;
}
public int min(int x, int y)
{
  ret x < y ? x : y;
}


|Key
{
  B, D, F, U, DB, UB, DF, UF,
  nB, nD, nF, nU, nDB, nUB, nDF, nUF,
  Bs, Ds, Fs, Us, DBs, UBs, DFs, UFs,
  nBs, nDs, nFs, nUs, nDBs, nUBs, nDFs, nUFs,
  a, b, c, x, y, z, q, w, e, s,
  na, nb, nc, nx, ny, nz, nq, nw, ne, ns,
}

public &Buffer
{
  public int Bb, Db, Fb, Ub;
  public int ab, bb, cb, xb, yb, zb, qb, wb, eb, sb;
  public byte B, D, F, U;
  public byte a, b, c, x, y, z, q, w, e, s, esc;
  new()
  {
    `reset();
  }
  public void input(
    bool B, bool D, bool F, bool U, bool a, bool b, bool c,
    bool x, bool y, bool z, bool q, bool w, bool e, bool s)
  {
    if((B&!F) != (`B>0)){`Bb = 0; `B *= -1;} `Bb += `B;
    if((D&!U) != (`D>0)){`Db = 0; `D *= -1;} `Db += `D;
    if((F&!B) != (`F>0)){`Fb = 0; `F *= -1;} `Fb += `F;
    if((U&!D) != (`U>0)){`Ub = 0; `U *= -1;} `Ub += `U;
    if(a != (`a>0)){`ab = 0; `a *= -1;} `ab += `a;
    if(b != (`b>0)){`bb = 0; `b *= -1;} `bb += `b;
    if(c != (`c>0)){`cb = 0; `c *= -1;} `cb += `c;
    if(x != (`x>0)){`xb = 0; `x *= -1;} `xb += `x;
    if(y != (`y>0)){`yb = 0; `y *= -1;} `yb += `y;
    if(z != (`z>0)){`zb = 0; `z *= -1;} `zb += `z;
	if(q != (`q>0)){`qb = 0; `q *= -1;} `qb += `q;
	if(w != (`w>0)){`wb = 0; `w *= -1;} `wb += `w;
	if(e != (`e>0)){`eb = 0; `e *= -1;} `eb += `e;
    if(s != (`s>0)){`sb = 0; `s *= -1;} `sb += `s;
  }
  public void reset()
  {
    `Bb = 0; `Db = 0; `Fb = 0; `Ub = 0;
    `ab = 0; `bb = 0; `cb = 0;
    `xb = 0; `yb = 0; `zb = 0;
	`qb = 0; `wb = 0; `eb = 0;`sb = 0;
    `B=-1; `D=-1; `F=-1; `U=-1;
    `a=-1; `b=-1; `c=-1;
    `x=-1; `y=-1; `z=-1;
	`q=-1; `w=-1; `e=-1; `s=-1; `esc=-1;
  }
  /int keyState(|.Key k)
  {
    switch(k){
    case .Key::B: ret .min(-.max(`Db, `Ub), `Bb);
    case .Key::D: ret .min(-.max(`Bb, `Fb), `Db);
    case .Key::F: ret .min(-.max(`Db, `Ub), `Fb);
    case .Key::U: ret .min(-.max(`Bb, `Fb), `Ub);
      //
    case .Key::DB: ret .min(`Db, `Bb);
    case .Key::UB: ret .min(`Ub, `Bb);
    case .Key::DF: ret .min(`Db, `Fb);
    case .Key::UF: ret .min(`Ub, `Fb);
      //
    case .Key::Bs: ret `Bb;
    case .Key::Ds: ret `Db;
    case .Key::Fs: ret `Fb;
    case .Key::Us: ret `Ub;
      //
    case .Key::DBs:
      ret .min(-.max(`Ub, `Fb), .max(`Db, `Bb));
    case .Key::UBs:
      ret .min(-.max(`Db, `Fb), .max(`Ub, `Bb));
    case .Key::DFs:
      ret .min(-.max(`Ub, `Bb), .max(`Db, `Fb));
    case .Key::UFs:
      ret .min(-.max(`Db, `Bb), .max(`Ub, `Fb));
      //
    case .Key::a: ret `ab;
    case .Key::b: ret `bb;
    case .Key::c: ret `cb;
    case .Key::x: ret `xb;
    case .Key::y: ret `yb;
    case .Key::z: ret `zb;
	case .Key::q: ret `qb;
	case .Key::w: ret `wb;
	case .Key::e: ret `eb;
    case .Key::s: ret `sb;
      //
    case .Key::nB: ret -.min(-.max(`Db, `Ub), `Bb);
    case .Key::nD: ret -.min(-.max(`Bb, `Fb), `Db);
    case .Key::nF: ret -.min(-.max(`Db, `Ub), `Fb);
    case .Key::nU: ret -.min(-.max(`Bb, `Fb), `Ub);
      //
    case .Key::nDB: ret -.min(`Db, `Bb);
    case .Key::nUB: ret -.min(`Ub, `Bb);
    case .Key::nDF: ret -.min(`Db, `Fb);
    case .Key::nUF: ret -.min(`Ub, `Fb);
      //
    case .Key::nBs: ret -`Bb;
    case .Key::nDs: ret -`Db;
    case .Key::nFs: ret -`Fb;
    case .Key::nUs: ret -`Ub;
      //
    case .Key::nDBs:
      ret -.min(-.max(`Ub, `Fb), .max(`Db, `Bb));
    case .Key::nUBs:
      ret -.min(-.max(`Db, `Fb), .max(`Ub, `Bb));
    case .Key::nDFs:
      ret -.min(-.max(`Ub, `Bb), .max(`Db, `Fb));
    case .Key::nUFs:
      ret -.min(-.max(`Db, `Bb), .max(`Ub, `Fb));
      //
    case .Key::na: ret -`ab;
    case .Key::nb: ret -`bb;
    case .Key::nc: ret -`cb;
    case .Key::nx: ret -`xb;
    case .Key::ny: ret -`yb;
    case .Key::nz: ret -`zb;
	case .Key::nq: ret -`qb;
	case .Key::nw: ret -`wb;
	case .Key::ne: ret -`eb;
    case .Key::ns: ret -`sb;
    }
    ret 0;
  }
  /int keyState2(|.Key k)
  {
    int foo(int a, int b, int c)
    {
      branch{
      cond a > 0: ret -.max(b, c);
      cond b > 0: ret -.max(a, c);
      cond c > 0: ret -.max(a, b);
      }
      ret -.max(a, .max(b, c));
    }
    switch(k){
    case .Key::Bs: ret `Bb < 0 ? `Bb : .min(#`Bb, .min(#`Db, #`Ub));
    case .Key::Ds: ret `Db < 0 ? `Db : .min(#`Db, .min(#`Bb, #`Fb));
    case .Key::Fs: ret `Fb < 0 ? `Fb : .min(#`Fb, .min(#`Db, #`Ub));
    case .Key::Us: ret `Ub < 0 ? `Ub : .min(#`Ub, .min(#`Bb, #`Fb));
      //
    case .Key::DBs:
      ret `keyState(.Key::DBs) < 0 ? `keyState(.Key::DBs) : .min(#`Db, #`Bb);
    case .Key::UBs:
      ret `keyState(.Key::UBs) < 0 ? `keyState(.Key::UBs) : .min(#`Ub, #`Bb);
    case .Key::DFs:
      ret `keyState(.Key::DFs) < 0 ? `keyState(.Key::DFs) : .min(#`Db, #`Fb);
    case .Key::UFs:
      ret `keyState(.Key::UFs) < 0 ? `keyState(.Key::UFs) : .min(#`Ub, #`Fb);
      //
    case .Key::nBs:
      ret foo(`keyState(.Key::B), `keyState(.Key::DB), `keyState(.Key::UB));
    case .Key::nDs:
      ret foo(`keyState(.Key::D), `keyState(.Key::DB), `keyState(.Key::DF));
    case .Key::nFs:
      ret foo(`keyState(.Key::F), `keyState(.Key::DF), `keyState(.Key::UF));
    case .Key::nUs:
      ret foo(`keyState(.Key::U), `keyState(.Key::UB), `keyState(.Key::UF));
      //
    case .Key::nDBs:
      ret foo(`keyState(.Key::DB), `keyState(.Key::D), `keyState(.Key::B));
    case .Key::nUBs:
      ret foo(`keyState(.Key::UB), `keyState(.Key::U), `keyState(.Key::B));
    case .Key::nDFs:
      ret foo(`keyState(.Key::DF), `keyState(.Key::D), `keyState(.Key::F));
    case .Key::nUFs:
      ret foo(`keyState(.Key::UF), `keyState(.Key::U), `keyState(.Key::F));
    }
    ret `keyState(k);
  }
  /int lastDirectionTime()
  {
     ret .min(#`Bb)<, .min(#`Db)<, .min(#`Fb)<, #`Ub;
 }
  /int lastChangeTime()
  {
    ret
      .min(`lastDirectionTime())<,
      .min(#`ab)<, .min(#`bb)<, .min(#`cb)<,
      .min(#`xb)<, .min(#`yb)<, .min(#`zb)<,
	  .min(#`qb)<, .min(#`wb)<, .min(#`eb)<, #`sb;
  }
}

public bool disablePadP1, disablePadP2;

|PlaybackState
{
  None, CtrlP2, Record, Play, Loop, Wait, End
}
public |.PlaybackState pbState;

public int pbCfgRecSlot = 1, pbCfgPlaySlot = 1, pbCfgPlayOrder = 0;
public bool pbCfgPlayLoop = false;
public ^bool pbCfgSlot;
.pbCfgSlot.new(5);

public bool modKeyState(bool keyState, int jn, int key)
{
  bool ctrl = .sdl.JoystickButtonState(:-1, 224:) || .sdl.JoystickButtonState(:-1, 228:);
  branch{
  cond !keyState: ret true;
  else:
    branch{
    cond !.str.equ(.com.gameMode,"practice") && .com.gameState == 1:
      ret false;
    cond jn > -1:
      ret false;
    cond key != 6 && key != 15 && key != 19 && key != 21 && key != 22 && key != 25:
      ret false;
    cond !(ctrl && (((.sdl.JoystickButtonState(:-1, 6:) || .sdl.JoystickButtonState(:-1, 15:) || .sdl.JoystickButtonState(:-1, 19:) || .sdl.JoystickButtonState(:-1, 21:) || .sdl.JoystickButtonState(:-1, 22:)) && .com.gameState == 1) || (.sdl.JoystickButtonState(:-1, 25:) && .com.gameState == 0))):
      ret false;
    else:
      ret true;
    }
  }
  ret true;
}

//OLD
//public bool modKeyState(bool keyState, int jn, int key)
//{
  //bool ctrl = .sdl.JoystickButtonState(:-1, 224:) || .sdl.JoystickButtonState(:-1, 228:);
  //branch{
  //cond !keyState: ret true;
  //else:
    //branch{
    //cond jn > -1:
      //ret false;
    //cond !(ctrl && (((.sdl.JoystickButtonState(:-1, 6:) || .sdl.JoystickButtonState(:-1, 15:) || .sdl.JoystickButtonState(:-1, 22:)) && .com.gameState == 1) || (.sdl.JoystickButtonState(:-1, 25:) && .com.gameState == 0))):
      //ret false;
    //cond key != 6 && key != 15 && key != 22 && key != 25:
      //ret false;
    //cond !.str.equ(.com.gameMode,"practice") && .com.gameState == 1:
      //ret false;
    //else:
      //ret true;
    //}
  //}
  //ret true;
//}

&KeyInfo
{
  const int U = 1<<0, D = 1<<1, L = 1<<2, R = 1<<3;
  const int A = 1<<4, B = 1<<5, C = 1<<6;
  const int X = 1<<7, Y = 1<<8, Z = 1<<9, Q = 1<<10, W = 1<<11, E = 1<<12, S = 1<<13;
  public int stat = 0;
  public bool setLocalIn(int in)
  {
    if(!.m.inRange!int?(0, #.cfg.in-1, in)) ret false;
    int pn = in +.com.sysControls;
    int jn = .cfg.in[pn].jn;
    if(jn < -1) ret false;
    `stat =
      (int).sdl.JoystickButtonState(:jn, .cfg.in[pn].u:)
	  | ((int).sdl.JoystickButtonState(:.cfg.in[pn+2].jn, .cfg.in[pn+2].u:) & (int)(pn == (.com.sysControls) ? (.disablePadP1 == false) : pn == (.com.sysControls + 1) ? (.disablePadP2 == false) : true))
      | (int).sdl.JoystickButtonState(:jn, .cfg.in[pn].d:) << 1
	  | ((int).sdl.JoystickButtonState(:.cfg.in[pn+2].jn, .cfg.in[pn+2].d:) & (int)(pn == (.com.sysControls) ? (.disablePadP1 == false) : pn == (.com.sysControls + 1) ? (.disablePadP2 == false) : true)) << 1
      | (int).sdl.JoystickButtonState(:jn, .cfg.in[pn].l:) << 2
      | ((int).sdl.JoystickButtonState(:.cfg.in[pn+2].jn, .cfg.in[pn+2].l:) & (int)(pn == (.com.sysControls) ? (.disablePadP1 == false) : pn == (.com.sysControls + 1) ? (.disablePadP2 == false) : true)) << 2
      | (int).sdl.JoystickButtonState(:jn, .cfg.in[pn].r:) << 3
      | ((int).sdl.JoystickButtonState(:.cfg.in[pn+2].jn, .cfg.in[pn+2].r:) & (int)(pn == (.com.sysControls) ? (.disablePadP1 == false) : pn == (.com.sysControls + 1) ? (.disablePadP2 == false) : true)) << 3
      | (int).sdl.JoystickButtonState(:jn, .cfg.in[pn].a:) << 4
      | ((int).sdl.JoystickButtonState(:.cfg.in[pn+2].jn, .cfg.in[pn+2].a:) & (int)(pn == (.com.sysControls) ? (.disablePadP1 == false) : pn == (.com.sysControls + 1) ? (.disablePadP2 == false) : true)) << 4
      | (int).sdl.JoystickButtonState(:jn, .cfg.in[pn].b:) << 5
      | ((int).sdl.JoystickButtonState(:.cfg.in[pn+2].jn, .cfg.in[pn+2].b:) & (int)(pn == (.com.sysControls) ? (.disablePadP1 == false) : pn == (.com.sysControls + 1) ? (.disablePadP2 == false) : true)) << 5
      | (int).sdl.JoystickButtonState(:jn, .cfg.in[pn].c:) << 6
      | ((int).sdl.JoystickButtonState(:.cfg.in[pn+2].jn, .cfg.in[pn+2].c:) & (int)(pn == (.com.sysControls) ? (.disablePadP1 == false) : pn == (.com.sysControls + 1) ? (.disablePadP2 == false) : true)) << 6
      | (int).sdl.JoystickButtonState(:jn, .cfg.in[pn].x:) << 7
      | ((int).sdl.JoystickButtonState(:.cfg.in[pn+2].jn, .cfg.in[pn+2].x:) & (int)(pn == (.com.sysControls) ? (.disablePadP1 == false) : pn == (.com.sysControls + 1) ? (.disablePadP2 == false) : true)) << 7
      | (int).sdl.JoystickButtonState(:jn, .cfg.in[pn].y:) << 8
      | ((int).sdl.JoystickButtonState(:.cfg.in[pn+2].jn, .cfg.in[pn+2].y:) & (int)(pn == (.com.sysControls) ? (.disablePadP1 == false) : pn == (.com.sysControls + 1) ? (.disablePadP2 == false) : true)) << 8
      | (int).sdl.JoystickButtonState(:jn, .cfg.in[pn].z:) << 9
      | ((int).sdl.JoystickButtonState(:.cfg.in[pn+2].jn, .cfg.in[pn+2].z:) & (int)(pn == (.com.sysControls) ? (.disablePadP1 == false) : pn == (.com.sysControls + 1) ? (.disablePadP2 == false) : true)) << 9
	  | (int).sdl.JoystickButtonState(:jn, .cfg.in[pn].q:) << 10
      | ((int).sdl.JoystickButtonState(:.cfg.in[pn+2].jn, .cfg.in[pn+2].q:) & (int)(pn == (.com.sysControls) ? (.disablePadP1 == false) : pn == (.com.sysControls + 1) ? (.disablePadP2 == false) : true)) << 10
	  | (int).sdl.JoystickButtonState(:jn, .cfg.in[pn].w:) << 11
      | ((int).sdl.JoystickButtonState(:.cfg.in[pn+2].jn, .cfg.in[pn+2].w:) & (int)(pn == (.com.sysControls) ? (.disablePadP1 == false) : pn == (.com.sysControls + 1) ? (.disablePadP2 == false) : true)) << 11
	  | (int).sdl.JoystickButtonState(:jn, .cfg.in[pn].e:) << 12
      | ((int).sdl.JoystickButtonState(:.cfg.in[pn+2].jn, .cfg.in[pn+2].e:) & (int)(pn == (.com.sysControls) ? (.disablePadP1 == false) : pn == (.com.sysControls + 1) ? (.disablePadP2 == false) : true)) << 12
      | (int).sdl.JoystickButtonState(:jn, .cfg.in[pn].s:) << 13
      | ((int).sdl.JoystickButtonState(:.cfg.in[pn+2].jn, .cfg.in[pn+2].s:) & (int)(pn == (.com.sysControls) ? (.disablePadP1 == false) : pn == (.com.sysControls + 1) ? (.disablePadP2 == false) : true)) << 13;
    ret true;
  }
  /void input(&.Buffer b=, int f)
  {
    b.input(
      f < 0 ? (`stat&`R) != 0 : (`stat&`L) != 0,
      (`stat&`D) != 0,
      f < 0 ? (`stat&`L) != 0 : (`stat&`R) != 0,
      (`stat&`U) != 0,
      (`stat&`A) != 0, (`stat&`B) != 0, (`stat&`C) != 0,
      (`stat&`X) != 0, (`stat&`Y) != 0, (`stat&`Z) != 0,
      (`stat&`Q) != 0, (`stat&`W) != 0, (`stat&`E) != 0, (`stat&`S) != 0);
  }
  /bool anybutton()
  {
    ret (`stat & (`A|`B|`C|`X|`Y|`Z)) != 0;
  }
  /bool startbutton()
  {
    ret (`stat & (`S|`S|`S|`S|`S|`S)) != 0;
  }
}

&KeyBuffer
{
  public ^&.KeyInfo data;
  /index timec = 0, timei = 0, times = 0;
  new()
  {
    `data.new(32);
  }
  public void reset(int time)
  {
    `timec = `timei = `times = time;
  }
  public bool localUpdate(int in)
  {
    if(`timei - `timec >= 32) ret true;
    bool b = `data[`timei&31].setLocalIn(in);
    `timei++;
    ret b;
  }
  public int remoteUpdate(&.soc.Socket s=)
  {
    if(`timei - `timec >= 32) ret 1;
    bool b = s.recv!int?(`data[`timei&31].stat=);
    if(`data[`timei&31].stat < 0) ret -1;
    `times = ++`timei;
    ret (int)b;
  }
  public bool sendInput(&.soc.Socket s=)
  {
    if(`times >= `timei) ret true;
    bool b = s.send!int?(`data[`times&31].stat=);
    `times++;
    ret b;
  }
  public bool input(&.Buffer b=, int f)
  {
    if(`timec >= `timei) ret false;
    `data[`timec&31].input(b=, f);
    ret true;
  }
  public void setCurTime(int ct)
  {
    `timec = ct;
  }
}

|NetState
{
  Stop, Playing, End, Stoped, Error
}

void sendThread(^&.soc.Socket s, ^&.KeyBuffer k, ^|.NetState st)
{
  loop{while; do:
    if(!k~sendInput(s<>=)){
      st<> = .NetState::Error;
      ret;
    }
    .th.sleep(0x1);
  while st<> == .NetState::Playing:
    {
      int tmp = -1;
      s~send!int?(tmp=);
    }
  }
}

void recvThread(^&.soc.Socket s, ^&.KeyBuffer k, ^|.NetState st)
{
  loop{
    int n;
    while;
  do:
    if((n = k~remoteUpdate(s<>=)) <= 0){
      st<> = n == 0 ? .NetState::Error : .NetState::Stoped;
      ret;
    }
    .th.sleep(0x1);
  while st<> == .NetState::Playing:
    loop{
      int tmp;
    do:
      if(!s~recv!int?(tmp=)) break;
    while tmp != -1:}
  }
}

void acceptThread(^&.soc.Socket liso, ^&.soc.Socket s, ^bool cansel)
{
  loop{do:
    if(liso~accept(s<>=, 1, true)) break;
  while !cansel<>:}
  liso~close();
}

void connectThread(^&.soc.Socket s, ^/char serv, ^/char port, ^bool cansel)
{
  loop{
    int n = 1, next = n;
  do:
    if(n++ >= next){
      next <<= 1;
      if(s~connect(serv, port, 30, true)) break, break;
    }
    .th.sleep(0x1000);
  while !cansel<>:}
}

public &NetInput
{
  ^&.soc.Socket liso, so;
  ^|.NetState st;
  thread!.sendThread? sen;
  thread!.recvThread? rec;
  thread!.acceptThread? acc;
  thread!.connectThread? con;
  %&.KeyBuffer kb;
  /index lo = 0, re = 0;
  int time = 0;
  int stopedcnt = 0, delay = 0;
  ^bool cansel;
  &.file.File rep;
  /bool host;
  new()
  {
    `liso.new(1);
    `so.new(1);
    `st.new(1);
    `st<> = .NetState::Stop;
    `cansel.new(1);
    `cansel<> = false;
    `host = false;
  }
  delete()
  {
    `cansel<> = true;
    `end();
  }
  void setlore(index ho=, index ge=)
  {
    ho = ge = -1;
    `kb.new(#.com.com);
    loop{index i = 0; while; do:
      if(.com.com[i] == 0) branch{
      cond ho < 0:
        ho = i;
      cond ge < 0:
        ge = i;
      }
      i++;
    while i < #.com.com:}
    if(ho < 0) ho = 0;
    if(ge < 0) ge = (ho+1) % #.com.com;
  }
  public bool openReplayFile(^/char replay)
  {
    ret `rep.open(replay, "wb");
  }
  public bool accept(^/char port)
  {
    if(!`liso~listen(port, 1, true)) ret false;
    `host = true;
    `setlore(`lo=, `re=);
    `cansel<> = false;
    `acc..(`liso, `so, `cansel);
    ret true;
  }
  public void connect(^/char serv, ^/char port)
  {
    `host = false;
    `setlore(`re=, `lo=);
    `cansel<> = false;
    `con..(`so, serv, port, `cansel);
  }
  public bool isConnected()
  {
    ret `so~isOpen();
  }
  public void stop()
  {
    if(.se.esc){
      `end();
      ret;
    }
    if(`st<> != .NetState::End && `st<> != .NetState::Error){
      `st<> = .NetState::Stop;
    }
    <wait>(`sen, `rec);
  }
  public void end()
  {
    if(`st<> != .NetState::Error) `st<> = .NetState::End;
    <wait>(`sen, `rec);
  }
  public bool synchronize()
  {
    if(!`isConnected() || `st<> == .NetState::Error) ret false;
    `stop();
    int seed;
    branch{
    cond `host:
      seed = .m.random();
      if(!`so~send!int?(seed=)) ret false;
    else:
      if(!`so~recv!int?(seed=)) ret false;
    }
    .m.srand(seed);
    `rep.write!int?(seed=);
    int tmp;
    if(!`so~send!int?(`time=)) ret false;
    if(!`so~recv!int?(tmp=) || tmp != `time) ret false;
    `kb[`lo].reset(`time);
    `kb[`re].reset(`time);
    `st<> = .NetState::Playing;
    `sen..(`so, `kb[`lo..`lo+1], `st);
    `rec..(`so, `kb[`re..`re+1], `st);
    `update();
    ret true;
  }
  public bool input(&.Buffer b=, int in, int f)
  {
    if(!.m.inRange!int?(0, #`kb-1, in)) ret false;
    ret `kb[.com.inputRemap[in]].input(b=, f);
  }
  public bool anybutton()
  {
    loop{index i = 0; while; do:
      if(`kb[i].data[`kb[i].timec&31].anybutton()) ret true;
      i++;
    while i < #`kb:}
    ret false;
  }
  public bool startbutton()
  {
    loop{index i = 0; while; do:
      if(`kb[i].data[`kb[i].timec&31].startbutton()) ret true;
      i++;
    while i < #`kb:}
    ret false;
  }
  public bool update()
  {
    if(`st<> != .NetState::Stoped) `stopedcnt = 0;
    if(!.se.end) switch(`st<>){
    case .NetState::Stoped:
      if(++`stopedcnt > 60){
        `st<> = .NetState::End;
        break, break;
      }
    case .NetState::Playing:<-
      loop{
        int foo;
        continue;
      do:
        if(.se.esc || !.se.event(60) || `st<> != .NetState::Playing){
          break, break;
        }
      continue:
        foo = .m.min!int?(`kb[`lo].times, `kb[`re].times);
        branch{
          int tmp = (`kb[`re].timei + (`delay >> 3)) - `kb[`lo].timei;
        cond tmp >= 0:
          `kb[`lo].localUpdate(0);
          if(`delay > 0) `delay--;
        cond tmp < -1:
          `delay += 4;
        }
      while `time >= foo:
        `kb[`lo].setCurTime(`time);
        `kb[`re].setCurTime(`time);
        loop{index i = 0; while; do:
          `rep.write!&.KeyInfo?(`kb[i].data[`time&31]=);
          i++;
        while i < #`kb:}
        if(++`time >= foo) `kb[`lo].localUpdate(0);
      }
    case .NetState::End, .NetState::Error:
      .se.esc = true;
    }
    if(.se.esc) `end();
    ret !.se.end;
  }
}

public ^&NetInput net;

public int rFacing, pbFacing;

public &FileInput
{
  &.file.File f;
  ^&.KeyInfo ki;
  new()
  {
    `ki.new(#.com.com);
  }
  public void open(^/char fn)
  {
    `f.open(fn, "rb");
  }
  public bool synchronize()
  {
    int seed;
    if(!`f.read!int?(seed=)) ret false;
    .m.srand(seed);
    `update();
    ret true;
  }
  public bool init()
  {
    int facing;
    if(!`f.read!int?(facing=)) ret false;
    .pbFacing = facing;
    `update();
    ret true;
  }
  public bool input(&.Buffer b=, int in, int f)
  {
    if(!.m.inRange!int?(0, #`ki-1, in)) ret false;
    `ki[.com.inputRemap[in]].input(b=, f);
    ret true;
  }
  public bool anybutton()
  {
    loop{index i = 0; while; do:
      if(`ki[i].anybutton()) ret true;
      i++;
    while i < #`ki:}
    ret false;
  }
  public bool startbutton()
  {
    loop{index i = 0; while; do:
      if(`ki[i].startbutton()) ret true;
      i++;
    while i < #`ki:}
    ret false;
  }
  public bool update()
  {
    if(
      .com.oldNextAddTime > 0.0
      && `f.readAry!&.KeyInfo?(`ki) < #`ki){
      branch{
      cond .pbState != .PlaybackState::Play:
        .se.esc = true;
        if(.com.gameState == 1) .com.exitMatch = true;
      else:
        `f.close();
        .pbState = .pbCfgPlayLoop ? .PlaybackState::Loop : .PlaybackState::Wait;
      }
    }
    if((.se.esc && (.com.pause || #.net > 0 || .com.gameState == 0)) || .com.exitMatch) {
      `f.close();
    }
    ret !.se.end;
  }
}

public ^&FileInput replay, pbRep;

&AiInput
{
  int muki = 0, st = 0, ab = 0, bb = 0, cb = 0, xb = 0, yb = 0, zb = 0, qb = 0, wb = 0, eb = 0, sb = 0;
  public void update()
  {
    int osu = 15, hanasu = 60;
    bool sub(int t=)
    {
      if(--t <= 0){
        if(.m.rand(1, `osu) == 1){
          t = .m.rand(1, `hanasu);
          ret true;
        }
        t = 0;
      }
      ret false;
    }
    if(sub(`st=)) `muki = .m.rand(0, 10); //.m.rand(0, 7)
    osu = hanasu = 30;
    sub(`ab=);sub(`bb=);sub(`cb=);sub(`xb=);sub(`yb=);sub(`zb=);sub(`qb=);sub(`wb=);sub(`eb=);
    osu = 3600;
    sub(`sb=);
    if(.com.intro != 0) `st = `ab = `bb = `cb = `xb = `yb = `zb = `qb = `wb = `eb = `sb = 0;
  }
  /bool l()
  {
    ret `st != 0 && (`muki == 5 || `muki == 6 || `muki == 7);
  }
  /bool r()
  {
    ret `st != 0 && (`muki == 1 || `muki == 2 || `muki == 3);
  }
  /bool u()
  {
    ret `st != 0 && (`muki == 7 || `muki == 0 || `muki == 1);
  }
  /bool d()
  {
    ret `st != 0 && (`muki == 3 || `muki == 4 || `muki == 5);
  }
  /bool a()
  {
    ret `ab != 0;
  }
  /bool b()
  {
    ret `bb != 0;
  }
  /bool c()
  {
    ret `cb != 0;
  }
  /bool x()
  {
    ret `xb != 0;
  }
  /bool y()
  {
    ret `yb != 0;
  }
  /bool z()
  {
    ret `zb != 0;
  }
  /bool q()
  {
    ret `qb != 0;
  }
  /bool w()
  {
    ret `wb != 0;
  }
  /bool e()
  {
    ret `eb != 0;
  }
  /bool s()
  {
    ret `sb != 0;
  }
}

%&AiInput aiil;

public &PlaybackInput
{
  %&.KeyBuffer kb;
  /index lo = 0, re = 0;
  int time = 0, delay = 0;
  &.file.File rep;
  void setlore(index ho=, index ge=)
  {
    ho = ge = -1;
    `kb.new(#.com.com);
    loop{index i = 0; while; do:
      if(.com.com[i] == 0) branch{
      cond ho < 0:
        ho = i;
      cond ge < 0:
        ge = i;
      }
      i++;
    while i < #.com.com:}
    if(ho < 0) ho = 0;
    if(ge < 0) ge = (ho+1) % #.com.com;
  }
  public bool openReplayFile(^/char replay)
  {
    ret `rep.open(replay, "wb");
  }
  public bool init(int f)
  {
    `setlore(`re=, `lo=);
    `kb[`lo].reset(`time);
    `kb[`re].reset(`time);
    %int facing .= f;
    `rep.writeAry!int?(facing);
    `update();
    ret true;
  }
  public bool input(&.Buffer b=, int in, int f)
  {
    if(!.m.inRange!int?(0, #`kb-1, in)) ret false;
    ret `kb[.com.inputRemap[in]].input(b=, f);
  }
  public bool anybutton()
  {
    loop{index i = 0; while; do:
      if(`kb[i].data[`kb[i].timec&31].anybutton()) ret true;
      i++;
    while i < #`kb:}
    ret false;
  }
  public bool update()
  {
    branch{
      int tmp = (`kb[`re].timei + (`delay >> 3)) - `kb[`lo].timei;
    cond tmp >= 0:
      `kb[`lo].localUpdate(0);
      if(`delay > 0) `delay--;
    cond tmp < -1:
      `delay += 4;
    }
    `kb[`lo].setCurTime(`time);
    `kb[`re].setCurTime(`time);
    loop{index i = 0; while; do:
      `rep.write!&.KeyInfo?(`kb[i].data[`time&31]=);
      i++;
    while i < #`kb:}
    if(++`time >= 0) `kb[`lo].localUpdate(0);
    ret !.se.end;
  }
}

public ^&PlaybackInput pbRec;

public bool update()
{
  branch{
  cond #.replay > 0:
    .se.event(.anyHardButton() ? 240 : 60);
    ret .replay~update();
  cond #.net > 0:
    .se.event(60);
    ret .net~update();
  cond #.pbRec > 0 && .com.sysControls == 0:
    .se.event(60);
    ret .pbRec~update();
  cond #.pbRep > 0:
    .se.event(60);
    ret .pbRep~update();
  }
  ret .se.event(60);
}

public bool synchronize()
{
  branch{
  cond #.replay > 0:
    .replay~synchronize();
  cond #.net > 0:
    if(!.net~synchronize()) ret false;
  }
  ret true;
}

public |Key  a,  b,  c,  x,  y,  z,  q,  w,  e,  s; //DON'T USE "m" because you get error
public |Key na, nb, nc, nx, ny, nz, nq, nw, ne, ns;
resetReadKeymap();
public void resetReadKeymap()
{
  . a = .Key:: a; . b = .Key:: b; . c = .Key:: c;
  . x = .Key:: x; . y = .Key:: y; . z = .Key:: z;
  . q = .Key:: q; . w = .Key:: w; . e = .Key:: e; . s = .Key:: s; //DON'T USE "m" because you get error
  .na = .Key::na; .nb = .Key::nb; .nc = .Key::nc;
  .nx = .Key::nx; .ny = .Key::ny; .nz = .Key::nz;
  .nq = .Key::nq; .nw = .Key::nw; .ne = .Key::ne; .ns = .Key::ns;
}

public &Command
{
  &CmdButton
  {
    public %|.Key key;
    public int tametime = 1;
    public bool slash = false, greater = false, direction = false;
    public bool padding = false;
    /bool isDirection()
    {
      ret !`slash && #`key == 1 && `key[0] < .Key::a;
    }
    public void clear()
    {
      `key.new(0);
      `tametime = 1;
      `slash = false;
      `greater = false;
      `direction = false;
    }
  }
  public ^/char name;
  public %^/|.Key hold;
  public ^bool held;
  public %&CmdButton cmd;
  public index cmdidx = 0, tameidx = -1;
  public int time = 1, current = 0;
  public int buffertime = 1, curbuftime = 0;
  public void readCmd(^/char cmdstr)
  {
    char nextChar(^/char s, index i=)
    {
      loop{while; do:
        if(!.str.cMatch!char?(.str.blank, s[i])) ret s[i];
        i++;
      while i < #s:}
      ret '\0';
    }
    `cmd.new(0);
    `hold.new(0);
    ^^/char cmds = .str.split(",", cmdstr);
    loop{
      index i = 0, j = 0;
      bool tilde = false;
      while;
    do:
      branch{
      cond #`cmd > 0 && `cmd[-1].slash:
        `hold .= `cmd[-1].key;
        `cmd[-1].clear();
      else:
        `cmd.new[-1];
      }
      i = 0;
      switch(nextChar(cmds[j], i=)){
      case '>':
        `cmd[-1].greater = true;
        i++;
        switch(nextChar(cmds[j], i=)){
        case '/':
          `cmd[-1].slash = true;
          i++;
        default:<-
          break, break;
        case '~':
        }
      case '~':<-
        tilde = true;
        loop{
          i++;
          int n = 0;
          while;
        do:
          n = n*10 + (int)(cmds[j][i] -'0');
          i++;
        while i < #cmds[j] && '0' <= cmds[j][i] && cmds[j][i] <= '9':
          if(n > 0) `cmd[-1].tametime = n;
        }
      case '/':
        `cmd[-1].slash = true;
        i++;
      }
      loop{while; do:
        switch(nextChar(cmds[j], i=)){
        case 'B':
          `cmd[-1].key .= (tilde ? .Key::nB : .Key::B);
          tilde = false;
        case 'D':
          branch{
          cond cmds[j][i+1] == 'B':
            i++;
            `cmd[-1].key .= (tilde ? .Key::nDB : .Key::DB);
          cond cmds[j][i+1] == 'F':
            i++;
            `cmd[-1].key .= (tilde ? .Key::nDF : .Key::DF);
          else:
            `cmd[-1].key .= (tilde ? .Key::nD : .Key::D);
          }
          tilde = false;
        case 'F':
          `cmd[-1].key .= (tilde ? .Key::nF : .Key::F);
          tilde = false;
        case 'U':
          branch{
          cond cmds[j][i+1] == 'B':
            i++;
            `cmd[-1].key .= (tilde ? .Key::nUB : .Key::UB);
          cond cmds[j][i+1] == 'F':
            i++;
            `cmd[-1].key .= (tilde ? .Key::nUF : .Key::UF);
          else:
            `cmd[-1].key .= (tilde ? .Key::nU : .Key::U);
          }
          tilde = false;
          //
        case 'a': `cmd[-1].key .= (tilde ? .na : .a); tilde = false;
        case 'b': `cmd[-1].key .= (tilde ? .nb : .b); tilde = false;
        case 'c': `cmd[-1].key .= (tilde ? .nc : .c); tilde = false;
        case 'x': `cmd[-1].key .= (tilde ? .nx : .x); tilde = false;
        case 'y': `cmd[-1].key .= (tilde ? .ny : .y); tilde = false;
        case 'z': `cmd[-1].key .= (tilde ? .nz : .z); tilde = false;
		case 'q': `cmd[-1].key .= (tilde ? .nq : .q); tilde = false;
		case 'w': `cmd[-1].key .= (tilde ? .nw : .w); tilde = false;
		case 'e': `cmd[-1].key .= (tilde ? .ne : .e); tilde = false; //DON'T USE "m" because you get error
        case 's': `cmd[-1].key .= (tilde ? .ns : .s); tilde = false;
          //
        case '$':
          i++;
          switch(nextChar(cmds[j], i=)){
          case 'B':
            `cmd[-1].key .= (tilde ? .Key::nBs : .Key::Bs);
            tilde = false;
          case 'D':
            branch{
            cond cmds[j][i+1] == 'B':
              i++;
              `cmd[-1].key .= (tilde ? .Key::nDBs : .Key::DBs);
            cond cmds[j][i+1] == 'F':
              i++;
              `cmd[-1].key .= (tilde ? .Key::nDFs : .Key::DFs);
            else:
              `cmd[-1].key .= (tilde ? .Key::nDs : .Key::Ds);
            }
            tilde = false;
          case 'F':
            `cmd[-1].key .= (tilde ? .Key::nFs : .Key::Fs);
            tilde = false;
          case 'U':
            branch{
            cond cmds[j][i+1] == 'B':
              i++;
              `cmd[-1].key .= (tilde ? .Key::nUBs : .Key::UBs);
            cond cmds[j][i+1] == 'F':
              i++;
              `cmd[-1].key .= (tilde ? .Key::nUFs : .Key::UFs);
            else:
              `cmd[-1].key .= (tilde ? .Key::nUs : .Key::Us);
            }
            tilde = false;
          default:
            //error
            i--;
          }
          //
        case '~':
          tilde = true;
        case '+':
        default:
          //error
        }
        i++;
      while i < #cmds[j]:}
      if(
        #`cmd >= 2 && `cmd[-1].isDirection()
        && `cmd[#`cmd - 2].isDirection())
      {
        `cmd[-1].direction = true;
      }
      j++;
    while j < #cmds:
      if(`cmd[-1].slash) `hold .= `cmd[-1].key;
    }
    `held.new(#`hold);
    `held:<-[void(h=){h = false;}];
  }
  bool isDToB(&`CmdButton cmd1, &`CmdButton cmd2)
  {:<-
    bool foo(&`CmdButton cmd1, &`CmdButton cmd2)
    {
      if(#cmd1.key != #cmd2.key) ret true;
      loop{index i = 0; while; do:
        if(
          cmd1.key[i] != cmd2.key[i] && !(
            (
              .m.inRange!|.Key?(.Key::B, .Key::UF, cmd1.key[i])
              || .m.inRange!|.Key?(.Key::Bs, .Key::UFs, cmd1.key[i]))
            && (
              .m.inRange!|.Key?(.Key::B, .Key::UF, cmd2.key[i])
              || .m.inRange!|.Key?(.Key::Bs, .Key::UFs, cmd2.key[i]))))
        {
          ret true;
        }
        i++;
      while i < #cmd1.key:}
      ret false;
    }
    if(cmd2.slash) ret false;
    loop{index i = 0; while; do:
      if(cmd1.key[i] < .Key::a) break;
      i++;
    while i < #cmd1.key:
      ret false;
    }
    ret foo(cmd1, cmd2);
  }
  bool cmdChek(&.Buffer kbuf, bool ai, ^bool holdTemp=)
  {
    bool anyHeld = false;
    ~$bool() fail = [bool(){
      branch{
      cond `cmdidx == 0:
        ret anyHeld;
      else:
        if(!ai && (`cmd[`cmdidx].greater || `cmd[`cmdidx].direction)) loop{
          index j = 0;
          int t =
            `cmd[`cmdidx].greater
            ? kbuf.lastChangeTime() : kbuf.lastDirectionTime();
          while;
        do:
          if(#kbuf.keyState2(`cmd[`cmdidx-1].key[j]) == t) break;
          j++;
        while j < #`cmd[`cmdidx-1].key:
          `clear();
          ret self(kbuf, ai, holdTemp=);
        }
      }
      ret true;
    }];
    int notHeld = 0;
    if(#`hold > 0 && !ai) loop{
      index j = 0;
      if(#holdTemp == 0){
        holdTemp.new((int).Key::ns + 1);
        holdTemp:<-[void(t=){t = true;}];
      }
      bool allHold = true;
      while;
    do:
      loop{index i = 0; while; do:
        branch{
          int ks = kbuf.keyState(`hold[j][i]);
        cond
          ks == 1 && (`cmdidx > 0 || #`hold > 1)
          && !`held[j] && holdTemp[(int)`hold[j][i]]
          :
          `held[j] = true;
          holdTemp[(int)`hold[j][i]] = false;
        comm:
          if(ks > 0) break, break;
        }
        i++;
      while i < #`hold[j]:
        allHold = false;
      }
      notHeld += (int)!`held[j];
      anyHeld |= `held[j];
      j++;
    while j < #`hold:
      if(`cmdidx == #`cmd - 1 && (!allHold || notHeld > 1)){
        ret anyHeld || `cmdidx > 0;
      }
    }
    if(!ai && `cmd[`cmdidx].slash){
      if(`cmdidx > 0) branch{
      cond notHeld == 1:
        if(#`cmd[`cmdidx - 1].key != 1) ret false;
        if(
          `cmd[`cmdidx - 1].key<> >= .Key::a
          && `cmd[`cmdidx - 1].key<> <= .Key::s
          && kbuf.keyState(`cmd[`cmdidx - 1].key<>) > 0
          && kbuf.keyState(`cmd[`cmdidx - 1].key<>)
          <= kbuf.lastDirectionTime()) ret true;
      cond #`cmd[`cmdidx - 1].key > 1:
        loop{index i = 0; while; do:
          if(
            `cmd[`cmdidx - 1].key[i] >= .Key::a
            && `cmd[`cmdidx - 1].key[i] <= .Key::s
            && kbuf.keyState(`cmd[`cmdidx - 1].key[i]) > 0) ret false;
          i++;
        while i < #`cmd[`cmdidx - 1].key:}
      }
      `cmdidx++;
      ret true;
    }
    if(`tameidx != `cmdidx) branch{
    cond `cmd[`cmdidx].tametime > 1:
      loop{index i = 0; while; do:
        if(kbuf.keyState(`cmd[`cmdidx].key[i]) > 0) ret ai;
        if(
          ai ? .m.rand(0, `cmd[`cmdidx].tametime) != 0
          : -kbuf.keyState(`cmd[`cmdidx].key[i])
          < `cmd[`cmdidx].tametime) ret anyHeld || `cmdidx > 0;
        i++;
      while i < #`cmd[`cmdidx].key:
        `tameidx = `cmdidx;
      }
    cond
      `cmdidx > 0 && #`cmd[`cmdidx-1].key == 1 && #`cmd[`cmdidx].key == 1
      && `cmd[`cmdidx-1].key[0] < .Key::Bs && `cmd[`cmdidx].key[0] < .Key::nB
      && ((int)`cmd[`cmdidx-1].key[0]-(int)`cmd[`cmdidx].key[0] & 7) == 0
      :
      branch{
      cond kbuf.B < 0 && kbuf.D < 0 && kbuf.F < 0 && kbuf.U < 0:
        `tameidx = `cmdidx;
      else:
        ret fail(::);
      }
    }
    loop{
      index i = 0;
      bool foo = false;
      int n;
      while;
    do:
      n = kbuf.keyState2(`cmd[`cmdidx].key[i]);
      branch{
      cond `cmd[`cmdidx].slash:
        foo |= n > 0;
      else:
        foo |= n == 1;
        if(n <= 0 || n > 7) ret fail(::);
      }
      i++;
    while i < #`cmd[`cmdidx].key:
      if(!foo) ret fail(::);
      `cmdidx++;
      if(`cmdidx < #`cmd && `isDToB(`cmd[`cmdidx-1], `cmd[`cmdidx])){
        ret self(kbuf, ai, holdTemp=);
      }
    }
    ret true;
  }
  public void step(^&.Buffer kbuf, bool ai, bool hitpause, int buftime)
  {
    if(!hitpause && `curbuftime > 0) `curbuftime--;
	if(#`cmd == 0) ret;
    {
      int ocbt = `curbuftime;
      ^bool holdTemp;
      if(#kbuf == 0 || !`cmdChek(kbuf<>, ai, holdTemp=)){
        index foo = `tameidx == `cmdidx && `cmdidx == 0 ? 0 : -1;
        `clear();
        `tameidx = foo;
        ret;
      }
      `current++;
      if(`cmdidx == 1 && `cmd[0].slash) `current = 0;
      branch{
      cond<a> `cmdidx == #`cmd:
      cond<b> !ai && `current > `time:
      else:
        break;
      comm:
        `clear();
      diff<a>:
        `curbuftime = `buffertime + buftime;
      }
    break:
      if(`curbuftime < ocbt) `curbuftime = ocbt;
    }
  }
  public void clear()
  {
    `cmdidx = 0;
    `tameidx = -1;
    `current = 0;
    `curbuftime = 0;
    `held:<-[void(h=){h = false;}];
  }
  public void copy(`self c=)
  {
    `name = c.name;
    `hold = c.hold;
    `held = .str.clone!bool?(c.held);
    `cmd = c.cmd;
    `cmdidx = c.cmdidx;
    `tameidx = c.tameidx;
    `time = c.time;
    `current = c.current;
    `buffertime = c.buffertime;
    `curbuftime = c.curbuftime;
  }
}

public &CommandList
{
  public ^&.Buffer buffer;
  public ^&.tbl.NameTable!index? cTable;
  public %%&.Command commands;
  public int defaultTime;
  public int defaultBufferTime;
  public ^&.Command ctmp;
  public bool ac = false;
  public int pbRecTime = 0, pbPlayInc = 0;
  public ^int pbPlaylist;
  new()
  {
    `clear();
  }
  public void clear()
  {
    `cTable.new(1);
    `defaultTime = 15;
    `defaultBufferTime = 1;
    `ctmp.new(0);
  }
  public void copyList(`self src=)
  {
    `cTable = src.cTable;
    `commands.new(#src.commands);
    loop{index i = 0; while; do:
      `commands[i].new(#src.commands[i]);
      loop{index j = 0; while; do:
        `commands[i][j].copy(src.commands[i][j]=);
        j++;
      while j < #`commands[i]:}
      i++;
    while i < #`commands:}
  }
  public bool input(int input, int facing)
  {
    bool step = `buffer~Bb != 0;
    if(input < 0 && input >= -.com.maxSimul*2){
      .aiil.new[!input].update();//Here to avoid getting out of sync
    }
	if(.str.equ(.com.gameMode, "practice") && .com.pauseMenu == 0) `playback(input,facing);
    branch{
      if(input < 0) else;
    cond #.replay > 0: //&& .com.sysControls == 0: //Pause Menu in Replay Mode broken with menu controls active
      .replay~input(`buffer<>=, input, facing);
    cond #.net > 0:
      .net~input(`buffer<>=, input, facing);
    cond #.pbRec > 0 && .com.sysControls == 0:
      .pbRec~input(`buffer<>=, input, facing);
    cond #.pbRep > 0 && .com.sysControls == 0 && input != 0:
      .pbRep~input(`buffer<>=, input, .rFacing == .pbFacing ? facing : -facing);
    else:
      {
        bool l, r, u, d, a, b, c, x, y, z, q, w, e, s;
        branch{
        cond input < 0:
          if(input < -.com.maxSimul*2) else;
          l = .aiil[!input].l();
          r = .aiil[!input].r();
          u = .aiil[!input].u();
          d = .aiil[!input].d();
          a = .aiil[!input].a();
          b = .aiil[!input].b();
          c = .aiil[!input].c();
          x = .aiil[!input].x();
          y = .aiil[!input].y();
          z = .aiil[!input].z();
		  q = .aiil[!input].q();
		  w = .aiil[!input].w();
		  e = .aiil[!input].e();
          s = .aiil[!input].s();
        cond input < #.com.inputRemap && .com.inputRemap[input] < #.cfg.in:
          {
            int in = .com.inputRemap[input] + .com.sysControls;
            int jn = .cfg.in[in].jn;
            if(jn < -1) break, else;
            l = !.modKeyState(.sdl.JoystickButtonState(:jn, .cfg.in[in].l:),jn,.cfg.in[in].l) || (.sdl.JoystickButtonState(:.cfg.in[in+2].jn, .cfg.in[in+2].l:) && (in == (.com.sysControls) ? (.disablePadP1 == false) : in == (.com.sysControls + 1) ? (.disablePadP2 == false) : true));
            r = !.modKeyState(.sdl.JoystickButtonState(:jn, .cfg.in[in].r:),jn,.cfg.in[in].r) || (.sdl.JoystickButtonState(:.cfg.in[in+2].jn, .cfg.in[in+2].r:) && (in == (.com.sysControls) ? (.disablePadP1 == false) : in == (.com.sysControls + 1) ? (.disablePadP2 == false) : true));
            u = !.modKeyState(.sdl.JoystickButtonState(:jn, .cfg.in[in].u:),jn,.cfg.in[in].u) || (.sdl.JoystickButtonState(:.cfg.in[in+2].jn, .cfg.in[in+2].u:) && (in == (.com.sysControls) ? (.disablePadP1 == false) : in == (.com.sysControls + 1) ? (.disablePadP2 == false) : true));
            //d = (`ac && .com.sysControls == 0) || (!.modKeyState(.sdl.JoystickButtonState(:jn, .cfg.in[in].d:),jn,.cfg.in[in].d) || (.sdl.JoystickButtonState(:.cfg.in[in+2].jn, .cfg.in[in+2].d:) && (in == (.com.sysControls) ? (.disablePadP1 == false) : in == (.com.sysControls + 1) ? (.disablePadP2 == false) : true)));
			d = !.modKeyState(.sdl.JoystickButtonState(:jn, .cfg.in[in].d:),jn,.cfg.in[in].d) || (.sdl.JoystickButtonState(:.cfg.in[in+2].jn, .cfg.in[in+2].d:) && (in == (.com.sysControls) ? (.disablePadP1 == false) : in == (.com.sysControls + 1) ? (.disablePadP2 == false) : true));
			a = !.modKeyState(.sdl.JoystickButtonState(:jn, .cfg.in[in].a:),jn,.cfg.in[in].a) || (.sdl.JoystickButtonState(:.cfg.in[in+2].jn, .cfg.in[in+2].a:) && (in == (.com.sysControls) ? (.disablePadP1 == false) : in == (.com.sysControls + 1) ? (.disablePadP2 == false) : true));
            b = !.modKeyState(.sdl.JoystickButtonState(:jn, .cfg.in[in].b:),jn,.cfg.in[in].b) || (.sdl.JoystickButtonState(:.cfg.in[in+2].jn, .cfg.in[in+2].b:) && (in == (.com.sysControls) ? (.disablePadP1 == false) : in == (.com.sysControls + 1) ? (.disablePadP2 == false) : true));
            c = !.modKeyState(.sdl.JoystickButtonState(:jn, .cfg.in[in].c:),jn,.cfg.in[in].c) || (.sdl.JoystickButtonState(:.cfg.in[in+2].jn, .cfg.in[in+2].c:) && (in == (.com.sysControls) ? (.disablePadP1 == false) : in == (.com.sysControls + 1) ? (.disablePadP2 == false) : true));
            x = !.modKeyState(.sdl.JoystickButtonState(:jn, .cfg.in[in].x:),jn,.cfg.in[in].x) || (.sdl.JoystickButtonState(:.cfg.in[in+2].jn, .cfg.in[in+2].x:) && (in == (.com.sysControls) ? (.disablePadP1 == false) : in == (.com.sysControls + 1) ? (.disablePadP2 == false) : true));
            y = !.modKeyState(.sdl.JoystickButtonState(:jn, .cfg.in[in].y:),jn,.cfg.in[in].y) || (.sdl.JoystickButtonState(:.cfg.in[in+2].jn, .cfg.in[in+2].y:) && (in == (.com.sysControls) ? (.disablePadP1 == false) : in == (.com.sysControls + 1) ? (.disablePadP2 == false) : true));
            z = !.modKeyState(.sdl.JoystickButtonState(:jn, .cfg.in[in].z:),jn,.cfg.in[in].z) || (.sdl.JoystickButtonState(:.cfg.in[in+2].jn, .cfg.in[in+2].z:) && (in == (.com.sysControls) ? (.disablePadP1 == false) : in == (.com.sysControls + 1) ? (.disablePadP2 == false) : true));
            q = !.modKeyState(.sdl.JoystickButtonState(:jn, .cfg.in[in].q:),jn,.cfg.in[in].q) || (.sdl.JoystickButtonState(:.cfg.in[in+2].jn, .cfg.in[in+2].q:) && (in == (.com.sysControls) ? (.disablePadP1 == false) : in == (.com.sysControls + 1) ? (.disablePadP2 == false) : true));
			w = !.modKeyState(.sdl.JoystickButtonState(:jn, .cfg.in[in].w:),jn,.cfg.in[in].w) || (.sdl.JoystickButtonState(:.cfg.in[in+2].jn, .cfg.in[in+2].w:) && (in == (.com.sysControls) ? (.disablePadP1 == false) : in == (.com.sysControls + 1) ? (.disablePadP2 == false) : true));
			e = !.modKeyState(.sdl.JoystickButtonState(:jn, .cfg.in[in].e:),jn,.cfg.in[in].e) || (.sdl.JoystickButtonState(:.cfg.in[in+2].jn, .cfg.in[in+2].e:) && (in == (.com.sysControls) ? (.disablePadP1 == false) : in == (.com.sysControls + 1) ? (.disablePadP2 == false) : true));
			s = !.modKeyState(.sdl.JoystickButtonState(:jn, .cfg.in[in].s:),jn,.cfg.in[in].s) || (.sdl.JoystickButtonState(:.cfg.in[in+2].jn, .cfg.in[in+2].s:) && (in == (.com.sysControls) ? (.disablePadP1 == false) : in == (.com.sysControls + 1) ? (.disablePadP2 == false) : true));
          }
        else:
          l = r = u = d = a = b = c = x = y = z = q = w = e = s = false;
        comm:
          `buffer~input(
            facing < 0 ? r : l, d, facing < 0 ? l : r, u, a, b, c, x, y, z, q, w, e, s);
        }
      }
    }
    ret step;
  }
  public void step(int facing, bool ai, bool hitpause, int buftime)
  {
    `commands:<-:<-[void(c=){c.step(`buffer, ai, hitpause, buftime);}];
  }
  public void bufReset()
  {
    if(#`buffer == 0) ret;
    `buffer~reset();
    `commands:<-:<-[void(c=){c.clear();}];
  }
  public void add(&.Command c=)
  {
    ^index ci = `cTable~get(c.name);
    if(#ci == 0 || ci<> < 0 || ci<> >= #`commands){
      ci.new(1);
      ci<> = #`commands;
    }
    `commands.new[ci<>].new[-1].copy(c=);
    `cTable~set(c.name, ci);
  }
  public ^&.Command get(^/char name)
  {
    ^index ci = `cTable~get(name);
    if(#ci == 0) ret .consts.null!&.Command?();
    ret `at(ci<>);
  }
  public ^&.Command at(index i)
  {
    if(i < 0 || i >= #`commands) ret .consts.null!&.Command?();
    ret `commands[i];
  }
  public bool playback(int input, int facing)
  {
    if(input > 0){ //Isn't processed for P1.
      if(`pbRecTime > 0) `pbRecTime--;
      branch{
      cond .pbState == .PlaybackState::CtrlP2 && .com.inputRemap[1] != 0:
        `buffer~reset();
        .com.inputRemap[0] = .com.IERR; //Kills human input for P1 char.
        .com.inputRemap[1] = 0; //P1 now controls P2 char.
      cond .pbState == .PlaybackState::Record && #.pbRec <= 0:
        `buffer~reset();
        .com.resetRemapInput(); //Because the init() function internally swaps P1 and P2 input for recording.
        .pbRec.new(1);
        .pbRec~openReplayFile("save/playback/" + ''.pbCfgRecSlot + ".dat");
        .pbRec~init(facing);
        `pbRecTime = 3600; //1 minute
      cond (.pbState == .PlaybackState::Play && #.pbRep <= 0) || (.pbState == .PlaybackState::Loop) || (.pbState == .PlaybackState::Wait && `pbPlayInc > 0):
        if(.pbState == .PlaybackState::Loop || `pbPlayInc > 0) .pbState = .PlaybackState::Play;
        //There shouldn't be any way for all slots to be excluded, but just in case that somehow happens, this block won't run.
        if((int).pbCfgSlot[0]+(int).pbCfgSlot[1]+(int).pbCfgSlot[2]+(int).pbCfgSlot[3]+(int).pbCfgSlot[4] != 0){
          if(#.pbRep <= 0 && .pbCfgPlayOrder > 0) `populatePlaylist((.pbCfgPlayOrder&1) > 0);
          if(.pbCfgPlayOrder == 1) .pbCfgPlaySlot = `pbPlaylist[.m.rand(0,#`pbPlaylist-1)];
          if((.pbCfgPlayOrder&2) > 0){
            `pbPlayInc = (#.pbRep <= 0 || (.pbCfgPlayLoop && `pbPlayInc >= #`pbPlaylist)) ? 1 : `pbPlayInc+1;
            if(!.pbCfgPlayLoop && `pbPlayInc > #`pbPlaylist){
              .pbState = .PlaybackState::End;
              .pbRep.new(0);
              `pbPlayInc = 0;
              ret false;
            }
            .pbCfgPlaySlot = `pbPlaylist[`pbPlayInc-1];
          }
        }
        .pbRep.new(1);
        .pbRep~open("save/playback/" + ''.pbCfgPlaySlot + ".dat");
        if(!.pbRep~init()){
          .pbState = .PlaybackState::End;
          .pbRep.new(0);
		  .com.playbackState = #.pbRep;
          ret false;
        }
        .rFacing = facing;
      cond ((#.pbRec > 0 || #.pbRep > 0) && .pbState == .PlaybackState::None) || (int).pbState > 4 || `pbRecTime == 0:
        .com.resetRemapInput();
        .pbRec.new(0);
        .pbRep.new(0);
        `pbRecTime = -1;
        `pbPlayInc = 0;
        .pbState = .PlaybackState::None;
      }
	  .com.recordState = (int).pbState;
	  .com.playbackState = #.pbRep;
      ret true;
    }
    ret false;
  }
  public void populatePlaylist(bool r)
  {
    int num = (int).pbCfgSlot[0]+(int).pbCfgSlot[1]+(int).pbCfgSlot[2]+(int).pbCfgSlot[3]+(int).pbCfgSlot[4];
    `pbPlaylist.new(num);
    loop{index i = 0, j = 0; while; do:
      branch{
      cond .pbCfgSlot[j] == true:
        `pbPlaylist[i] = j+1;
        i++;
        j++;
      else:
        j++;
        if(j > #.pbCfgSlot) break, break;
      }
    while i < #`pbPlaylist:}
    if(r && #`pbPlaylist > 1) loop{index i = 0; index j; index oldVal; while; do:
      j = .m.rand(1,#`pbPlaylist)-1;
      oldVal = `pbPlaylist[i];
      `pbPlaylist[i] = `pbPlaylist[j];
      `pbPlaylist[j] = oldVal;
      i++;
    while i < #`pbPlaylist-(int)(#`pbPlaylist <= 2):}
  }
}

public ^int sBuf.new(2);

public bool startButton(int pn)
{
  int jn = .cfg.in[pn-1].jn;
  if(#.net > 0 || pn < 1 || pn > 2) ret false;
  branch{
  cond jn >= -1 && (!.modKeyState(.sdl.JoystickButtonState(:jn, .cfg.in[pn+9].s:),jn,.cfg.in[pn+9].s) || .sdl.JoystickButtonState(:.cfg.in[pn+11].jn, .cfg.in[pn+11].s:)): .sBuf[pn-1]++;
  else: .sBuf[pn-1] = 0;
  }
  ret .sBuf[pn-1] == 1 || .sBuf[pn-1] == 2;
}

bool startHardButton()
{
  loop{
    index i = 0;
    int jn;
    while;
  do:
    jn = .cfg.in[i].jn;
    if(
      jn >= -1 && (
        !.modKeyState(.sdl.JoystickButtonState(:jn, .cfg.in[i].s:),jn,.cfg.in[i].s)
        || !.modKeyState(.sdl.JoystickButtonState(:jn, .cfg.in[i].s:),jn,.cfg.in[i].s)
        || !.modKeyState(.sdl.JoystickButtonState(:jn, .cfg.in[i].s:),jn,.cfg.in[i].s)
        || !.modKeyState(.sdl.JoystickButtonState(:jn, .cfg.in[i].s:),jn,.cfg.in[i].s)
        || !.modKeyState(.sdl.JoystickButtonState(:jn, .cfg.in[i].s:),jn,.cfg.in[i].s)
        || !.modKeyState(.sdl.JoystickButtonState(:jn, .cfg.in[i].s:),jn,.cfg.in[i].s))) ret true;
    i++;
  while i < #.cfg.in:}
  ret false;
}

public bool introbutton()
{
  if(#.replay > 0) ret .replay~startbutton();
  if(#.net > 0) ret .net~startbutton();
  ret .startHardButton();
}

bool anyHardButton()
{
  loop{
    index i = 0;
    int jn;
    while;
  do:
    jn = .cfg.in[i].jn;
    if(
      jn >= -1 && (
        !.modKeyState(.sdl.JoystickButtonState(:jn, .cfg.in[i].a:),jn,.cfg.in[i].a)
        || !.modKeyState(.sdl.JoystickButtonState(:jn, .cfg.in[i].b:),jn,.cfg.in[i].b)
        || !.modKeyState(.sdl.JoystickButtonState(:jn, .cfg.in[i].c:),jn,.cfg.in[i].c)
        || !.modKeyState(.sdl.JoystickButtonState(:jn, .cfg.in[i].x:),jn,.cfg.in[i].x)
        || !.modKeyState(.sdl.JoystickButtonState(:jn, .cfg.in[i].y:),jn,.cfg.in[i].y)
        || !.modKeyState(.sdl.JoystickButtonState(:jn, .cfg.in[i].z:),jn,.cfg.in[i].z))) ret true;
    i++;
  while i < #.cfg.in:}
  ret false;
}

public bool anybutton()
{
  if(#.replay > 0) ret .replay~anybutton();
  if(#.net > 0) ret .net~anybutton();
  if(#.pbRec > 0) ret .pbRec~anybutton();
  if(#.pbRep > 0) ret .pbRep~anybutton();
  ret .anyHardButton();
}