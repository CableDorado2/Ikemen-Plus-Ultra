lib cfg = "../save/config.ssz";

//Load "lib/" Scripts
lib consts = <consts.ssz>;
lib m = <math.ssz>;
lib s = <string.ssz>;

//Load "lib/alpha/" Scripts
lib lua = <alpha/lua.ssz>;
lib se = <alpha/sdlevent.ssz>;
lib sdl = <alpha/sdlplugin.ssz>;

//Load "script/ssz/" Scripts
lib bg = "bg.ssz";
lib chr = "char.ssz";
lib cmd = "command.ssz";
lib com = "common.ssz";
lib fnt = "font.ssz";
lib sc = "script.ssz";
lib sff = "sff.ssz";
lib snd = "sound.ssz";
lib sys = "system.ssz";
lib vid = "video.ssz";


^/char listenPort = .cfg.listenPort;
^/char UserName = .cfg.UserName;
.com.brightness = .cfg.Brightness;
.sdl.setVolume(.cfg.GlVol, .cfg.SEVol, .cfg.BGMVol);

public bool keyReset = false, p1PadReset = false, p2PadReset = false;
public bool padReset = false;
public int p1PadButtonID = 101, p2PadButtonID = 101;
public int padButtonID = 101;

public &sys.System syst;

public &TextImg
{
  ^/char text;
  ^&.fnt.Font fnt;
  &.sdl.Rect window;
  float winX, winY, winW, winH;
  int bank = 0, align = 0;
  float x = 0.0, y = 0.0;
  float xscl = 1.0, yscl = 1.0;
  int salpha = 255, dalpha = 0;
  float oldScale;
  new()
  {
  `window = .com.scrrect;
  `winX = (float)`window.x;
  `winY = (float)`window.y;
  `winW = (float)`window.w;
  `winH = (float)`window.h;
  `oldScale = .com.WidthScale;
  }
  public void setFont(^&.fnt.Font fo)
  {
    `fnt = fo;
  }
  public void draw()
  {
    if(.se.fskip || #`fnt == 0) ret;
	if(`oldScale != .com.WidthScale) `updateWindow();
    `fnt~drawText(`x, `y, `xscl, `yscl, `bank, `salpha, `dalpha, `window=, `align, `text); //`fnt~drawText(`x, `y, `xscl, `yscl, `bank, `align, `text);
  }
  public float getTextWidth()
  {
    ret (float)(`fnt~textWidth(`text))*`xscl;
  }
  public void setText(^/char t)
  {
    `text = t;
  }
  public void setBank(int b)
  {
    `bank = b;
  }
  public void setAlpha(int as, int ad)
  {
    `salpha = as;
    `dalpha = ad;
  }
  public void setWindow(float x, float y, float w, float h)
  {
    `window.x = (int)((x+(float)(.com.GameWidth-320)/2.0)*.com.WidthScale);
    `window.y = (int)((y+(float)(.com.GameHeight-240))*.com.HeightScale);
    `window.w = (int)(w * .com.WidthScale + 0.5);
    `window.h = (int)(h * .com.HeightScale + 0.5);
    `winX = x;
    `winY = y;
    `winW = w;
    `winH = h;
  }
  public void updateWindow()
  {
    `window.x = (int)((`winX+(float)(.com.GameWidth-320)/2.0)*.com.WidthScale);
    `window.y = (int)((`winY+(float)(.com.GameHeight-240))*.com.HeightScale);
    `window.w = (int)(`winW * .com.WidthScale + 0.5);
    `window.h = (int)(`winH * .com.HeightScale + 0.5);
    `oldScale = .com.WidthScale;
  }
  public void setAlign(int a)
  {
    `align = a;
  }
  public void setPos(float x, float y)
  {
    `x = x;
    `y = y;
  }
  public void addPos(float x, float y)
  {
    `x = `x + x;
    `y = `y + y;
  }
  public void setScale(float x, float y)
  {
    `xscl = x;
    `yscl = y;
  }
}

void textImgNew(&.lua.State L=, int re=)
{
  re = 1;
  ^&.TextImg textImg.new(1);
  L.pushRef(textImg);
}

void textImgGetWidth(&.lua.State L=, int re=)
{
  int argc = 0, nret = 1;
  ^&.TextImg textImg = .sc.refArg!&.TextImg?(L=, re=, argc=, nret);
  if(re < 0) ret; 
  L.pushNumber((double)textImg~getTextWidth());
}

void textImgSetFont(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^&.TextImg textImg = .sc.refArg!&.TextImg?(L=, re=, argc=, nret);
  if(re < 0) ret;
  ^&.sc.Font font = .sc.refArg!&.sc.Font?(L=, re=, argc=, nret);
  if(re < 0) ret;
  textImg~setFont(font~getFont());
}

void textImgSetBank(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^&.TextImg textImg = .sc.refArg!&.TextImg?(L=, re=, argc=, nret);
  if(re < 0) ret;
  int b = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  textImg~setBank(b);
}

void textImgSetAlpha(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^&.TextImg textImg = .sc.refArg!&.TextImg?(L=, re=, argc=, nret);
  if(re < 0) ret;
  int as = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  int ad = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  textImg~setAlpha(as, ad);
}

void textImgSetWindow(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^&.TextImg textImg = .sc.refArg!&.TextImg?(L=, re=, argc=, nret);
  if(re < 0) ret;
  float x = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float y = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float w = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float h = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  textImg~setWindow(x, y, w, h);
}

void textImgSetAlign(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^&.TextImg textImg = .sc.refArg!&.TextImg?(L=, re=, argc=, nret);
  if(re < 0) ret;
  int a = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  textImg~setAlign(a);
}

void textImgSetText(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^&.TextImg textImg = .sc.refArg!&.TextImg?(L=, re=, argc=, nret);
  if(re < 0) ret;
  ^/char text = .sc.strArg(L=, re=, argc=, nret); if(re < 0) ret;
  textImg~setText(text);
}

void textImgSetPos(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^&.TextImg textImg = .sc.refArg!&.TextImg?(L=, re=, argc=, nret);
  if(re < 0) ret;
  float x = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float y = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  textImg~setPos(x, y);
}

void textImgAddPos(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^&.TextImg textImg = .sc.refArg!&.TextImg?(L=, re=, argc=, nret);
  if(re < 0) ret;
  float x = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float y = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  textImg~addPos(x, y);
}

void textImgSetScale(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^&.TextImg textImg = .sc.refArg!&.TextImg?(L=, re=, argc=, nret);
  if(re < 0) ret;
  float x = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float y = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  textImg~setScale(x, y);
}

void textImgDraw(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^&.TextImg textImg = .sc.refArg!&.TextImg?(L=, re=, argc=, nret);
  if(re < 0) ret;
  textImg~draw();
}

public &Anim
{
  ^&.sff.Anim!&.bg.Frame? ani;
  &.sdl.Rect window;
  float winX, winY, winW, winH;
  float x = 0.0, y = 0.0;
  float xscl = 1.0, yscl = 1.0;
  float oldScale;
  new()
  {
    `ani.new(1);
    `ani~mask = 0;
    `window = .com.scrrect;
	`winX = (float)`window.x;
    `winY = (float)`window.y;
    `winW = (float)`window.w;
    `winH = (float)`window.h;
    `oldScale = .com.WidthScale;
  }
  public void setSff(^&.sff.Sff sf)
  {
    `ani~sff = sf;
  }
  public bool setAction(^/char str)
  {
    ^^/char lines = .s.splitLines(str);
    index i = 0;
    &.bg.Action act;
    act.read(lines, i=);
    `ani~reset();
    `ani~setFrames(act.frames, act.loopstart);
    ret #act.frames > 0;
  }
  public int animTime()
  {
    ret `ani~animTime();
  }
  public void update()
  {
    `ani~action();
  }
  public void reset()
  {
    `ani~reset();
  }
  public void draw()
  {
    if(.se.fskip) ret;
	if(`oldScale != .com.WidthScale) `updateWindow();
    `ani~draw(
      `window=, `x + (float)(.com.GameWidth-320)/2.0,
      `y + (float)(.com.GameHeight-240), 1.0, 1.0,
      `xscl, `xscl, `yscl, 0.0, 0.0, .consts.null!&.com.PalFX?(), false); 
  }
  public void setPos(float x, float y)
  {
    `x = x;
    `y = y;
  }
  public void addPos(float x, float y)
  {
    `x += x;
    `y += y;
  }
  public void setScale(float x, float y)
  {
    `xscl = x;
    `yscl = y;
  }
  public void setTile(int x, int y)
  {
    `ani~tile.w = x;
    `ani~tile.h = y;
  }
  public void setColorKey(int ck)
  {
    `ani~mask = ck;
  }
  public void setPal(int dest)
  {
    `ani~spal = 0;
    `ani~dpal = dest-1; //Pals start from 0
  }
  public void setAlpha(short sa, short da)
  {
    `ani~salpha = sa;
    `ani~dalpha = da;
  }
  public void setWindow(float x, float y, float w, float h)
  {
    `window.x = (int)((x+(float)(.com.GameWidth-320)/2.0)*.com.WidthScale);
    `window.y = (int)((y+(float)(.com.GameHeight-240))*.com.HeightScale);
    `window.w = (int)(w * .com.WidthScale + 0.5);
    `window.h = (int)(h * .com.HeightScale + 0.5);
	`winX = x;
    `winY = y;
    `winW = w;
    `winH = h;
  }
  public void updateWindow()
  {
    `window.x = (int)((`winX+(float)(.com.GameWidth-320)/2.0)*.com.WidthScale);
    `window.y = (int)((`winY+(float)(.com.GameHeight-240))*.com.HeightScale);
    `window.w = (int)(`winW * .com.WidthScale + 0.5);
    `window.h = (int)(`winH * .com.HeightScale + 0.5);
    `oldScale = .com.WidthScale;
  }
}

void animNew(&.lua.State L=, int re=)
{
  int argc = 0, nret = 1;
  ^&.Anim anim.new(1);
  ^&.sc.Sff sff = .sc.refArg!&.sc.Sff?(L=, re=, argc=, nret); if(re < 0) ret;
  ^/char action = .sc.strArg(L=, re=, argc=, nret); if(re < 0) ret;
  anim~setSff(sff~getSff());
  if(!anim~setAction(action)){
    L.pushString(
      \r\n + action[0..4096] + \r\n\r\n"Failed to load anim data.");
    re = -1;
    ret;
  }
  L.pushRef(anim);
}

void animSetPos(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^&.Anim anim = .sc.refArg!&.Anim?(L=, re=, argc=, nret); if(re < 0) ret;
  float x = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float y = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  anim~setPos(x, y);
}

void animAddPos(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^&.Anim anim = .sc.refArg!&.Anim?(L=, re=, argc=, nret); if(re < 0) ret;
  float x = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float y = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  anim~addPos(x, y);
}

void animSetTile(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^&.Anim anim = .sc.refArg!&.Anim?(L=, re=, argc=, nret); if(re < 0) ret;
  int x = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  int y = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  anim~setTile(x, y);
}

void animSetColorKey(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^&.Anim anim = .sc.refArg!&.Anim?(L=, re=, argc=, nret); if(re < 0) ret;
  int ck = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  anim~setColorKey(ck);
}

void animSetPal(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^&.Anim anim = .sc.refArg!&.Anim?(L=, re=, argc=, nret); if(re < 0) ret;
  int dest = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  anim~setPal(dest);
}

void animSetAlpha(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^&.Anim anim = .sc.refArg!&.Anim?(L=, re=, argc=, nret); if(re < 0) ret;
  int x = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  int y = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  anim~setAlpha(x, y);
}

void animSetScale(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^&.Anim anim = .sc.refArg!&.Anim?(L=, re=, argc=, nret); if(re < 0) ret;
  float x = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float y = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  anim~setScale(x, y);
}

void animSetWindow(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^&.Anim anim = .sc.refArg!&.Anim?(L=, re=, argc=, nret); if(re < 0) ret;
  float x = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float y = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float w = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float h = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  anim~setWindow(x, y, w, h);
}

void animGetFrame(&.lua.State L=, int re=)
{
  int argc = 0, nret = 1;
  ^&.Anim anim = .sc.refArg!&.Anim?(L=, re=, argc=, nret); if(re < 0) ret;
  branch{
  cond #anim > 0: L.pushNumber((double)anim~animTime());
  else: L.pushNumber((double)0);
  }
}

void animUpdate(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^&.Anim anim = .sc.refArg!&.Anim?(L=, re=, argc=, nret); if(re < 0) ret;
  anim~update();
}

void animReset(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^&.Anim anim = .sc.refArg!&.Anim?(L=, re=, argc=, nret); if(re < 0) ret;
  anim~reset();
}

void animDraw(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^&.Anim anim = .sc.refArg!&.Anim?(L=, re=, argc=, nret); if(re < 0) ret;
  anim~draw();
}

void enterNetPlay(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^/char host = .sc.strArg(L=, re=, argc=, nret); if(re < 0) ret;
  if(#.cmd.net > 0){
    L.pushString("Already communicating.");
    re = -1;
    ret;
  }
  .chr.chars.new(#.chr.chars);
  .cmd.net.new(1);
  .cmd.net~openReplayFile("save/data.replay");
  branch{
  cond #host > 0:
    .cmd.net~connect(host, .listenPort);
  else:
    .cmd.net~accept(.listenPort);
  }
}

void exitNetPlay(&.lua.State L=, int re=)
{
  re = 0;
  .cmd.net.new(0);
}

void enterReplay(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^/char file = .sc.strArg(L=, re=, argc=, nret); if(re < 0) ret;
  .chr.chars.new(#.chr.chars);
  .cmd.replay.new(1);
  .cmd.replay~open(file);
}

void exitReplay(&.lua.State L=, int re=)
{
  re = 0;
  .cmd.replay.new(0);
}

void setCom(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  int pn = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  if(!.m.inRange!int?(1, #.chr.chars, pn)){
    L.pushString("Invalid player number.");
    re = -1;
    ret;
  }
  int ai = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  .m.limMin!int?(ai=, 0);
  .com.com[pn-1] = ai;
}

void setTag(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  int pn = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  if(!.m.inRange!int?(1, #.chr.chars, pn)){
    L.pushString("Invalid player number.");
    re = -1;
    ret;
  }
  int tag = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  .m.limMin!int?(tag=, 0);
  .com.taglevel[pn-1] = tag;
}

void setAutoLevel(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  bool b = .sc.blArg(L=, re=, argc=, nret); if(re < 0) ret;
  .com.autolevel = b;
}

void setGameType(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  int gt = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  .com.gameType = gt;
}

void setGameMode(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^/char gm = .sc.strArg(L=, re=, argc=, nret); if(re < 0) ret;
  .com.gameMode = gm;
}

void getGameMode(&.lua.State L=, int re=)
{
  re = 1;
  L.pushString(#.cmd.replay > 0 ? "replay" : .com.gameMode);
}

void setService(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^/char gs = .sc.strArg(L=, re=, argc=, nret); if(re < 0) ret;
  .com.gameService = gs;
}

void getService(&.lua.State L=, int re=)
{
  re = 1;
  L.pushString(.com.gameService);
}

void setPlayerSide(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^/char ps = .sc.strArg(L=, re=, argc=, nret); if(re < 0) ret;
  .com.playerSide = ps;
}

void getPlayerSide(&.lua.State L=, int re=)
{
  re = 1;
  L.pushString(.com.playerSide);
}

void setPauseVar(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^/char pv = .sc.strArg(L=, re=, argc=, nret); if(re < 0) ret;
  .com.pauseVar = pv;
}

void getPauseVar(&.lua.State L=, int re=)
{
  re = 1;
  L.pushString(.com.pauseVar);
}

void setInputDisplay(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  int ipd = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  .com.inputDisplay = ipd;
}

void setDamageDisplay(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  int dmd = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  .com.damageDisplay = dmd;
}

void setPowerStateP1(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  int psl = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  .com.powerStateP1 = psl;
}

void setPowerStateP2(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  int psr = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  .com.powerStateP2 = psr;
}

void setLifeStateP1(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  int lsl = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  .com.lifeStateP1 = lsl;
}

void setLifeStateP2(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  int lsr = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  .com.lifeStateP2 = lsr;
}

void setDummyState(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  int dms = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  .com.dummyState = dms;
}

void setDummyDistance(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  int dd = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  .com.dummyDistance = dd;
}

void setDummyGuard(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  int dg = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  .com.dummyGuard = dg;
}

void setDummyRecovery(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  int dr = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  .com.dummyRecovery = dr;
}

void setCounterHit(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  int cht = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  .com.counterHit = cht;
}

void getListenPort(&.lua.State L=, int re=)
{
  re = 1;
  L.pushString(.listenPort);
}

void connected(&.lua.State L=, int re=)
{
  re = 1;
  L.pushBoolean(#.cmd.net > 0 && .cmd.net~isConnected());
}

void setListenPort(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^/char port = .sc.strArg(L=, re=, argc=, nret); if(re < 0) ret;
  if(#port > 0) .listenPort = port;
}

void getUserName(&.lua.State L=, int re=)
{
  re = 1;
  L.pushString(.UserName);
}

void setUserName(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^/char name = .sc.strArg(L=, re=, argc=, nret); if(re < 0) ret;
  .UserName = name;
}

void setBrightness(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  int brt = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  .com.brightness = brt;
}

void getBrightness(&.lua.State L=, int re=)
{
  re = 1;
  L.pushNumber((double).cfg.Brightness);
}

void setOpacity(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  float op = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  .sdl.setOpacity(op);
}

void setVolume(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  float g = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float s = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float b = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  .sdl.setVolume(g, s, b);
}

void setPanStr(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  float p = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  .snd.panstr = p;
}

public bool cfgMod = false, trnMod = false;
void configModified(&.lua.State L=, int re=)
{
  int argc = 0, nret = 1;
  ^/char mod = .sc.strArg(L=, re=, argc=, nret); if(re < 0) ret;
  branch{
  cond .s.equ(mod,"true"): .cfgMod = true;
  cond .s.equ(mod,"false"): .cfgMod = false;
  }
  L.pushBoolean(.cfgMod);
}

void synchronize(&.lua.State L=, int re=)
{
  re = 0;
  if(!.cmd.synchronize()){
    L.pushString("Synchronization error.");
    re = -1;
    ret;
  }
}

void getWidth(&.lua.State L=, int re=)
{
  re = 1;
  L.pushNumber((double).sdl.getWidth());
}

void getHeight(&.lua.State L=, int re=)
{
  re = 1;
  L.pushNumber((double).sdl.getHeight());
}

void setGameRes(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  int w = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  int h = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  //.com.setSize(w,h); //FIX WHEN CHANGE RESOLUTION DURING EXECUTION
  .sdl.windowSize(w,h);
}

void setWindowType(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  int state = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  .sdl.setWindowType(state);
}

void getWindowType(&.lua.State L=, int re=)
{
  re = 1;
  L.pushNumber((double).cfg.WindowType);
}

void getFullScreenMode(&.lua.State L=, int re=)
{
  re = 1;
  L.pushBoolean(.se.fullReal);
}

void setFullScreenMode(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  bool fs = .sc.blArg(L=, re=, argc=, nret); if(re < 0) ret;
  .sdl.fullScreenMode(fs);
  .se.fullReal = fs;
}

void getScreenMode(&.lua.State L=, int re=)
{
  re = 1;
  L.pushBoolean(.se.full);
}

void setScreenMode(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  bool f = .sc.blArg(L=, re=, argc=, nret); if(re < 0) ret;
  if(.sdl.fullScreen(f)) .sdl.showCursor(!f || f && !.se.fullReal);
  .se.full = f;
}

void getAspectRatio(&.lua.State L=, int re=)
{
  re = 1;
  L.pushBoolean(.se.aspect);
}

void setAspectRatio(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  bool kar = .sc.blArg(L=, re=, argc=, nret); if(re < 0) ret;
  .sdl.keepAspectRatio(kar);
  .se.aspect = kar;
}

void takeScreenShot(&.lua.State L=, int re=)
{
  int argc = 0, nret = 1;
  ^/char dir = .sc.strArg(L=, re=, argc=, nret); if(re < 0) ret;
  .sdl.takeScreenShot(dir);
}

void swapGamepad(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  int jnP1 = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  int jnP2 = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  .cfg.in[2].jn = jnP1;
  .cfg.in[3].jn = jnP2;
  .cfg.in[12].jn = jnP1;
  .cfg.in[13].jn = jnP2;
}

void disableGamepad(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  bool P1 = .sc.blArg(L=, re=, argc=, nret); if(re < 0) ret;
  bool P2 = .sc.blArg(L=, re=, argc=, nret); if(re < 0) ret;
  .cmd.disablePadP1 = P1;
  .cmd.disablePadP2 = P2;
}

void inputReset(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  int c = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  branch{ //This can't use a switch here.
  cond c == -1: .keyReset = true;
  cond c == .cfg.in[2].jn: .p1PadReset = true;
  cond c == .cfg.in[3].jn: .p2PadReset = true;	
  }
}

void getInputKeyboard(&.lua.State L=, int re=)
{
  re = 1;
  branch{
	cond .sdl.KeyState(:.se.sdle.key.keysym.scancode:) == true && .keyReset == false:
	  L.pushNumber((double).se.sdle.key.keysym.scancode);
	  //.keyReset = true;
	else:
	  L.pushNumber((double)0);
  }
  if(.sdl.KeyState(:.se.sdle.key.keysym.scancode:) == false && .keyReset == true) .keyReset = false;
}

void getInputID(&.lua.State L=, int re=)
{
  int argc = 0, nret = 1;
  int cn = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  L.pushNumber((double)101); //Something outside the range we're checking.
  loop{index i = -100; while; do:
	if((int).sdl.JoystickButtonState(:cn,i:) == 1){
	  .padButtonID = i;
	  if(.padReset == false) L.pushNumber((double)i);
	  //.padReset = true;
	}
	i++;
  while i <= 100:}
  //if((int).sdl.JoystickButtonState(:cn,.padButtonID:) == 0 && .padReset == true) .padReset = false;
}

void getInputIDNextVer(&.lua.State L=, int re=)
{
  int argc = 0, nret = 1;
  int j = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  L.pushNumber((double)101); //Something outside the range we're checking.
    loop{index i = -100; while; do:
      if((int).sdl.JoystickButtonState(:j,i:) == 1){
        branch{ //Can't use a switch function here apparently.
        cond j == .cfg.in[2].jn:
          .p1PadButtonID = i;
          if(!.p1PadReset) L.pushNumber((double)i);
          .p1PadReset = true;
        cond j == .cfg.in[3].jn:
          .p2PadButtonID = i;
          if(!.p2PadReset) L.pushNumber((double)i);
          .p2PadReset = true;
        }
      }
      i++;
    while i <= 100:}
  branch{
  cond j == .cfg.in[2].jn:
    if((int).sdl.JoystickButtonState(:j,.p1PadButtonID:) == 0 && .p1PadReset) .p1PadReset = false;
  cond j == .cfg.in[3].jn:
    if((int).sdl.JoystickButtonState(:j,.p2PadButtonID:) == 0 && .p2PadReset) .p2PadReset = false;
  }
}

public int keySwap(^/char key)
{
  branch{
  //KEYBOARD KEYS
  cond .s.equ(key, "a") || .s.equ(key, "A"): ret 4;
  cond .s.equ(key, "b") || .s.equ(key, "B"): ret 5;
  cond .s.equ(key, "c") || .s.equ(key, "C"): ret 6;
  cond .s.equ(key, "d") || .s.equ(key, "D"): ret 7;
  cond .s.equ(key, "e") || .s.equ(key, "E"): ret 8;
  cond .s.equ(key, "f") || .s.equ(key, "F"): ret 9;
  cond .s.equ(key, "g") || .s.equ(key, "G"): ret 10;
  cond .s.equ(key, "h") || .s.equ(key, "H"): ret 11;
  cond .s.equ(key, "i") || .s.equ(key, "I"): ret 12;
  cond .s.equ(key, "j") || .s.equ(key, "J"): ret 13;
  cond .s.equ(key, "k") || .s.equ(key, "K"): ret 14;
  cond .s.equ(key, "l") || .s.equ(key, "L"): ret 15;
  cond .s.equ(key, "m") || .s.equ(key, "M"): ret 16;
  cond .s.equ(key, "n") || .s.equ(key, "N"): ret 17;
  cond .s.equ(key, "o") || .s.equ(key, "O"): ret 18;
  cond .s.equ(key, "p") || .s.equ(key, "P"): ret 19;
  cond .s.equ(key, "q") || .s.equ(key, "Q"): ret 20;
  cond .s.equ(key, "r") || .s.equ(key, "R"): ret 21;
  cond .s.equ(key, "s") || .s.equ(key, "S"): ret 22;
  cond .s.equ(key, "t") || .s.equ(key, "T"): ret 23;
  cond .s.equ(key, "u") || .s.equ(key, "U"): ret 24;
  cond .s.equ(key, "v") || .s.equ(key, "V"): ret 25;
  cond .s.equ(key, "w") || .s.equ(key, "W"): ret 26;
  cond .s.equ(key, "x") || .s.equ(key, "X"): ret 27;
  cond .s.equ(key, "y") || .s.equ(key, "Y"): ret 28;
  cond .s.equ(key, "z") || .s.equ(key, "Z"): ret 29;
  cond .s.equ(key, "_1"): ret 30;
  cond .s.equ(key, "_2"): ret 31;
  cond .s.equ(key, "_3"): ret 32;
  cond .s.equ(key, "_4"): ret 33;
  cond .s.equ(key, "_5"): ret 34;
  cond .s.equ(key, "_6"): ret 35;
  cond .s.equ(key, "_7"): ret 36;
  cond .s.equ(key, "_8"): ret 37;
  cond .s.equ(key, "_9"): ret 38;
  cond .s.equ(key, "_0"): ret 39;
  cond .s.equ(key, "RETURN"): ret 40;
  cond .s.equ(key, "ESCAPE"): ret 41;
  cond .s.equ(key, "BACKSPACE"): ret 42;
  cond .s.equ(key, "TAB"): ret 43;
  cond .s.equ(key, "SPACE"): ret 44;
  cond .s.equ(key, "MINUS"): ret 45;
  cond .s.equ(key, "EQUALS"): ret 46;
  cond .s.equ(key, "LEFTBRACKET"): ret 47;
  cond .s.equ(key, "RIGHTBRACKET"): ret 48;
  cond .s.equ(key, "BACKSLASH"): ret 49;
  cond .s.equ(key, "NONUSHASH"): ret 50;
  cond .s.equ(key, "SEMICOLON"): ret 51;
  cond .s.equ(key, "APOSTROPHE"): ret 52;
  cond .s.equ(key, "GRAVE"): ret 53;
  cond .s.equ(key, "COMMA"): ret 54;
  cond .s.equ(key, "PERIOD"): ret 55;
  cond .s.equ(key, "SLASH"): ret 56;
  cond .s.equ(key, "CAPSLOCK"): ret 57;
  cond .s.equ(key, "F1"): ret 58;
  cond .s.equ(key, "F2"): ret 59;
  cond .s.equ(key, "F3"): ret 60;
  cond .s.equ(key, "F4"): ret 61;
  cond .s.equ(key, "F5"): ret 62;
  cond .s.equ(key, "F6"): ret 63;
  cond .s.equ(key, "F7"): ret 64;
  cond .s.equ(key, "F8"): ret 65;
  cond .s.equ(key, "F9"): ret 66;
  cond .s.equ(key, "F10"): ret 67;
  cond .s.equ(key, "F11"): ret 68;
  cond .s.equ(key, "F12"): ret 69;
  cond .s.equ(key, "PRINTSCREEN"): ret 70;
  cond .s.equ(key, "SCROLLLOCK"): ret 71;
  cond .s.equ(key, "PAUSE"): ret 72;
  cond .s.equ(key, "INSERT"): ret 73;
  cond .s.equ(key, "HOME"): ret 74;
  cond .s.equ(key, "PAGEUP"): ret 75;
  cond .s.equ(key, "DELETE"): ret 76;
  cond .s.equ(key, "END"): ret 77;
  cond .s.equ(key, "PAGEDOWN"): ret 78;
  cond .s.equ(key, "RIGHT"): ret 79;
  cond .s.equ(key, "LEFT"): ret 80;
  cond .s.equ(key, "DOWN"): ret 81;
  cond .s.equ(key, "UP"): ret 82;
  cond .s.equ(key, "NUMLOCKCLEAR"): ret 83;
  cond .s.equ(key, "KP_DIVIDE"): ret 84;
  cond .s.equ(key, "KP_MULTIPLY"): ret 85;
  cond .s.equ(key, "KP_MINUS"): ret 86;
  cond .s.equ(key, "KP_PLUS"): ret 87;
  cond .s.equ(key, "KP_ENTER"): ret 88;
  cond .s.equ(key, "KP_1"): ret 89;
  cond .s.equ(key, "KP_2"): ret 90;
  cond .s.equ(key, "KP_3"): ret 91;
  cond .s.equ(key, "KP_4"): ret 92;
  cond .s.equ(key, "KP_5"): ret 93;
  cond .s.equ(key, "KP_6"): ret 94;
  cond .s.equ(key, "KP_7"): ret 95;
  cond .s.equ(key, "KP_8"): ret 96;
  cond .s.equ(key, "KP_9"): ret 97;
  cond .s.equ(key, "KP_0"): ret 98;
  cond .s.equ(key, "KP_PERIOD"): ret 99;
  cond .s.equ(key, "NONUSBACKSLASH"): ret 100;
  cond .s.equ(key, "APPLICATION"): ret 101;
  cond .s.equ(key, "POWER"): ret 102;
  cond .s.equ(key, "KP_EQUALS"): ret 103;
  cond .s.equ(key, "F13"): ret 104;
  cond .s.equ(key, "F14"): ret 105;
  cond .s.equ(key, "F15"): ret 106;
  cond .s.equ(key, "F16"): ret 107;
  cond .s.equ(key, "F17"): ret 108;
  cond .s.equ(key, "F18"): ret 109;
  cond .s.equ(key, "F19"): ret 110;
  cond .s.equ(key, "F20"): ret 111;
  cond .s.equ(key, "F21"): ret 112;
  cond .s.equ(key, "F22"): ret 113;
  cond .s.equ(key, "F23"): ret 114;
  cond .s.equ(key, "F24"): ret 115;
  cond .s.equ(key, "EXECUTE"): ret 116;
  cond .s.equ(key, "HELP"): ret 117;
  cond .s.equ(key, "MENU"): ret 118;
  cond .s.equ(key, "SELECT"): ret 119;
  cond .s.equ(key, "STOP"): ret 120;
  cond .s.equ(key, "AGAIN"): ret 121;
  cond .s.equ(key, "UNDO"): ret 122;
  cond .s.equ(key, "CUT"): ret 123;
  cond .s.equ(key, "COPY"): ret 124;
  cond .s.equ(key, "PASTE"): ret 125;
  cond .s.equ(key, "FIND"): ret 126;
  cond .s.equ(key, "MUTE"): ret 127;
  cond .s.equ(key, "VOLUMEUP"): ret 128;
  cond .s.equ(key, "VOLUMEDOWN"): ret 129;
  cond .s.equ(key, "KP_COMMA"): 133;
  cond .s.equ(key, "KP_EQUALSAS400"): 134;
  cond .s.equ(key, "INTERNATIONAL1"): 135;
  cond .s.equ(key, "INTERNATIONAL2"): 136;
  cond .s.equ(key, "INTERNATIONAL3"): 137;
  cond .s.equ(key, "INTERNATIONAL4"): 138;
  cond .s.equ(key, "INTERNATIONAL5"): 139;
  cond .s.equ(key, "INTERNATIONAL6"): 140;
  cond .s.equ(key, "INTERNATIONAL7"): 141;
  cond .s.equ(key, "INTERNATIONAL8"): 142;
  cond .s.equ(key, "INTERNATIONAL9"): 143;
  cond .s.equ(key, "LANG1"): 144;
  cond .s.equ(key, "LANG2"): 145;
  cond .s.equ(key, "LANG3"): 146;
  cond .s.equ(key, "LANG4"): 147;
  cond .s.equ(key, "LANG5"): 148;
  cond .s.equ(key, "LANG6"): 149;
  cond .s.equ(key, "LANG7"): 150;
  cond .s.equ(key, "LANG8"): 151;
  cond .s.equ(key, "LANG9"): 152;
  cond .s.equ(key, "ALTERASE"): 153;
  cond .s.equ(key, "SYSREQ"): 154;
  cond .s.equ(key, "CANCEL"): 155;
  cond .s.equ(key, "CLEAR"): 156;
  cond .s.equ(key, "PRIOR"): 157;
  cond .s.equ(key, "RETURN2"): 158;
  cond .s.equ(key, "SEPARATOR"): 159;
  cond .s.equ(key, "OUT"): 160;
  cond .s.equ(key, "OPER"): 161;
  cond .s.equ(key, "CLEARAGAIN"): 162;
  cond .s.equ(key, "CRSEL"): 163;
  cond .s.equ(key, "EXSEL"): 164;
  cond .s.equ(key, "KP_00"): 176;
  cond .s.equ(key, "KP_000"): 177;
  cond .s.equ(key, "THOUSANDSSEPARATOR"): 178;
  cond .s.equ(key, "DECIMALSEPARATOR"): 179;
  cond .s.equ(key, "CURRENCYUNIT"): 180;
  cond .s.equ(key, "CURRENCYSUBUNIT"): 181;
  cond .s.equ(key, "KP_LEFTPAREN"): 182;
  cond .s.equ(key, "KP_RIGHTPAREN"): 183;
  cond .s.equ(key, "KP_LEFTBRACE"): 184;
  cond .s.equ(key, "KP_RIGHTBRACE"): 185;
  cond .s.equ(key, "KP_TAB"): 186;
  cond .s.equ(key, "KP_BACKSPACE"): 187;
  cond .s.equ(key, "KP_A"): 188;
  cond .s.equ(key, "KP_B"): 189;
  cond .s.equ(key, "KP_C"): 190;
  cond .s.equ(key, "KP_D"): 191;
  cond .s.equ(key, "KP_E"): 192;
  cond .s.equ(key, "KP_F"): 193;
  cond .s.equ(key, "KP_XOR"): 194;
  cond .s.equ(key, "KP_POWER"): 195;
  cond .s.equ(key, "KP_PERCENT"): 196;
  cond .s.equ(key, "KP_LESS"): 197;
  cond .s.equ(key, "KP_GREATER"): 198;
  cond .s.equ(key, "KP_AMPERSAND"): 199;
  cond .s.equ(key, "KP_DBLAMPERSAND"): 200;
  cond .s.equ(key, "KP_VERTICALBAR"): 201;
  cond .s.equ(key, "KP_DBLVERTICALBAR"): 202;
  cond .s.equ(key, "KP_COLON"): 203;
  cond .s.equ(key, "KP_HASH"): 204;
  cond .s.equ(key, "KP_SPACE"): 205;
  cond .s.equ(key, "KP_AT"): 206;
  cond .s.equ(key, "KP_EXCLAM"): 207;
  cond .s.equ(key, "KP_MEMSTORE"): 208;
  cond .s.equ(key, "KP_MEMRECALL"): 209;
  cond .s.equ(key, "KP_MEMCLEAR"): 210;
  cond .s.equ(key, "KP_MEMADD"): 211;
  cond .s.equ(key, "KP_MEMSUBTRACT"): 212;
  cond .s.equ(key, "KP_MEMMULTIPLY"): 213;
  cond .s.equ(key, "KP_MEMDIVIDE"): 214;
  cond .s.equ(key, "KP_PLUSMINUS"): 215;
  cond .s.equ(key, "KP_CLEAR"): 216;
  cond .s.equ(key, "KP_CLEARENTRY"): 217;
  cond .s.equ(key, "KP_BINARY"): 218;
  cond .s.equ(key, "KP_OCTAL"): 219;
  cond .s.equ(key, "KP_DECIMAL"): 220;
  cond .s.equ(key, "KP_HEXADECIMAL"): 221;
  cond .s.equ(key, "LCTRL"): 224;
  cond .s.equ(key, "LSHIFT"): 225;
  cond .s.equ(key, "LALT"): 226;
  cond .s.equ(key, "LGUI"): 227;
  cond .s.equ(key, "RCTRL"): 228;
  cond .s.equ(key, "RSHIFT"): 229;
  cond .s.equ(key, "RALT"): 230;
  cond .s.equ(key, "RGUI"): 231;
  cond .s.equ(key, "MODE"): 257;
  cond .s.equ(key, "AUDIONEXT"): 258;
  cond .s.equ(key, "AUDIOPREV"): 259;
  cond .s.equ(key, "AUDIOSTOP"): 260;
  cond .s.equ(key, "AUDIOPLAY"): 261;
  cond .s.equ(key, "AUDIOMUTE"): 262;
  cond .s.equ(key, "MEDIASELECT"): 263;
  cond .s.equ(key, "WWW"): 264;
  cond .s.equ(key, "MAIL"): 265;
  cond .s.equ(key, "CALCULATOR"): 266;
  cond .s.equ(key, "COMPUTER"): 267;
  cond .s.equ(key, "AC_SEARCH"): 268;
  cond .s.equ(key, "AC_HOME"): 269;
  cond .s.equ(key, "AC_BACK"): 270;
  cond .s.equ(key, "AC_FORWARD"): 271;
  cond .s.equ(key, "AC_STOP"): 272;
  cond .s.equ(key, "AC_REFRESH"): 273;
  cond .s.equ(key, "AC_BOOKMARKS"): 274;
  cond .s.equ(key, "BRIGHTNESSDOWN"): 275;
  cond .s.equ(key, "BRIGHTNESSUP"): 276;
  cond .s.equ(key, "DISPLAYSWITCH"): 277;
  cond .s.equ(key, "KBDILLUMTOGGLE"): 278;
  cond .s.equ(key, "KBDILLUMDOWN"): 279;
  cond .s.equ(key, "KBDILLUMUP"): 280;
  cond .s.equ(key, "EJECT"): 281;
  cond .s.equ(key, "SLEEP"): 282;
  cond .s.equ(key, "APP1"): 283;
  cond .s.equ(key, "APP2"): 284;
  cond .s.equ(key, "NUM_SCANCODES"): 512;
  }
  ret 0;
}

void swapController(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  int pnO = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  int pnN = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  int tmpJN = .cfg.in[pnO].jn;
  int tmpU = .cfg.in[pnO].u;
  int tmpD = .cfg.in[pnO].d;
  int tmpL = .cfg.in[pnO].l;
  int tmpR = .cfg.in[pnO].r;
  int tmpA = .cfg.in[pnO].a;
  int tmpB = .cfg.in[pnO].b;
  int tmpC = .cfg.in[pnO].c;
  int tmpX = .cfg.in[pnO].x;
  int tmpY = .cfg.in[pnO].y;
  int tmpZ = .cfg.in[pnO].z;
  int tmpQ = .cfg.in[pnO].q;
  int tmpW = .cfg.in[pnO].w;
  int tmpE = .cfg.in[pnO].e;
  int tmpS = .cfg.in[pnO].s;
  .cfg.in[pnO].set(
	.cfg.in[pnN].jn,
	.cfg.in[pnN].u,
	.cfg.in[pnN].d,
	.cfg.in[pnN].l,
	.cfg.in[pnN].r,
	.cfg.in[pnN].a,
	.cfg.in[pnN].b,
	.cfg.in[pnN].c,
	.cfg.in[pnN].x,
	.cfg.in[pnN].y,
	.cfg.in[pnN].z,
	.cfg.in[pnN].q,
	.cfg.in[pnN].w,
	.cfg.in[pnN].e,
	.cfg.in[pnN].s);
  .cfg.in[pnN].set(
	tmpJN,
	tmpU,
	tmpD,
	tmpL,
	tmpR,
	tmpA,
	tmpB,
	tmpC,
	tmpX,
	tmpY,
	tmpZ,
	tmpQ,
	tmpW,
	tmpE,
	tmpS);
}

void setInputConfig(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  int pn = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  int cn = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  if(cn == -1){
	^/char u = .sc.strArg(L=, re=, argc=, nret); if(re < 0) ret;
	^/char d = .sc.strArg(L=, re=, argc=, nret); if(re < 0) ret;
	^/char l = .sc.strArg(L=, re=, argc=, nret); if(re < 0) ret;
	^/char r = .sc.strArg(L=, re=, argc=, nret); if(re < 0) ret;
	^/char a = .sc.strArg(L=, re=, argc=, nret); if(re < 0) ret;
	^/char b = .sc.strArg(L=, re=, argc=, nret); if(re < 0) ret;
	^/char c = .sc.strArg(L=, re=, argc=, nret); if(re < 0) ret;
	^/char x = .sc.strArg(L=, re=, argc=, nret); if(re < 0) ret;
	^/char y = .sc.strArg(L=, re=, argc=, nret); if(re < 0) ret;
	^/char z = .sc.strArg(L=, re=, argc=, nret); if(re < 0) ret;
	^/char q = .sc.strArg(L=, re=, argc=, nret); if(re < 0) ret;
	^/char w = .sc.strArg(L=, re=, argc=, nret); if(re < 0) ret;
	^/char e = .sc.strArg(L=, re=, argc=, nret); if(re < 0) ret;
	^/char s = .sc.strArg(L=, re=, argc=, nret); if(re < 0) ret;
	.cfg.in[pn].set(
	  cn,
	  .keySwap(u),
	  .keySwap(d),
	  .keySwap(l),
	  .keySwap(r),
	  .keySwap(a),
	  .keySwap(b),
	  .keySwap(c),
	  .keySwap(x),
	  .keySwap(y),
	  .keySwap(z),
	  .keySwap(q),
	  .keySwap(w),
	  .keySwap(e),
	  .keySwap(s));
  }
  if(cn > -1){
	int u = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
	int d = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
	int l = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
	int r = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
	int a = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
	int b = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
	int c = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
	int x = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
	int y = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
	int z = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
	int q = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
	int w = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
	int e = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
	int s = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
	.cfg.in[pn].set(
	  cn,
	  u,
	  d,
	  l,
	  r,
	  a,
	  b,
	  c,
	  x,
	  y,
	  z,
	  q,
	  w,
	  e,
	  s);
  }
}

void addChar(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^^/char lines = .s.splitLines(.sc.strArg(L=, re=, argc=, nret));
  if(re < 0) ret;
  loop{index i = 0; while; do:
    .syst.selinf.sel.addChar(lines[i]);
    i++;
  while i < #lines:}
}

void addStage(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^^/char lines = .s.splitLines(.sc.strArg(L=, re=, argc=, nret));
  if(re < 0) ret;
  loop{index i = 0; while; do:
    .syst.selinf.sel.addStage(lines[i]);
    i++;
  while i < #lines:}
}

void setRandomSpr(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^&.sc.Sff sff = .sc.refArg!&.sc.Sff?(L=, re=, argc=, nret); if(re < 0) ret;
  int g = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  int n = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float xs = .syst.selinf.sel.randxscl, ys = .syst.selinf.sel.randyscl;
  if(L.getTop() > argc){
    xs = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  }
  if(L.getTop() > argc){
    ys = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  }
  ^&.sff.Sff sf = sff~getSff();
  if(#sf > 0) .syst.selinf.sel.randomspr = sf~getOwnPalSprite(g, n);
  .syst.selinf.sel.randxscl = xs;
  .syst.selinf.sel.randyscl = ys;
}

void setSelColRow(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  int c = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  int r = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  .syst.selinf.sel.columns = c;
  .syst.selinf.sel.rows = r;
}

void setSelCellSize(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  float x = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float y = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  .syst.selinf.sel.cellsizex = x;
  .syst.selinf.sel.cellsizey = y;
}

void setSelCellScale(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  float x = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float y = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  .syst.selinf.sel.cellscalex = x;
  .syst.selinf.sel.cellscaley = y;
}

void numSelCells(&.lua.State L=, int re=)
{
  re = 1;
  L.pushNumber((double)#.syst.selinf.sel.charlist);
}

void setStage(&.lua.State L=, int re=)
{
  int argc = 0, nret = 1;
  int n = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  L.pushNumber((double).syst.selinf.sel.setStageNo(n));
}

void selectStage(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  int n = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  .syst.selinf.sel.selectStage(n);
}

void setStgMusic(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^/char bgm = .sc.strArg(L=, re=, argc=, nret); if(re < 0) ret;
  if(#bgm > 0) .chr.stage.bgmusic = bgm;
}

void setTeamMode(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  int pn = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  if(!.m.inRange!int?(1, 2, pn)){
    L.pushString("Invalid team number.");
    re = -1;
    ret;
  }
  int tm = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  if(!.m.inRange!int?(0, 2, tm)){
    L.pushString("Invalid mode number.");
    re = -1;
    ret;
  }
  int nt = 1;
  if(tm >= 1){
    nt = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
    if(!.m.inRange!int?(1, 10, nt)){
      L.pushString("Incorrect team size.");
      re = -1;
      ret;
    }
  }
  .syst.selinf.p[pn-1].selchr.new(0);
  .com.tmode[pn-1] = tm;
  .com.numturns[pn-1] = .com.numSimul[pn-1] = nt;
  if(tm == 1 && nt == 1) .com.tmode[pn-1] = 0;
}

void getCharName(&.lua.State L=, int re=)
{
  int argc = 0, nret = 1;
  int n = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  ^&.sys.Select::Char c = .syst.selinf.sel.getChar(n);
  L.pushString(#c > 0 ? c~name : "");
}

void getCharFileName(&.lua.State L=, int re=)
{
  int argc = 0, nret = 1;
  int n = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  ^&.sys.Select::Char c = .syst.selinf.sel.getChar(n);
  L.pushString(#c > 0 ? c~def : "");
}

void selectChar(&.lua.State L=, int re=)
{
  int argc = 0, nret = 1;
  int pn = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  if(!.m.inRange!int?(1, 2, pn)){
    L.pushString("Invalid team number.");
    re = -1;
    ret;
  }
  int cn = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  int pl = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  int retval = 0;
  if(.m.inRange!int?(1, 12, pl) && .syst.selinf.addSelchr(pn-1, cn, pl)){
    switch(.com.tmode[pn-1]){
    case (int).com.TeamMode::Single:
      retval = 2;
    case (int).com.TeamMode::Simul:
      retval = #.syst.selinf.p[pn-1].selchr >= .com.numSimul[pn-1] ? 2 : 1;
    case (int).com.TeamMode::Turns:
      retval = #.syst.selinf.p[pn-1].selchr >= .com.numturns[pn-1] ? 2 : 1;
    }
  }
  L.pushNumber((double)retval);
}

void getCharVar(&.lua.State L=, int re=)
{
  int argc = 0, nret = 1;
  int pn = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  ^/char vt = .sc.strArg(L=, re=, argc=, nret); if(re < 0) ret;
  int vn = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  if(!.m.inRange!int?(1, #.chr.chars, pn))
  {
    L.pushString("Invalid player number.");
    re = -1;
    ret;
  }
  int retval = .s.equ(vt, "t") ? .chr.chars[pn-1]<>~tivar[vn]+1 : .chr.chars[pn-1]<>~ivar[vn];
  L.pushNumber((double)retval);
}

void setCharVar(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  int pn = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  ^/char vt = .sc.strArg(L=, re=, argc=, nret); if(re < 0) ret;
  int vn = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  int val = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  if(!.m.inRange!int?(1, #.chr.chars, pn))
  {
    L.pushString("Invalid player number.");
    re = -1;
    ret;
  }
  branch{
  cond .s.equ(vt, "t"):
    .chr.chars[pn-1]<>~tivar[vn] = val-1;
  else:
    .chr.chars[pn-1]<>~ivar[vn] = val;
  }
}

void getHelperVar(&.lua.State L=, int re=)
{
  int argc = 0, nret = 1;
  int pn = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  int id = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  ^/char vt = .sc.strArg(L=, re=, argc=, nret); if(re < 0) ret;
  int vn = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  if(!.m.inRange!int?(1, #.chr.chars, pn))
  {
    L.pushString("Invalid player number.");
    re = -1;
    ret;
  }
  int retval = 0;
  loop{index i = 1; while; do:
    if(
      !.chr.chars[pn-1][i]~ls(.chr.lsDESTROY)
      && (id <= 0 || id == .chr.chars[pn-1][i]~helperid))
    {
      retval = .s.equ(vt, "t") ? .chr.chars[pn-1][i]~tivar[vn]+1 : .chr.chars[pn-1][i]~ivar[vn];
    }
    i++;
  while i < #.chr.chars[pn-1]:}
  L.pushNumber((double)retval);
}

void setHelperVar(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  int pn = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  int id = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  ^/char vt = .sc.strArg(L=, re=, argc=, nret); if(re < 0) ret;
  int vn = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  int val = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  if(!.m.inRange!int?(1, #.chr.chars, pn))
  {
    L.pushString("Invalid player number.");
    re = -1;
    ret;
  }
  loop{index i = 1; while; do:
    if(
      !.chr.chars[pn-1][i]~ls(.chr.lsDESTROY)
      && (id <= 0 || id == .chr.chars[pn-1][i]~helperid))
    {
      branch{
      cond .s.equ(vt, "t"):
        .chr.chars[pn-1][i]~tivar[vn] = val-1;
      else:
        .chr.chars[pn-1][i]~ivar[vn] = val;
      }
    }
    i++;
  while i < #.chr.chars[pn-1]:}
}

void getStageName(&.lua.State L=, int re=)
{
  int argc = 0, nret = 1;
  int n = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  L.pushString(.syst.selinf.sel.getStageName(n));
}

void refresh(&.lua.State L=, int re=)
{
  re = 0;
  if(!.se.fskip){
  /?/*.cfg.OpenGL:
    .sdl.GlSwapBuffers(::);
  /*true:
    .sdl.flip();
    .com.screenFill(0x00000000);
  /*?*/
  }
  .snd.playSound();
  if(!.cmd.update()) .se.end = true;
  if(.se.end){
    L.pushString("<game end>");
    re = -1;
  }
}

void drawFace(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  float x = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float y = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  int offset = 0;
  if(L.getTop() > argc){
    offset = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  }
  if(!.se.fskip) loop{
    int j = 0;
    ^&.sys.Select::Char c;
    while;
  do:
    loop{int i = 0; while; do:
      c = .syst.selinf.sel.getChar(offset++);
      if(#c > 0) branch{
      cond #c~facePortrait > 0:
        c~facePortrait~draw(
          x + (float)i*.syst.selinf.sel.cellsizex,
          y + (float)j*.syst.selinf.sel.cellsizey,
          .syst.selinf.sel.cellscalex, .syst.selinf.sel.cellscaley,
          c~facePortrait~colorPallet);
      cond .s.equ(c~def, "randomselect") && #.syst.selinf.sel.randomspr > 0:
        .syst.selinf.sel.randomspr~draw(
          x + (float)i*.syst.selinf.sel.cellsizex,
          y + (float)j*.syst.selinf.sel.cellsizey,
          .syst.selinf.sel.randxscl, .syst.selinf.sel.randyscl,
          .syst.selinf.sel.randomspr~colorPallet);
      }
      i++;
    while i < .syst.selinf.sel.columns:}
    j++;
  while j < .syst.selinf.sel.rows:}
}

void drawTourneyPortrait(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  index n = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float x = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float y = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float xscl = 1.0, yscl = 1.0;
  if(L.getTop() > argc){
    xscl = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  }
  if(L.getTop() > argc){
    yscl = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  }
  if(!.se.fskip){
    ^&.sys.Select::Char c = .syst.selinf.sel.getChar(n);
    if(#c > 0 && #c~facePortrait > 0){
      c~facePortrait~draw(x, y, xscl, yscl, c~facePortrait~colorPallet);
    }
  }
}

void drawPortrait(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  index n = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float x = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float y = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float xscl = 1.0, yscl = 1.0;
  if(L.getTop() > argc){
    xscl = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  }
  if(L.getTop() > argc){
    yscl = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  }
  if(!.se.fskip){
    ^&.sys.Select::Char c = .syst.selinf.sel.getChar(n);
    if(#c > 0 && #c~bigPortrait > 0){
      c~bigPortrait~draw(x, y, xscl, yscl, c~bigPortrait~colorPallet);
    }
  }
}

void drawFacePortrait(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  index n = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float x = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float y = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float xscl = 1.0, yscl = 1.0;
  if(L.getTop() > argc){
    xscl = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  }
  if(L.getTop() > argc){
    yscl = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  }
  if(!.se.fskip){
    ^&.sys.Select::Char c = .syst.selinf.sel.getChar(n);
    if(#c > 0 && #c~facePortrait > 0){
      c~facePortrait~draw(x, y, xscl, yscl, c~facePortrait~colorPallet);
    }
  }
}

void drawOrderPortrait(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  index n = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float x = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float y = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float xscl = 1.0, yscl = 1.0;
  if(L.getTop() > argc){
    xscl = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  }
  if(L.getTop() > argc){
    yscl = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  }
  if(!.se.fskip){
    ^&.sys.Select::Char c = .syst.selinf.sel.getChar(n);
    if(#c > 0 && #c~orderPortrait > 0){
      c~orderPortrait~draw(x, y, xscl, yscl, c~orderPortrait~colorPallet);
    }
  }
}

void drawVSPortrait(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  index n = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float x = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float y = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float xscl = 1.0, yscl = 1.0;
  if(L.getTop() > argc){
    xscl = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  }
  if(L.getTop() > argc){
    yscl = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  }
  if(!.se.fskip){
    ^&.sys.Select::Char c = .syst.selinf.sel.getChar(n);
    if(#c > 0 && #c~vsPortrait > 0){
      c~vsPortrait~draw(x, y, xscl, yscl, c~vsPortrait~colorPallet);
    }
  }
}

void drawWinPortrait(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  index n = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float x = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float y = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float xscl = 1.0, yscl = 1.0;
  if(L.getTop() > argc){
    xscl = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  }
  if(L.getTop() > argc){
    yscl = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  }
  if(!.se.fskip){
    ^&.sys.Select::Char c = .syst.selinf.sel.getChar(n);
    if(#c > 0 && #c~winPortrait > 0){
      c~winPortrait~draw(x, y, xscl, yscl, c~winPortrait~colorPallet);
    }
  }
}

void drawLoserPortrait(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  index n = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float x = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float y = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float xscl = 1.0, yscl = 1.0;
  if(L.getTop() > argc){
    xscl = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  }
  if(L.getTop() > argc){
    yscl = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  }
  if(!.se.fskip){
    ^&.sys.Select::Char c = .syst.selinf.sel.getChar(n);
    if(#c > 0 && #c~loserPortrait > 0){
      c~loserPortrait~draw(x, y, xscl, yscl, c~loserPortrait~colorPallet);
    }
  }
}

void drawResultPortrait(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  index n = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float x = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float y = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float xscl = 1.0, yscl = 1.0;
  if(L.getTop() > argc){
    xscl = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  }
  if(L.getTop() > argc){
    yscl = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  }
  if(!.se.fskip){
    ^&.sys.Select::Char c = .syst.selinf.sel.getChar(n);
    if(#c > 0 && #c~resultPortrait > 0){
      c~resultPortrait~draw(x, y, xscl, yscl, c~resultPortrait~colorPallet);
    }
  }
}

void drawExtraPortrait(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  index n = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float x = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float y = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float xscl = 1.0, yscl = 1.0;
  if(L.getTop() > argc){
    xscl = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  }
  if(L.getTop() > argc){
    yscl = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  }
  if(!.se.fskip){
    ^&.sys.Select::Char c = .syst.selinf.sel.getChar(n);
    if(#c > 0 && #c~extraPortrait > 0){
      c~extraPortrait~draw(x, y, xscl, yscl, c~extraPortrait~colorPallet);
    }
  }
}

void drawStageIcon(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  index n = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float x = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float y = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float xscl = 1.0, yscl = 1.0;
  if(L.getTop() > argc){
    xscl = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  }
  if(L.getTop() > argc){
    yscl = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  }
  if(!.se.fskip){ 
    ^&.sys.Select::Stage c = .syst.selinf.sel.getStage(n);
    if(#c > 0 && #c~iconStagePortrait > 0){ 
       c~iconStagePortrait~draw(x, y, xscl, yscl, c~iconStagePortrait~colorPallet);
    }
  }
}

void drawStagePortrait(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  index n = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float x = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float y = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float xscl = 1.0, yscl = 1.0;
  if(L.getTop() > argc){
    xscl = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  }
  if(L.getTop() > argc){
    yscl = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  }
  if(!.se.fskip){ 
    ^&.sys.Select::Stage c = .syst.selinf.sel.getStage(n);
    if(#c > 0 && #c~bigStagePortrait > 0){ 
       c~bigStagePortrait~draw(x, y, xscl, yscl, c~bigStagePortrait~colorPallet);
    }
  }
}

void drawVSStagePortrait(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  index n = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float x = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float y = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float xscl = 1.0, yscl = 1.0;
  if(L.getTop() > argc){
    xscl = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  }
  if(L.getTop() > argc){
    yscl = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  }
  if(!.se.fskip){ 
    ^&.sys.Select::Stage c = .syst.selinf.sel.getStage(n);
    if(#c > 0 && #c~vsStagePortrait > 0){ 
       c~vsStagePortrait~draw(x, y, xscl, yscl, c~vsStagePortrait~colorPallet);
    }
  }
}

void drawWinStagePortrait(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  index n = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float x = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float y = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float xscl = 1.0, yscl = 1.0;
  if(L.getTop() > argc){
    xscl = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  }
  if(L.getTop() > argc){
    yscl = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  }
  if(!.se.fskip){ 
    ^&.sys.Select::Stage c = .syst.selinf.sel.getStage(n);
    if(#c > 0 && #c~winStagePortrait > 0){ 
       c~winStagePortrait~draw(x, y, xscl, yscl, c~winStagePortrait~colorPallet);
    }
  }
}

void drawExtraStagePortrait(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  index n = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float x = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float y = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float xscl = 1.0, yscl = 1.0;
  if(L.getTop() > argc){
    xscl = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  }
  if(L.getTop() > argc){
    yscl = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  }
  if(!.se.fskip){ 
    ^&.sys.Select::Stage c = .syst.selinf.sel.getStage(n);
    if(#c > 0 && #c~extraStagePortrait > 0){ 
       c~extraStagePortrait~draw(x, y, xscl, yscl, c~extraStagePortrait~colorPallet);
    }
  }
}

void loadLifebar(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^/char lifebar = .sc.strArg(L=, re=, argc=, nret); if(re < 0) ret;
  .syst.fig.new(1);
  ^/char error;
  if(#.syst.fig~load(lifebar)=>error > 0){
    L.pushString(error);
    re = -1;
    ret;
  }
}

void loadDebugFont(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^/char font = .sc.strArg(L=, re=, argc=, nret); if(re < 0) ret;
  .fnt.debugFont.new(1);
  .fnt.debugFont~loadFile(font);
}

void setDebugScript(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^/char dscript = .sc.strArg(L=, re=, argc=, nret); if(re < 0) ret;
  .com.debugScript = dscript;
}

void setLifeMul(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  float l = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  .com.life = l;
}

void setPowerMul(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  int p = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  .com.power = p;
}

void setTeam1VS2Life(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  float t12 = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  .com.team1VS2Life = t12;
}

void setTurnsRecoveryRate(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  float tr = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  .com.turnsRecoveryRate = tr;
}

void setZoom(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  bool z = .sc.blArg(L=, re=, argc=, nret); if(re < 0) ret;
  .com.cam.zoom = z;
}

void setZoomMin(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  float zmi = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  .com.cam.zoomMin = zmi;
}

void setZoomMax(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  float zma = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  .com.cam.zoomMax = zma;
}

void setZoomSpeed(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  float zs = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  .com.cam.zoomSpeed = 12.0 - zs;
}

void resetRemapInput(&.lua.State L=, int re=)
{
  re = 0;
  .com.resetRemapInput();
}

void getRemapInput(&.lua.State L=, int re=)
{
  int argc = 0, nret = 1;
  int pn = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  if(
    !.m.inRange!int?(1, #.com.inputRemap, pn))
  {
    L.pushString("Invalid player number.");
    re = -1;
    ret;
  }
  L.pushNumber((double).com.inputRemap[pn-1]+1.0);
}

void remapInput(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  int src = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  int dest = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  if(
    !.m.inRange!int?(1, #.com.inputRemap, src)
    || !.m.inRange!int?(1, #.com.inputRemap, dest))
  {
    L.pushString("Invalid player number.");
    re = -1;
    ret;
  }
  .com.inputRemap[src-1] = dest-1;
}

void setSharedLife(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  bool b = .sc.blArg(L=, re=, argc=, nret); if(re < 0) ret;
  .com.sharedLife = b;
}

void setHUD(&.lua.State L=, int re=)//Search setHUD in main.lua
{
  int argc = 0, nret = 0;
  bool b = .sc.blArg(L=, re=, argc=, nret); if(re < 0) ret;
  .com.statusDraw = b;
}

void setConfigTVars(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  int st = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  int dst = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  int ag = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  int ch = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  int ge = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  int rec = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  int recdir = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  int dis = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  int inp = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  //int ru = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  //int vc = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  //int lb = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  if(#.chr.chars > 1){
    .chr.chars[1]<>~tivar[1] = st;
    .chr.chars[1]<>~tivar[2] = dst;
    .chr.chars[1]<>~tivar[3] = ag;
    .chr.chars[0]<>~tivar[12] = ch;
    .chr.chars[1]<>~tivar[4] = ge;
    .chr.chars[1]<>~tivar[5] = rec;
    .chr.chars[1]<>~tivar[10] = recdir;
    .chr.chars[1]<>~tivar[6] = dis;
    .chr.chars[0]<>~tivar[11] = inp;
    //.chr.chars[1]<>~tivar[7] = ru;
    //.chr.chars[1]<>~tivar[8] = vc;
    //.chr.chars[1]<>~tivar[9] = lb;
  }
}

void getConfigTVars(&.lua.State L=, int re=)
{
  int argc = 0, nret = 1;
  int v = 0;
  int tvar = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  if(#.chr.chars > 1){
    v = .chr.chars[1-(int)(tvar==12||tvar==11)]<>~tivar[tvar];
  }
  L.pushNumber((double)v);
}

void startDummyRecord(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^&.sc.Snd snd = .sc.refArg!&.sc.Snd?(L=, re=, argc=, nret); if(re < 0) ret;  
  branch{
  cond .cmd.pbState == .cmd.PlaybackState::None:
    .cmd.pbState = .cmd.PlaybackState::CtrlP2;
    .cmd.pbState = .cmd.PlaybackState::Record;
  }
  snd~play(320, 2);
}

void endDummyPlayback(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^&.sc.Snd snd = .sc.refArg!&.sc.Snd?(L=, re=, argc=, nret); if(re < 0) ret;
  .cmd.pbState = .cmd.PlaybackState::None;
  snd~play(320, 0);
}

void playDummyRecord(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^&.sc.Snd snd = .sc.refArg!&.sc.Snd?(L=, re=, argc=, nret); if(re < 0) ret;
  .cmd.pbState = .cmd.PlaybackState::Play;
  snd~play(320, 3);
}

void setPlaybackCfg(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  int recSlot = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  int playSlot = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  bool playLoop = .sc.blArg(L=, re=, argc=, nret); if(re < 0) ret;
  bool slot1 = .sc.blArg(L=, re=, argc=, nret); if(re < 0) ret;
  bool slot2 = .sc.blArg(L=, re=, argc=, nret); if(re < 0) ret;
  bool slot3 = .sc.blArg(L=, re=, argc=, nret); if(re < 0) ret;
  bool slot4 = .sc.blArg(L=, re=, argc=, nret); if(re < 0) ret;
  bool slot5 = .sc.blArg(L=, re=, argc=, nret); if(re < 0) ret;
  .cmd.pbCfgRecSlot = recSlot;
  .cmd.pbCfgPlaySlot = playSlot <= 5 ? playSlot : 1;
  .cmd.pbCfgPlayOrder = playSlot > 5 ? playSlot-5 : 0;
  .cmd.pbCfgPlayLoop = playLoop;
  .cmd.pbCfgSlot[0] = slot1;
  .cmd.pbCfgSlot[1] = slot2;
  .cmd.pbCfgSlot[2] = slot3;
  .cmd.pbCfgSlot[3] = slot4;
  .cmd.pbCfgSlot[4] = slot5;
}

void getPlaybackCfg(&.lua.State L=, int re=)
{
  int argc = 0, nret = 1;
  int vi = 0;
  bool vb = false;
  ^/char cfg = .sc.strArg(L=, re=, argc=, nret); if(re < 0) ret;
  branch{
  cond .s.equ(cfg,"RecSlot"): vi = .cmd.pbCfgRecSlot;
  cond .s.equ(cfg,"PlaySlot"): vi = .cmd.pbCfgPlaySlot;
  cond .s.equ(cfg,"PlayLoop"): vb = .cmd.pbCfgPlayLoop;
  cond .s.equ(cfg,"Slot1"): vb = .cmd.pbCfgSlot[0];
  cond .s.equ(cfg,"Slot2"): vb = .cmd.pbCfgSlot[1];
  cond .s.equ(cfg,"Slot3"): vb = .cmd.pbCfgSlot[2];
  cond .s.equ(cfg,"Slot4"): vb = .cmd.pbCfgSlot[3];
  cond .s.equ(cfg,"Slot5"): vb = .cmd.pbCfgSlot[4];
  }
  branch{
  cond .s.equ(cfg,"RecSlot") || .s.equ(cfg,"PlaySlot"): L.pushNumber((double)vi);
  else:  L.pushBoolean(vb);
  }
}

void setSuaveMode(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  int sm = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  .com.suaveMode = sm;
}

public void init(&.lua.State L=)
{
  .sc.init(L=);
  L.register("textImgNew", .textImgNew);
  L.register("textImgGetWidth", .textImgGetWidth);
  L.register("textImgSetFont", .textImgSetFont);
  L.register("textImgSetBank", .textImgSetBank);
  L.register("textImgSetAlpha", .textImgSetAlpha);
  L.register("textImgSetWindow", .textImgSetWindow);
  L.register("textImgSetAlign", .textImgSetAlign);
  L.register("textImgSetText", .textImgSetText);
  L.register("textImgSetPos", .textImgSetPos);
  L.register("textImgAddPos", .textImgAddPos);
  L.register("textImgSetScale", .textImgSetScale);
  L.register("textImgDraw", .textImgDraw);
  L.register("animNew", .animNew);
  L.register("animSetPos", .animSetPos);
  L.register("animAddPos", .animAddPos);
  L.register("animSetTile", .animSetTile);
  L.register("animSetColorKey", .animSetColorKey);
  L.register("animSetPal", .animSetPal);
  L.register("animSetAlpha", .animSetAlpha);
  L.register("animSetScale", .animSetScale);
  L.register("animSetWindow", .animSetWindow);
  L.register("animGetFrame", .animGetFrame);
  L.register("animUpdate", .animUpdate);
  L.register("animReset", .animReset);
  L.register("animDraw", .animDraw);
  L.register("enterNetPlay", .enterNetPlay);
  L.register("exitNetPlay", .exitNetPlay);
  L.register("enterReplay", .enterReplay);
  L.register("exitReplay", .exitReplay);
  L.register("setCom", .setCom);
  L.register("setTag", .setTag);
  L.register("setAutoLevel", .setAutoLevel);
  L.register("setGameType", .setGameType);
  L.register("setGameMode", .setGameMode);
  L.register("getGameMode", .getGameMode);
  L.register("setService", .setService);
  L.register("getService", .getService);
  L.register("setPlayerSide", .setPlayerSide);
  L.register("getPlayerSide", .getPlayerSide);
  L.register("setPauseVar", .setPauseVar);
  L.register("getPauseVar", .getPauseVar);
  L.register("getListenPort", .getListenPort);
  L.register("setListenPort", .setListenPort);
  L.register("getUserName", .getUserName);
  L.register("setUserName", .setUserName);
  L.register("setBrightness", .setBrightness);
  L.register("getBrightness", .getBrightness);
  L.register("setOpacity", .setOpacity);
  L.register("setVolume", .setVolume);
  L.register("setPanStr", .setPanStr);
  L.register("getWidth", .getWidth);
  L.register("getHeight", .getHeight);
  L.register("setGameRes", .setGameRes);
  L.register("getFullScreenMode", .getFullScreenMode);
  L.register("setFullScreenMode", .setFullScreenMode);
  L.register("getScreenMode", .getScreenMode);
  L.register("setScreenMode", .setScreenMode);
  L.register("getAspectRatio", .getAspectRatio);
  L.register("setAspectRatio", .setAspectRatio);
  L.register("getWindowType", .getWindowType);
  L.register("setWindowType", .setWindowType);
  L.register("takeScreenShot", .takeScreenShot);
  L.register("configModified", .configModified);
  L.register("connected", .connected);
  L.register("synchronize", .synchronize);
  L.register("addChar", .addChar);
  L.register("addStage", .addStage);
  L.register("setRandomSpr", .setRandomSpr);
  L.register("setSelColRow", .setSelColRow);
  L.register("setSelCellSize", .setSelCellSize);
  L.register("setSelCellScale", .setSelCellScale);
  L.register("numSelCells", .numSelCells);
  L.register("setStage", .setStage);
  L.register("selectStage", .selectStage);
  L.register("setStgMusic", .setStgMusic);
  L.register("setTeamMode", .setTeamMode);
  L.register("getCharName", .getCharName);
  L.register("getCharFileName", .getCharFileName);
  L.register("selectChar", .selectChar);
  L.register("getCharVar", .getCharVar);
  L.register("setCharVar", .setCharVar);
  L.register("getHelperVar", .getHelperVar);
  L.register("setHelperVar", .setHelperVar);
  L.register("getStageName", .getStageName);
  L.register("refresh", .refresh);
  L.register("drawFace", .drawFace);
  L.register("drawPortrait", .drawPortrait);
  L.register("drawTourneyPortrait", .drawTourneyPortrait);
  L.register("drawFacePortrait", .drawFacePortrait);
  L.register("drawOrderPortrait", .drawOrderPortrait);
  L.register("drawVSPortrait", .drawVSPortrait);
  L.register("drawWinPortrait", .drawWinPortrait);
  L.register("drawLoserPortrait", .drawLoserPortrait);
  L.register("drawResultPortrait", .drawResultPortrait);
  L.register("drawExtraPortrait", .drawExtraPortrait);
  L.register("drawStageIcon", .drawStageIcon);
  L.register("drawStagePortrait", .drawStagePortrait);
  L.register("drawVSStagePortrait", .drawVSStagePortrait);
  L.register("drawWinStagePortrait", .drawWinStagePortrait);
  L.register("drawExtraStagePortrait", .drawExtraStagePortrait);
  L.register("loadLifebar", .loadLifebar);
  L.register("loadDebugFont", .loadDebugFont);
  L.register("setDebugScript", .setDebugScript);
  L.register("setLifeMul", .setLifeMul);
  L.register("setPowerMul", .setPowerMul);
  L.register("setTeam1VS2Life", .setTeam1VS2Life);
  L.register("setTurnsRecoveryRate", .setTurnsRecoveryRate);
  L.register("setZoom", .setZoom);
  L.register("setZoomMin", .setZoomMin);
  L.register("setZoomMax", .setZoomMax);
  L.register("setZoomSpeed", .setZoomSpeed);
  L.register("swapController", .swapController);
  L.register("swapGamepad", .swapGamepad);
  L.register("disableGamepad", .disableGamepad);
  L.register("getInputKeyboard", .getInputKeyboard);
  L.register("getInputID", .getInputID);
  L.register("inputReset", .inputReset);
  L.register("setInputConfig", .setInputConfig);
  L.register("resetRemapInput", .resetRemapInput);
  L.register("getRemapInput", .getRemapInput);
  L.register("remapInput", .remapInput);
  L.register("setSharedLife", .setSharedLife);
  L.register("setHUD", .setHUD);
  L.register("setInputDisplay", .setInputDisplay);
  L.register("setDamageDisplay", .setDamageDisplay);
  L.register("setPowerStateP1", .setPowerStateP1);
  L.register("setPowerStateP2", .setPowerStateP2);
  L.register("setLifeStateP1", .setLifeStateP1);
  L.register("setLifeStateP2", .setLifeStateP2);
  L.register("setDummyState", .setDummyState);
  L.register("setDummyDistance", .setDummyDistance);
  L.register("setDummyGuard", .setDummyGuard);
  L.register("setDummyRecovery", .setDummyRecovery);
  L.register("setCounterHit", .setCounterHit);
  L.register("setConfigTVars", .setConfigTVars);
  L.register("getConfigTVars", .getConfigTVars);
  L.register("setPlaybackCfg", .setPlaybackCfg);
  L.register("getPlaybackCfg", .getPlaybackCfg);
  L.register("startDummyRecord", .startDummyRecord);
  L.register("endDummyPlayback", .endDummyPlayback);
  L.register("playDummyRecord", .playDummyRecord);
  L.register("setSuaveMode", .setSuaveMode);
}