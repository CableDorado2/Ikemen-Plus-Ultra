--;===========================================================
--; INITIAL ACTIONS
--;===========================================================
math.randomseed(os.time())

--Load Common stuff (shared with pause.lua)
require("script.common")

--Debug/Match Stuff
loadDebugFont(fontDebug)
setDebugScript("script/match.lua")

--Assign Lifebar Screenpack
loadLifebar(fightDef)

--;===========================================================
--; GLOBAL VARIABLES DEFINITION
--;===========================================================
onlinegame = false
replaygame = false
coinSystem = true
songsSettings = false
soundTest = false
altBGM = false
data.tagmode = 1
data.stageviewer = false
menuSelect = ""
P2overP1 = false
secretTarget = ""
unlockTarget = ""
vnNoSel = true
--Default turns/simul count after starting the game
p1numTurns = 2
p2numTurns = 2
p1numSimul = 2
p2numSimul = 2
--default team mode after starting the game (0 - Single, 1 - Simul, 2 - Turns)
p1teamMode = 0
p2teamMode = 0

function f_resetArcadeStuff()
stats.continueCount = 0 --Restart Times Continue in Arcade
f_saveStats()
keepLSide = false
keepRSide = false
end

--;===========================================================
--; LOAD ADDITIONAL SCRIPTS
--;===========================================================
assert(loadfile("script/loader.lua"))()
assert(loadfile("data/visualnovel/VNresources.lua"))()
require("script.options")

--;===========================================================
--; GAME START
--;===========================================================
function f_mainStart()
	gameTime = (os.clock()/1000)
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	f_infoReset() --Allow select options below if the Engine detects characters or stages
--First Check (Table generated by Sections)
	if data.engineMode == "FG" then
		if t_selChars == nil then --If the Engine not detect Characters
			charsInfo = true
			infoScreen = true
			f_exitMenu()
		elseif t_selStages == nil then --If the Engine not detect Stages
			stagesInfo = true
			infoScreen = true
			f_exitMenu()
		elseif t_selOptions == nil then --If the Engine not detect Arcade and Survival roster Config in [Options] section from select.def
			configInfo = true
			infoScreen = true
			f_exitMenu()
		end
	elseif data.engineMode == "VN" then
		t_selChars = {}
		t_selStages = {}
		if t_selVN == 0 then --If the Engine not detect Visual Novel
			vnInfo = true
			infoScreen = true
			f_exitMenu()
		end
	end
--Second Check (Content store in tables)
	if #t_selChars == 0 and data.engineMode == "FG" then --[Characters] section detected but there's not characters added
		charsInfo = true
		infoScreen = true
		f_exitMenu()
	elseif #t_selStages == 0 and data.engineMode == "FG" then --[ExtraStages] section detected but there's not stages added
		stagesInfo = true
		infoScreen = true
		f_exitMenu()
	else --Everything is "ok"
		f_resetTemp()
		f_soundtrack() --Load Soundtrack Tables from common.lua for use in menus
		f_unlock(false) --Check For Unlocked Content
		f_updateUnlocks() --Print Unlock Data (when Save Debug Logs is Enabled)
		f_mainLogos()
		if data.engineMode == "VN" then --Engine will load main menu function for Visual Novel Game
			f_mainTitle()
		elseif data.engineMode == "FG" then --Engine will load main menu function for Fighting Game
			f_resetArcadeStuff()
			if data.attractMode == true then
				coinSystem = false
			--[[Restart Credits for Attract Mode
				stats.attractCoins = 0
				f_saveStats()
			]]
				f_mainAttract()
			else
				f_mainTitle()
			end
		end
	end
end

--;===========================================================
--; LOGOS SCREEN
--;===========================================================
function f_mainLogos()
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	f_storyboard(storyboardLogo)
	f_mainOpening()
end

function f_mainOpening()
	--if altBGM then playBGM(bgmIntroJP) else playBGM(bgmIntro) end
	--f_storyboard("data/screenpack/intro.def")
	playVideo(videoOpening)
	if altBGM then altBGM = false else altBGM = true end --Alternate Storyboard Opening BGM Songs
end

--;===========================================================
--; TITLE SCREEN
--;===========================================================
function f_mainTitle()
	cmdInput()
	local i = 0
	local t = 0
	f_resetFadeBGM()
	playBGM(bgmTitle)
	while true do
		if i == 500 then
			i = 0
			--if data.engineMode == "FG" then demoModeCfg() end
			f_mainLogos()
			playBGM(bgmTitle)
		elseif btnPalNo(p1Cmd) > 0 or btnPalNo(p2Cmd) > 0 then
			sndPlay(sndSys, 100, 1) --Play SFX from .snd file
			i = 0
			f_mainMenu()
		elseif esc() or commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then
			i = 0
			sndPlay(sndSys, 100, 2)
			f_exitMenu()
		end
		drawBottomMenuSP()
		animSetWindow(cursorBox, 0, 160, 290, 13)
		f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
		animDraw(f_animVelocity(cursorBox, -1, -1))
		drawMiddleMenuSP()
		textImgDraw(txt_titleFt)
		textImgSetText(txt_titleFt, "WELCOME TO SUEHIRO IKEMEN ENGINE")
		f_sysTime()
		drawTitleInputHints()
		if t%60 < 30 then
			textImgDraw(txt_mainTitle)
		end
		t = t >= 60 and 0 or t + 1
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		i = i + 1
		cmdInput()
		refresh()
	end
end

--Load Common Settings for Demo Mode
function demoModeCfg()
	f_default()
	setGameMode('demo')
	data.gameMode = "demo"
	data.rosterMode = "cpu"
	data.aiFight = true
	data.versusScreen = false
	data.victoryscreen = false
	data.p1TeamMenu = {mode = 0, chars = 1}
	data.p2TeamMenu = {mode = 0, chars = 1}
	data.p1Char = {t_selChars[t_randomChars[math.random(#t_randomChars)]+1].char} --Pick Random Char
	data.p2Char = {t_selChars[t_randomChars[math.random(#t_randomChars)]+1].char} --Pick Random Char
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	f_selectSimple()
	f_resetTemp()
end

--;===========================================================
--; ATTRACT MENU
--;===========================================================
function f_mainAttract()
	cmdInput()
	local t = 0
	attractSeconds = data.attractTime
	attractTimer = attractSeconds*gameTick --Set time for Attract Title Screen
	local demoTimer = 0
	playBGM(bgmTitle)
	f_attractExitItem()
	while true do
	--INSERT COIN
		if btnPalNo(p1Cmd) > 0 or btnPalNo(p2Cmd) > 0 then
		   sndPlay(sndSys, 200, 0)
		   demoTimer = 0
		   stats.attractCoins = stats.attractCoins + 1
		   f_saveStats()
		   attractTimer = attractSeconds*gameTick --Reset Timer
	--START GAME MODE
		elseif ((commandGetState(p1Cmd, 's') or commandGetState(p2Cmd, 's')) or attractTimer == 0) and stats.attractCoins > 0 then
		   --playVideo(videoHowToPlay)
		   data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
		   sndPlay(sndSys, 100, 1)
		   stats.attractCoins = stats.attractCoins - 1
		   f_saveStats()
		   attractTimer = attractSeconds*gameTick
		   f_default()
		   --data.p1TeamMenu = {mode = 0, chars = 1}
		   --data.p2TeamMenu = {mode = 0, chars = 1}
		   data.p2In = 1
		   data.p2SelectMenu = false
		   data.serviceScreen = true
		   data.arcadeIntro = true
		   data.arcadeEnding = true
		   --data.stageMenu = true
		   setGameMode('arcade')
		   data.gameMode = "arcade"
		   data.rosterMode = "arcade"
		   textImgSetText(txt_mainSelect, "ARCADE")
		   f_selectAdvance()
	--START DEMO MODE
		elseif demoTimer == 350 then
		   demoModeCfg()
		   f_mainLogos()
		   playBGM(bgmTitle)
		   demoTimer = 0
		   attractTimer = attractSeconds*gameTick
	--EXIT
		elseif esc() or commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then
			sndPlay(sndSys, 100, 2)
			attractTimer = attractSeconds*gameTick
			f_exitMenu()
			--attractSeconds = data.attractTime --Load New Attract Time settings in case that you modify them
		end
		animDraw(f_animVelocity(titleBG0, -2.15, 0))
		animSetWindow(cursorBox, 0, 160, 290, 13)
		f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
		animDraw(f_animVelocity(cursorBox, -1, -1))
		animDraw(titleBG1)
		animAddPos(titleBG2, -1, 0)
		animUpdate(titleBG2)
		animDraw(titleBG2)
		animDraw(titleBG3)
		animDraw(titleBG4)
		animDraw(titleBG5)
		f_titleText()
		f_attractCredits()
		attractTimeNumber = attractTimer/gameTick --Convert Ticks to Seconds
		nodecimalAttractTime = string.format("%.0f",attractTimeNumber) --Delete Decimals
		textImgSetText(txt_attractTimer, nodecimalAttractTime)
		if attractTimer > 0 and stats.attractCoins > 0 then
			attractTimer = attractTimer - 0.5 --Activate Title Screen Timer
			textImgDraw(txt_attractTimer)
		else --when attractTimer <= 0
			demoTimer = demoTimer + 1
		end
		f_sysTime()
		drawAttractInputHints()
		if t%60 < 30 then
			if stats.attractCoins > 0 then
				textImgDraw(txt_mainTitle)
			else
				textImgDraw(txt_coinTitle)
			end
		end
		t = t >= 60 and 0 or t + 1
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		cmdInput()
		refresh()
	end
end

--;===========================================================
--; MAIN MENU
--;===========================================================
function f_mainMenu()
	cmdInput()
	local cursorPosY = 0
	local moveTxt = 0
	local mainMenu = 1
	local bufu = 0
	local bufd = 0
	local bufr = 0
	local bufl = 0
	closeText = 1
	f_menuMusic()
	f_infoReset()
	f_infoboxReset()
	f_resetFadeBGM()
	f_resetMenuArrowsPos()
	while true do
		if not infoScreen and not infoboxScreen then
		--First Run Msg
			if stats.firstRun then
				firstRunInfo = true
				infoScreen = true
			end
			if f1Key() then infoboxScreen = true end --Show Classic Mugen Info Screen
			if esc() or commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then
				sndPlay(sndSys, 100, 2)
				playBGM(bgmTitle)
				return
			elseif commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u') or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30) then
				sndPlay(sndSys, 100, 0)
				mainMenu = mainMenu - 1
			elseif commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd') or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30) then
				sndPlay(sndSys, 100, 0)
				mainMenu = mainMenu + 1
			end
		--mode titles/cursor position calculation
			if mainMenu < 1 then
				mainMenu = #t_mainMenu
				if #t_mainMenu > 5 then
					cursorPosY = 5
				else
					cursorPosY = #t_mainMenu-1
				end
			elseif mainMenu > #t_mainMenu then
				mainMenu = 1
				cursorPosY = 0
			elseif ((commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u')) or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30)) and cursorPosY > 0 then
				cursorPosY = cursorPosY - 1
			elseif ((commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd')) or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30)) and cursorPosY < 5 then
				cursorPosY = cursorPosY + 1
			end
			if cursorPosY == 5 then
				moveTxt = (mainMenu - 6) * 13
			elseif cursorPosY == 0 then
				moveTxt = (mainMenu - 1) * 13
			end
			if #t_mainMenu <= 5 then
				maxMainMenu = #t_mainMenu
			elseif mainMenu - cursorPosY > 0 then
				maxMainMenu = mainMenu + 5 - cursorPosY
			else
				maxMainMenu = 5
			end
		--Enter Actions
			if btnPalNo(p1Cmd) > 0 or btnPalNo(p2Cmd) > 0 then
				sndPlay(sndSys, 100, 1)
				f_gotoFunction(t_mainMenu[mainMenu]) --Functions are called from t_mainMenu table
			end
		end
		drawBottomMenuSP()
		for i=1, #t_mainMenu do
			if i == mainMenu then
				bank = 5 --Text Color (0=Nothing, 1=Red, 2=Green, 3=Blue, 4=Nothing, 5=Yellow, 6=Pink, 7=Shadow, 8=Black, 9=¿?)
			else
				bank = 0
			end
			if not infoboxScreen then
				textImgDraw(f_updateTextImg(t_mainMenu[i].id, jgFnt, bank, 0, t_mainMenu[i].text, 159, 122+i*13-moveTxt)) --Text Position
			end
		end
		if not infoScreen and not infoboxScreen then
			animSetWindow(cursorBox, 0,125+cursorPosY*13, 316,13) --Position and Size of the selection cursor
			f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
			animDraw(f_animVelocity(cursorBox, -1, -1)) --Blink rate
		end
		drawMiddleMenuSP()
		f_sysTime()
		if not infoboxScreen then
			textImgDraw(txt_gameFt)
			textImgSetText(txt_gameFt, "MAIN MENU")
			textImgDraw(txt_version)
			textImgDraw(txt_f1)
			if maxMainMenu > 6 then
				animDraw(menuArrowUp)
				animUpdate(menuArrowUp)
			end
			if #t_mainMenu > 6 and maxMainMenu < #t_mainMenu then
				animDraw(menuArrowDown)
				animUpdate(menuArrowDown)
			end
		end
		if infoScreen then
			f_infoMenu()
		else
			drawMenuInputHints()
		end
		if infoboxScreen then f_infoboxMenu() end
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		if commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu') then
			bufd = 0
			bufu = bufu + 1
		elseif commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd') then
			bufu = 0
			bufd = bufd + 1
		else
			bufu = 0
			bufd = 0
		end
		cmdInput()
		refresh()
	end
end

--;===========================================================
--; OPTIONS MENU (adjust game settings)
--;===========================================================
function f_optionsMenu()
	onlinegame = false --only for identify purposes
	assert(loadfile(saveCfgPath))()
	script.options.f_mainCfg() --start f_mainCfg() function from script/options.lua
end

--;===========================================================
--; CHECK UPDATES
--;===========================================================
function f_checkUpdates()
	webOpen("https://github.com/CableDorado2/Ikemen-Plus-Ultra")
end

--;===========================================================
--; ARCADE MENU (select arcade variants)
--;===========================================================
function f_arcadeMenu()
	cmdInput()
	local cursorPosY = 0
	local moveTxt = 0
	local arcadeMenu = 1
	local bufu = 0
	local bufd = 0
	local bufr = 0
	local bufl = 0
	f_infoReset()
	f_sideReset() --Reset Values to Show Side Select
	while true do
		if not infoScreen and not sideScreen then --Turn off controls over arcade menu if Side Select is active
			if esc() or commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then
				sndPlay(sndSys, 100, 2)
				break
			elseif commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u') or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30) then
				sndPlay(sndSys, 100, 0)
				arcadeMenu = arcadeMenu - 1
			elseif commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd') or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30) then
				sndPlay(sndSys, 100, 0)
				arcadeMenu = arcadeMenu + 1
			end
			if arcadeMenu < 1 then
				arcadeMenu = #t_arcadeMenu
				if #t_arcadeMenu > 5 then
					cursorPosY = 5
				else
					cursorPosY = #t_arcadeMenu-1
				end
			elseif arcadeMenu > #t_arcadeMenu then
				arcadeMenu = 1
				cursorPosY = 0
			elseif ((commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u')) or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30)) and cursorPosY > 0 then
				cursorPosY = cursorPosY - 1
			elseif ((commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd')) or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30)) and cursorPosY < 5 then
				cursorPosY = cursorPosY + 1
			end
			if cursorPosY == 5 then
				moveTxt = (arcadeMenu - 6) * 13
			elseif cursorPosY == 0 then
				moveTxt = (arcadeMenu - 1) * 13
			end
			if #t_arcadeMenu <= 5 then
				maxArcadeMenu = #t_arcadeMenu
			elseif arcadeMenu - cursorPosY > 0 then
				maxArcadeMenu = arcadeMenu + 5 - cursorPosY
			else
				maxArcadeMenu = 5
			end
		--Enter Actions
			if btnPalNo(p1Cmd) > 0 or btnPalNo(p2Cmd) > 0 then
				sndPlay(sndSys, 100, 1)
				f_gotoFunction(t_arcadeMenu[arcadeMenu])
			end
		end
		drawBottomMenuSP()
		for i=1, #t_arcadeMenu do
			if i == arcadeMenu then
				bank = 5
			else
				bank = 0
			end
			textImgDraw(f_updateTextImg(t_arcadeMenu[i].id, jgFnt, bank, 0, t_arcadeMenu[i].text, 159, 122+i*13-moveTxt))
		end
		if not infoScreen and not sideScreen then
			animSetWindow(cursorBox, 0,125+cursorPosY*13, 316,13)
			f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
			animDraw(f_animVelocity(cursorBox, -1, -1))
		end
		drawMiddleMenuSP()
		textImgDraw(txt_gameFt)		
		textImgSetText(txt_gameFt, "ARCADE MODES")
		textImgDraw(txt_version)
		f_sysTime()
		if maxArcadeMenu > 6 then
			animDraw(menuArrowUp)
			animUpdate(menuArrowUp)
		end
		if #t_arcadeMenu > 6 and maxArcadeMenu < #t_arcadeMenu then
			animDraw(menuArrowDown)
			animUpdate(menuArrowDown)
		end
		if not infoScreen and not sideScreen then drawMenuInputHints() end
		if sideScreen then f_sideSelect() end --Show Side Select
		if infoScreen then f_infoMenu() end
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		if commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu') then
			bufd = 0
			bufu = bufu + 1
		elseif commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd') then
			bufu = 0
			bufd = bufd + 1
		else
			bufu = 0
			bufd = 0
		end
		cmdInput()
		refresh()
	end
end

--;===========================================================
--; VERSUS MENU (face specific opponents)
--;===========================================================
function f_vsMenu()
	cmdInput()
	local cursorPosY = 0
	local moveTxt = 0
	local vsMenu = 1
	local bufu = 0
	local bufd = 0
	local bufr = 0
	local bufl = 0
	f_infoReset()
	f_sideReset()
	while true do
		if not infoScreen and not sideScreen then
			if esc() or commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then
				sndPlay(sndSys, 100, 2)
				break
			elseif commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u') or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30) then
				sndPlay(sndSys, 100, 0)
				vsMenu = vsMenu - 1
			elseif commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd') or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30) then
				sndPlay(sndSys, 100, 0)
				vsMenu = vsMenu + 1
			end
			if vsMenu < 1 then
				vsMenu = #t_vsMenu
				if #t_vsMenu > 5 then
					cursorPosY = 5
				else
					cursorPosY = #t_vsMenu-1
				end
			elseif vsMenu > #t_vsMenu then
				vsMenu = 1
				cursorPosY = 0
			elseif ((commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u')) or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30)) and cursorPosY > 0 then
				cursorPosY = cursorPosY - 1
			elseif ((commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd')) or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30)) and cursorPosY < 5 then
				cursorPosY = cursorPosY + 1
			end
			if cursorPosY == 5 then
				moveTxt = (vsMenu - 6) * 13
			elseif cursorPosY == 0 then
				moveTxt = (vsMenu - 1) * 13
			end
			if #t_vsMenu <= 5 then
				maxVSMenu = #t_vsMenu
			elseif vsMenu - cursorPosY > 0 then
				maxVSMenu = vsMenu + 5 - cursorPosY
			else
				maxVSMenu = 5
			end
		--Enter Actions
			if btnPalNo(p1Cmd) > 0 or btnPalNo(p2Cmd) > 0 then
				sndPlay(sndSys, 100, 1)
				f_gotoFunction(t_vsMenu[vsMenu])
			end
		end
		drawBottomMenuSP()
		for i=1, #t_vsMenu do
			if i == vsMenu then
				bank = 5
			else
				bank = 0
			end
			textImgDraw(f_updateTextImg(t_vsMenu[i].id, jgFnt, bank, 0, t_vsMenu[i].text, 159, 122+i*13-moveTxt))
		end
		if not infoScreen and not sideScreen then
			animSetWindow(cursorBox, 0,125+cursorPosY*13, 316,13)
			f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
			animDraw(f_animVelocity(cursorBox, -1, -1))
		end
		drawMiddleMenuSP()
		textImgDraw(txt_gameFt)
		textImgSetText(txt_gameFt, "VERSUS MODES")
		textImgDraw(txt_version)
		f_sysTime()
		if maxVSMenu > 6 then
			animDraw(menuArrowUp)
			animUpdate(menuArrowUp)
		end
		if #t_vsMenu > 6 and maxVSMenu < #t_vsMenu then
			animDraw(menuArrowDown)
			animUpdate(menuArrowDown)
		end
		if not infoScreen and not sideScreen then drawMenuInputHints() end
		if sideScreen then f_sideSelect() end
		if infoScreen then f_infoMenu() end
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		if commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu') then
			bufd = 0
			bufu = bufu + 1
		elseif commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd') then
			bufu = 0
			bufd = bufd + 1
		else
			bufu = 0
			bufd = 0
		end
		cmdInput()
		refresh()
	end
end

--;===========================================================
--; TRAINING MODE (practice special attacks and combos with training dummy character(s) of your choice)
--;===========================================================
function f_training()
	f_default()
	setGameMode('practice')
	data.gameMode = "training"
	data.rosterMode = "training"
	setRoundTime(-1) --round time disabled
	data.versusScreen = false --versus screen disabled
	data.victoryscreen = false --victory screen disabled
	data.stageMenu = true
	data.p1TeamMenu = {mode = 0, chars = 1} --predefined P1 team mode as Single, 1 Character				
	data.p2TeamMenu = {mode = 0, chars = 1} --predefined P2 team mode as Single, 1 Character
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	--sndPlay(sndSys, 100, 1)
	if #t_trainingChar ~= 0 then --If a training char is detected in select.def with training=1 paramvalue
		data.p2In = 2
		data.p2Char = {t_selChars[t_trainingChar[math.random(#t_trainingChar)]+1].char} --pick a random training char from the table
	else --Training Char will be selected in char select if there is not training chars detected in select.def with training=1 paramvalue
		data.p2In = 1
		data.p2Faces = true
	end
	textImgSetText(txt_mainSelect, "TRAINING MODE")
	f_selectSimple()
end

--;===========================================================
--; CHALLENGES MENU (play advanced game modes)
--;===========================================================	
function f_challengeMenu()
	cmdInput()
	local cursorPosY = 0
	local moveTxt = 0
	local challengeMenu = 1
	local bufu = 0
	local bufd = 0
	local bufr = 0
	local bufl = 0
	f_infoReset()
	f_sideReset()
	while true do
		if not infoScreen and not sideScreen then
			if esc() or commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then
				sndPlay(sndSys, 100, 2)
				break
			elseif commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u') or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30) then
				sndPlay(sndSys, 100, 0)
				challengeMenu = challengeMenu - 1
			elseif commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd') or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30) then
				sndPlay(sndSys, 100, 0)
				challengeMenu = challengeMenu + 1
			end
			if challengeMenu < 1 then
				challengeMenu = #t_challengeMenu
				if #t_challengeMenu > 5 then
					cursorPosY = 5
				else
					cursorPosY = #t_challengeMenu-1
				end
			elseif challengeMenu > #t_challengeMenu then
				challengeMenu = 1
				cursorPosY = 0
			elseif ((commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u')) or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30)) and cursorPosY > 0 then
				cursorPosY = cursorPosY - 1
			elseif ((commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd')) or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30)) and cursorPosY < 5 then
				cursorPosY = cursorPosY + 1
			end
			if cursorPosY == 5 then
				moveTxt = (challengeMenu - 6) * 13
			elseif cursorPosY == 0 then
				moveTxt = (challengeMenu - 1) * 13
			end
			if #t_challengeMenu <= 5 then
				maxChallengeMenu = #t_challengeMenu
			elseif challengeMenu - cursorPosY > 0 then
				maxChallengeMenu = challengeMenu + 5 - cursorPosY
			else
				maxChallengeMenu = 5
			end
		--Enter Actions
			if btnPalNo(p1Cmd) > 0 or btnPalNo(p2Cmd) > 0 then
				sndPlay(sndSys, 100, 1)
				f_gotoFunction(t_challengeMenu[challengeMenu])
			end
		end
		drawBottomMenuSP()
		for i=1, #t_challengeMenu do
			if i == challengeMenu then
				bank = 1
			else
				bank = 0
			end
			textImgDraw(f_updateTextImg(t_challengeMenu[i].id, jgFnt, bank, 0, t_challengeMenu[i].text, 159, 122+i*13-moveTxt))
		end
		if not infoScreen and not sideScreen then
			animSetWindow(cursorBox, 0,125+cursorPosY*13, 316,13)
			f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
			animDraw(f_animVelocity(cursorBox, -1, -1))
		end
		drawMiddleMenuSP()
		textImgDraw(txt_gameFt)
		textImgSetText(txt_gameFt, "CHALLENGES MODES")
		textImgDraw(txt_version)
		f_sysTime()
		if maxChallengeMenu > 6 then
			animDraw(menuArrowUp)
			animUpdate(menuArrowUp)
		end
		if #t_challengeMenu > 6 and maxChallengeMenu < #t_challengeMenu then
			animDraw(menuArrowDown)
			animUpdate(menuArrowDown)
		end
		if not infoScreen and not sideScreen then drawMenuInputHints() end
		if sideScreen then f_sideSelect() end
		if infoScreen then f_infoMenu() end
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		if commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu') then
			bufd = 0
			bufu = bufu + 1
		elseif commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd') then
			bufu = 0
			bufd = bufd + 1
		else
			bufu = 0
			bufd = 0
		end
		cmdInput()
		refresh()
	end
end

--;===========================================================
--; EXTRAS MENU (play special game modes)
--;===========================================================	
function f_extrasMenu()
	if stats.modes.arcade.clear < 1 then
		f_secret()
		return
	end
	cmdInput()
	local cursorPosY = 0
	local moveTxt = 0
	local extrasMenu = 1
	local bufu = 0
	local bufd = 0
	local bufr = 0
	local bufl = 0
	f_sideReset()
	f_infoReset()
	while true do
		if not sideScreen and not infoScreen then
			if esc() or commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then
				sndPlay(sndSys, 100, 2)
				break
			elseif commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u') or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30) then
				sndPlay(sndSys, 100, 0)
				extrasMenu = extrasMenu - 1
			elseif commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd') or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30) then
				sndPlay(sndSys, 100, 0)
				extrasMenu = extrasMenu + 1
			end
			if extrasMenu < 1 then
				extrasMenu = #t_extrasMenu
				if #t_extrasMenu > 5 then
					cursorPosY = 5
				else
					cursorPosY = #t_extrasMenu-1
				end
			elseif extrasMenu > #t_extrasMenu then
				extrasMenu = 1
				cursorPosY = 0
			elseif ((commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u')) or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30)) and cursorPosY > 0 then
				cursorPosY = cursorPosY - 1
			elseif ((commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd')) or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30)) and cursorPosY < 5 then
				cursorPosY = cursorPosY + 1
			end
			if cursorPosY == 5 then
				moveTxt = (extrasMenu - 6) * 13
			elseif cursorPosY == 0 then
				moveTxt = (extrasMenu - 1) * 13
			end
			if #t_extrasMenu <= 5 then
				maxExtrasMenu = #t_extrasMenu
			elseif extrasMenu - cursorPosY > 0 then
				maxExtrasMenu = extrasMenu + 5 - cursorPosY
			else
				maxExtrasMenu = 5
			end
		--Enter Actions
			if btnPalNo(p1Cmd) > 0 or btnPalNo(p2Cmd) > 0 then
				sndPlay(sndSys, 100, 1)
				f_gotoFunction(t_extrasMenu[extrasMenu])
			end
		end
		drawBottomMenuSP()
		for i=1, #t_extrasMenu do
			if i == extrasMenu then
				bank = 2
			else
				bank = 0
			end
			textImgDraw(f_updateTextImg(t_extrasMenu[i].id, jgFnt, bank, 0, t_extrasMenu[i].text, 159, 122+i*13-moveTxt))
		end
		if not sideScreen and not infoScreen then
			animSetWindow(cursorBox, 0,125+cursorPosY*13, 316,13)
			f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
			animDraw(f_animVelocity(cursorBox, -1, -1))
		end
		drawMiddleMenuSP()
		textImgDraw(txt_gameFt)
		textImgSetText(txt_gameFt, "EXTRA MODES")
		textImgDraw(txt_version)
		f_sysTime()
		if maxExtrasMenu > 6 then
			animDraw(menuArrowUp)
			animUpdate(menuArrowUp)
		end
		if #t_extrasMenu > 6 and maxExtrasMenu < #t_extrasMenu then
			animDraw(menuArrowDown)
			animUpdate(menuArrowDown)
		end
		if not infoScreen and not sideScreen then drawMenuInputHints() end
		if sideScreen then f_sideSelect() end
		if infoScreen then f_infoMenu() end
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		if commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu') then
			bufd = 0
			bufu = bufu + 1
		elseif commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd') then
			bufu = 0
			bufd = bufd + 1
		else
			bufu = 0
			bufd = 0
		end
		cmdInput()
		refresh()
	end
end

--;===========================================================
--; WATCH MENU (watch replays, rankings, player data, gallery and more)
--;===========================================================
function f_watchMenu()
	cmdInput()
	local cursorPosY = 0
	local moveTxt = 0
	local watchMenu = 1
	local bufu = 0
	local bufd = 0
	local bufr = 0
	local bufl = 0
	f_infoReset()
	while true do
		if not infoScreen then
			if esc() or commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then
				sndPlay(sndSys, 100, 2)
				break
			elseif commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u') or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30) then
				sndPlay(sndSys, 100, 0)
				watchMenu = watchMenu - 1
			elseif commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd') or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30) then
				sndPlay(sndSys, 100, 0)
				watchMenu = watchMenu + 1
			end
			if watchMenu < 1 then
				watchMenu = #t_watchMenu
				if #t_watchMenu > 5 then
					cursorPosY = 5
				else
					cursorPosY = #t_watchMenu-1
				end
			elseif watchMenu > #t_watchMenu then
				watchMenu = 1
				cursorPosY = 0
			elseif ((commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u')) or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30)) and cursorPosY > 0 then
				cursorPosY = cursorPosY - 1
			elseif ((commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd')) or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30)) and cursorPosY < 5 then
				cursorPosY = cursorPosY + 1
			end
			if cursorPosY == 5 then
				moveTxt = (watchMenu - 6) * 13
			elseif cursorPosY == 0 then
				moveTxt = (watchMenu - 1) * 13
			end
			if #t_watchMenu <= 5 then
				maxWatchMenu = #t_watchMenu
			elseif watchMenu - cursorPosY > 0 then
				maxWatchMenu = watchMenu + 5 - cursorPosY
			else
				maxWatchMenu = 5
			end
		--Enter Actions
			if btnPalNo(p1Cmd) > 0 or btnPalNo(p2Cmd) > 0 then
				sndPlay(sndSys, 100, 1)
				f_gotoFunction(t_watchMenu[watchMenu])
			end
		end
		drawBottomMenuSP()
		for i=1, #t_watchMenu do
			if i == watchMenu then
				bank = 5
			else
				bank = 0
			end
			textImgDraw(f_updateTextImg(t_watchMenu[i].id, jgFnt, bank, 0, t_watchMenu[i].text, 159, 122+i*13-moveTxt))
		end
		if not infoScreen then
			animSetWindow(cursorBox, 0,125+cursorPosY*13, 316,13)
			f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
			animDraw(f_animVelocity(cursorBox, -1, -1))
		end
		drawMiddleMenuSP()
		textImgDraw(txt_gameFt)
		textImgSetText(txt_gameFt, "WATCH CONTENT")
		textImgDraw(txt_version)
		f_sysTime()
		if maxWatchMenu > 6 then
			animDraw(menuArrowUp)
			animUpdate(menuArrowUp)
		end
		if #t_watchMenu > 6 and maxWatchMenu < #t_watchMenu then
			animDraw(menuArrowDown)
			animUpdate(menuArrowDown)
		end
		if infoScreen then f_infoMenu() else drawMenuInputHints() end
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		if commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu') then
			bufd = 0
			bufu = bufu + 1
		elseif commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd') then
			bufu = 0
			bufd = bufd + 1
		else
			bufu = 0
			bufd = 0
		end
		cmdInput()
		refresh()
	end
end

--;===========================================================
--; CLASSIC ARCADE MODE (play a customizable arcade ladder)
--;===========================================================
function f_arcadeBoot()
	menuSelect = "arcade"
	sideScreen = true
end

--Load Common Settings for Classic Arcade Modes
function arcadeCfg()
	f_resetArcadeStuff()
	f_default() --Load f_default function defined in common.lua
	setGameMode('arcade')
	data.gameMode = "arcade" --mode recognized in select screen as arcade
	data.rosterMode = "arcade" --to record statistics
	data.serviceScreen = true --Enable Service Screen if you lose and continue
	data.arcadeIntro = true --Enable characters arcade intro before versus screen
	data.arcadeEnding = true --Enable characters arcade ending before credits screen
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	sndPlay(sndSys, 100, 1)
end

--HUMAN VS CPU (fight against CPU controlled opponents in a customizable arcade ladder from left side)
function arcadeHumanvsCPU()
	if P2overP1 then --Set player 2 controls config over player 1
		remapInput(1, 2) --P1 swap controls with p2 side
		setPlayerSide('p2left') --will be used to open challenger screen
	else
		setPlayerSide('p1left')
	end
	data.p2In = 1 --P1 controls P2 side of the select screen (but not the character only menus)
	data.p2SelectMenu = false --P2 character selection disabled
	textImgSetText(txt_mainSelect, "ARCADE") --message displayed on top of select screen
	f_selectAdvance() --start f_selectAdvance() function
	P2overP1 = false --Reset Player 2 Control Swap Detection
end

--CPU VS HUMAN (fight against CPU controlled opponents in a customizable arcade ladder from right side)
function arcadeCPUvsHuman()
	remapInput(1, 2)
	if not P2overP1 then
		remapInput(2, 1) --P2 swap controls with p1 side
		setPlayerSide('p1right') --set Pause Controls if P1 is in Right Side
	else
		setPlayerSide('p2right')
	end
	data.p1In = 2
	data.p2In = 2
	data.p1SelectMenu = false --P1 character selection disabled
	textImgSetText(txt_mainSelect, "ARCADE")
	f_selectAdvance()
	P2overP1 = false
end

--P1&P2 VS CPU [CO-OP MODE] (team up with another player from left side against CPU controlled opponents in a customizable arcade ladder)
function arcadeP1P2vsCPU()
	data.p2In = 2
	data.p2Faces = true
	data.coop = true --P2 fighting on P1 side enabled
	setPlayerSide('p1left')
	setGameMode('arcadecoop') --to avoid challenger screen
	textImgSetText(txt_mainSelect, "ARCADE COOPERATIVE")
	f_selectAdvance()
end

--CPU VS P1&P2 [CO-OP MODE] (team up with another player from right side against CPU controlled opponents in a customizable arcade ladder)
function arcadeCPUvsP1P2()
	f_comingSoon()
	--[[
	setPlayerSide('p1right')
	data.p1In = 2
	data.p2In = 2
	data.p2Faces = true
	data.coop = true
	setGameMode('arcadecoop')
	textImgSetText(txt_mainSelect, "ARCADE COOPERATIVE")
	f_selectAdvance()
	]]
end

--CPU MODE (watch CPU fight in a customizable arcade ladder)
function arcadeCPUvsCPU()
	data.p2In = 1
	data.p2SelectMenu = false
	data.aiFight = true --AI = data.difficulty for all characters enabled
	setPlayerSide('p1left')
	setGameMode('arcadecpu') --to avoid challenger screen
	data.rosterMode = "cpu" --to avoid record stats
	textImgSetText(txt_mainSelect, "WATCH ARCADE")
	f_selectAdvance()
end

--;===========================================================
--; TOWER ARCADE MODE (play through customizable arcade routes/ladders)
--;===========================================================
function f_towerBoot()
	if data.debugMode then f_loadTowers() end
	if #t_selTower ~= 0 then
		menuSelect = "tower"
		sideScreen = true
	else --If there are not towers loaded
		towerInfo = true
		infoScreen = true
	end
end

--Load Common Settings for Tower Modes
function towerCfg()
	f_resetArcadeStuff()
	f_default()
	setGameMode('tower')
	data.gameMode = "tower"
	data.rosterMode = "tower"
	--data.arcadeIntro = true --Enable characters arcade intro before tower select
	data.arcadeEnding = true
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	sndPlay(sndSys, 100, 1)
end

--HUMAN VS CPU (fight against CPU controlled opponents in customizable tower ladders from left side)
function towerHumanvsCPU()
	if P2overP1 then
		remapInput(1, 2)
		setPlayerSide('p2left')
	else
		setPlayerSide('p1left')
	end
	data.p2TeamMenu = {mode = 0, chars = 1}
	data.p2In = 1
	data.p2SelectMenu = false
	textImgSetText(txt_mainSelect, "TOWER MODE")
	f_selectAdvance()
	P2overP1 = false
end

--CPU VS HUMAN (fight against CPU controlled opponents in customizable tower ladders from right side)
function towerCPUvsHuman()
	remapInput(1, 2)
	if not P2overP1 then
		remapInput(2, 1)
		setPlayerSide('p1right')
	else
		setPlayerSide('p2right')
	end
	data.p1TeamMenu = {mode = 0, chars = 1}
	data.p1In = 2
	data.p2In = 2
	data.p1SelectMenu = false
	textImgSetText(txt_mainSelect, "TOWER MODE")
	f_selectAdvance()
	P2overP1 = false
end

--P1&P2 VS CPU [CO-OP MODE] (team up with another player from left side against CPU controlled opponents in customizable tower ladders)
function towerP1P2vsCPU()
	data.p2In = 2
	data.p2Faces = true
	data.coop = true
	setPlayerSide('p1left')
	setGameMode('towercoop')
	textImgSetText(txt_mainSelect, "TOWER COOPERATIVE")
	f_selectAdvance()
end

--CPU VS P1&P2 [CO-OP MODE] (team up with another player from right side against CPU controlled opponents in customizable tower ladders)
function towerCPUvsP1P2()
	f_comingSoon()
	--[[
	setPlayerSide('p1right')
	data.p1In = 2
	data.p2In = 2
	data.p2Faces = true
	data.coop = true
	setGameMode('towercoop')
	textImgSetText(txt_mainSelect, "TOWER COOPERATIVE")
	f_selectAdvance()
	]]
end

--CPU MODE (watch CPU fight in customizable tower ladders)
function towerCPUvsCPU()
	data.p2TeamMenu = {mode = 0, chars = 1}
	data.p2In = 1
	data.p2SelectMenu = false
	data.aiFight = true
	setPlayerSide('p1left')
	setGameMode('towercpu')
	data.rosterMode = "cpu"
	textImgSetText(txt_mainSelect, "WATCH TOWER")
	f_selectAdvance()
end

--;===========================================================
--; QUICK/RANDOM MATCH MODE (play a random fight)
--;===========================================================
function f_quickvsBoot()
	menuSelect = "quick match"
	sideScreen = true
end

--Load Common Settings for Quick Match Modes
function randomModeCfg()
	f_default()
	setGameMode('random')
	data.gameMode = "quick match"
	data.rosterMode = "versus"
	data.p1TeamMenu = {mode = 0, chars = 1}
	data.p2TeamMenu = {mode = 0, chars = 1}
	data.p1Char = {t_selChars[t_randomChars[math.random(#t_randomChars)]+1].char} --Pick Random Char
	data.p2Char = {t_selChars[t_randomChars[math.random(#t_randomChars)]+1].char} --Pick Random Char
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	sndPlay(sndSys, 100, 1)
end

--HUMAN VS CPU (defeat from left side a random CPU controlled opponent)
function randomHumanvsCPU()
	if P2overP1 then
		remapInput(1, 2)
	end
	data.p2In = 1
	f_selectSimple()
	P2overP1 = false
end

--CPU VS HUMAN (defeat from right side a random CPU controlled opponent of your choice)
function randomCPUvsHuman()
	remapInput(1, 2)
	if not P2overP1 then
		remapInput(2, 1)
	end
	setPlayerSide('p1right')
	data.p1In = 2
	data.p2In = 2
	f_selectSimple()
	P2overP1 = false
end

--HUMAN VS HUMAN (fight from left side to defeat a random human opponent)
function randomHumanvsHuman()
	if P2overP1 then
		setHomeTeam(2)
		remapInput(1, 2)
		remapInput(2, 1)
		setPlayerSide('p1right')
	else
		setHomeTeam(1)
	end
	data.p2In = 2
	f_selectSimple()
	P2overP1 = false
end

--CPU MATCH (watch random CPU controlled match)
function randomCPUvsCPU()
	data.aiFight = true
	data.rosterMode = "cpu"
	f_selectSimple()
end

--P1&P2 VS CPU (team up with another player from left side to defeat random CPU controlled opponents)
function randomP1P2vsCPU()
	--f_selectSimple()
	f_comingSoon()
end

--CPU VS P1&P2 (team up with another player from right side to defeat random CPU controlled opponents)
function randomCPUvsP1P2()
	--f_selectSimple()
	f_comingSoon()
end

--;===========================================================
--; FREE BATTLE MODE (play fights with your own rules)
--;===========================================================
function f_vsBoot()
	menuSelect = "free battle"
	sideScreen = true
end

--Load Common Settings for Free Battle Modes
function freeModeCfg()
	f_default()
	setGameMode('vs')
	data.gameMode = "versus"
	data.rosterMode = "versus"
	data.stageMenu = true --stage selection enabled
	data.p2Faces = true --additional window with P2 select screen small portraits (faces) enabled
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	sndPlay(sndSys, 100, 1)
end

--HUMAN VS CPU (choose a fighter to defeat from left side a CPU controlled opponent of your choice)
function freeHumanvsCPU()
	if P2overP1 then
		remapInput(1, 2)
	end
	data.p2In = 1
	textImgSetText(txt_mainSelect, "FREE VERSUS")
	f_selectSimple()
	P2overP1 = false
end

--CPU VS HUMAN (choose a fighter to defeat from right side a CPU controlled opponent of your choice)
function freeCPUvsHuman()
	remapInput(1, 2)
	if not P2overP1 then
		remapInput(2, 1)
	end
	setPlayerSide('p1right')
	data.p1In = 2
	data.p2In = 2
	textImgSetText(txt_mainSelect, "FREE VERSUS")
	f_selectSimple()
	P2overP1 = false
end

--HUMAN VS HUMAN (choose a fighter from left side to defeat a human opponent)
function freeHumanvsHuman()
	if P2overP1 then
		setHomeTeam(2) --P2 side considered the home team
		remapInput(1, 2)
		remapInput(2, 1)
		setPlayerSide('p1right')
	else
		setHomeTeam(1) --P1 side considered the home team
	end
	data.p2In = 2 --P2 controls P2 side of the select screen
	textImgSetText(txt_mainSelect, "VERSUS MODE")
	f_selectSimple()
	P2overP1 = false
end

--CPU MATCH (watch CPU controlled match of your choice)
function freeCPUvsCPU()
	data.p2In = 1
	data.aiFight = true
	data.rosterMode = "cpu"
	textImgSetText(txt_mainSelect, "WATCH VERSUS")
	f_selectSimple()
end

--P1&P2 VS CPU (team up with another player from left side to defeat CPU controlled opponents of your choice)
function freeP1P2vsCPU()
	f_comingSoon()
	--[[
	setHomeTeam(1)
	data.p2In = 2
	data.stageMenu = false
	data.stage = "stages/training room.def"
	data.coop = true
	textImgSetText(txt_mainSelect, "FREE VERSUS COOPERATIVE")
	f_selectSimple()
	]]
end

--CPU VS P1&P2 (team up with another player from right side to defeat CPU controlled opponents of your choice)
function freeCPUvsP1P2()
	f_comingSoon()
end

--[[P1&P3 VS P2&P4 (team up with another player to defeat co-op team of human opponents)
function freeP1P3vsP2P4()
	setHomeTeam(1)
	data.p2In = 2
	data.coop = true
	textImgSetText(txt_mainSelect, "FREE VERSUS TEAM COOPERATIVE")
	f_selectSimple()
end
]]

--;===========================================================
--; SURVIVAL MENU (survive in a series of matches with special conditions)
--;===========================================================
function f_survivalMenu()
	cmdInput()
	local cursorPosY = 0
	local moveTxt = 0
	local survivalMenu = 1
	local bufu = 0
	local bufd = 0
	local bufr = 0
	local bufl = 0
	f_infoReset()
	f_sideReset()
	while true do
		if not infoScreen and not sideScreen then
			if esc() or commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then
				sndPlay(sndSys, 100, 2)
				break
			elseif commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u') or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30) then
				sndPlay(sndSys, 100, 0)
				survivalMenu = survivalMenu - 1
			elseif commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd') or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30) then
				sndPlay(sndSys, 100, 0)
				survivalMenu = survivalMenu + 1
			end
			if survivalMenu < 1 then
				survivalMenu = #t_survivalMenu
				if #t_survivalMenu > 5 then
					cursorPosY = 5
				else
					cursorPosY = #t_survivalMenu-1
				end
			elseif survivalMenu > #t_survivalMenu then
				survivalMenu = 1
				cursorPosY = 0
			elseif ((commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u')) or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30)) and cursorPosY > 0 then
				cursorPosY = cursorPosY - 1
			elseif ((commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd')) or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30)) and cursorPosY < 5 then
				cursorPosY = cursorPosY + 1
			end
			if cursorPosY == 5 then
				moveTxt = (survivalMenu - 6) * 13
			elseif cursorPosY == 0 then
				moveTxt = (survivalMenu - 1) * 13
			end
			if #t_survivalMenu <= 5 then
				maxsurvivalMenu = #t_survivalMenu
			elseif survivalMenu - cursorPosY > 0 then
				maxsurvivalMenu = survivalMenu + 5 - cursorPosY
			else
				maxsurvivalMenu = 5
			end
			if btnPalNo(p1Cmd) > 0 or btnPalNo(p2Cmd) > 0 then
				sndPlay(sndSys, 100, 1)
				f_gotoFunction(t_survivalMenu[survivalMenu])
			end
		end
		drawBottomMenuSP()
		for i=1, #t_survivalMenu do
			if i == survivalMenu then
				bank = 1
			else
				bank = 0
			end
			textImgDraw(f_updateTextImg(t_survivalMenu[i].id, jgFnt, bank, 0, t_survivalMenu[i].text, 159, 122+i*13-moveTxt))
		end
		if not infoScreen and not sideScreen then
			animSetWindow(cursorBox, 0,125+cursorPosY*13, 316,13)
			f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
			animDraw(f_animVelocity(cursorBox, -1, -1))
		end
		drawMiddleMenuSP()
		textImgDraw(txt_gameFt)
		textImgSetText(txt_gameFt, "SURVIVAL MODES")
		textImgDraw(txt_version)
		f_sysTime()
		if maxsurvivalMenu > 6 then
			animDraw(menuArrowUp)
			animUpdate(menuArrowUp)
		end
		if #t_survivalMenu > 6 and maxsurvivalMenu < #t_survivalMenu then
			animDraw(menuArrowDown)
			animUpdate(menuArrowDown)
		end
		if not infoScreen and not sideScreen then drawMenuInputHints() end
		if sideScreen then f_sideSelect() end
		if infoScreen then f_infoMenu() end
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		if commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu') then
			bufd = 0
			bufu = bufu + 1
		elseif commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd') then
			bufu = 0
			bufd = bufd + 1
		else
			bufu = 0
			bufd = 0
		end
		cmdInput()
		refresh()
	end
end

--;===========================================================
--; SURVIVAL MODE (defeat opponents with a single health meter)
--;===========================================================
function f_survivalBoot()
	menuSelect = "survival"
	sideScreen = true
end

--Load Common Settings for Survival Modes
function survivalCfg()
	f_default()
	data.gameMode = "survival"
	data.rosterMode = "survival"
	data.stageMenu = true
	setRoundsToWin(1)
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	sndPlay(sndSys, 100, 1)
end

--HUMAN VS CPU (defeat as many opponents as you can with a single Health Meter from left side)
function survivalHumanvsCPU()
	if P2overP1 then
		remapInput(1, 2)
	end
	data.p2In = 1
	data.p2SelectMenu = false
	textImgSetText(txt_mainSelect, "SURVIVAL")
	f_selectAdvance()
	P2overP1 = false
end

--CPU VS HUMAN (defeat as many opponents as you can with a single Health Meter from right side)
function survivalCPUvsHuman()
	remapInput(1, 2)
	if not P2overP1 then
		remapInput(2, 1)
	end
	setPlayerSide('p1right')
	data.p1In = 2
	data.p2In = 2
	data.p1SelectMenu = false
	textImgSetText(txt_mainSelect, "SURVIVAL")
	f_selectAdvance()
	P2overP1 = false
end

--P1&P2 VS CPU [CO-OP MODE] (team up with another player from left side to defeat as many opponents as you can with a single Health Meter)
function survivalP1P2vsCPU()
	data.p2In = 2
	data.p2Faces = true
	data.coop = true
	textImgSetText(txt_mainSelect, "SURVIVAL COOPERATIVE")
	f_selectAdvance()
end

--CPU VS P1&P2 [CO-OP MODE] (team up with another player from right side to defeat as many opponents as you can with a single Health Meter)
function survivalCPUvsP1P2()
	f_comingSoon()
	--[[
	setPlayerSide('p1right')
	data.p1In = 2
	data.p2In = 2
	data.p2Faces = true
	data.coop = true
	textImgSetText(txt_mainSelect, "SURVIVAL COOPERATIVE")
	f_selectAdvance()
	]]
end

--CPU MODE (watch CPU defeat as many opponents as it can with a single Health Meter)
function survivalCPUvsCPU()
	data.p2In = 1
	data.p2SelectMenu = false
	data.aiFight = true
	data.rosterMode = "cpu"
	textImgSetText(txt_mainSelect, "WATCH SURVIVAL")
	f_selectAdvance()
end

--;===========================================================
--; BOSS RUSH MODE (defeat all bosses in a row)
--;===========================================================
function f_bossrushBoot()
	if #t_bossChars == 0 then
		bossInfo = true
		infoScreen = true
		return
	else
		menuSelect = "boss rush"
		sideScreen = true
	end
end

--Load Common Settings for Boss Rush Modes
function bossrushCfg()
	f_default()
	data.gameMode = "bossrush"
	data.rosterMode = "boss"
	--data.stageMenu = true
	setRoundsToWin(1)
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	sndPlay(sndSys, 100, 1)
end

--HUMAN VS CPU (defeat all bosses in a row from left side)
function bossrushHumanvsCPU()
	if P2overP1 then
		remapInput(1, 2)
	end
	data.p2In = 1
	data.p2SelectMenu = false
	textImgSetText(txt_mainSelect, "BOSS RUSH")					
	f_selectAdvance()
	P2overP1 = false
end

--CPU VS HUMAN (defeat all bosses in a row from right side)
function bossrushCPUvsHuman()
	remapInput(1, 2)
	if not P2overP1 then
		remapInput(2, 1)
	end
	setPlayerSide('p1right')
	data.p1In = 2
	data.p2In = 2
	data.p1SelectMenu = false
	textImgSetText(txt_mainSelect, "BOSS RUSH")					
	f_selectAdvance()
	P2overP1 = false
end

--P1&P2 VS CPU [CO-OP MODE] (team up with another player from left side to defeat all bosses in a row)
function bossrushP1P2vsCPU()
	data.p2In = 2
	data.p2Faces = true
	data.coop = true
	textImgSetText(txt_mainSelect, "BOSS RUSH COOPERATIVE")					
	f_selectAdvance()
end

--CPU VS P1&P2 [CO-OP MODE] (team up with another player from right side to defeat all bosses in a row)
function bossrushCPUvsP1P2()
	f_comingSoon()
	--[[
	setPlayerSide('p1right')
	data.p1In = 2
	data.p2In = 2
	data.p2Faces = true
	data.coop = true
	textImgSetText(txt_mainSelect, "BOSS RUSH COOPERATIVE")					
	f_selectAdvance()
	]]
end

--CPU MODE (watch CPU defeat all bosses in a row)
function bossrushCPUvsCPU()
	data.p2In = 1
	data.p2SelectMenu = false
	data.aiFight = true
	data.rosterMode = "cpu"
	textImgSetText(txt_mainSelect, "WATCH BOSS RUSH")
	f_selectAdvance()
end

--;===========================================================
--; SINGLE BOSS MENU (face a specific Boss Character)
--;===========================================================
function f_bossChars()
	if #t_bossChars == 0 then
		bossInfo = true
		infoScreen = true
		return
	end
	cmdInput()
	f_rushTables() --From loader.lua
	bossChars = 1 --Need to be public to be readed by above functions
	local cursorPosY = 0
	local moveTxt = 0
	local bufu = 0
	local bufd = 0
	local bufr = 0
	local bufl = 0
	f_sideReset()
	while true do
		if not sideScreen then
			if esc() or commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then
				sndPlay(sndSys, 100, 2)
				break
			elseif commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u') or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30) then
				sndPlay(sndSys, 100, 0)
				bossChars = bossChars - 1
			elseif commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd') or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30) then
				sndPlay(sndSys, 100, 0)
				bossChars = bossChars + 1
			end
			if bossChars < 1 then
				bossChars = #t_bossSingle
				if #t_bossSingle > 5 then
					cursorPosY = 5
				else
					cursorPosY = #t_bossSingle-1
				end
			elseif bossChars > #t_bossSingle then
				bossChars = 1
				cursorPosY = 0
			elseif ((commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u')) or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30)) and cursorPosY > 0 then
				cursorPosY = cursorPosY - 1
			elseif ((commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd')) or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30)) and cursorPosY < 5 then
				cursorPosY = cursorPosY + 1
			end
			if cursorPosY == 5 then
				moveTxt = (bossChars - 6) * 13
			elseif cursorPosY == 0 then
				moveTxt = (bossChars - 1) * 13
			end
			if #t_bossSingle <= 5 then
				maxBossChars = #t_bossSingle
			elseif bossChars - cursorPosY > 0 then
				maxBossChars = bossChars + 5 - cursorPosY
			else
				maxBossChars = 5
			end
			if btnPalNo(p1Cmd) > 0 or btnPalNo(p2Cmd) > 0 then
				sndPlay(sndSys, 100, 1)
				menuSelect = "boss"
				sideScreen = true
			end
		end
		drawBottomMenuSP()
		for i=1, #t_bossSingle do
			if i == bossChars then
				bank = 1
			else
				bank = 0
			end
			--Draw Boss Name
			textImgDraw(f_updateTextImg(t_bossSingle[i].id, jgFnt, bank, 0, t_bossSingle[i].text, 159, 122+i*13-moveTxt))
		end
		if not sideScreen then
			animSetWindow(cursorBox, 0,125+cursorPosY*13, 316,13)
			f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
			animDraw(f_animVelocity(cursorBox, -1, -1))
		end
		drawMiddleMenuSP()
		textImgDraw(txt_gameFt)
		textImgSetText(txt_gameFt, "BOSS FIGHT")
		textImgDraw(txt_version)
		f_sysTime()
		if maxBossChars > 6 then
			animDraw(menuArrowUp)
			animUpdate(menuArrowUp)
		end
		if #t_bossSingle > 6 and maxBossChars < #t_bossSingle then
			animDraw(menuArrowDown)
			animUpdate(menuArrowDown)
		end
		if sideScreen then f_sideSelect() else drawMenuInputHints() end
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		if commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu') then
			bufd = 0
			bufu = bufu + 1
		elseif commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd') then
			bufu = 0
			bufd = bufd + 1
		else
			bufu = 0
			bufd = 0
		end
		cmdInput()
		refresh()
	end
end

--Load Common Settings for Single Boss Fight Modes
function bossCfg()
	f_default()
	data.gameMode = "singleboss"
	data.rosterMode = "boss"
	--data.stageMenu = true
	textImgSetText(txt_mainSelect, t_selChars[t_bossChars[bossChars]+1].displayname)
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	sndPlay(sndSys, 100, 1)
end

--HUMAN VS CPU (defeat selected boss character from left side)
function bossHumanvsCPU()
	if P2overP1 then
		remapInput(1, 2)
	end
	data.p2In = 1
	data.p2TeamMenu = {mode = 0, chars = 1}
	data.p2Char = {t_selChars[t_bossChars[bossChars]+1].char}
	f_selectSimple()
	P2overP1 = false
end

--CPU VS HUMAN (defeat selected boss character from right side)
function bossCPUvsHuman()
	remapInput(1, 2)
	if not P2overP1 then
		remapInput(2, 1)
	end
	setPlayerSide('p1right')
	data.p1In = 2
	data.p2In = 2
	data.p1SelectMenu = false
	data.p1TeamMenu = {mode = 0, chars = 1}
	data.p1Char = {t_selChars[t_bossChars[bossChars]+1].char}
	f_selectSimple()
	P2overP1 = false
end

--CPU MODE (watch CPU defeat selected boss character)
function bossCPUvsCPU()
	--data.p2SelectMenu = false
	data.aiFight = true
	data.rosterMode = "cpu"
	data.p2TeamMenu = {mode = 0, chars = 1}
	data.p2Char = {t_selChars[t_bossChars[bossChars]+1].char}
	f_selectSimple()
end

--;===========================================================
--; BONUS GAMES MENU (play bonus games)
--;===========================================================
function f_bonusMenu()
	if #t_bonusChars == 0 then
		bonusInfo = true
		infoScreen = true
		return
	end
	cmdInput()
	local cursorPosY = 0
	local moveTxt = 0
	local bonusMenu = 1
	local bufu = 0
	local bufd = 0
	local bufr = 0
	local bufl = 0
	f_sideReset()
	while true do
		if not sideScreen then
			if esc() or commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then
				sndPlay(sndSys, 100, 2)
				break
			elseif commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u') or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30) then
				sndPlay(sndSys, 100, 0)
				bonusMenu = bonusMenu - 1
			elseif commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd') or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30) then
				sndPlay(sndSys, 100, 0)
				bonusMenu = bonusMenu + 1
			end
			if bonusMenu < 1 then
				bonusMenu = #t_bonusMenu
				if #t_bonusMenu > 5 then
					cursorPosY = 5
				else
					cursorPosY = #t_bonusMenu-1
				end
			elseif bonusMenu > #t_bonusMenu then
				bonusMenu = 1
				cursorPosY = 0
			elseif ((commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u')) or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30)) and cursorPosY > 0 then
				cursorPosY = cursorPosY - 1
			elseif ((commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd')) or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30)) and cursorPosY < 5 then
				cursorPosY = cursorPosY + 1
			end
			if cursorPosY == 5 then
				moveTxt = (bonusMenu - 6) * 13
			elseif cursorPosY == 0 then
				moveTxt = (bonusMenu - 1) * 13
			end
			if #t_bonusMenu <= 5 then
				maxBonusMenu = #t_bonusMenu
			elseif bonusMenu - cursorPosY > 0 then
				maxBonusMenu = bonusMenu + 5 - cursorPosY
			else
				maxBonusMenu = 5
			end
			if btnPalNo(p1Cmd) > 0 or btnPalNo(p2Cmd) > 0 then
				sndPlay(sndSys, 100, 1)
				f_gotoFunction(t_bonusMenu[bonusMenu])
			end
		end
		drawBottomMenuSP()
		for i=1, #t_bonusMenu do
			if i == bonusMenu then
				bank = 5
			else
				bank = 0
			end
			textImgDraw(f_updateTextImg(t_bonusMenu[i].id, jgFnt, bank, 0, t_bonusMenu[i].text, 159, 122+i*13-moveTxt))
		end
		if not sideScreen then
			animSetWindow(cursorBox, 0,125+cursorPosY*13, 316,13)
			f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
			animDraw(f_animVelocity(cursorBox, -1, -1))
		end
		drawMiddleMenuSP()
		textImgDraw(txt_gameFt)
		textImgSetText(txt_gameFt, "MINI-GAMES")
		textImgDraw(txt_version)
		f_sysTime()
		if maxBonusMenu > 6 then
			animDraw(menuArrowUp)
			animUpdate(menuArrowUp)
		end
		if #t_bonusMenu > 6 and maxBonusMenu < #t_bonusMenu then
			animDraw(menuArrowDown)
			animUpdate(menuArrowDown)
		end
		if sideScreen then f_sideSelect() else drawMenuInputHints() end
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		if commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu') then
			bufd = 0
			bufu = bufu + 1
		elseif commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd') then
			bufu = 0
			bufd = bufd + 1
		else
			bufu = 0
			bufd = 0
		end
		cmdInput()
		refresh()
	end
end

--;===========================================================
--; SINGLE BONUS GAMES MODE (clear the bonus game selected)
--;===========================================================
function f_bonusExtras()
	cmdInput()
	f_rushTables()
	bonusExtras = 1 --Need to be public to be readed by above functions
	local cursorPosY = 0
	local moveTxt = 0
	local bufu = 0
	local bufd = 0
	local bufr = 0
	local bufl = 0
	f_sideReset()
	while true do
		if not sideScreen then
			if esc() or commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then
				sndPlay(sndSys, 100, 2)
				break
			elseif commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u') or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30) then
				sndPlay(sndSys, 100, 0)
				bonusExtras = bonusExtras - 1
			elseif commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd') or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30) then
				sndPlay(sndSys, 100, 0)
				bonusExtras = bonusExtras + 1
			end
			if bonusExtras < 1 then
				bonusExtras = #t_bonusExtras
				if #t_bonusExtras > 5 then
					cursorPosY = 5
				else
					cursorPosY = #t_bonusExtras-1
				end
			elseif bonusExtras > #t_bonusExtras then
				bonusExtras = 1
				cursorPosY = 0
			elseif ((commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u')) or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30)) and cursorPosY > 0 then
				cursorPosY = cursorPosY - 1
			elseif ((commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd')) or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30)) and cursorPosY < 5 then
				cursorPosY = cursorPosY + 1
			end
			if cursorPosY == 5 then
				moveTxt = (bonusExtras - 6) * 13
			elseif cursorPosY == 0 then
				moveTxt = (bonusExtras - 1) * 13
			end
			if #t_bonusExtras <= 5 then
				maxBonusExtras = #t_bonusExtras
			elseif bonusExtras - cursorPosY > 0 then
				maxBonusExtras = bonusExtras + 5 - cursorPosY
			else
				maxBonusExtras = 5
			end
			if btnPalNo(p1Cmd) > 0 or btnPalNo(p2Cmd) > 0 then
				sndPlay(sndSys, 100, 1)
				menuSelect = "bonus"
				sideScreen = true
			end
		end
		drawBottomMenuSP()
		for i=1, #t_bonusExtras do
			if i == bonusExtras then
				bank = 5
			else
				bank = 0
			end
			--Draw Bonus Name
			textImgDraw(f_updateTextImg(t_bonusExtras[i].id, jgFnt, bank, 0, t_bonusExtras[i].text, 159, 122+i*13-moveTxt))
		end
		if not sideScreen then
			animSetWindow(cursorBox, 0,125+cursorPosY*13, 316,13)
			f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
			animDraw(f_animVelocity(cursorBox, -1, -1))
		end
		drawMiddleMenuSP()
		textImgDraw(txt_gameFt)
		textImgSetText(txt_gameFt, "BONUS STAGES")
		textImgDraw(txt_version)
		f_sysTime()
		if maxBonusExtras > 6 then
			animDraw(menuArrowUp)
			animUpdate(menuArrowUp)
		end
		if #t_bonusExtras > 6 and maxBonusExtras < #t_bonusExtras then
			animDraw(menuArrowDown)
			animUpdate(menuArrowDown)
		end
		if sideScreen then f_sideSelect() else drawMenuInputHints() end
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		if commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu') then
			bufd = 0
			bufu = bufu + 1
		elseif commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd') then
			bufu = 0
			bufd = bufd + 1
		else
			bufu = 0
			bufd = 0
		end
		cmdInput()
		refresh()
	end
end

--Load Common Settings for Bonus Games Modes
function bonusCfg()
	f_default()
	data.gameMode = "singlebonus"
	data.rosterMode = "bonus"
	--data.stageMenu = true
	data.versusScreen = false
	setRoundsToWin(1)
	textImgSetText(txt_mainSelect, t_selChars[t_bonusChars[bonusExtras]+1].displayname)
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	sndPlay(sndSys, 100, 1)
end

--HUMAN VS CPU (clear the bonus game selected from left side)
function bonusHumanvsCPU()
	if P2overP1 then
		remapInput(1, 2)
	end
	data.p2In = 1
	data.p2TeamMenu = {mode = 0, chars = 1}
	data.p2Char = {t_selChars[t_bonusChars[bonusExtras]+1].char}
	f_selectSimple()
	P2overP1 = false
end

--CPU VS HUMAN (clear the bonus game selected from right side)
function bonusCPUvsHuman()
	remapInput(1, 2)
	if not P2overP1 then
		remapInput(2, 1)
	end
	setPlayerSide('p1right')
	data.p1In = 2
	data.p2In = 2
	data.p1SelectMenu = false
	data.p1TeamMenu = {mode = 0, chars = 1}
	data.p1Char = {t_selChars[t_bonusChars[bonusExtras]+1].char}
	f_selectSimple()
	P2overP1 = false
end

--;===========================================================
--; BONUS RUSH MODE (clear all bonus games in a row)
--;===========================================================
function f_bonusrushBoot()
	menuSelect = "bonus rush"
	sideScreen = true
end

--Load Common Settings for Bonus Rush Modes
function bonusrushCfg()
	f_default()
	data.gameMode = "bonusrush"
	data.rosterMode = "bonus"
	setRoundsToWin(1)
	--data.stageMenu = true
	data.versusScreen = false
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)			
	sndPlay(sndSys, 100, 1)
end

--HUMAN VS CPU (clear all bonus games in a row from left side)
function bonusrushHumanvsCPU()
	if P2overP1 then
		remapInput(1, 2)
	end
	data.p2In = 1
	data.p2SelectMenu = false
	data.p2TeamMenu = {mode = 0, chars = 1}
	textImgSetText(txt_mainSelect, "BONUS RUSH")
	f_selectAdvance()
	P2overP1 = false
end

--CPU VS HUMAN (clear all bonus games in a row from right side)
function bonusrushCPUvsHuman()
	remapInput(1, 2)
	if not P2overP1 then
		remapInput(2, 1)
	end
	setPlayerSide('p1right')
	data.p1In = 2
	data.p2In = 2
	data.p1SelectMenu = false
	data.p1TeamMenu = {mode = 0, chars = 1}
	textImgSetText(txt_mainSelect, "BONUS RUSH")
	f_selectAdvance()
	P2overP1 = false
end

--P1&P2 VS CPU [CO-OP MODE] (team up with another player from left side to clear all bonus games in a row)
function bonusrushP1P2vsCPU()
	data.p2In = 2
	data.p2Faces = true
	data.coop = true
	textImgSetText(txt_mainSelect, "BONUS RUSH COOPERATIVE")
	f_selectAdvance()
end

--CPU VS P1&P2 [CO-OP MODE] (team up with another player from right side to clear all bonus games in a row)
function bonusrushCPUvsP1P2()
	f_comingSoon()
	--[[
	setPlayerSide('p1right')
	data.p1In = 2
	data.p2In = 2
	data.p2Faces = true
	data.coop = true
	textImgSetText(txt_mainSelect, "BONUS RUSH COOPERATIVE")
	f_selectAdvance()
	]]
end

--;===========================================================
--; SCORE ATTACK MODE (defeat opponents getting high score as possible)
--;===========================================================
function f_scoreattackBoot()
	f_comingSoon()
--[[
	menuSelect = "score attack"
	sideScreen = true
]]
end

--Load Common Settings for Score Attack Modes
function scoreattackCfg()
	f_default()
	data.gameMode = "allroster"
	data.rosterMode = "scoreattack"
	--data.stageMenu = true
	setRoundTime(-1)
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	sndPlay(sndSys, 100, 1)
end

--HUMAN VS CPU (defeat all character roster as quickly as possible, beating previous score records from left side)
function scoreattackHumanvsCPU()
	if P2overP1 then
		remapInput(1, 2)
	end
	data.p2In = 1
	data.p2SelectMenu = false
	textImgSetText(txt_mainSelect, "SCORE ATTACK")
	f_selectAdvance()
	P2overP1 = false
end

--CPU VS HUMAN (defeat all character roster as quickly as possible, beating previous score records from right side)
function scoreattackCPUvsHuman()
	remapInput(1, 2)
	if not P2overP1 then
		remapInput(2, 1)
	end
	setPlayerSide('p1right')
	data.p1In = 2
	data.p2In = 2
	data.p1SelectMenu = false
	textImgSetText(txt_mainSelect, "SCORE ATTACK")
	f_selectAdvance()
	P2overP1 = false
end

--P1&P2 VS CPU [CO-OP MODE] (team up with another player from left side to defeat all character roster as quickly as possible, beating previous score records)
function scoreattackP1P2vsCPU()
	data.p2In = 2
	data.p2Faces = true
	data.coop = true
	textImgSetText(txt_mainSelect, "SCORE ATTACK COOPERATIVE")
	f_selectAdvance()
end

--CPU VS P1&P2 [CO-OP MODE] (team up with another player from right side to defeat all character roster as quickly as possible, beating previous score records)
function scoreattackCPUvsP1P2()
	f_comingSoon()
	--[[
	setPlayerSide('p1right')
	data.p1In = 2
	data.p2In = 2
	data.p2Faces = true
	data.coop = true
	textImgSetText(txt_mainSelect, "SCORE ATTACK COOPERATIVE")
	f_selectAdvance()
	]]
end

--CPU MODE (watch CPU defeat all character roster as quickly as possible, beating previous score records)
function scoreattackCPUvsCPU()
	data.p2In = 1
	data.p2SelectMenu = false
	data.aiFight = true
	data.rosterMode = "cpu"
	textImgSetText(txt_mainSelect, "WATCH SCORE ATTACK")
	f_selectAdvance()
end

--;===========================================================
--; TIME ATTACK MODE (defeat opponents as quickly as possible)
--;===========================================================
function f_timeattackBoot()
	f_comingSoon()
--[[
	menuSelect = "time attack"
	sideScreen = true
]]
end

--Load Common Settings for Time Attack Modes
function timeattackCfg()
	f_default()
	data.gameMode = "allroster"
	data.rosterMode = "timeattack"
	--data.stageMenu = true
	setRoundTime(-1)
	setRoundsToWin(1)
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	sndPlay(sndSys, 100, 1)
end

--HUMAN VS CPU (defeat all character roster as quickly as possible, beating previous time records from left side)
function timeattackHumanvsCPU()
	if P2overP1 then
		remapInput(1, 2)
	end
	data.p2In = 1
	data.p2SelectMenu = false
	textImgSetText(txt_mainSelect, "TIME ATTACK")
	f_selectAdvance()
	P2overP1 = false
end

--CPU VS HUMAN (defeat all character roster as quickly as possible, beating previous time records from right side)
function timeattackCPUvsHuman()
	remapInput(1, 2)
	if not P2overP1 then
		remapInput(2, 1)
	end
	setPlayerSide('p1right')
	data.p1In = 2
	data.p2In = 2
	data.p1SelectMenu = false
	textImgSetText(txt_mainSelect, "TIME ATTACK")
	f_selectAdvance()
	P2overP1 = false
end

--P1&P2 VS CPU [CO-OP MODE] (team up with another player from left side to defeat all character roster as quickly as possible, beating previous time records)
function timeattackP1P2vsCPU()
	data.p2In = 2
	data.p2Faces = true
	data.coop = true
	textImgSetText(txt_mainSelect, "TIME ATTACK COOPERATIVE")
	f_selectAdvance()
end

--CPU VS P1&P2 [CO-OP MODE] (team up with another player from right side to defeat all character roster as quickly as possible, beating previous time records)
function timeattackCPUvsP1P2()
	f_comingSoon()
	--[[
	setPlayerSide('p1right')
	data.p1In = 2
	data.p2In = 2
	data.p2Faces = true
	data.coop = true
	textImgSetText(txt_mainSelect, "TIME ATTACK COOPERATIVE")
	f_selectAdvance()
	]]
end

--CPU MODE (watch CPU defeat all character roster as quickly as possible, beating previous time records)
function timeattackCPUvsCPU()
	data.p2In = 1
	data.p2SelectMenu = false
	data.aiFight = true
	data.rosterMode = "cpu"
	textImgSetText(txt_mainSelect, "WATCH TIME ATTACK")
	f_selectAdvance()
end

--;===========================================================
--; TIME RUSH MODE (rush to defeat opponents before time runs out)
--;===========================================================
function f_timerushBoot()
	menuSelect = "time rush"
	sideScreen = true	
end

--Load Common Settings for Time Rush Modes
function timerushCfg()
	f_default()
	data.gameMode = "allroster"
	data.rosterMode = "timerush"
	--data.stageMenu = true
	setRoundTime(3600)
	setRoundsToWin(1)
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	sndPlay(sndSys, 100, 1)
end

--HUMAN VS CPU (rush to defeat opponents before time runs out, beating previous time records from left side)
function timerushHumanvsCPU()
	if P2overP1 then
		remapInput(1, 2)
	end
	data.p2In = 1
	data.p2SelectMenu = false
	textImgSetText(txt_mainSelect, "TIME RUSH")
	f_selectAdvance()
	P2overP1 = false
end

--CPU VS HUMAN (rush to defeat opponents before time runs out, beating previous time records from right side)
function timerushCPUvsHuman()
	remapInput(1, 2)
	if not P2overP1 then
		remapInput(2, 1)
	end
	setPlayerSide('p1right')
	data.p1In = 2
	data.p2In = 2
	data.p1SelectMenu = false
	textImgSetText(txt_mainSelect, "TIME RUSH")
	f_selectAdvance()
	P2overP1 = false
end

--P1&P2 VS CPU [CO-OP MODE] (team up with another player from left side to rush to defeat opponents before time runs out, beating previous time records)
function timerushP1P2vsCPU()
	data.p2In = 2
	data.p2Faces = true
	data.coop = true
	textImgSetText(txt_mainSelect, "TIME RUSH COOPERATIVE")
	f_selectAdvance()
end

--CPU VS P1&P2 [CO-OP MODE] (team up with another player from right side to rush to defeat opponents before time runs out, beating previous time records)
function timerushCPUvsP1P2()
	f_comingSoon()
	--[[
	setPlayerSide('p1right')
	data.p1In = 2
	data.p2In = 2
	data.p2Faces = true
	data.coop = true
	textImgSetText(txt_mainSelect, "TIME RUSH COOPERATIVE")
	f_selectAdvance()
	]]
end

--CPU MODE (watch CPU rush to defeat opponents before time runs out, beating previous time records)
function timerushCPUvsCPU()
	data.p2In = 1
	data.p2SelectMenu = false
	data.aiFight = true
	data.rosterMode = "cpu"
	textImgSetText(txt_mainSelect, "WATCH TIME RUSH")
	f_selectAdvance()
end

--;===========================================================
--; VS X KUMITE MODE (defeat as many opponents as you can in predefined "data.kumite" successive matches)
--;===========================================================
function f_kumiteBoot()
	menuSelect = "kumite"
	sideScreen = true	
end

function getKumiteData()
	kumiteDataText = "VS "..data.kumite.." KUMITE"
	return kumiteDataText
end

--Load Common Settings for VS X Kumite Modes
function kumiteCfg()
	f_default()
	data.gameMode = "vskumite"
	data.rosterMode = "vskumite"
	--data.stageMenu = true
	setRoundsToWin(1)
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	sndPlay(sndSys, 100, 1)
end

--P1 VS HUMAN (see how many characters out of all roster you can take down in 1 Hit from left side)
function kumiteHumanvsCPU()
	if P2overP1 then
		remapInput(1, 2)
	end
	data.p2In = 1
	data.p2SelectMenu = false
	textImgSetText(txt_mainSelect, getKumiteData())
	f_selectAdvance()
	P2overP1 = false
end

--CPU VS HUMAN (see how many characters out of all roster you can take down in 1 Hit from right side)
function kumiteCPUvsHuman()
	remapInput(1, 2)
	if not P2overP1 then
		remapInput(2, 1)
	end
	setPlayerSide('p1right')
	data.p1In = 2
	data.p2In = 2
	data.p1SelectMenu = false
	textImgSetText(txt_mainSelect, getKumiteData())
	f_selectAdvance()
	P2overP1 = false
end

--P1&P2 VS CPU [CO-OP MODE] (team up with another player from left side to see how many characters out of all roster you can take down in 1 Hit)
function kumiteP1P2vsCPU()
	data.p2In = 2
	data.p2Faces = true
	data.coop = true
	textImgSetText(txt_mainSelect, getKumiteData().." COOPERATIVE")
	f_selectAdvance()
end

--CPU VS P1&P2 [CO-OP MODE] (team up with another player from right side to see how many characters out of all roster you can take down in 1 Hit)
function kumiteCPUvsP1P2()
	f_comingSoon()
	--[[
	setPlayerSide('p1right')
	data.p1In = 2
	data.p2In = 2
	data.p2Faces = true
	data.coop = true
	textImgSetText(txt_mainSelect, getKumiteData().." COOPERATIVE")
	f_selectAdvance()
	]]
end

--CPU MODE (see how many characters out of all roster the CPU can take down in 1 Hit)
function kumiteCPUvsCPU()
	data.p2In = 1
	data.p2SelectMenu = false
	data.aiFight = true
	data.rosterMode = "cpu"
	textImgSetText(txt_mainSelect, "WATCH "..getKumiteData())
	f_selectAdvance()
end

--;===========================================================
--; SUDDEN DEATH MODE (defeat opponents in 1 hit)
--;===========================================================
function f_suddendeathBoot()
	menuSelect = "sudden death"
	sideScreen = true
end

--Load Common Settings for Sudden Death Modes
function suddenCfg()
	f_default()
	data.gameMode = "allroster"
	data.rosterMode = "suddendeath"
	--data.stageMenu = true
	setRoundTime(1000)
	setRoundsToWin(1)
	setLifeMul(0) --overwrite players life
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	sndPlay(sndSys, 100, 1)
end

--P1 VS HUMAN (see how many characters out of all roster you can take down in 1 Hit from left side)
function suddenHumanvsCPU()
	if P2overP1 then
		remapInput(1, 2)
	end
	data.p2In = 1
	data.p2SelectMenu = false
	textImgSetText(txt_mainSelect, "SUDDEN DEATH")
	f_selectAdvance()
	P2overP1 = false
end

--CPU VS HUMAN (see how many characters out of all roster you can take down in 1 Hit from right side)
function suddenCPUvsHuman()
	remapInput(1, 2)
	if not P2overP1 then
		remapInput(2, 1)
	end
	setPlayerSide('p1right')
	data.p1In = 2
	data.p2In = 2
	data.p1SelectMenu = false
	textImgSetText(txt_mainSelect, "SUDDEN DEATH")
	f_selectAdvance()
	P2overP1 = false
end

--P1&P2 VS CPU [CO-OP MODE] (team up with another player from left side to see how many characters out of all roster you can take down in 1 Hit)
function suddenP1P2vsCPU()
	data.p2In = 2
	data.p2Faces = true
	data.coop = true
	textImgSetText(txt_mainSelect, "SUDDEN DEATH COOPERATIVE")
	f_selectAdvance()
end

--CPU VS P1&P2 [CO-OP MODE] (team up with another player from right side to see how many characters out of all roster you can take down in 1 Hit)
function suddenCPUvsP1P2()
	f_comingSoon()
	--[[
	setPlayerSide('p1right')
	data.p1In = 2
	data.p2In = 2
	data.p2Faces = true
	data.coop = true
	textImgSetText(txt_mainSelect, "SUDDEN DEATH COOPERATIVE")
	f_selectAdvance()
	]]
end

--CPU MODE (see how many characters out of all roster the CPU can take down in 1 Hit)
function suddenCPUvsCPU()
	data.p2In = 1
	data.p2SelectMenu = false
	data.aiFight = true
	data.rosterMode = "cpu"
	textImgSetText(txt_mainSelect, "WATCH SUDDEN DEATH")
	f_selectAdvance()
end

--;===========================================================
--; ENDLESS MODE (fight in endless matches)
--;===========================================================
function f_endlessBoot()
	menuSelect = "endless"
	sideScreen = true
end

--Load Common Settings for Endless Modes
function endlessCfg()
	f_default()
	data.gameMode = "endless"
	data.rosterMode = "endless"
	data.stageMenu = true
	data.versusScreen = false
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	sndPlay(sndSys, 100, 1)
end

--P1 VS HUMAN (choose a fighter to defeat endless CPU controlled opponents from left side)
function endlessHumanvsCPU()
	if P2overP1 then
		remapInput(1, 2)
	end
	data.p2In = 1
	data.p2SelectMenu = false
	textImgSetText(txt_mainSelect, "ENDLESS MODE")
	f_selectAdvance()
	P2overP1 = false
end

--CPU VS HUMAN (choose a fighter to defeat endless CPU controlled opponents from right side)
function endlessCPUvsHuman()
	remapInput(1, 2)
	if not P2overP1 then
		remapInput(2, 1)
	end
	setPlayerSide('p1right')
	data.p1In = 2
	data.p2In = 2
	data.p1SelectMenu = false
	textImgSetText(txt_mainSelect, "ENDLESS MODE")
	f_selectAdvance()
	P2overP1 = false
end

--P1&P2 VS CPU [CO-OP MODE] (team up with another player from left side to defeat endless CPU controlled opponents)
function endlessP1P2vsCPU()
	data.p2In = 2
	data.p2Faces = true
	data.coop = true
	textImgSetText(txt_mainSelect, "ENDLESS COOPERATIVE")
	f_selectAdvance()
end

--CPU VS P1&P2 [CO-OP MODE] (team up with another player from right side to defeat endless CPU controlled opponents)
function endlessCPUvsP1P2()
	f_comingSoon()
	--[[
	setPlayerSide('p1right')
	data.p1In = 2
	data.p2In = 2
	data.p2Faces = true
	data.coop = true
	textImgSetText(txt_mainSelect, "ENDLESS COOPERATIVE")
	f_selectAdvance()
	]]
end

--CPU MODE (choose a fighter to watch endless CPU fights)
function endlessCPUvsCPU()
	data.p2In = 1
	data.p2SelectMenu = false
	data.aiFight = true
	data.rosterMode = "cpu"
	textImgSetText(txt_mainSelect, "WATCH ENDLESS")
	f_selectAdvance()
end

--;===========================================================
--; MISSIONS MENU (complete customizable tasks)
--;===========================================================
function f_missionMenu()
	if data.debugMode then f_loadMissions() end --Load in real-time only if dev/debug mode is enabled
	if #t_missions == 0 then
		missionInfo = true
		infoScreen = true
		return
	end
	cmdInput()
	local missionMenu = 1
	local cursorPosY = 1
	local moveTxt = 0
	local bufu = 0
	local bufd = 0
	local bufr = 0
	local bufl = 0
	local previewInfotxt = nil
	local missionNametxt = nil
	local previewPosX = nil
	local previewPosY = nil
	local previewScaleX = nil
	local previewScaleY = nil
	local previewTransS = nil
	local previewTransD = nil
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	animSetPos(menuArrowUp, 280, 130)
	animSetPos(menuArrowDown, 280, 195)
	f_unlock(false)
	f_updateUnlocks()
	while true do
	--Missions Progress Logic
		stats.modes.mission.clearall = stats.modes.mission.clear1 + stats.modes.mission.clear2 + stats.modes.mission.clear3
		missionsData = (math.floor((stats.modes.mission.clearall * 100 / 3) + 0.5)) --The number (3) is the amount of all data.missionStatus
		textImgSetText(txt_missionProgress,"["..missionsData.."%]")
		if esc() or commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then
			f_saveStats()
			data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
			sndPlay(sndSys, 100, 2)
			f_resetMenuArrowsPos()
			break
		elseif commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u') or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30) then
			sndPlay(sndSys, 100, 0)
			missionMenu = missionMenu - 1
		elseif commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd') or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30) then
			sndPlay(sndSys, 100, 0)
			missionMenu = missionMenu + 1
		--START MISSION
		elseif btnPalNo(p1Cmd) > 0 or btnPalNo(p2Cmd) > 0 then
			--MISSION AVAILABLE
			if t_unlockLua.modes[t_missions[missionMenu].id] == nil then --If the mission is unlocked
				data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
				sndPlay(sndSys, 100, 1)
				f_default()
				data.missionNo = missionMenu --with this data.missionNo is sync with menu item selected
				data.rosterMode = "mission"
				setGameMode('mission')
				textImgSetText(txt_mainSelect, "MISSION "..data.missionNo.." [" .. t_missions[data.missionNo].status .. "]")
				if t_missions[data.missionNo].path ~= nil then --Detects if lua file is defined
					assert(loadfile(t_missions[data.missionNo].path))()
				end
				if winner == 1 then f_missionStatus() end --Save progress only if you win
				f_unlock(false)
				f_updateUnlocks()
			--MISSION UNAVAILABLE
			else
				sndPlay(sndSys, 100, 5)
			end
		end
	--Cursor position calculation
		if missionMenu < 1 then
			missionMenu = #t_missions
			if #t_missions > 5 then
				cursorPosY = 5
			else
				cursorPosY = #t_missions
			end
		elseif missionMenu > #t_missions then
			missionMenu = 1
			cursorPosY = 1
		elseif ((commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u')) or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30)) and cursorPosY > 1 then
			cursorPosY = cursorPosY - 1
		elseif ((commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd')) or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30)) and cursorPosY < 5 then
			cursorPosY = cursorPosY + 1
		end
		if cursorPosY == 5 then
			moveTxt = (missionMenu - 5) * 15
		elseif cursorPosY == 1 then
			moveTxt = (missionMenu - 1) * 15
		end
		if #t_missions <= 5 then
			maxMissions = #t_missions
		elseif missionMenu - cursorPosY > 0 then
			maxMissions = missionMenu + 5 - cursorPosY
		else
			maxMissions = 5
		end
		animDraw(f_animVelocity(commonBG0, -1, -1))
	--Draw Above Transparent BG
		animSetScale(missionBG1, 219.5, 94)
		animSetWindow(missionBG1, 0,5, 320,110)
		animDraw(missionBG1)
	--Draw Title Menu
		textImgDraw(txt_missionMenu)
		textImgDraw(txt_missionProgress)
	--Draw Below Transparent Table BG
		animSetScale(missionBG2, 240, maxMissions*15)
		animSetWindow(missionBG2, 10,10, 269,195)
		animDraw(missionBG2)
	--Draw Below Table Cursor
		animSetWindow(cursorBox, 40,115+cursorPosY*15, 239,15)
		f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
		animDraw(f_animVelocity(cursorBox, -1, -1))
	--Draw Mission Image Preview
		if t_missions[missionMenu].sprPosX ~= nil then previewPosX = t_missions[missionMenu].sprPosX --Use position stored in events.def file
		else previewPosX = missionCommonPosX --Use common position loaded in screenpack.lua
		end
		if t_missions[missionMenu].sprPosY ~= nil then previewPosY = t_missions[missionMenu].sprPosY
		else previewPosY = missionCommonPosY
		end
		if t_missions[missionMenu].sprScaleX ~= nil then previewScaleX = t_missions[missionMenu].sprScaleX --Use scale stored in events.def file
		else previewScaleX = missionCommonScaleX --Use common scale loaded in screenpack.lua
		end
		if t_missions[missionMenu].sprScaleY ~= nil then previewScaleY = t_missions[missionMenu].sprScaleY
		else previewScaleY = missionCommonScaleY
		end
		--
		if t_unlockLua.modes[t_missions[missionMenu].id] == nil then --If the mission is unlocked
			previewTransS = nil
			previewTransD = nil
		else
			previewTransS = 150 --Apply Transparent
			previewTransD = 0
		end
		f_drawMissionPreview(t_missions[missionMenu].sprGroup, t_missions[missionMenu].sprIndex, previewPosX, previewPosY, previewScaleX, previewScaleY, previewTransS, previewTransD)
	--Draw Mission Info
		if t_unlockLua.modes[t_missions[missionMenu].id] == nil then
			previewInfotxt = t_missions[missionMenu].infounlock
		else
			animPosDraw(padlock, padlockMissionPosX, padlockMissionPosY) --Draw Padlock Icon
			previewInfotxt = t_missions[missionMenu].infolock
		end
		textImgDraw(f_updateTextImg(t_missions[missionMenu].txtID, font11, 0, 0, previewInfotxt, 157, 13.5))
	--Set mission status
		if stats.modes.mission.clear1 == 1 then t_missions[1].status = txt_missionClear end
		if stats.modes.mission.clear2 == 1 then t_missions[2].status = txt_missionClear end
		if stats.modes.mission.clear3 == 1 then t_missions[3].status = txt_missionClear end
	--Draw Text for Below Table
		for i=1, maxMissions do
			if t_unlockLua.modes[t_missions[i].id] == nil then
				missionNametxt = t_missions[i].name
			else
				missionNametxt = "???"
			end
			if i > missionMenu - cursorPosY then
				if t_missions[i].txtID ~= nil then
					textImgDraw(f_updateTextImg(t_missions[i].txtID, font2, 0, 1, missionNametxt, 45, 125+i*15-moveTxt))
					textImgDraw(f_updateTextImg(t_missions[i].txtID, font2, 0, -1, t_missions[i].status, 275, 125+i*15-moveTxt))
				end
			end
		end
	--Draw Up Animated Cursor
		if maxMissions > 5 then
			animDraw(menuArrowUp)
			animUpdate(menuArrowUp)
		end
	--Draw Down Animated Cursor
		if #t_missions > 5 and maxMissions < #t_missions then
			animDraw(menuArrowDown)
			animUpdate(menuArrowDown)
		end
	--Draw Input Hints Panel
		drawMissionInputHints()
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		if commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu') then
			bufd = 0
			bufu = bufu + 1
		elseif commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd') then
			bufu = 0
			bufd = bufd + 1
		else
			bufu = 0
			bufd = 0
		end
		cmdInput()
		refresh()
	end
end

--Get Missions Preview
function f_drawMissionPreview(group, index, posX, posY, scaleX, scaleY, alphaS, alphaD)
	local scaleX = scaleX or 1
	local scaleY = scaleY or 1
	local alphaS = alphaS or 255
	local alphaD = alphaD or 0
	local anim = group..','..index..', 0,0, 0'
	anim = animNew(t_missions.sffData, anim)
	animSetAlpha(anim, alphaS, alphaD)
	animSetScale(anim, scaleX, scaleY)
	animSetPos(anim, posX, posY)
	animUpdate(anim)
	animDraw(anim)
	--return anim
end

--;===========================================================
--; MISSION SAVE DATA
--;===========================================================
function f_missionStatus()
	if data.missionNo == 1 then stats.modes.mission.clear1 = 1
	elseif data.missionNo == 2 then stats.modes.mission.clear2 = 1
	elseif data.missionNo == 3 then stats.modes.mission.clear3 = 1
	end
	f_saveStats()
end

--;===========================================================
--; EVENTS MENU (complete customizable tasks at certain hours, days, weeks, months or years)
--;===========================================================
function f_eventMenu()
	if data.debugMode then f_loadEvents() end
	if #t_events == 0 then
		eventInfo = true
		infoScreen = true
		return
	end
	cmdInput()
	local eventMenu = 1
	local cursorPosX = 1
	local moveTxt = 0
	local bufu = 0
	local bufd = 0
	local bufr = 0
	local bufl = 0
	local previewInfotxt = nil
	local previewPosX = nil
	local previewPosY = nil
	local previewScaleX = nil
	local previewScaleY = nil
	local previewTransS = nil
	local previewTransD = nil
	f_lockedInfoReset()
	f_resetEventArrowsPos()
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	f_unlock(false)
	f_updateUnlocks()
	while true do
	--Event Progress Logic
		stats.modes.event.clearall = (stats.modes.event.clear1 + stats.modes.event.clear2 + stats.modes.event.clear3)
		eventsData = (math.floor((stats.modes.event.clearall * 100 / 3) + 0.5)) --The number (3) is the amount of all data.eventStatus
		textImgSetText(txt_eventProgress,"["..eventsData.."%]")
		if not lockedScreen then
			if esc() or commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then
				f_saveStats()
				data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
				sndPlay(sndSys, 100, 2)
				break
			elseif commandGetState(p1Cmd, 'l') or commandGetState(p2Cmd, 'l') or ((commandGetState(p1Cmd, 'holdl') or commandGetState(p2Cmd, 'holdl')) and bufl >= 30) then
				sndPlay(sndSys, 100, 0)
				eventMenu = eventMenu - 1
			elseif commandGetState(p1Cmd, 'r') or commandGetState(p2Cmd, 'r') or ((commandGetState(p1Cmd, 'holdr') or commandGetState(p2Cmd, 'holdr')) and bufr >= 30) then
				sndPlay(sndSys, 100, 0)
				eventMenu = eventMenu + 1
			elseif btnPalNo(p1Cmd) > 0 or btnPalNo(p2Cmd) > 0 then
				sndPlay(sndSys, 100, 1)
				--EVENT AVAILABLE
				if t_unlockLua.modes[t_events[eventMenu].id] == nil then --If the event is unlocked
					data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
					f_default()
					data.rosterMode = "event"
					setGameMode('event')
					data.eventNo = eventMenu --with this data.eventNo is sync with menu item selected
					if t_events[eventMenu].path ~= nil then --Detects if lua file is defined
						assert(loadfile(t_events[eventMenu].path))()
					end
					if winner == 1 then f_eventStatus() end --Save progress only if you win
					f_unlock(false)
					f_updateUnlocks()
				--EVENT UNAVAILABLE
				else
					noeventInfo = true
					lockedScreen = true
				end
			end
		--Cursor position calculation
			if eventMenu < 1 then
				eventMenu = #t_events
				if #t_events > 3 then
					cursorPosX = 3
				else
					cursorPosX = #t_events
				end
			elseif eventMenu > #t_events then
				eventMenu = 1
				cursorPosX = 1
			elseif ((commandGetState(p1Cmd, 'l') or commandGetState(p2Cmd, 'l')) or ((commandGetState(p1Cmd, 'holdl') or commandGetState(p2Cmd, 'holdl')) and bufl >= 30)) and cursorPosX > 1 then
				cursorPosX = cursorPosX - 1
			elseif ((commandGetState(p1Cmd, 'r') or commandGetState(p2Cmd, 'r')) or ((commandGetState(p1Cmd, 'holdr') or commandGetState(p2Cmd, 'holdr')) and bufr >= 30)) and cursorPosX < 3 then
				cursorPosX = cursorPosX + 1
			end
		end
		if cursorPosX == 3 then
			moveTxt = (eventMenu - 3) * 105 --Set how many space will move Event Status text
			moveImg = (eventMenu - 3) * 160 --Set how many space will move Event Preview image
		elseif cursorPosX == 1 then
			moveTxt = (eventMenu - 1) * 105
			moveImg = (eventMenu - 1) * 160
		end
		if #t_events <= 3 then
			maxEvents = #t_events
		elseif eventMenu - cursorPosX > 0 then
			maxEvents = eventMenu + 3 - cursorPosX
		else
			maxEvents = 3
		end
		animDraw(f_animVelocity(commonBG0, -1, -1))
	--Draw Event Title Transparent BG
		animSetScale(eventBG1, 319.5, 94)
		animSetWindow(eventBG1, 0,21, 320,22)
		animDraw(eventBG1)
	--Draw Title Menu
		textImgDraw(txt_eventMenu)
		textImgDraw(txt_eventProgress)
	--Draw Content Transparent BG
		animSetScale(eventBG2, 318, 154)
		animSetWindow(eventBG2, 3,49, 314,154)
		animDraw(eventBG2)
	--Set Event Progress
		if stats.modes.event.clear1 == 1 then t_events[1].status = txt_eventClear end
		if stats.modes.event.clear2 == 1 then t_events[2].status = txt_eventClear end
		if stats.modes.event.clear3 == 1 then t_events[3].status = txt_eventClear end
	--Set Scroll Logic
		for i=1, maxEvents do
			if i > eventMenu - cursorPosX then
				if i == eventMenu then
					bank = 5
				else
					bank = 0
				end
			--Draw Text for Event Status
				if t_events[i].txtID ~= nil then
					textImgDraw(f_updateTextImg(t_events[i].txtID, jgFnt, bank, 0, t_events[i].status, -50.5+i*105-moveTxt, 213)) -- [*] value needs to be equal to: moveTxt = (eventMenu - ) [*] value to keep static in each press
				end
			--Draw Event Preview Image
				if t_events[i].sprPosX ~= nil then previewPosX = t_events[i].sprPosX --Use position stored in events.def file
				else previewPosX = eventCommonPosX --Use common position loaded in screenpack.lua
				end
				if t_events[i].sprPosY ~= nil then previewPosY = t_events[i].sprPosY
				else previewPosY = eventCommonPosY
				end
				if t_events[i].sprScaleX ~= nil then previewScaleX = t_events[i].sprScaleX --Use scale stored in events.def file
				else previewScaleX = eventCommonScaleX --Use common scale loaded in screenpack.lua
				end
				if t_events[i].sprScaleY ~= nil then previewScaleY = t_events[i].sprScaleY
				else previewScaleY = eventCommonScaleY
				end
				--
				if t_unlockLua.modes[t_events[i].id] == nil then --If the event is unlocked
					previewTransS = nil
					previewTransD = nil
				else
					previewTransS = 150 --Apply Transparent
					previewTransD = 0
				end
				f_drawEventPreview(t_events[i].sprGroup, t_events[i].sprIndex, previewPosX+i*105-moveTxt, previewPosY, previewScaleX, previewScaleY, previewTransS, previewTransD)
			--Draw Event Slot Icon
				f_drawQuickSpr(eventSlot, eventSlotPosX+i*105-moveTxt, eventSlotPosY, eventSlotScaleX, eventSlotScaleY, previewTransS, previewTransD)
			--Draw Padlock Icon
				if t_unlockLua.modes[t_events[i].id] ~= nil then
					animPosDraw(padlock, padlockEventPosX+i*105-moveTxt, padlockEventPosY)
				end
			end
		end
	--Draw Event Cursor
		if not lockedScreen then
			animSetWindow(cursorBox, -100+cursorPosX*104.5,51, 100,150) --As eventMenu is the first value for cursorBox; it will move on X position (x, y) = (-100+cursorPosX*104.5, 60)
			f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
			animDraw(f_animVelocity(cursorBox, -1, -1))
		end
	--Draw Event Info
		if t_unlockLua.modes[t_events[eventMenu].id] == nil then
			previewInfotxt = t_events[eventMenu].infounlock
		else
			previewInfotxt = t_events[eventMenu].infolock
		end
		textImgDraw(f_updateTextImg(t_events[eventMenu].txtID, font11, 0, 0, previewInfotxt, 160, 34))
		f_eventTime() --Draw Date and Time
	--Draw Left Animated Cursor
		if maxEvents > 3 then
			animDraw(menuArrowLeft)
			animUpdate(menuArrowLeft)
		end
	--Draw Right Animated Cursor
		if #t_events > 3 and maxEvents < #t_events then
			animDraw(menuArrowRight)
			animUpdate(menuArrowRight)
		end
		if lockedScreen then f_lockedInfo() else drawEventInputHints() end --Show Locked Event Info Message
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		if commandGetState(p1Cmd, 'holdr') or commandGetState(p2Cmd, 'holdr') then
			bufl = 0
			bufr = bufr + 1
		elseif commandGetState(p1Cmd, 'holdl') or commandGetState(p2Cmd, 'holdl') then
			bufr = 0
			bufl = bufl + 1
		else
			bufr = 0
			bufl = 0
		end
		cmdInput()
		refresh()
	end
end

--Get Events Preview
function f_drawEventPreview(group, index, posX, posY, scaleX, scaleY, alphaS, alphaD)
	local scaleX = scaleX or 1
	local scaleY = scaleY or 1
	local alphaS = alphaS or 255
	local alphaD = alphaD or 0
	local anim = group..','..index..', 0,0, 0'
	anim = animNew(t_events.sffData, anim)
	animSetAlpha(anim, alphaS, alphaD)
	animSetScale(anim, scaleX, scaleY)
	animSetPos(anim, posX, posY)
	animUpdate(anim)
	animDraw(anim)
	--return anim
end

--[[
function countdown(t) --TODO make a Countdown for the sysTime Event
	local d = math.floor(t / 86400)
	local h = math.floor((t % 86400) / 3600)
	local m = math.floor((t % 3600) / 60)
	local s = math.floor((t % 60))
	return string.format("%d:%02d:%02d:%02d", d, h, m, s)
end
]]

function f_lockedInfo()
	cmdInput()
	--Draw Fade BG
	animDraw(fadeWindowBG)
	--Draw Menu BG
	animDraw(infoEventWindowBG)
	animUpdate(infoEventWindowBG)
	--Draw Title
	if noeventInfo then
		textImgDraw(txt_lockedInfo)
	end
	--Draw Ok Text
	textImgDraw(txt_lockedOk)
	--Draw Cursor
	animSetWindow(cursorBox, 87,141, 144,13)
	f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
	animDraw(f_animVelocity(cursorBox, -1, -1))
	--Draw Info Title Text
	textImgDraw(txt_lockedinfoTitle)
	--Draw Input Hints Panel
	drawInfoEventInputHints()
	--Actions
	if btnPalNo(p1Cmd) > 0 or btnPalNo(p2Cmd) > 0 then
		sndPlay(sndSys, 100, 2)
		f_lockedInfoReset()
	end
	cmdInput()
end

function f_lockedInfoReset()
	lockedScreen = false
	noeventInfo = false
end

--;===========================================================
--; EVENT SAVE DATA
--;===========================================================
function f_eventStatus()
	if data.eventNo == 1 then stats.modes.event.clear1 = 1
	elseif data.eventNo == 2 then stats.modes.event.clear2 = 1
	elseif data.eventNo == 3 then stats.modes.event.clear3 = 1
	end
	f_saveStats()
end

--;===========================================================
--; STAGE VIEWER MODE (watch a selected stage without fight)
--;===========================================================
function f_stageViewer()
	if data.stageviewer then
		f_default()
		data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
		setRoundTime(-1)
		data.p2In = 2
		data.stageMenu = true
		data.versusScreen = false
		data.victoryscreen = false
		data.p1TeamMenu = {mode = 0, chars = 1}			
		data.p2TeamMenu = {mode = 0, chars = 1}
		data.p1Char = {"Stage Viewer"}
		data.p2Char = {"Stage Viewer"}
		data.gameMode = "stage viewer"
		setGameMode('stageviewer')
		textImgSetText(txt_mainSelect, "STAGE VIEWER")
		f_selectSimple()
	else
		stviewerInfo = true
		infoScreen = true
	end
end

--;===========================================================
--; PROFILE MENU (display overall player data [PLAYER RECORDS, RANKINGS, ACHIEVEMENTS])
--;===========================================================
function f_statsMenu()
	cmdInput()
	local cursorPosY = 1
	local moveTxt = 0
	local statsMenu = 1
	local bufu = 0
	local bufd = 0
	local bufr = 0
	local bufl = 0
	local maxItems = 12
	local back = false
	f_getStats() --Load Stats
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	animSetPos(menuArrowUp, 278, 11)
	animSetPos(menuArrowDown, 278, 201.5)
	while true do
		--f_playTime() --Test Played Time on live...
		if esc() or commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') or back then
			data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
			sndPlay(sndSys, 100, 2)
			f_resetMenuArrowsPos()
			break
		elseif commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u') or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30) then
			sndPlay(sndSys, 100, 0)
			statsMenu = statsMenu - 1
		elseif commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd') or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30) then
			sndPlay(sndSys, 100, 0)
			statsMenu = statsMenu + 1
		--BACK
		elseif (btnPalNo(p1Cmd) > 0 or btnPalNo(p2Cmd) > 0) and statsMenu == #t_statsMenu then
			back = true
		end
		--Cursor position calculation
		if statsMenu < 1 then
			statsMenu = #t_statsMenu
			if #t_statsMenu > maxItems then
				cursorPosY = maxItems
			else
				cursorPosY = #t_statsMenu
			end
		elseif statsMenu > #t_statsMenu then
			statsMenu = 1
			cursorPosY = 1
		elseif ((commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u')) or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30)) and cursorPosY > 1 then
			cursorPosY = cursorPosY - 1
		elseif ((commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd')) or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30)) and cursorPosY < maxItems then
			cursorPosY = cursorPosY + 1
		end
		if cursorPosY == maxItems then
			moveTxt = (statsMenu - maxItems) * 15
		elseif cursorPosY == 1 then
			moveTxt = (statsMenu - 1) * 15
		end	
		if #t_statsMenu <= maxItems then
			maxStats = #t_statsMenu
		elseif statsMenu - cursorPosY > 0 then
			maxStats = statsMenu + maxItems - cursorPosY
		else
			maxStats = maxItems
		end
		animDraw(f_animVelocity(commonBG0, -1, -1))
		--Draw Transparent Table BG
		animSetScale(commonTBG, 290, maxStats*15)
		animSetWindow(commonTBG, 30,20, 260,180)
		animDraw(commonTBG)
		--Draw Title Menu
		textImgDraw(txt_statsMenu)
		textImgDraw(txt_statsProgress)
		--Draw Stats Table Cursor
		animSetWindow(cursorBox, 30,5+cursorPosY*15, 260,15)
		f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
		animDraw(f_animVelocity(cursorBox, -1, -1))
		--Draw Stats Text for Table
		for i=1, maxStats do
			if i > statsMenu - cursorPosY then
				if t_statsMenu[i].varID ~= nil then
					textImgDraw(f_updateTextImg(t_statsMenu[i].varID, font2, 0, 1, t_statsMenu[i].text, 35, 15+i*15-moveTxt))
					textImgDraw(f_updateTextImg(t_statsMenu[i].varID, font2, 0, -1, t_statsMenu[i].varText, 286, 15+i*15-moveTxt))
				end
			end
		end
		--Draw Up Animated Cursor
		if maxStats > maxItems then
			animDraw(menuArrowUp)
			animUpdate(menuArrowUp)
		end
		--Draw Down Animated Cursor
		if #t_statsMenu > maxItems and maxStats < #t_statsMenu then
			animDraw(menuArrowDown)
			animUpdate(menuArrowDown)
		end
		drawListInputHints()
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		if commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu') then
			bufd = 0
			bufu = bufu + 1
		elseif commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd') then
			bufu = 0
			bufd = bufd + 1
		else
			bufu = 0
			bufd = 0
		end
		cmdInput()
		refresh()
	end
end

--;===========================================================
--; PLAYER SAVE DATA
--;===========================================================
function f_victories()
	stats.wins = stats.wins + 1
	f_saveStats()
end

function f_defeats()
	stats.losses = stats.losses + 1
	f_saveStats()
end

function f_records()
	--[[
	if data.rosterMode == "suddendeath" then
		if winCnt > data.suddenrecord then
			data.suddenrecord = winCnt
		end
	elseif data.rosterMode == "endless" then
		if winCnt > data.endlessrecord then
			data.endlessrecord = winCnt
		end
	end
	f_saveStats()
	]]
end

function f_modeplayTime()
	if data.rosterMode == "story" then stats.modes.story.playtime = stats.modes.story.playtime + clearTime --(math.floor(clearTime)) (Save time from Float to Integer)
	elseif data.rosterMode == "arcade" then stats.modes.arcade.playtime = stats.modes.arcade.playtime + clearTime
	elseif data.rosterMode == "versus" then stats.modes.versus.playtime = stats.modes.versus.playtime + clearTime
	elseif data.rosterMode == "training" then stats.modes.training.playtime = stats.modes.training.playtime + clearTime
	elseif data.rosterMode == "trials" then stats.modes.trials.playtime = stats.modes.trials.playtime + clearTime
	elseif data.rosterMode == "cpu" then stats.modes.watch.playtime = stats.modes.watch.playtime + clearTime
	elseif data.rosterMode == "survival" then stats.modes.survival.playtime = stats.modes.survival.playtime + clearTime
	elseif data.rosterMode == "boss" then stats.modes.boss.playtime = stats.modes.boss.playtime + clearTime
	elseif data.rosterMode == "bonus" then stats.modes.bonus.playtime = stats.modes.bonus.playtime + clearTime
	elseif data.rosterMode == "scoreattack" then stats.modes.scoreattack.playtime = stats.modes.scoreattack.playtime + clearTime
	elseif data.rosterMode == "timeattack" then stats.modes.timeattack.playtime = stats.modes.timeattack.playtime + clearTime
	elseif data.rosterMode == "timerush" then stats.modes.timerush.playtime = stats.modes.timerush.playtime + clearTime
	elseif data.rosterMode == "endless" then stats.modes.endless.playtime = stats.modes.endless.playtime + clearTime
	elseif data.rosterMode == "suddendeath" then stats.modes.suddendeath.playtime = stats.modes.suddendeath.playtime + clearTime
	elseif data.rosterMode == "vskumite" then stats.modes.vskumite.playtime = stats.modes.vskumite.playtime + clearTime
	elseif data.rosterMode == "mission" then stats.modes.mission.playtime = stats.modes.mission.playtime + clearTime
	elseif data.rosterMode == "event" then stats.modes.event.playtime = stats.modes.event.playtime + clearTime
	elseif data.rosterMode == "tower" then stats.modes.tower.playtime = stats.modes.tower.playtime + clearTime
	elseif data.rosterMode == "tourney" then stats.modes.tourney.playtime = stats.modes.tourney.playtime + clearTime
	elseif data.rosterMode == "abyss" then stats.modes.abyss.playtime = stats.modes.abyss.playtime + clearTime
	elseif data.rosterMode == "legion" then stats.modes.legion.playtime = stats.modes.legion.playtime + clearTime
	elseif data.rosterMode == "beatemup" then stats.modes.beatemup.playtime = stats.modes.beatemup.playtime + clearTime
	elseif data.rosterMode == "adventure" then stats.modes.adventure.playtime = stats.modes.adventure.playtime + clearTime
	end
	f_saveStats()
end

function f_favoriteChar()
	data.favoriteChar = f_getName(data.t_p1selected[1].cel) --Improve store logic with json
	f_saveStats()
end

function f_favoriteStage()
	data.favoriteStage = getStageName(stageList):gsub('^["%s]*(.-)["%s]*$', '%1') --Improve store logic with json
	f_saveStats()
end

function f_gameState()
if stats.modes.arcade.clear >= 1 then arcadeProgress = 1 else arcadeProgress = 0 end
if stats.modes.survival.clear >= 1 then survivalProgress = 1 else survivalProgress = 0 end
gameProgress = (arcadeProgress + survivalProgress + stats.modes.mission.clearall + stats.modes.event.clearall + (data.storiesProgress/100))
gameData = (math.floor((gameProgress * 100 / 11) + 0.5))
--[[
The number (11) is the sumation of true amount of all gameProgress values:
(arcadeProgress = 1 + survivalProgress = 1 + stats.modes.mission.clearall = 3 + stats.modes.event.clearall = 3 + data.storiesProgress = 3)
]]
end

function f_getStats()
--Progress Logic
	f_gameState()
	textImgSetText(txt_statsMenu,"" .. data.userName .. " PROGRESS:")
	textImgSetText(txt_statsProgress,"["..gameData.."%]")
--Get Stats Info
	s = math.floor((stats.playtime%60))
	m = math.floor((stats.playtime%3600)/60)
	h = math.floor((stats.playtime%86400)/3600)
	d = math.floor(stats.playtime/86400)
	--timePlayed = string.format("%d:Days %02d:Hours %02d:Minutes %02d:Seconds", d, h, m, s)
	timePlayed = string.format("%d:Days %02d:Hours %02d:Minutes", d, h, m)
	t_statsMenu[1].varText = timePlayed
	t_statsMenu[2].varText = (stats.wins+stats.losses)
	t_statsMenu[3].varText = stats.wins
	t_statsMenu[4].varText = stats.losses
	t_statsMenu[5].varText = "WIP"--data.favoriteChar
	t_statsMenu[6].varText = "WIP"--data.favoriteStage
	t_statsMenu[7].varText = "None" --If all Preferred Mode are equal
	--Preferred Mode Logic
	if (stats.modes.story.playtime > stats.modes.arcade.playtime) and
	   (stats.modes.story.playtime > stats.modes.versus.playtime) and
	   (stats.modes.story.playtime > stats.modes.survival.playtime) and
	   (stats.modes.story.playtime > stats.modes.boss.playtime) and
	   (stats.modes.story.playtime > stats.modes.bonus.playtime) and
	   (stats.modes.story.playtime > stats.modes.timeattack.playtime) and
	   (stats.modes.story.playtime > stats.modes.timerush.playtime) and
	   (stats.modes.story.playtime > stats.modes.suddendeath.playtime) and
	   (stats.modes.story.playtime > stats.modes.vskumite.playtime) and
	   (stats.modes.story.playtime > stats.modes.watch.playtime) and
	   (stats.modes.story.playtime > stats.modes.event.playtime) and
	   (stats.modes.story.playtime > stats.modes.mission.playtime) and
	   (stats.modes.story.playtime > stats.modes.endless.playtime) and
	   (stats.modes.story.playtime > stats.modes.scoreattack.playtime) and
	   (stats.modes.story.playtime > stats.modes.tower.playtime) and
	   (stats.modes.story.playtime > stats.modes.tourney.playtime) and
	   (stats.modes.story.playtime > stats.modes.adventure.playtime) then
		t_statsMenu[7].varText = "Story"
	end
	if (stats.modes.arcade.playtime > stats.modes.versus.playtime) and
	   (stats.modes.arcade.playtime > stats.modes.survival.playtime) and
	   (stats.modes.arcade.playtime > stats.modes.boss.playtime) and
	   (stats.modes.arcade.playtime > stats.modes.bonus.playtime) and
	   (stats.modes.arcade.playtime > stats.modes.timeattack.playtime) and
	   (stats.modes.arcade.playtime > stats.modes.timerush.playtime) and
	   (stats.modes.arcade.playtime > stats.modes.suddendeath.playtime) and
	   (stats.modes.arcade.playtime > stats.modes.vskumite.playtime) and
	   (stats.modes.arcade.playtime > stats.modes.watch.playtime) and
	   (stats.modes.arcade.playtime > stats.modes.event.playtime) and
	   (stats.modes.arcade.playtime > stats.modes.mission.playtime) and
	   (stats.modes.arcade.playtime > stats.modes.endless.playtime) and
	   (stats.modes.arcade.playtime > stats.modes.scoreattack.playtime) and
	   (stats.modes.arcade.playtime > stats.modes.tower.playtime) and
	   (stats.modes.arcade.playtime > stats.modes.story.playtime) and
	   (stats.modes.arcade.playtime > stats.modes.tourney.playtime) and
	   (stats.modes.arcade.playtime > stats.modes.adventure.playtime) then
		t_statsMenu[7].varText = "Arcade"
	end
	if (stats.modes.versus.playtime > stats.modes.arcade.playtime) and
	   (stats.modes.versus.playtime > stats.modes.survival.playtime) and
	   (stats.modes.versus.playtime > stats.modes.boss.playtime) and
	   (stats.modes.versus.playtime > stats.modes.bonus.playtime) and
	   (stats.modes.versus.playtime > stats.modes.timeattack.playtime) and
	   (stats.modes.versus.playtime > stats.modes.timerush.playtime) and
	   (stats.modes.versus.playtime > stats.modes.suddendeath.playtime) and
	   (stats.modes.versus.playtime > stats.modes.vskumite.playtime) and
	   (stats.modes.versus.playtime > stats.modes.watch.playtime) and
	   (stats.modes.versus.playtime > stats.modes.event.playtime) and
	   (stats.modes.versus.playtime > stats.modes.mission.playtime) and
	   (stats.modes.versus.playtime > stats.modes.endless.playtime) and
	   (stats.modes.versus.playtime > stats.modes.scoreattack.playtime) and
	   (stats.modes.versus.playtime > stats.modes.tower.playtime) and
	   (stats.modes.versus.playtime > stats.modes.story.playtime) and
	   (stats.modes.versus.playtime > stats.modes.tourney.playtime) and
	   (stats.modes.versus.playtime > stats.modes.adventure.playtime) then
		t_statsMenu[7].varText = "Versus"
	end
	if (stats.modes.watch.playtime > stats.modes.arcade.playtime) and
	   (stats.modes.watch.playtime > stats.modes.versus.playtime) and
	   (stats.modes.watch.playtime > stats.modes.survival.playtime) and
	   (stats.modes.watch.playtime > stats.modes.boss.playtime) and
	   (stats.modes.watch.playtime > stats.modes.bonus.playtime) and
	   (stats.modes.watch.playtime > stats.modes.timeattack.playtime) and
	   (stats.modes.watch.playtime > stats.modes.timerush.playtime) and
	   (stats.modes.watch.playtime > stats.modes.suddendeath.playtime) and
	   (stats.modes.watch.playtime > stats.modes.vskumite.playtime) and
	   (stats.modes.watch.playtime > stats.modes.event.playtime) and
	   (stats.modes.watch.playtime > stats.modes.mission.playtime) and
	   (stats.modes.watch.playtime > stats.modes.endless.playtime) and
	   (stats.modes.watch.playtime > stats.modes.scoreattack.playtime) and
	   (stats.modes.watch.playtime > stats.modes.tower.playtime) and
	   (stats.modes.watch.playtime > stats.modes.story.playtime) and
	   (stats.modes.watch.playtime > stats.modes.tourney.playtime) and
	   (stats.modes.watch.playtime > stats.modes.adventure.playtime) then
		t_statsMenu[7].varText = "CPU Match"
	end
	if (stats.modes.survival.playtime > stats.modes.arcade.playtime) and
	   (stats.modes.survival.playtime > stats.modes.versus.playtime) and
	   (stats.modes.survival.playtime > stats.modes.boss.playtime) and
	   (stats.modes.survival.playtime > stats.modes.bonus.playtime) and
	   (stats.modes.survival.playtime > stats.modes.timeattack.playtime) and
	   (stats.modes.survival.playtime > stats.modes.timerush.playtime) and
	   (stats.modes.survival.playtime > stats.modes.suddendeath.playtime) and
	   (stats.modes.survival.playtime > stats.modes.vskumite.playtime) and
	   (stats.modes.survival.playtime > stats.modes.watch.playtime) and
	   (stats.modes.survival.playtime > stats.modes.event.playtime) and
	   (stats.modes.survival.playtime > stats.modes.mission.playtime) and
	   (stats.modes.survival.playtime > stats.modes.endless.playtime) and
	   (stats.modes.survival.playtime > stats.modes.scoreattack.playtime) and
	   (stats.modes.survival.playtime > stats.modes.tower.playtime) and
	   (stats.modes.survival.playtime > stats.modes.story.playtime) and
	   (stats.modes.survival.playtime > stats.modes.tourney.playtime) and
	   (stats.modes.survival.playtime > stats.modes.adventure.playtime) then
		t_statsMenu[7].varText = "Survival"
	end
	if (stats.modes.boss.playtime > stats.modes.arcade.playtime) and
	   (stats.modes.boss.playtime > stats.modes.versus.playtime) and
	   (stats.modes.boss.playtime > stats.modes.survival.playtime) and
	   (stats.modes.boss.playtime > stats.modes.bonus.playtime) and
	   (stats.modes.boss.playtime > stats.modes.timeattack.playtime) and
	   (stats.modes.boss.playtime > stats.modes.timerush.playtime) and
	   (stats.modes.boss.playtime > stats.modes.suddendeath.playtime) and
	   (stats.modes.boss.playtime > stats.modes.vskumite.playtime) and
	   (stats.modes.boss.playtime > stats.modes.watch.playtime) and
	   (stats.modes.boss.playtime > stats.modes.event.playtime) and
	   (stats.modes.boss.playtime > stats.modes.mission.playtime) and
	   (stats.modes.boss.playtime > stats.modes.endless.playtime) and
	   (stats.modes.boss.playtime > stats.modes.scoreattack.playtime) and
	   (stats.modes.boss.playtime > stats.modes.tower.playtime) and
	   (stats.modes.boss.playtime > stats.modes.story.playtime) and
	   (stats.modes.boss.playtime > stats.modes.tourney.playtime) and
	   (stats.modes.boss.playtime > stats.modes.adventure.playtime) then
		t_statsMenu[7].varText = "Boss Fight"
	end
	if (stats.modes.bonus.playtime > stats.modes.arcade.playtime) and
	   (stats.modes.bonus.playtime > stats.modes.versus.playtime) and
	   (stats.modes.bonus.playtime > stats.modes.survival.playtime) and
	   (stats.modes.bonus.playtime > stats.modes.boss.playtime) and
	   (stats.modes.bonus.playtime > stats.modes.timeattack.playtime) and
	   (stats.modes.bonus.playtime > stats.modes.timerush.playtime) and
	   (stats.modes.bonus.playtime > stats.modes.suddendeath.playtime) and
	   (stats.modes.bonus.playtime > stats.modes.vskumite.playtime) and
	   (stats.modes.bonus.playtime > stats.modes.watch.playtime) and
	   (stats.modes.bonus.playtime > stats.modes.event.playtime) and
	   (stats.modes.bonus.playtime > stats.modes.mission.playtime) and
	   (stats.modes.bonus.playtime > stats.modes.endless.playtime) and
	   (stats.modes.bonus.playtime > stats.modes.scoreattack.playtime) and
	   (stats.modes.bonus.playtime > stats.modes.tower.playtime) and
	   (stats.modes.bonus.playtime > stats.modes.story.playtime) and
	   (stats.modes.bonus.playtime > stats.modes.tourney.playtime) and
	   (stats.modes.bonus.playtime > stats.modes.adventure.playtime) then
		t_statsMenu[7].varText = "Bonus Games"
	end
	if (stats.modes.timeattack.playtime > stats.modes.arcade.playtime) and
	   (stats.modes.timeattack.playtime > stats.modes.versus.playtime) and
	   (stats.modes.timeattack.playtime > stats.modes.survival.playtime) and
	   (stats.modes.timeattack.playtime > stats.modes.boss.playtime) and
	   (stats.modes.timeattack.playtime > stats.modes.bonus.playtime) and
	   (stats.modes.timeattack.playtime > stats.modes.suddendeath.playtime) and
	   (stats.modes.timeattack.playtime > stats.modes.vskumite.playtime) and
	   (stats.modes.timeattack.playtime > stats.modes.watch.playtime) and
	   (stats.modes.timeattack.playtime > stats.modes.event.playtime) and
	   (stats.modes.timeattack.playtime > stats.modes.mission.playtime) and
	   (stats.modes.timeattack.playtime > stats.modes.endless.playtime) and
	   (stats.modes.timeattack.playtime > stats.modes.scoreattack.playtime) and
	   (stats.modes.timeattack.playtime > stats.modes.timerush.playtime) and
	   (stats.modes.timeattack.playtime > stats.modes.tower.playtime) and
	   (stats.modes.timeattack.playtime > stats.modes.story.playtime) and
	   (stats.modes.timeattack.playtime > stats.modes.tourney.playtime) and
	   (stats.modes.timeattack.playtime > stats.modes.adventure.playtime) then
		t_statsMenu[7].varText = "Time Attack"
	end
	if (stats.modes.timerush.playtime > stats.modes.arcade.playtime) and
	   (stats.modes.timerush.playtime > stats.modes.versus.playtime) and
	   (stats.modes.timerush.playtime > stats.modes.survival.playtime) and
	   (stats.modes.timerush.playtime > stats.modes.boss.playtime) and
	   (stats.modes.timerush.playtime > stats.modes.bonus.playtime) and
	   (stats.modes.timerush.playtime > stats.modes.suddendeath.playtime) and
	   (stats.modes.timerush.playtime > stats.modes.vskumite.playtime) and
	   (stats.modes.timerush.playtime > stats.modes.watch.playtime) and
	   (stats.modes.timerush.playtime > stats.modes.event.playtime) and
	   (stats.modes.timerush.playtime > stats.modes.mission.playtime) and
	   (stats.modes.timerush.playtime > stats.modes.endless.playtime) and
	   (stats.modes.timerush.playtime > stats.modes.scoreattack.playtime) and
	   (stats.modes.timerush.playtime > stats.modes.timeattack.playtime) and
	   (stats.modes.timerush.playtime > stats.modes.tower.playtime) and
	   (stats.modes.timerush.playtime > stats.modes.story.playtime) and
	   (stats.modes.timerush.playtime > stats.modes.tourney.playtime) and
	   (stats.modes.timerush.playtime > stats.modes.adventure.playtime) then
		t_statsMenu[7].varText = "Time Rush"
	end
	if (stats.modes.scoreattack.playtime > stats.modes.arcade.playtime) and
	   (stats.modes.scoreattack.playtime > stats.modes.versus.playtime) and
	   (stats.modes.scoreattack.playtime > stats.modes.survival.playtime) and
	   (stats.modes.scoreattack.playtime > stats.modes.boss.playtime) and
	   (stats.modes.scoreattack.playtime > stats.modes.bonus.playtime) and
	   (stats.modes.scoreattack.playtime > stats.modes.timeattack.playtime) and
	   (stats.modes.scoreattack.playtime > stats.modes.timerush.playtime) and
	   (stats.modes.scoreattack.playtime > stats.modes.suddendeath.playtime) and
	   (stats.modes.scoreattack.playtime > stats.modes.vskumite.playtime) and
	   (stats.modes.scoreattack.playtime > stats.modes.watch.playtime) and
	   (stats.modes.scoreattack.playtime > stats.modes.event.playtime) and
	   (stats.modes.scoreattack.playtime > stats.modes.mission.playtime) and
	   (stats.modes.scoreattack.playtime > stats.modes.endless.playtime) and
	   (stats.modes.scoreattack.playtime > stats.modes.tower.playtime) and
	   (stats.modes.scoreattack.playtime > stats.modes.story.playtime) and
	   (stats.modes.scoreattack.playtime > stats.modes.tourney.playtime) and
	   (stats.modes.scoreattack.playtime > stats.modes.adventure.playtime) then
		t_statsMenu[7].varText = "Score Attack"
	end
	if (stats.modes.endless.playtime > stats.modes.arcade.playtime) and
	   (stats.modes.endless.playtime > stats.modes.versus.playtime) and
	   (stats.modes.endless.playtime > stats.modes.survival.playtime) and
	   (stats.modes.endless.playtime > stats.modes.boss.playtime) and
	   (stats.modes.endless.playtime > stats.modes.bonus.playtime) and
	   (stats.modes.endless.playtime > stats.modes.timeattack.playtime) and
	   (stats.modes.endless.playtime > stats.modes.timerush.playtime) and
	   (stats.modes.endless.playtime > stats.modes.suddendeath.playtime) and
	   (stats.modes.endless.playtime > stats.modes.vskumite.playtime) and
	   (stats.modes.endless.playtime > stats.modes.watch.playtime) and
	   (stats.modes.endless.playtime > stats.modes.event.playtime) and
	   (stats.modes.endless.playtime > stats.modes.mission.playtime) and
	   (stats.modes.endless.playtime > stats.modes.scoreattack.playtime) and
	   (stats.modes.endless.playtime > stats.modes.tower.playtime) and
	   (stats.modes.endless.playtime > stats.modes.story.playtime) and
	   (stats.modes.endless.playtime > stats.modes.tourney.playtime) and
	   (stats.modes.endless.playtime > stats.modes.adventure.playtime) then
		t_statsMenu[7].varText = "Endless"
	end
	if (stats.modes.suddendeath.playtime > stats.modes.arcade.playtime) and
	   (stats.modes.suddendeath.playtime > stats.modes.versus.playtime) and
	   (stats.modes.suddendeath.playtime > stats.modes.survival.playtime) and
	   (stats.modes.suddendeath.playtime > stats.modes.boss.playtime) and
	   (stats.modes.suddendeath.playtime > stats.modes.bonus.playtime) and
	   (stats.modes.suddendeath.playtime > stats.modes.timeattack.playtime) and
	   (stats.modes.suddendeath.playtime > stats.modes.timerush.playtime) and
	   (stats.modes.suddendeath.playtime > stats.modes.vskumite.playtime) and
	   (stats.modes.suddendeath.playtime > stats.modes.watch.playtime) and
	   (stats.modes.suddendeath.playtime > stats.modes.event.playtime) and
	   (stats.modes.suddendeath.playtime > stats.modes.mission.playtime) and
	   (stats.modes.suddendeath.playtime > stats.modes.endless.playtime) and
	   (stats.modes.suddendeath.playtime > stats.modes.scoreattack.playtime) and
	   (stats.modes.suddendeath.playtime > stats.modes.tower.playtime) and
	   (stats.modes.suddendeath.playtime > stats.modes.story.playtime) and
	   (stats.modes.suddendeath.playtime > stats.modes.tourney.playtime) and
	   (stats.modes.suddendeath.playtime > stats.modes.adventure.playtime) then
		t_statsMenu[7].varText = "Sudden Death"
	end
	if (stats.modes.vskumite.playtime > stats.modes.arcade.playtime) and
	   (stats.modes.vskumite.playtime > stats.modes.versus.playtime) and
	   (stats.modes.vskumite.playtime > stats.modes.survival.playtime) and
	   (stats.modes.vskumite.playtime > stats.modes.boss.playtime) and
	   (stats.modes.vskumite.playtime > stats.modes.bonus.playtime) and
	   (stats.modes.vskumite.playtime > stats.modes.timeattack.playtime) and
	   (stats.modes.vskumite.playtime > stats.modes.timerush.playtime) and
	   (stats.modes.vskumite.playtime > stats.modes.suddendeath.playtime) and
	   (stats.modes.vskumite.playtime > stats.modes.watch.playtime) and
	   (stats.modes.vskumite.playtime > stats.modes.event.playtime) and
	   (stats.modes.vskumite.playtime > stats.modes.mission.playtime) and
	   (stats.modes.vskumite.playtime > stats.modes.endless.playtime) and
	   (stats.modes.vskumite.playtime > stats.modes.scoreattack.playtime) and
	   (stats.modes.vskumite.playtime > stats.modes.tower.playtime) and
	   (stats.modes.vskumite.playtime > stats.modes.story.playtime) and
	   (stats.modes.vskumite.playtime > stats.modes.tourney.playtime) and
	   (stats.modes.vskumite.playtime > stats.modes.adventure.playtime) then
		t_statsMenu[7].varText = getKumiteData()
	end
	if (stats.modes.mission.playtime > stats.modes.arcade.playtime) and
	   (stats.modes.mission.playtime > stats.modes.versus.playtime) and
	   (stats.modes.mission.playtime > stats.modes.survival.playtime) and
	   (stats.modes.mission.playtime > stats.modes.boss.playtime) and
	   (stats.modes.mission.playtime > stats.modes.bonus.playtime) and
	   (stats.modes.mission.playtime > stats.modes.timeattack.playtime) and
	   (stats.modes.mission.playtime > stats.modes.timerush.playtime) and
	   (stats.modes.mission.playtime > stats.modes.vskumite.playtime) and
	   (stats.modes.mission.playtime > stats.modes.suddendeath.playtime) and
	   (stats.modes.mission.playtime > stats.modes.watch.playtime) and
	   (stats.modes.mission.playtime > stats.modes.event.playtime) and
	   (stats.modes.mission.playtime > stats.modes.endless.playtime) and
	   (stats.modes.mission.playtime > stats.modes.scoreattack.playtime) and
	   (stats.modes.mission.playtime > stats.modes.tower.playtime) and
	   (stats.modes.mission.playtime > stats.modes.story.playtime) and
	   (stats.modes.mission.playtime > stats.modes.tourney.playtime) and
	   (stats.modes.mission.playtime > stats.modes.adventure.playtime) then
		t_statsMenu[7].varText = "Missions"
	end
	if (stats.modes.event.playtime > stats.modes.arcade.playtime) and
	   (stats.modes.event.playtime > stats.modes.versus.playtime) and
	   (stats.modes.event.playtime > stats.modes.survival.playtime) and
	   (stats.modes.event.playtime > stats.modes.boss.playtime) and
	   (stats.modes.event.playtime > stats.modes.bonus.playtime) and
	   (stats.modes.event.playtime > stats.modes.timeattack.playtime) and
	   (stats.modes.event.playtime > stats.modes.timerush.playtime) and
	   (stats.modes.event.playtime > stats.modes.vskumite.playtime) and
	   (stats.modes.event.playtime > stats.modes.suddendeath.playtime) and
	   (stats.modes.event.playtime > stats.modes.watch.playtime) and
	   (stats.modes.event.playtime > stats.modes.mission.playtime) and
	   (stats.modes.event.playtime > stats.modes.endless.playtime) and
	   (stats.modes.event.playtime > stats.modes.scoreattack.playtime) and
	   (stats.modes.event.playtime > stats.modes.tower.playtime) and
	   (stats.modes.event.playtime > stats.modes.story.playtime) and
	   (stats.modes.event.playtime > stats.modes.tourney.playtime) and
	   (stats.modes.event.playtime > stats.modes.adventure.playtime) then
		t_statsMenu[7].varText = "Events"
	end
	if (stats.modes.tower.playtime > stats.modes.arcade.playtime) and
	   (stats.modes.tower.playtime > stats.modes.versus.playtime) and
	   (stats.modes.tower.playtime > stats.modes.survival.playtime) and
	   (stats.modes.tower.playtime > stats.modes.boss.playtime) and
	   (stats.modes.tower.playtime > stats.modes.bonus.playtime) and
	   (stats.modes.tower.playtime > stats.modes.timeattack.playtime) and
	   (stats.modes.tower.playtime > stats.modes.timerush.playtime) and
	   (stats.modes.tower.playtime > stats.modes.vskumite.playtime) and
	   (stats.modes.tower.playtime > stats.modes.suddendeath.playtime) and
	   (stats.modes.tower.playtime > stats.modes.watch.playtime) and
	   (stats.modes.tower.playtime > stats.modes.event.playtime) and
	   (stats.modes.tower.playtime > stats.modes.mission.playtime) and
	   (stats.modes.tower.playtime > stats.modes.endless.playtime) and
	   (stats.modes.tower.playtime > stats.modes.scoreattack.playtime) and
	   (stats.modes.tower.playtime > stats.modes.story.playtime) and
	   (stats.modes.tower.playtime > stats.modes.tourney.playtime) and
	   (stats.modes.tower.playtime > stats.modes.adventure.playtime) then
		t_statsMenu[7].varText = "Tower"
	end
	if (stats.modes.tourney.playtime > stats.modes.arcade.playtime) and
	   (stats.modes.tourney.playtime > stats.modes.versus.playtime) and
	   (stats.modes.tourney.playtime > stats.modes.survival.playtime) and
	   (stats.modes.tourney.playtime > stats.modes.boss.playtime) and
	   (stats.modes.tourney.playtime > stats.modes.bonus.playtime) and
	   (stats.modes.tourney.playtime > stats.modes.timeattack.playtime) and
	   (stats.modes.tourney.playtime > stats.modes.timerush.playtime) and
	   (stats.modes.tourney.playtime > stats.modes.vskumite.playtime) and
	   (stats.modes.tourney.playtime > stats.modes.suddendeath.playtime) and
	   (stats.modes.tourney.playtime > stats.modes.watch.playtime) and
	   (stats.modes.tourney.playtime > stats.modes.event.playtime) and
	   (stats.modes.tourney.playtime > stats.modes.mission.playtime) and
	   (stats.modes.tourney.playtime > stats.modes.endless.playtime) and
	   (stats.modes.tourney.playtime > stats.modes.scoreattack.playtime) and
	   (stats.modes.tourney.playtime > stats.modes.tower.playtime) and
	   (stats.modes.tourney.playtime > stats.modes.story.playtime) and
	   (stats.modes.tourney.playtime > stats.modes.adventure.playtime) then
		t_statsMenu[7].varText = "Tourney"
	end
	if (stats.modes.adventure.playtime > stats.modes.arcade.playtime) and
	   (stats.modes.adventure.playtime > stats.modes.versus.playtime) and
	   (stats.modes.adventure.playtime > stats.modes.survival.playtime) and
	   (stats.modes.adventure.playtime > stats.modes.boss.playtime) and
	   (stats.modes.adventure.playtime > stats.modes.bonus.playtime) and
	   (stats.modes.adventure.playtime > stats.modes.timeattack.playtime) and
	   (stats.modes.adventure.playtime > stats.modes.timerush.playtime) and
	   (stats.modes.adventure.playtime > stats.modes.vskumite.playtime) and
	   (stats.modes.adventure.playtime > stats.modes.suddendeath.playtime) and
	   (stats.modes.adventure.playtime > stats.modes.watch.playtime) and
	   (stats.modes.adventure.playtime > stats.modes.event.playtime) and
	   (stats.modes.adventure.playtime > stats.modes.mission.playtime) and
	   (stats.modes.adventure.playtime > stats.modes.endless.playtime) and
	   (stats.modes.adventure.playtime > stats.modes.scoreattack.playtime) and
	   (stats.modes.adventure.playtime > stats.modes.tower.playtime) and
	   (stats.modes.adventure.playtime > stats.modes.story.playtime) and
	   (stats.modes.adventure.playtime > stats.modes.tourney.playtime) then
		t_statsMenu[7].varText = "Adventure"
	end
	ts = math.floor((stats.modes.training.playtime%60))
	tm = math.floor((stats.modes.training.playtime%3600)/60)
	th = math.floor((stats.modes.training.playtime%86400)/3600)
	td = math.floor(stats.modes.training.playtime/86400)
	--practiceTime = string.format("%d:Days %02d:Hours %02d:Minutes %02d:Seconds", td, th, tm, ts)
	practiceTime = string.format("%d:Days %02d:Hours %02d:Minutes", td, th, tm)
	t_statsMenu[8].varText = practiceTime
	t_statsMenu[9].varText = stats.coins
	t_statsMenu[10].varText = math.floor(data.storiesProgress/100).."/3"
	t_statsMenu[11].varText = stats.modes.mission.clearall.."/3"
	t_statsMenu[12].varText = stats.modes.event.clearall.."/3"
end

--;===========================================================
--; LEADERBOARDS SCREEN (display rankings data)
--;===========================================================
function f_rankings()
	--TODO
end

--;===========================================================
--; GALLERY MENU (view pictures, storyboards and video cutscenes)
--;===========================================================
function f_drawGalleryPreview(sffData, group, index, x, y, scaleX, scaleY, x1, y1, x2, y2, alphaS, alphaD)
	local x = x or 0
	local y = y or 0
	local scaleX = scaleX or 1
	local scaleY = scaleY or 1
	local alphaS = alphaS or 255
	local alphaD = alphaD or 0
	local anim = group .. ',' .. index .. ',' .. x .. ',' .. y .. ',' .. '-1'
	anim = animNew(sffData, anim)
	animSetAlpha(anim, alphaS, alphaD)
	animSetScale(anim, scaleX, scaleY)
	animSetWindow(anim, x1, y1, x2, y2)
	animUpdate(anim)
	animDraw(anim)
end

function f_setGalleryCursorPos() --Used to calculate gallery cursor pos in gallery menu
	galleryCursor = (galleryCursorX+(galleryColumns+galleryHiddenColumns)*galleryCursorY) + 1
end

function f_drawGallery(t, columns, rows) --Draw Gallery Content
	local unlockSection = nil
	local sprData = nil
	if galleryMenu == 1 then
		sprData = sprArtworks
		unlockSection = 'artworks'
	elseif galleryMenu == 2 then
		sprData = sprStoryboards
		unlockSection = 'storyboards'
	elseif galleryMenu == 3 then
		sprData = sprMovies
		unlockSection = 'videos'
	end
	for i=0, columns-1 do
		for j=0, rows-1 do
			local index = (i + columns * j) + 1 --This is the same logic of f_setGalleryCursorPos() function
			if index <= #t then
			--Draw Preview Cell Slots
				animPosDraw(
					galleryPreviewSlot,
					galleryPreviewSlotPosX + i * (galleryPreviewSlotSizeX + galleryPreviewSlotSpacingX) - (galleryMoveX * (galleryPreviewSlotSizeX + galleryPreviewSlotSpacingX)),
					galleryPreviewSlotPosY + j * (galleryPreviewSlotSizeY + galleryPreviewSlotSpacingY) - (galleryMoveY * (galleryPreviewSlotSizeY + galleryPreviewSlotSpacingY))
				)
				animSetWindow(galleryPreviewSlot, galleryWindowX1, galleryWindowY1, galleryWindowX2, galleryWindowY2)
			--Draw Preview (only if has Spr Data defined)
				if t[index].spr[1] and t[index].spr[2] ~= nil then
					if t_unlockLua[unlockSection][t[index].id] == nil then --If the artwork is Unlocked
						f_drawGalleryPreview(
							sprData,
							t[index].spr[1], t[index].spr[2],
							t[index].previewpos[1] + i * (t[index].size[1] + t[index].previewspacing[1]) - (galleryMoveX * (t[index].size[1] + t[index].previewspacing[1])),
							t[index].previewpos[2] + j * (t[index].size[2] + t[index].previewspacing[2]) - (galleryMoveY * (t[index].size[2] + t[index].previewspacing[2])),
							t[index].previewscale[1], t[index].previewscale[2],
							galleryWindowX1, galleryWindowY1, galleryWindowX2, galleryWindowY2
						)
					else --If the artwork is Locked
						animPosDraw(
							galleryPreviewUnknown,
							galleryPreviewUnknownPosX + i * (galleryPreviewUnknownSizeX + galleryPreviewUnknownSpacingX) - (galleryMoveX * (galleryPreviewUnknownSizeX + galleryPreviewUnknownSpacingX)),
							galleryPreviewUnknownPosY + j * (galleryPreviewUnknownSizeY + galleryPreviewUnknownSpacingY) - (galleryMoveY * (galleryPreviewUnknownSizeY + galleryPreviewUnknownSpacingY))
						)
						animSetWindow(galleryPreviewUnknown, galleryWindowX1, galleryWindowY1, galleryWindowX2, galleryWindowY2)
					end
				end
			end
		end
	end
end

function f_galleryMenu()
	cmdInput()
	local bufu = 0
	local bufd = 0
	local bufr = 0
	local bufl = 0
	local bufz = 0
	local bufy = 0
	galleryCursorX = 0
	galleryCursorY = 0
	galleryMoveX = 0
	galleryMoveY = 0
	f_setGalleryCursorPos()
--Sections Vars
	galleryMenu = 1
	local cursorSectionPosX = 1
	local moveSectionTxt = 0
	local maxSectionItems = 3
	--f_updateGallery()
--
	local slotMax = (galleryColumns + galleryHiddenColumns)*(galleryRows + galleryHiddenRows)
	local artMax = nil
	if slotMax > #t_gallery[galleryMenu] then
		artMax = #t_gallery[galleryMenu] --Set artworks loaded in t_gallery as slotMax amount to prevent issues
	else
		artMax = slotMax
	end
	local textData = nil
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	f_resetGalleryArrowsPos()
	f_unlock(false)
	f_updateUnlocks()
	while true do
	--BACK BUTTON
		if esc() or commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then
			data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
			sndPlay(sndSys, 100, 2)
			break
	--PREVIOUS SECTION
		elseif commandGetState(p1Cmd, 'y') or commandGetState(p2Cmd, 'y') or ((commandGetState(p1Cmd, 'holdy') or commandGetState(p2Cmd, 'holdy')) and bufy >= 30) then
			if galleryMenu > 1 then
				sndPlay(sndSys, 100, 0)
				galleryMenu = galleryMenu - 1
				--f_updateGallery()
			end
	--NEXT SECTION
		elseif commandGetState(p1Cmd, 'z') or commandGetState(p2Cmd, 'z') or ((commandGetState(p1Cmd, 'holdz') or commandGetState(p2Cmd, 'holdz')) and bufz >= 30) then
			if galleryMenu < #t_gallery then
				sndPlay(sndSys, 100, 0)
				galleryMenu = galleryMenu + 1
				--f_updateGallery()
			end
	--SCROLL UP (Cursor Y - Previous Row)
		elseif commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u') or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30) then
			sndPlay(sndSys, 100, 0)
			if galleryCursorY > 0 then
				galleryCursorY = galleryCursorY - 1
			--Hidden Rows Logic
				if galleryMoveY > 0 then
					galleryMoveY = galleryMoveY - 1
				end
			else --Wrap
				galleryCursorY = galleryRows-1 + galleryHiddenRows
				--if galleryHiddenRows > 0 then
					galleryMoveY = galleryHiddenRows
				--end
			end
			f_setGalleryCursorPos() --Set New Cursor Pos
		--Prevent fall out of t_gallery items
			if galleryCursor > artMax then
				while t_gallery[galleryMenu][galleryCursor] == nil do
					galleryCursorY = galleryCursorY - 1
					if galleryMoveY > 0 then
						galleryMoveY = galleryMoveY - 1
					end
					f_setGalleryCursorPos()
				end
			end
	--SCROLL DOWN (Cursor Y - Next Row)
		elseif commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd') or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30) then
			sndPlay(sndSys, 100, 0)
			if galleryCursorY < galleryRows-1 + galleryHiddenRows then
				galleryCursorY = galleryCursorY + 1
			--Hidden Rows Logic
				if galleryCursorY > galleryRows-1 then
					galleryMoveY = galleryMoveY + 1
				end
			else --Wrap
				galleryCursorY = 0
				galleryMoveY = 0
			end
			f_setGalleryCursorPos() --Set New Cursor Pos
		--Prevent fall out of t_gallery items
			if galleryCursor > artMax then
				galleryCursorY = 0
				galleryMoveY = 0
				f_setGalleryCursorPos()
			end
	--SCROLL LEFT (Cursor X - Previous Column)
		elseif commandGetState(p1Cmd, 'l') or commandGetState(p2Cmd, 'l') or ((commandGetState(p1Cmd, 'holdl') or commandGetState(p2Cmd, 'holdl')) and bufl >= 30) then
			sndPlay(sndSys, 100, 0)
			if galleryCursorX > 0 then
				galleryCursorX = galleryCursorX - 1
			--Hidden Columns Logic
				if galleryMoveX > 0 then
					galleryMoveX = galleryMoveX - 1
				end
			else --Wrap
				galleryCursorX = galleryColumns-1 + galleryHiddenColumns
				--if galleryHiddenColumns > 0 then
					galleryMoveX = galleryHiddenColumns
				--end
			end
			f_setGalleryCursorPos() --Set New Cursor Pos
		--Prevent fall out of t_gallery items
			if galleryCursor > artMax then
				while t_gallery[galleryMenu][galleryCursor] == nil do
					galleryCursorX = galleryCursorX - 1
					if galleryMoveX > 0 then
						galleryMoveX = galleryMoveX - 1
					end
					f_setGalleryCursorPos()
				end
			end
	--SCROLL RIGHT (Cursor X - Next Column)
		elseif commandGetState(p1Cmd, 'r') or commandGetState(p2Cmd, 'r') or ((commandGetState(p1Cmd, 'holdr') or commandGetState(p2Cmd, 'holdr')) and bufr >= 30) then
			sndPlay(sndSys, 100, 0)
			if galleryCursorX < galleryColumns-1 + galleryHiddenColumns then
				galleryCursorX = galleryCursorX + 1
			--Hidden Columns Logic
				if galleryCursorX > galleryColumns-1 then
					galleryMoveX = galleryMoveX + 1
				end
			else --Wrap
				galleryCursorX = 0
				galleryMoveX = 0
			end
			f_setGalleryCursorPos() --Set New Cursor Pos
		--Prevent fall out of t_gallery items
			if galleryCursor > artMax then
				galleryCursorX = 0
				galleryMoveX = 0
				f_setGalleryCursorPos()
			end
	--ENTER BUTTON
		elseif commandGetState(p1Cmd, 'w') or commandGetState(p2Cmd, 'w') then
		--ARTWORK (watch pictures)
			if galleryMenu == 1 then
				if t_unlockLua.artworks[galleryCursor] == nil then --If the artwork is unlocked
					sndPlay(sndSys, 100, 1)
					f_artMenu(artMax)
					f_setGalleryCursorPos() --Replace with a logic that calculates the new position of the cursor after having moved in artwork viewer...
				else
					sndPlay(sndSys, 100, 5)
				end
		--STORYBOARDS (watch storyboards)
			elseif galleryMenu == 2 and t_gallery[galleryMenu][galleryCursor].file ~= nil then
				if t_unlockLua.storyboards[galleryCursor] == nil then --If the storyboard is unlocked
					sndPlay(sndSys, 100, 1)
				--Play Storyboard
					cmdInput()
					f_storyboard(t_gallery[galleryMenu][galleryCursor].file) --Start Storyboard
				--When Storyboard Ends:
					data.fadeTitle = f_fadeAnim(50, 'fadein', 'black', sprFade)
					f_menuMusic()
				else
					sndPlay(sndSys, 100, 5)
				end
		--CUTSCENES (watch video cutscenes)
			elseif galleryMenu == 3 and t_gallery[galleryMenu][galleryCursor].file ~= nil then
				if t_unlockLua.videos[galleryCursor] == nil then --If the video is unlocked
					sndPlay(sndSys, 100, 1)
					playVideo(t_gallery[galleryMenu][galleryCursor].file)
				--When Video Ends:
					data.fadeTitle = f_fadeAnim(50, 'fadein', 'black', sprFade)
					f_menuMusic()
				else
					sndPlay(sndSys, 100, 5)
				end
		--SCREENSHOTS (view your screenshots collection)
			--elseif galleryMenu == 4 then
				
			end
		end
	--Section Cursor position calculation
		if galleryMenu < 1 then
			galleryMenu = #t_gallery
			if #t_gallery > maxSectionItems then
				cursorSectionPosX = maxSectionItems
			else
				cursorSectionPosX = #t_gallery
			end
		elseif galleryMenu > #t_gallery then
			galleryMenu = 1
			cursorSectionPosX = 1
		elseif ((commandGetState(p1Cmd, 'y') or commandGetState(p2Cmd, 'y')) or ((commandGetState(p1Cmd, 'holdy') or commandGetState(p2Cmd, 'holdy')) and bufy >= 30)) and cursorSectionPosX > 1 then
			cursorSectionPosX = cursorSectionPosX - 1
		elseif ((commandGetState(p1Cmd, 'z') or commandGetState(p2Cmd, 'z')) or ((commandGetState(p1Cmd, 'holdz') or commandGetState(p2Cmd, 'holdz')) and bufz >= 30)) and cursorSectionPosX < maxSectionItems then
			cursorSectionPosX = cursorSectionPosX + 1
		end
		if cursorSectionPosX == maxSectionItems then
			moveSectionTxt = (galleryMenu - maxSectionItems) * 15
		elseif cursorSectionPosX == 1 then
			moveSectionTxt = (galleryMenu - 1) * 15
		end	
		if #t_gallery <= maxSectionItems then
			maxSection = #t_gallery
		elseif galleryMenu - cursorSectionPosX > 0 then
			maxSection = galleryMenu + maxSectionItems - cursorSectionPosX
		else
			maxSection = maxSectionItems
		end
	--Draw BG
		animDraw(f_animVelocity(commonBG0, -1, -1))
	--Draw Title Menu
		textImgDraw(txt_galleryTitle)
	--Draw Items Text for Gallery Section Table
		for i=1, maxSection do
			if i > galleryMenu - cursorSectionPosX then
				if i == galleryMenu then
					bank = 5
				else
					bank = 0
				end
				if t_gallery[i].displayname ~= nil then
					textImgDraw(f_updateTextImg(t_gallery[i].txtID, jgFnt, bank, 0, t_gallery[i].displayname, -70+i*115-moveSectionTxt, 30))
				end
			end
		end
	--Draw Left Animated Cursor
		if maxSection > maxSectionItems then
			animDraw(menuArrowLeft)
			animUpdate(menuArrowLeft)
		end
	--Draw Right Animated Cursor
		if #t_gallery > maxSectionItems and maxSection < #t_gallery then
			animDraw(menuArrowRight)
			animUpdate(menuArrowRight)
		end
	--Draw Gallery Content
		f_drawGallery(t_gallery[galleryMenu], galleryColumns+galleryHiddenColumns, galleryRows+galleryHiddenRows)
	--Draw Gallery Cursor
		animPosDraw(
			galleryPreviewCursor,
			galleryPreviewCursorPosX + (galleryCursorX-galleryMoveX) * (galleryPreviewCursorSizeX + galleryPreviewCursorSpacingX),
			galleryPreviewCursorPosY + (galleryCursorY-galleryMoveY) * (galleryPreviewCursorSizeY + galleryPreviewCursorSpacingY)
		)
		animSetWindow(galleryPreviewCursor, galleryWindowX1, galleryWindowY1, galleryWindowX2, galleryWindowY2)
	--Draw Gallery Info
		if t_gallery[galleryMenu][galleryCursor].spr[1] and t_gallery[galleryMenu][galleryCursor].spr[2] ~= nil then
			if (galleryMenu == 1 and t_unlockLua.artworks[t_gallery[galleryMenu][galleryCursor].id] == nil) or
				(galleryMenu == 2 and t_unlockLua.storyboards[t_gallery[galleryMenu][galleryCursor].id] == nil) or
				(galleryMenu == 3 and t_unlockLua.videos[t_gallery[galleryMenu][galleryCursor].id] == nil) then
				textData = t_gallery[galleryMenu][galleryCursor].info
			else
				--textData = t_gallery[galleryMenu][galleryCursor].infolock
				textData = txt_galleryUnknown
			end
		else
			textData = txt_noData
		end
		animPosDraw(galleryInfoBG, -56, 185) --Draw Info Text BG
		textImgSetText(txt_galleryInfo, textData)
		textImgDraw(txt_galleryInfo)
	--DEBUG STUFF
	--[[
		f_drawQuickText(txt_debugGalleryCursor, jgFnt, 0, 1, "ITEM: "..galleryCursor, 10, 100+15)
		f_drawQuickText(txt_debugGalleryCursorX, jgFnt, 0, 1, "CURSOR X: "..galleryCursorX, 10, 100+30)
		f_drawQuickText(txt_debugGalleryCursorY, jgFnt, 0, 1, "CURSOR Y: "..galleryCursorY, 10, 100+45)
		f_drawQuickText(txt_debugGalleryMoveX, jgFnt, 0, 1, "MOVE X: "..galleryMoveX, 10, 100+60)
		f_drawQuickText(txt_debugGalleryMoveY, jgFnt, 0, 1, "MOVE Y: "..galleryMoveY, 10, 100+75)
	--]]
	--Draw Input Hints Panel
		drawGalleryInputHints()
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
	--GALLERY MENU BUF KEY CONTROL
		if commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu') then
			bufd = 0
			bufu = bufu + 1
		elseif commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd') then
			bufu = 0
			bufd = bufd + 1
		elseif commandGetState(p1Cmd, 'holdr') or commandGetState(p2Cmd, 'holdr') then
			bufl = 0
			bufr = bufr + 1
		elseif commandGetState(p1Cmd, 'holdl') or commandGetState(p2Cmd, 'holdl') then
			bufr = 0
			bufl = bufl + 1
		else
			bufr = 0
			bufl = 0
			bufu = 0
			bufd = 0
		end
	--GALLERY SECTIONS BUF KEY CONTROL
		if commandGetState(p1Cmd, 'holdz') or commandGetState(p2Cmd, 'holdz') then
			bufy = 0
			bufz = bufz + 1
		elseif commandGetState(p1Cmd, 'holdy') or commandGetState(p2Cmd, 'holdy') then
			bufz = 0
			bufy = bufy + 1
		else
			bufz = 0
			bufy = 0
		end
		cmdInput()
		refresh()
	end
end
--;===========================================================================================
--; ARTWORK VIEWER MENU
--;===========================================================================================
function f_drawArtwork()
local artPic = t_gallery[galleryMenu][galleryCursor].spr[1] ..','.. t_gallery[galleryMenu][galleryCursor].spr[2].. ', 0,0, -1'
artPic = animNew(sprArtworks, artPic)
animSetScale(artPic, artScaleX, artScaleY)
animSetPos(artPic, artPosX, artPosY)
animUpdate(artPic)
animDraw(artPic)
end

function f_resetArtPos()
artPosX = t_gallery[galleryMenu][galleryCursor].pos[1]
artPosY = t_gallery[galleryMenu][galleryCursor].pos[2]
artScaleX = t_gallery[galleryMenu][galleryCursor].scale[1]
artScaleY = t_gallery[galleryMenu][galleryCursor].scale[2]
end

function f_nextArt(limit)
	local limit = limit
	galleryCursor = galleryCursor + 1
	if galleryCursor > limit then --Go to first art
		galleryCursor = 1
	end
end

function f_previousArt(limit)
	local limit = limit
	galleryCursor = galleryCursor - 1
	if galleryCursor < 1 then --Go to last art
		galleryCursor = limit
	end
end

function f_getNewCursorPos() --Get new gallery cursor position when exit from artwork viewer (Unfinished)
	galleryCursorX = (galleryCursor - 1) - galleryColumns*galleryCursorY
	galleryCursorY = (galleryCursor - 1 - galleryCursorX) / galleryColumns
end

function f_artMenu(artLimit)
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	local bufu = 0
	local bufd = 0
	local bufr = 0
	local bufl = 0
	local bufc = 0
	local bufb = 0
	local bufz = 0
	local bufy = 0
	local bufx = 0
	
	artPosX = nil
	artPosY = nil
	artScaleX = nil
	artScaleY = nil
	
	local maxArt = artLimit
	local artZero = ""
	local artLimitZero = ""
	if maxArt < 10 then artLimitZero = "0" end
	local hideMenu = false
	local textData = nil
	f_resetArtPos()
	f_resetArtworkArrowsPos()
	cmdInput()
	while true do
	--RETURN TO GALLERY MENU
		if esc() or commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then
			data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
			sndPlay(sndSys, 100, 2)
			break
	--NEXT ART PAGE
		elseif ((commandGetState(p1Cmd, 'c') or commandGetState(p2Cmd, 'c')) or 
		((commandGetState(p1Cmd, 'holdc') or commandGetState(p2Cmd, 'holdc')) and bufc >= 30)) then
			data.fadeTitle = f_fadeAnim(50, 'fadein', 'black', sprFade)
			sndPlay(sndSys, 100, 3)
			f_nextArt(maxArt)
		--If current item is not unlocked
			while t_unlockLua.artworks[t_gallery[galleryMenu][galleryCursor].id] ~= nil do
				f_nextArt(maxArt) --Go to an unlocked art
			end
			f_resetArtPos()
	--PREVIOUS ART PAGE
		elseif ((commandGetState(p1Cmd, 'b') or commandGetState(p2Cmd, 'b')) or 
		((commandGetState(p1Cmd, 'holdb') or commandGetState(p2Cmd, 'holdb')) and bufb >= 30)) then
			data.fadeTitle = f_fadeAnim(50, 'fadein', 'black', sprFade)
			sndPlay(sndSys, 100, 3)
			f_previousArt(maxArt)
		--If current item is not unlocked
			while t_unlockLua.artworks[t_gallery[galleryMenu][galleryCursor].id] ~= nil do
				f_previousArt(maxArt) --Go to an unlocked art
			end
			f_resetArtPos()
	--RESET ART POSITION
		elseif commandGetState(p1Cmd, 'w') or commandGetState(p2Cmd, 'w') then
			f_resetArtPos()
	--HIDE MENU
		elseif commandGetState(p1Cmd, 's') or commandGetState(p2Cmd, 's') then
			if not hideMenu then hideMenu = true else hideMenu = false end
		end
	--MOVE UP ART
		if ((commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u')) or 
		((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 5)) then
			if artPosY > t_gallery[galleryMenu][galleryCursor].movelimit[2] then
				artPosY = artPosY - galleryArtMoveSpeed
			end
	--MOVE DOWN ART
		elseif ((commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd')) or 
		((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 5)) then
			if artPosY < t_gallery[galleryMenu][galleryCursor].movelimit[4] then
				artPosY = artPosY + galleryArtMoveSpeed
			end
		end
	--MOVE LEFT ART
		if ((commandGetState(p1Cmd, 'l') or commandGetState(p2Cmd, 'l')) or 
		((commandGetState(p1Cmd, 'holdl') or commandGetState(p2Cmd, 'holdl')) and bufl >= 5)) then
			if artPosX > t_gallery[galleryMenu][galleryCursor].movelimit[1] then
				artPosX = artPosX - galleryArtMoveSpeed
			end
	--MOVE RIGHT ART
		elseif ((commandGetState(p1Cmd, 'r') or commandGetState(p2Cmd, 'r')) or 
		((commandGetState(p1Cmd, 'holdr') or commandGetState(p2Cmd, 'holdr')) and bufr >= 5)) then
			if artPosX < t_gallery[galleryMenu][galleryCursor].movelimit[3] then
				artPosX = artPosX + galleryArtMoveSpeed
			end
		end
	--ZOOM IN ART
		if ((commandGetState(p1Cmd, 'z') or commandGetState(p2Cmd, 'z')) or 
		((commandGetState(p1Cmd, 'holdz') or commandGetState(p2Cmd, 'holdz')) and bufz >= 10)) then
			if artScaleX < t_gallery[galleryMenu][galleryCursor].zoomlimit[2] and artScaleY < t_gallery[galleryMenu][galleryCursor].zoomlimit[2] then
				artScaleX = artScaleX + galleryArtZoomSpeed
				artScaleY = artScaleY + galleryArtZoomSpeed
			end
	--ZOOM OUT ART
		elseif ((commandGetState(p1Cmd, 'y') or commandGetState(p2Cmd, 'y')) or 
		((commandGetState(p1Cmd, 'holdy') or commandGetState(p2Cmd, 'holdy')) and bufy >= 10)) then
			if artScaleX > t_gallery[galleryMenu][galleryCursor].zoomlimit[1] and artScaleY > t_gallery[galleryMenu][galleryCursor].zoomlimit[1] then
				artScaleX = artScaleX - galleryArtZoomSpeed
				artScaleY = artScaleY - galleryArtZoomSpeed
			end
		end
	--Draw Artwork (only if has Spr Data defined)
		if t_gallery[galleryMenu][galleryCursor].spr[1] and t_gallery[galleryMenu][galleryCursor].spr[2] ~= nil then
			f_drawArtwork()
			textData = t_gallery[galleryMenu][galleryCursor].info
		else
			textData = txt_noData
		end
	--Draw HUD Assets
		if not hideMenu then
		--Draw Artwork Info
			--animPosDraw(galleryInfoBG, -56, 185) --Draw Info Text BG
			textImgSetText(txt_artInfo, textData)
			textImgDraw(txt_artInfo)
		--Draw Page Info
			if galleryCursor < 10 then artZero = "0" else artZero = "" end
			f_drawQuickText(txt_galleryPageInfo, font14, 0, -1, "PAGE "..artZero..galleryCursor.."/"..artLimitZero..maxArt, 312, 15) --draw pictures page numbers text
			--if galleryCursor > 1 then
				animDraw(menuArrowLeft)
				animUpdate(menuArrowLeft)
			--end
			--if galleryCursor < maxArt then
				animDraw(menuArrowRight)
				animUpdate(menuArrowRight)
			--end
		end
	--DEBUG STUFF
	--[
		f_drawQuickText(txt_debugGalleryZoom, jgFnt, 0, 1, "ZOOM: "..artScaleX, 10, 15)
		f_drawQuickText(txt_debugGalleryArtPosX, jgFnt, 0, 1, "POS X: "..artPosX, 10, 30)
		f_drawQuickText(txt_debugGalleryArtPosY, jgFnt, 0, 1, "POS Y: "..artPosY, 10, 45)
	--]]
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		if not hideMenu then drawArtInputHints() end --Draw Input Hints Panel
	--ART PAGE BUF KEY CONTROL
		if commandGetState(p1Cmd, 'holdc') or commandGetState(p2Cmd, 'holdc') then
			bufb = 0
			bufc = bufc + 1
		elseif commandGetState(p1Cmd, 'holdb') or commandGetState(p2Cmd, 'holdb') then
			bufc = 0
			bufb = bufb + 1
		else
			bufb = 0
			bufc = 0
		end
	--VERTICAL BUF KEY CONTROL
		if commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu') then
			bufd = 0
			bufu = bufu + 1
		elseif commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd') then
			bufu = 0
			bufd = bufd + 1
		else
			bufu = 0
			bufd = 0			
		end
	--LATERAL BUF KEY CONTROL
		if commandGetState(p1Cmd, 'holdr') or commandGetState(p2Cmd, 'holdr') then
			bufl = 0
			bufr = bufr + 1
		elseif commandGetState(p1Cmd, 'holdl') or commandGetState(p2Cmd, 'holdl') then
			bufr = 0
			bufl = bufl + 1
		else
			bufr = 0
			bufl = 0
		end
	--ZOOM BUF KEY CONTROL
		if commandGetState(p1Cmd, 'holdz') or commandGetState(p2Cmd, 'holdz') then
			bufy = 0
			bufz = bufz + 1
		elseif commandGetState(p1Cmd, 'holdy') or commandGetState(p2Cmd, 'holdy') then
			bufz = 0
			bufy = bufy + 1
		else
			bufz = 0
			bufy = 0
		end
		cmdInput()
		refresh()
	end
end

--;===========================================================
--; SOUND TEST MENU (listen music/soundtrack)
--;===========================================================
function f_songMenu()
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	cmdInput()
	f_confirmSongReset()
	local bufu = 0
	local bufd = 0
	local bufr = 0
	local bufl = 0
	local cursorPosY = 1
	local moveTxt = 0
	local maxItems = 12
	songMenu = 1 --Not local because will be used in other menus
	songFolder = 1
	selectedSong = nil
	folderRefer = "" --To use in random select song
	songChanged = false
	f_soundtrack() --Reload from common.lua
	f_resetListArrowsPos()
	f_resetSoundTestArrowsPos()
	while true do
		if backSongConfirm == true then
			data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
			script.options.f_setCfgSong() --SAVE AND BACK SONG FOR OPTIONS MENU
			f_menuMusic()
			sndPlay(sndSys, 100, 2)
			backSongConfirm = false
			soundTest = false
			f_resetFadeBGM()
			f_resetMenuArrowsPos()
			break
		end
		if not confirmSong then
			if esc() or commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then
				if soundTest == true or songChanged == false then --Another damn check just to know in what menu where are and if you select something..
					backSongConfirm = true
				else --IF YOU ARE IN SYSTEM SONGS SETTINGS
					confirmSong = true
				end
			elseif commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u') or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30) then
				sndPlay(sndSys, 100, 0)
				songMenu = songMenu - 1
			elseif commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd') or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30) then
				sndPlay(sndSys, 100, 0)
				songMenu = songMenu + 1
			elseif commandGetState(p1Cmd, 'l') or commandGetState(p2Cmd, 'l') or ((commandGetState(p1Cmd, 'holdl') or commandGetState(p2Cmd, 'holdl')) and bufl >= 30) then
				sndPlay(sndSys, 100, 0)
				songFolder = songFolder - 1
				songMenu = 1 --Restart Cursor Values to prevent nil values issues
				cursorPosY = 1 --Restart Cursor Values to prevent nil values issues
			elseif commandGetState(p1Cmd, 'r') or commandGetState(p2Cmd, 'r') or ((commandGetState(p1Cmd, 'holdr') or commandGetState(p2Cmd, 'holdr')) and bufr >= 30) then
				sndPlay(sndSys, 100, 0)
				songFolder = songFolder + 1
				songMenu = 1 --Restart Cursor Values to prevent nil values issues
				cursorPosY = 1 --Restart Cursor Values to prevent nil values issues
			elseif btnPalNo(p1Cmd) > 0 or btnPalNo(p2Cmd) > 0 then
				if songMenu == #t_songList[songFolder] then --BACK
					if soundTest == true or songChanged == false then --Same esc logic
						backSongConfirm = true
					else
						confirmSong = true
					end
				elseif songMenu == #t_songList[songFolder]-1 then --RANDOM SELECT
					if not soundTest then --If you are setting system songs in options
						sndPlay(sndSys, 100, 1)
						songChanged = true
						selectedSong = t_songList[songFolder][songMenu].path
						selectedSongName = t_songList[songFolder][songMenu].name
						folderRefer = songFolder
						--Back Copy
						if soundTest == true or songChanged == false then --Same esc logic
							backSongConfirm = true
						else
							confirmSong = true
						end
					else --If you are in sound test
						if #t_songList[data.menuSongFolder]-2 ~= 0 then --If there's songs loaded
							--randomSongFolder = math.random(1, #t_songList) --Get random folder song
							--randomSongSel = math.random(1, #t_songList[randomSongFolder]-2)
							randomSongSel = math.random(1, #t_songList[songFolder]-2) --Get random song (-2 excludes back and random select items)
							selectedSong = t_songList[songFolder][randomSongSel].path --Use random song obtained to get his path
							selectedSongName = t_songList[songFolder][randomSongSel].name
							playBGM(selectedSong) --Play Random Song from Folder Selected
						else --If There's no songs loaded
							playBGM(bgmNothing)
						end
					end
				else --Play Selected Song
					if not soundTest then
						sndPlay(sndSys, 100, 1)
						songChanged = true
					end
					selectedSong = t_songList[songFolder][songMenu].path
					selectedSongName = t_songList[songFolder][songMenu].name
					playBGM(selectedSong)
				end
			end
			--Folder Select Logic
			if songFolder < 1 then
				songFolder = #t_songList
			elseif songFolder > #t_songList then
				songFolder = 1
			end
			--Cursor position calculation
			if songMenu < 1 then
				songMenu = #t_songList[songFolder]
				if #t_songList[songFolder] > maxItems then
					cursorPosY = maxItems
				else
					cursorPosY = #t_songList[songFolder]
				end
			elseif songMenu > #t_songList[songFolder] then
				songMenu = 1
				cursorPosY = 1
			elseif ((commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u')) or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30)) and cursorPosY > 1 then
				cursorPosY = cursorPosY - 1
			elseif ((commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd')) or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30)) and cursorPosY < maxItems then
				cursorPosY = cursorPosY + 1
			end
			if cursorPosY == maxItems then
				moveTxt = (songMenu - maxItems) * 15
			elseif cursorPosY == 1 then
				moveTxt = (songMenu - 1) * 15
			end	
			if #t_songList[songFolder] <= maxItems then
				maxSongs = #t_songList[songFolder]
			elseif songMenu - cursorPosY > 0 then
				maxSongs = songMenu + maxItems - cursorPosY
			else
				maxSongs = maxItems
			end
		end
		--Draw Menu BG
		animDraw(f_animVelocity(commonBG0, -1, -1))
		--Draw Transparent Table BG
		animSetScale(commonTBG, 240, maxSongs*15)
		animSetWindow(commonTBG, 80,20, 160,180)
		animDraw(commonTBG)
		--Draw Title Menu
		textImgSetText(txt_song, "[".. t_songList[songFolder].folder:upper().."]")
		textImgDraw(txt_song)
		if not confirmSong then
			--Draw Table Cursor
			animSetWindow(cursorBox, 80,5+cursorPosY*15, 160,15)
			f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
			animDraw(f_animVelocity(cursorBox, -1, -1))
		end
		--Draw Text for Table
		for i=1, maxSongs do
			if t_songList[songFolder][i].name:len() > 28 then --If name is too long, shortcut with ...
				songText = string.sub(t_songList[songFolder][i].name, 1, 24)
				songText = tostring(songText .. "...")
			else
				songText = t_songList[songFolder][i].name
			end
			if i > songMenu - cursorPosY then
				t_songList[songFolder][i].id = createTextImg(font2, 0, 1, songText, 85, 15+i*15-moveTxt)
				textImgDraw(t_songList[songFolder][i].id)
			end
		end
		--Draw Up Animated Cursor
		if maxSongs > maxItems then
			animDraw(menuArrowUp)
			animUpdate(menuArrowUp)
		end
		--Draw Down Animated Cursor
		if #t_songList[songFolder] > maxItems and maxSongs < #t_songList[songFolder] then
			animDraw(menuArrowDown)
			animUpdate(menuArrowDown)
		end
		--Draw Left Animated Cursor
		if songFolder > 1 then
			animDraw(menuArrowLeft)
			animUpdate(menuArrowLeft)
		end
		--Draw Right Animated Cursor
		if songFolder < #t_songList then
			animDraw(menuArrowRight)
			animUpdate(menuArrowRight)
		end
		if confirmSong then f_confirmSongMenu() else drawSoundTestInputHints() end
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		if commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu') then
			bufd = 0
			bufu = bufu + 1
		elseif commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd') then
			bufu = 0
			bufd = bufd + 1
		elseif commandGetState(p1Cmd, 'holdr') or commandGetState(p2Cmd, 'holdr') then
			bufl = 0
			bufr = bufr + 1
		elseif commandGetState(p1Cmd, 'holdl') or commandGetState(p2Cmd, 'holdl') then
			bufr = 0
			bufl = bufl + 1
		else
			bufu = 0
			bufd = 0
			bufr = 0
			bufl = 0
		end
		--if selectedSong == nil then f_fadeOutBGM(1) else f_resetFadeBGM() end
		cmdInput()
		refresh()
	end
end

function f_confirmSongMenu()
	cmdInput()
	--Cursor Position
	if commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u') then
		sndPlay(sndSys, 100, 0)
		confirmSongMenu = confirmSongMenu - 1
	elseif commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd') then
		sndPlay(sndSys, 100, 0)
		confirmSongMenu = confirmSongMenu + 1
	end
	if confirmSongMenu < 1 then
		confirmSongMenu = #t_confirmSongMenu
		if #t_confirmSongMenu > 4 then
			cursorPosYSongConfirm = 4
		else
			cursorPosYSongConfirm = #t_confirmSongMenu-1
		end
	elseif confirmSongMenu > #t_confirmSongMenu then
		confirmSongMenu = 1
		cursorPosYSongConfirm = 0
	elseif commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u') and cursorPosYSongConfirm > 0 then
		cursorPosYSongConfirm = cursorPosYSongConfirm - 1
	elseif commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd') and cursorPosYSongConfirm < 4 then
		cursorPosYSongConfirm = cursorPosYSongConfirm + 1
	end
	if cursorPosYSongConfirm == 4 then
		moveTxtSongConfirm = (confirmSongMenu - 5) * 13
	elseif cursorPosYSongConfirm == 0 then
		moveTxtSongConfirm = (confirmSongMenu - 1) * 13
	end
	--Draw Fade BG
	animDraw(fadeWindowBG)
	--Draw Menu BG
	animDraw(confirmSongWindowBG)
	animUpdate(confirmSongWindowBG)
	--Draw Title
	textImgDraw(txt_confirmSong)
	--Draw Select content
	f_drawQuickText(txt_songSelected, font6, 0, 0, selectedSongName, 160, 120, 0.68, 0.68)
	--Draw Table Text
	for i=1, #t_confirmSongMenu do
		if i == confirmSongMenu then
			bank = 5
		else
			bank = 0
		end
		textImgDraw(f_updateTextImg(t_confirmSongMenu[i].id, jgFnt, bank, 0, t_confirmSongMenu[i].text, 159, 120+i*13-moveTxtSongConfirm))
	end
	--Draw Cursor
	animSetWindow(cursorBox, 87,123+cursorPosYSongConfirm*13, 144,13)
	f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
	animDraw(f_animVelocity(cursorBox, -1, -1))
	--Draw Input Hints Panel
	drawConfirmInputHints()
	--Actions
	if btnPalNo(p1Cmd) > 0 or btnPalNo(p2Cmd) > 0 then
		--YES
		if confirmSongMenu == 1 then
			--sndPlay(sndSys, 100, 1)
		--NO
		else
			selectedSong = nil
		end
		backSongConfirm = true
		f_confirmSongReset()
	end
	cmdInput()
end

function f_confirmSongReset()
	confirmSong = false
	moveTxtSongConfirm = 0
	--Cursor pos in NO
	cursorPosYSongConfirm = 1
	confirmSongMenu = 2
end

--;===========================================================
--; LICENSES MENU (display engine license files)
--;===========================================================
function f_licenseMenu()
	if data.debugMode then f_loadLicenses() end
	if #t_licenseList == 0 then
		licenseInfo = true
		infoScreen = true
		return
	end
	cmdInput()
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	local cursorPosX = 1
	local moveTxt = 0
	local licenseMenu = 1
	local bufu = 0
	local bufd = 0
	local bufr = 0
	local bufl = 0
	local maxItems = 1
	local cursorUpdate = true
	--
	local txtPosX = -50
	local function f_resetYPos() txtPosY = 30 end
	f_resetYPos()
	local txtSpacing = 12
	while true do
		--BACK
		if esc() or commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then
			data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
			sndPlay(sndSys, 100, 2)
			break
		--PREVIOUS PAGE
		elseif commandGetState(p1Cmd, 'l') or commandGetState(p2Cmd, 'l') or ((commandGetState(p1Cmd, 'holdl') or commandGetState(p2Cmd, 'holdl')) and bufl >= 30) then
			sndPlay(sndSys, 100, 0)
			licenseMenu = licenseMenu - 1
			cursorUpdate = true
		--NEXT PAGE
		elseif commandGetState(p1Cmd, 'r') or commandGetState(p2Cmd, 'r') or ((commandGetState(p1Cmd, 'holdr') or commandGetState(p2Cmd, 'holdr')) and bufr >= 30) then
			sndPlay(sndSys, 100, 0)
			licenseMenu = licenseMenu + 1
			cursorUpdate = true
		--MOVE UP TXT
		elseif ((commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u')) or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 5)) and txtPosY < 30 then
			txtPosY = txtPosY + 1
		--MOVE DOWN TXT
		elseif ((commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd')) or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 5)) then
			txtPosY = txtPosY - 1
		end
		if licenseMenu < 1 then
			licenseMenu = #t_licenseList
			if #t_licenseList > maxItems then
				cursorPosX = maxItems
			else
				cursorPosX = #t_licenseList
			end
		elseif licenseMenu > #t_licenseList then
			licenseMenu = 1
			cursorPosX = 1
		elseif ((commandGetState(p1Cmd, 'l') or commandGetState(p2Cmd, 'l')) or ((commandGetState(p1Cmd, 'holdl') or commandGetState(p2Cmd, 'holdl')) and bufl >= 30)) and cursorPosX > 1 then
			cursorPosX = cursorPosX - 1
		elseif ((commandGetState(p1Cmd, 'r') or commandGetState(p2Cmd, 'r')) or ((commandGetState(p1Cmd, 'holdr') or commandGetState(p2Cmd, 'holdr')) and bufr >= 30)) and cursorPosX < maxItems then
			cursorPosX = cursorPosX + 1
		end
		if cursorPosX == maxItems then
			moveTxt = (licenseMenu - maxItems) * 15
		elseif cursorPosX == 1 then
			moveTxt = (licenseMenu - 1) * 15
		end
		if #t_licenseList <= maxItems then
			maxLicenses = #t_licenseList
		elseif licenseMenu - cursorPosX > 0 then
			maxLicenses = licenseMenu + maxItems - cursorPosX
		else
			maxLicenses = maxItems
		end
		if cursorUpdate then
			f_resetYPos()
			--f_readLicense(t_licenseList[licenseMenu].path) --Get Text Data (old method)
			cursorUpdate = false
		end
		animDraw(f_animVelocity(licenseBG, -0.1, -0.1))
	--Draw License Text Content
		for i=1, #t_licenseList[licenseMenu].content do
			textImgSetText(txt_license, t_licenseList[licenseMenu].content[i])
			textImgSetPos(txt_license, txtPosX, txtPosY + txtSpacing * (i - 1))
			textImgDraw(txt_license)
		end
		--f_textRender(txt_license, licenseContent, 0, txtPosX, txtPosY, txtSpacing, 0, -1) --Draw Text from license file (old method)
		animPosDraw(licenseTitleBG, -56, 0) --Draw Title BG
		textImgSetText(txt_licenseTitle, t_licenseList[licenseMenu].name.." LICENSE")
		textImgDraw(txt_licenseTitle) --Draw Menu Title
		drawLicenseInputHints()
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		if commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu') then
			bufd = 0
			bufu = bufu + 1
		elseif commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd') then
			bufu = 0
			bufd = bufd + 1
		else
			bufu = 0
			bufd = 0
		end
		if commandGetState(p1Cmd, 'holdr') or commandGetState(p2Cmd, 'holdr') then
			bufl = 0
			bufr = bufr + 1
		elseif commandGetState(p1Cmd, 'holdl') or commandGetState(p2Cmd, 'holdl') then
			bufr = 0
			bufl = bufl + 1
		else
			bufr = 0
			bufl = 0
		end
		cmdInput()
		refresh()
	end
end

function f_readLicense(path)
licenseFile = io.open(path,"r") --Open .txt file refer in path var in reading mode
licenseContent = licenseFile:read("*all") --Read file content line by line
licenseFile:close() --Close .txt file
end

--;===========================================================
--; REPLAY MENU (watch recorded battles)
--;===========================================================
function f_replayMenu()
	cmdInput()
	local cursorPosY = 0
	local moveTxt = 0
	local replayMenu = 1
	local bufu = 0
	local bufd = 0
	local bufr = 0
	local bufl = 0
	f_infoReset()
	while true do
		if not infoScreen then
			if esc() or commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then
				sndPlay(sndSys, 100, 2)
				break
			elseif commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u') or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30) then
				sndPlay(sndSys, 100, 0)
				replayMenu = replayMenu - 1
			elseif commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd') or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30) then
				sndPlay(sndSys, 100, 0)
				replayMenu = replayMenu + 1
			end
			if replayMenu < 1 then
				replayMenu = #t_replayMenu
				if #t_replayMenu > 5 then
					cursorPosY = 5
				else
					cursorPosY = #t_replayMenu-1
				end
			elseif replayMenu > #t_replayMenu then
				replayMenu = 1
				cursorPosY = 0
			elseif ((commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u')) or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30)) and cursorPosY > 0 then
				cursorPosY = cursorPosY - 1
			elseif ((commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd')) or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30)) and cursorPosY < 5 then
				cursorPosY = cursorPosY + 1
			end
			if cursorPosY == 5 then
				moveTxt = (replayMenu - 6) * 13
			elseif cursorPosY == 0 then
				moveTxt = (replayMenu - 1) * 13
			end
			if #t_replayMenu <= 5 then
				maxreplayMenu = #t_replayMenu
			elseif replayMenu - cursorPosY > 0 then
				maxreplayMenu = replayMenu + 5 - cursorPosY
			else
				maxreplayMenu = 5
			end
			if btnPalNo(p1Cmd) > 0 or btnPalNo(p2Cmd) > 0 then
				sndPlay(sndSys, 100, 1)
				--ONLINE REPLAYS (watch saved replays of your online matches)
				if replayMenu == 1 then
					--if (resolutionHeight / 3 * 4) ~= resolutionWidth then --To watch an online replay you need to set a 4:3 Resolution to avoid desync
					--if (resolutionHeight / 10 * 16) ~= resolutionWidth then --To watch an online replay you need to set a 16:10 Resolution to avoid desync
					if (math.floor((resolutionHeight / 9 * 16) + 0.5)) ~= resolutionWidth then --To watch an online replay you need to set a 16:9 Resolution to avoid desync
						resolutionInfo = true
						infoScreen = true
					else
						data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
						f_mainReplay()
					end
				--LOCAL REPLAYS (watch saved replays of your local matches)
				elseif replayMenu == 2 then
					f_comingSoon()
				end
			end
		end
		drawBottomMenuSP()
		for i=1, #t_replayMenu do
			if i == replayMenu then
				bank = 2
			else
				bank = 0
			end
			textImgDraw(f_updateTextImg(t_replayMenu[i].id, jgFnt, bank, 0, t_replayMenu[i].text, 159, 122+i*13-moveTxt))
		end
		if not infoScreen then
			animSetWindow(cursorBox, 0,125+cursorPosY*13, 316,13)
			f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
			animDraw(f_animVelocity(cursorBox, -1, -1))
		end
		drawMiddleMenuSP()
		textImgDraw(txt_gameFt)
		textImgSetText(txt_gameFt, "REPLAY MODES")
		textImgDraw(txt_version)
		f_sysTime()
		if maxreplayMenu > 6 then
			animDraw(menuArrowUp)
			animUpdate(menuArrowUp)
		end
		if #t_replayMenu > 6 and maxreplayMenu < #t_replayMenu then
			animDraw(menuArrowDown)
			animUpdate(menuArrowDown)
		end
		if infoScreen then f_infoMenu() else drawMenuInputHints() end
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		if commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu') then
			bufd = 0
			bufu = bufu + 1
		elseif commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd') then
			bufu = 0
			bufd = bufd + 1
		else
			bufu = 0
			bufd = 0
		end
		cmdInput()
		refresh()
	end
end

--;===========================================================
--; ONLINE REPLAYS MENU
--;===========================================================
function f_mainReplay()
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	cmdInput()
	local cursorPosY = 1
	local moveTxt = 0
	local mainReplay = 1
	local bufu = 0
	local bufd = 0
	local bufr = 0
	local bufl = 0
	local exitReplayMenu = false
	local maxItems = 12
	netPlayer = "Host"
	coinSystem = false
	f_replayTable() --Load table
	f_resetListArrowsPos()
	while true do
		if exitReplayMenu then
			onlinegame = false --only for identify purposes
			replaygame = false
			coinSystem = true
			--netPlayer = "" Bloquea el acceso al menu de online en offline dejarlo comentado solo para devs
			assert(loadfile(saveCfgPath))()
			data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
			sndPlay(sndSys, 100, 2)
			f_resetMenuArrowsPos()
			break
		end
		if esc() or commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then exitReplayMenu = true
		elseif commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u') or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30) then
			sndPlay(sndSys, 100, 0)
			mainReplay = mainReplay - 1
		elseif commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd') or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30) then
			sndPlay(sndSys, 100, 0)
			mainReplay = mainReplay + 1
		elseif btnPalNo(p1Cmd) > 0 or btnPalNo(p2Cmd) > 0 then
		--BACK
			if mainReplay == #t_replayList then exitReplayMenu = true
		--OPEN REPLAY CONTROL MENU
			else
				sndPlay(sndSys, 100, 1)
				textImgSetText(txt_replayName, t_replayList[mainReplay].name)--Show Replay Selected Name
				local fileSize = lfs.attributes(t_replayList[mainReplay].path).size --Size Logic
				if fileSize > 1048576 then
					local replaySize = (math.floor(((fileSize/1048576)+0.50)))--Conversion from Bytes to Megabytes
					textImgSetText(txt_replaySize, replaySize.."MB")
				else
					local replaySize = (math.floor(((fileSize/1024)+0.50)))--Conversion from Bytes to Kilobytes
					textImgSetText(txt_replaySize, replaySize.."KB")
				end
				local replayOption = 2
				f_confirmReset()
				cmdInput()
				while true do
					if not confirmScreen then
						if esc() or commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then
							sndPlay(sndSys, 100, 2)
							break
						elseif commandGetState(p1Cmd, 'r') or commandGetState(p2Cmd, 'r') then
							sndPlay(sndSys, 100, 0)
							replayOption = replayOption + 1
						elseif commandGetState(p1Cmd, 'l') or commandGetState(p2Cmd, 'l') then
							sndPlay(sndSys, 100, 0)
							replayOption = replayOption - 1
						end
						if replayOption < 1 then replayOption = 3 elseif replayOption > 3 then replayOption = 1 end
					end
					if btnPalNo(p1Cmd) > 0 or btnPalNo(p2Cmd) > 0 then
					--OPEN CONFIRM DELETE REPLAY WINDOW
						if replayOption == 1 then
							sndPlay(sndSys, 100, 1)
							confirmScreen = true
					--WATCH SELECTED REPLAY
						elseif replayOption == 2 then
							onlinegame = true --only for identify purposes
							replaygame = true
							data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
							sndPlay(sndSys, 100, 1)
							--Set Default values to prevent desync.
							script.options.f_onlineDefault()
							script.options.f_netsaveCfg()
							enterReplay(t_replayList[mainReplay].path)
							synchronize()
							math.randomseed(sszRandom())
							script.options.f_onlineCfg()
							exitNetPlay()
							exitReplay()
							commandBufReset(p1Cmd, 1)
							commandBufReset(p2Cmd, 1)
					--RETURN TO REPLAY SELECT MENU
						elseif replayOption == 3 then
							sndPlay(sndSys, 100, 2)
							break
						end
					end
					animDraw(f_animVelocity(commonBG0, -1, -1))
				--Draw Replay Title
					animSetScale(replayMenuBG, 324, 74)
					animSetWindow(replayMenuBG, 0,5, 324,27)
					animDraw(replayMenuBG)
					textImgDraw(txt_replayName)
					textImgDraw(txt_replaySize)
					textImgDraw(txt_replayData)
				--Draw Mini Menu BG
					animDraw(replayMenuBG2)
					animUpdate(replayMenuBG2)
				--Draw Replay Option Text
					for i=1, #t_replayOption do
						if i == replayOption + 0 then -- +0 To start center
							textImgSetBank(t_replayOption[i].id, 5)
						else
							textImgSetBank(t_replayOption[i].id, 0)
						end
						textImgDraw(t_replayOption[i].id)
					end
					if not confirmScreen then
						--Draw Cursor
						animSetWindow(cursorBox, -108+replayOption*120,161, 56,15)
						f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
						animDraw(f_animVelocity(cursorBox, -1, -1))
					end
					if confirmScreen then f_confirmMenu() else drawReplayInputHints() end
					--DELETE SELECTED REPLAY
					if deleteReplay then
						os.remove(t_replayList[mainReplay].path)
						t_replayList = nil --Delete the Table
						f_replayTable() --Just reload the table with applied changes
						deleteReplay = false
						break
					end
					animDraw(data.fadeTitle)
					animUpdate(data.fadeTitle)
					cmdInput()
					refresh()
				end
			end
		end
		if mainReplay < 1 then
			mainReplay = #t_replayList
			if #t_replayList > maxItems then
				cursorPosY = maxItems
			else
				cursorPosY = #t_replayList
			end
		elseif mainReplay > #t_replayList then
			mainReplay = 1
			cursorPosY = 1
		elseif ((commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u')) or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30)) and cursorPosY > 1 then
			cursorPosY = cursorPosY - 1
		elseif ((commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd')) or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30)) and cursorPosY < maxItems then
			cursorPosY = cursorPosY + 1
		end
		if cursorPosY == maxItems then
			moveTxt = (mainReplay - maxItems) * 15
		elseif cursorPosY == 1 then
			moveTxt = (mainReplay - 1) * 15
		end
		if #t_replayList <= maxItems then
			maxReplays = #t_replayList
		elseif mainReplay - cursorPosY > 0 then
			maxReplays = mainReplay + maxItems - cursorPosY
		else
			maxReplays = maxItems
		end
		animDraw(f_animVelocity(commonBG0, -1, -1))
		animSetScale(commonTBG, 240, maxReplays*15)
		animSetWindow(commonTBG, 80,20, 160,180)
		animDraw(commonTBG)
		textImgDraw(txt_replay)
		--animSetScale(cursorBox, 160,maxReplays*15) --For Optimized Cursor Box
		animSetWindow(cursorBox, 80,5+cursorPosY*15, 160,15)
		f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
		animDraw(f_animVelocity(cursorBox, -1, -1))
		for i=1, maxReplays do
			if t_replayList[i].name:len() > 28 then
				replayText = string.sub(t_replayList[i].name, 1, 24)
				replayText = tostring(replayText .. "...")
			else
				replayText = t_replayList[i].name
			end
			if i > mainReplay - cursorPosY then
				t_replayList[i].id = createTextImg(font2, 0, 1, replayText, 85, 15+i*15-moveTxt)
				textImgDraw(t_replayList[i].id)
			end
		end
		if maxReplays > maxItems then
			animDraw(menuArrowUp)
			animUpdate(menuArrowUp)
		end
		if #t_replayList > maxItems and maxReplays < #t_replayList then
			animDraw(menuArrowDown)
			animUpdate(menuArrowDown)
		end
		drawListInputHints()
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		if commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu') then
			bufd = 0
			bufu = bufu + 1
		elseif commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd') then
			bufu = 0
			bufd = bufd + 1
		else
			bufu = 0
			bufd = 0
		end
		cmdInput()
		refresh()
	end
end

function f_replayTable()
	t_replayList = {}
	for file in lfs.dir(replaysPath) do
		if file:match('^.*(%.)[Rr][Ee][Pp][Ll][Aa][Yy]$') and not file:match('^data.replay$') then
			row = #t_replayList+1
			t_replayList[row] = {}
			t_replayList[row]['id'] = ''
			t_replayList[row]['name'] = file:gsub('^(.*)[%.][Rr][Ee][Pp][Ll][Aa][Yy]$', '%1')
			t_replayList[row]['path'] = replaysPath.."/"..file
		end
	end
	t_replayList[#t_replayList+1] = {id = '', name = "          BACK"}
	if data.debugLog then f_printTable(t_replayList, "save/debug/t_replayList.txt") end
end

--;===========================================================
--; ONLINE MENU (play online)
--;===========================================================
function checkNetplayAccess()
	--if (resolutionHeight / 3 * 4) ~= resolutionWidth then --To play online you need to set a 4:3 Resolution to avoid desync
	--if (resolutionHeight / 10 * 16) ~= resolutionWidth then --To play online you need to set a 16:10 Resolution to avoid desync
	if (math.floor((resolutionHeight / 9 * 16) + 0.5)) ~= resolutionWidth then --To play online you need to set a 16:9 Resolution to avoid desync
		resolutionInfo = true
		infoScreen = true
	else
		f_mainNetplay()
	end
end

function f_mainNetplay()
	--if (resolutionHeight / 3 * 4) ~= resolutionWidth then --To play online you need to set a 4:3 Resolution to avoid desync
	--if (resolutionHeight / 10 * 16) ~= resolutionWidth then --To play online you need to set a 16:10 Resolution to avoid desync
	if (math.floor((resolutionHeight / 9 * 16) + 0.5)) ~= resolutionWidth then --To play online you need to set a 16:9 Resolution to avoid desync
		resolutionInfo = true
		infoScreen = true
		return
	end
	cmdInput()
	local cursorPosY = 0
	local moveTxt = 0
	local mainNetplay = 1
	local bufu = 0
	local bufd = 0
	local bufr = 0
	local bufl = 0
	local cancel = false
	while true do
		if esc() or commandGetState(p1Cmd, 'e') then
			onlinegame = false --only for identify purposes
			assert(loadfile(saveCfgPath))()
			sndPlay(sndSys, 100, 2)
			f_resetMenuInputs()
			return
		end
		if commandGetState(p1Cmd, 'u') or (commandGetState(p1Cmd, 'holdu') and bufu >= 30) then
			sndPlay(sndSys, 100, 0)
			mainNetplay = mainNetplay - 1
		elseif commandGetState(p1Cmd, 'd') or (commandGetState(p1Cmd, 'holdd') and bufd >= 30) then
			sndPlay(sndSys, 100, 0)
			mainNetplay = mainNetplay + 1
		end
		if mainNetplay < 1 then
			mainNetplay = #t_mainNetplay
			if #t_mainNetplay > 5 then
				cursorPosY = 5
			else
				cursorPosY = #t_mainNetplay-1
			end
		elseif mainNetplay > #t_mainNetplay then
			mainNetplay = 1
			cursorPosY = 0
		elseif (commandGetState(p1Cmd, 'u') or (commandGetState(p1Cmd, 'holdu') and bufu >= 30)) and cursorPosY > 0 then
			cursorPosY = cursorPosY - 1
		elseif (commandGetState(p1Cmd, 'd') or (commandGetState(p1Cmd, 'holdd') and bufd >= 30)) and cursorPosY < 5 then
			cursorPosY = cursorPosY + 1
		end
		if cursorPosY == 5 then
			moveTxt = (mainNetplay - 6) * 13
		elseif cursorPosY == 0 then
			moveTxt = (mainNetplay - 1) * 13
		end
		if #t_mainNetplay <= 5 then
			maxMainNetplay = #t_mainNetplay
		elseif mainNetplay - cursorPosY > 0 then
			maxMainNetplay = mainNetplay + 5 - cursorPosY
		else
			maxMainNetplay = 5
		end
		if btnPalNo(p1Cmd) > 0 then
			f_default()
			sndPlay(sndSys, 100, 1)
			--HOST (create online room)
			if mainNetplay == 1 then
				onlinegame = true --only for identify purposes
				script.options.f_onlineDefault()
				script.options.f_netsaveCfg()
				data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
				cancel = f_create()
				if not cancel then
					synchronize()
					math.randomseed(sszRandom())
					script.options.f_onlineCfg()
				end
				exitNetPlay()
				exitReplay()
				commandBufReset(p1Cmd, 1)
				f_saveReplay()
			--CLIENT/JOIN (join an existing room)
			elseif mainNetplay == 2 then
				--Default Connection Method
				if data.connectMode == "Direct" then
					onlinegame = true
					script.options.f_onlineDefault()
					script.options.f_netsaveCfg()
					data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
					cancel = f_directConnect()
					if not cancel then
						synchronize()
						math.randomseed(sszRandom())
						script.options.f_onlineCfg()
					end
					exitNetPlay()
					exitReplay()
					commandBufReset(p1Cmd, 1)
					f_saveReplay()
				--Host info Stored in a Local Database
				elseif data.connectMode == "Database" then
					f_hostRooms()
				end
			end	
		end
		drawBottomMenuSP()
		for i=1, #t_mainNetplay do
			if i == mainNetplay then
				bank = 3
			else
				bank = 0
			end
			textImgDraw(f_updateTextImg(t_mainNetplay[i].id, jgFnt, bank, 0, t_mainNetplay[i].text, 159, 122+i*13-moveTxt))
		end
		animSetWindow(cursorBox, 0,125+cursorPosY*13, 316,13)
		f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
		animDraw(f_animVelocity(cursorBox, -1, -1))
		drawMiddleMenuSP()
		textImgDraw(txt_gameFt)
		textImgSetText(txt_gameFt, "ONLINE MODE")
		textImgDraw(txt_version)
		f_sysTime()
		if maxMainNetplay > 6 then
			animDraw(menuArrowUp)
			animUpdate(menuArrowUp)
		end
		if #t_mainNetplay > 6 and maxMainNetplay < #t_mainNetplay then
			animDraw(menuArrowDown)
			animUpdate(menuArrowDown)
		end
		drawMenuInputHints()
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		if commandGetState(p1Cmd, 'holdu') then
			bufd = 0
			bufu = bufu + 1
		elseif commandGetState(p1Cmd, 'holdd') then
			bufu = 0
			bufd = bufd + 1
		else
			bufu = 0
			bufd = 0
		end
		exitNetPlay()
    	exitReplay()
		cmdInput()
		refresh()
	end
end

--;===========================================================
--; SAVE ONLINE REPLAY
--;===========================================================
function f_saveReplay()
--Create Replay File
	local netplayFile = io.open("save/data.replay","rb") --Read origin file
	if netplayFile ~= nil then
		if not createExit or not joinExit then
			if lfs.attributes("save/data.replay", "size") > 0 then --Save replay if have content
				ltn12.pump.all(
				ltn12.source.file(assert(io.open("save/data.replay", "rb"))), --Use this file to make a copy
				ltn12.sink.file(assert(io.open("replays/" .. os.date("%Y-%m-%d %I-%M%p") .. ".replay", "wb"))) --Save replay with a new name
				)
			end
			netplayFile:close()
			netplayFile = nil
		end
	end
end

--;===========================================================
--; HOST MENU
--;===========================================================
function f_create()
	cmdInput()
	createExit = false
	textImgSetText(txt_hosting, "Waiting for Player 2...")
	enterNetPlay(inputDialogGetStr(inputdia))
	netPlayer = "Host" --For Replay Identify
	--if waitingRoom == "Training" then
		--data.p1In = 1
		--f_training() --Try to Wait client in Training Mode
	--end
	while not connected() do
		if esc() or commandGetState(p1Cmd, 'e') then --btnPalNo(p1Cmd) > 0 does not work when engine is waiting a connection, only esc, that's why still we can't program an Training Waiting Room
		    data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
			sndPlay(sndSys, 100, 2)
			netPlayer = ""
			return true
		end
		--Draw BG
		animDraw(f_animVelocity(commonBG0, -1, -1))
		--Draw Menu Title
		textImgDraw(txt_hostTitle)
		--Draw Window BG
		animDraw(joinWindowBG)
		animUpdate(joinWindowBG)
		--Draw Port Info
		textImgSetText(txt_netPort, "Netplay Port ["..getListenPort().."]")
		textImgDraw(txt_netPort)
		--Draw Cancel Button
		textImgDraw(txt_cancel)
		--Draw Cursor
		animSetWindow(cursorBox, 87,155, 144,13)
		f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
		animDraw(f_animVelocity(cursorBox, -1, -1))
		--Draw Hosting Info
		textImgDraw(txt_hosting)
		--Draw Animated Icon
		animDraw(wirelessBG)
		animUpdate(wirelessBG)
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		cmdInput()
		refresh()
	end
	return false
end

--;===========================================================
--; DIRECT CONNECTION MENU
--;===========================================================
function f_directConnect()
	textImgSetText(txt_clientTitle, "SEARCH ROOM")
	local ip = ""
	local doneIP = false
	local directJoinMenu = 2
	local i = 0
	joinExit = false
	cmdInput()
	--ENTER IP SCREEN
	while true do
		--EXIT LOGIC
		if joinExit == true then
			clearInputText()
			netPlayer = ""
			sndPlay(sndSys, 100, 2)
			data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
			return true
		end
		--MAIN SCREEN
		if not doneIP then
			if esc() then
				joinExit = true
			elseif commandGetState(p1Cmd, 'r') then
				sndPlay(sndSys, 100, 0)
				directJoinMenu = directJoinMenu + 1
			elseif commandGetState(p1Cmd, 'l') then
				sndPlay(sndSys, 100, 0)
				directJoinMenu = directJoinMenu - 1
			end
			if directJoinMenu < 1 then directJoinMenu = 2 elseif directJoinMenu > 2 then directJoinMenu = 1 end
			ip = inputText('num',true)
			if clipboardPaste() then
				if string.match(getClipboardText(),'^%d%d?%d?%.%d%d?%d?%.%d%d?%d?%.%d%d?%d?$') then
					setInputText(getClipboardText())
				elseif string.match(getClipboardText(),'^localhost$') then
					setInputText(getClipboardText())
				else
					sndPlay(sndSys, 100, 5)
				end
			end
			if ip:match('^%.') then
				ip = ""
				setInputText(ip)
			elseif ip:len() > 15 then
				ip = ip:sub(1,15)
				setInputText(ip)
			elseif ip:match('%.%.+') then
				ip = ip:gsub('%.%.+','.')
				setInputText(ip)
			elseif ip:match('%d%d%d%d+') then
				ip = ip:gsub('(%d%d%d)%d+','%1')
				setInputText(ip)
			elseif ip:match('%d+%.%d+%.%d+%.%d+%.') then
				ip = ip:gsub('(%d+%.%d+%.%d+%.%d+)%.','%1')
				setInputText(ip)
			end
			--BUTTON SELECT
			if btnPalNo(p1Cmd) > 0 then
				--BACK
				if directJoinMenu == 1 then
					joinExit = true
				--JOIN
				elseif directJoinMenu == 2 then
					if ip:match('^%d%d?%d?%.%d%d?%d?%.%d%d?%d?%.%d%d?%d?$') then
						doneIP = true
					elseif ip:match('^localhost$') then
						doneIP = true
					else
						sndPlay(sndSys, 100, 5)
					end
				end
			end
			--Draw BG
			animDraw(f_animVelocity(commonBG0, -1, -1))
			--Draw Menu Title
			textImgDraw(txt_clientTitle)
			--Draw IP Window BG
			animDraw(textWindowBG)
			animUpdate(textWindowBG)
			--Draw IP Window Title
			textImgDraw(txt_client)
			--Draw IP Text
			textImgSetText(txt_ip,ip)
			textImgDraw(txt_ip)
			if i%60 < 30 then
				textImgPosDraw(txt_bar, 160+(textImgGetWidth(txt_ip)*0.5)+(textImgGetWidth(txt_ip)>0 and 2 or 0), 134)
			end
			--Draw Button Option Text
			for i=1, #t_directJoinMenu do
				if i == directJoinMenu then
					textImgSetBank(t_directJoinMenu[i].id, 5)
				else
					textImgSetBank(t_directJoinMenu[i].id, 0)
				end
				textImgDraw(t_directJoinMenu[i].id)
			end
			--Draw Cursor
			animSetWindow(cursorBox, -9+directJoinMenu*96,141, 48.5,13)
			f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
			animDraw(f_animVelocity(cursorBox, -1, -1))
		end
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		i = i >= 60 and 0 or i + 1
		if doneIP then break end --Exit for this bucle to start connecting
		cmdInput()
		refresh()
	end
	--CONNECTING SCREEN
	sndPlay(sndSys, 100, 1)
	enterNetPlay(ip) --Connect to entered IP address
	netPlayer = "Client"
	textImgSetText(txt_connecting, "Now connecting to ["..ip.."]")
	while not connected() do
		--CANCEL CONNECTION
		if esc() or commandGetState(p1Cmd, 'e') then
			clearInputText()
			data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
			sndPlay(sndSys, 100, 2)
			netPlayer = ""
			joinExit = true
			return true
		end
		--Draw Connecting BG
		animDraw(f_animVelocity(commonBG0, -1, -1))
		--Draw Connecting Menu Title
		textImgSetText(txt_clientTitle, "SEARCHING HOST ROOM")
		textImgDraw(txt_clientTitle)
		--Draw Window BG
		animDraw(joinWindowBG)
		animUpdate(joinWindowBG)
		--Draw Port Info
		textImgSetText(txt_netPort, "Netplay Port ["..getListenPort().."]")
		textImgDraw(txt_netPort)
		--Draw Connecting Info
		textImgDraw(txt_connecting)
		--Draw Cancel Button
		textImgDraw(txt_cancel)
		--Draw Cursor
		animSetWindow(cursorBox, 87,155, 144,13)
		f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
		animDraw(f_animVelocity(cursorBox, -1, -1))
		--Draw Animated Icon
		animDraw(wirelessBG)
		animUpdate(wirelessBG)
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		cmdInput()
		refresh()
	end
	clearInputText()
	return false
end

--;===========================================================
--; HOST ROOMS MENU
--;===========================================================
function f_hostTable()
	local file = io.open(saveHostRoomPath,"r")
	host_rooms = json.decode(file:read("*all"))
	file:close()
	t_hostList = {{id = textImgNew(), text = "ADD NEW ROOM"},}
	for k, v in pairs(host_rooms.IP) do
		t_hostList[#t_hostList + 1] = {id = textImgNew(), text = k, address = v} --Insert Room Names from Local Database
	end
	t_hostList[#t_hostList+1] = {id = textImgNew(), text = "BACK"}
end

function f_hostRooms()
	cmdInput()
	local cursorPosY = 0
	local moveTxt = 0
	local hostList = 1
	local bufu = 0
	local bufd = 0
	local bufr = 0
	local bufl = 0
	local t_tmp = {}
	f_hostTable()
	f_editHostReset()
	f_crudHostReset()
	--local cancel = false
	while true do
		if editHostScreen == false and crudHostScreen == false then
			if esc() or commandGetState(p1Cmd, 'e') then
				--onlinegame = false
				--assert(loadfile(saveCfgPath))()
				sndPlay(sndSys, 100, 2)
				break
				--return
			end
			if commandGetState(p1Cmd, 'u') or (commandGetState(p1Cmd, 'holdu') and bufu >= 30) then
				sndPlay(sndSys, 100, 0)
				hostList = hostList - 1
			elseif commandGetState(p1Cmd, 'd') or (commandGetState(p1Cmd, 'holdd') and bufd >= 30) then
				sndPlay(sndSys, 100, 0)
				hostList = hostList + 1
			end
			if hostList < 1 then
				hostList = #t_hostList
				if #t_hostList > 5 then
					cursorPosY = 5
				else
					cursorPosY = #t_hostList-1
				end
			elseif hostList > #t_hostList then
				hostList = 1
				cursorPosY = 0
			elseif (commandGetState(p1Cmd, 'u') or (commandGetState(p1Cmd, 'holdu') and bufu >= 30)) and cursorPosY > 0 then
				cursorPosY = cursorPosY - 1
			elseif (commandGetState(p1Cmd, 'd') or (commandGetState(p1Cmd, 'holdd') and bufd >= 30)) and cursorPosY < 5 then
				cursorPosY = cursorPosY + 1
			end
			if cursorPosY == 5 then
				moveTxt = (hostList - 6) * 13
			elseif cursorPosY == 0 then
				moveTxt = (hostList - 1) * 13
			end
			if #t_hostList <= 5 then
				maxhostList = #t_hostList
			elseif hostList - cursorPosY > 0 then
				maxhostList = hostList + 5 - cursorPosY
			else
				maxhostList = 5
			end
			if btnPalNo(p1Cmd) > 0 then
				f_default()
				--ADD NEW HOST ADDRESS
				if hostList == 1 then
					sndPlay(sndSys, 100, 1)
					editHostScreen = true
				--BACK
				elseif hostList == #t_hostList then
					sndPlay(sndSys, 100, 2)
					--onlinegame = false
					--assert(loadfile(saveCfgPath))()
					break
				--OPEN CRUD MENU
				else
					sndPlay(sndSys, 100, 1)
					crudHostScreen = true
				end
			end
		end
		drawBottomMenuSP()
		for i=1, #t_hostList do
			if i == hostList then
				bank = 5
			else
				bank = 0
			end
			textImgDraw(f_updateTextImg(t_hostList[i].id, jgFnt, bank, 0, t_hostList[i].text, 159, 122+i*13-moveTxt))
		end
		if editHostScreen == false and crudHostScreen == false then
			animSetWindow(cursorBox, 0,125+cursorPosY*13, 316,13)
			f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
			animDraw(f_animVelocity(cursorBox, -1, -1))
		end
		drawMiddleMenuSP()
		if editHostScreen == false then
			textImgDraw(txt_gameFt)
			textImgSetText(txt_gameFt, "HOST ROOMS")
			textImgDraw(txt_version)
		end
		f_sysTime()
		if crudHostScreen == false then
			if maxhostList > 6 then
				animDraw(menuArrowUp)
				animUpdate(menuArrowUp)
			end
			if #t_hostList > 6 and maxhostList < #t_hostList then
				animDraw(menuArrowDown)
				animUpdate(menuArrowDown)
			end
		end
		if not crudHostScreen and not editHostScreen then drawMenuInputHints() end --Draw Input Hints Panel for Host Rooms
		textBar = textBar >= 60 and 0 or textBar + 1
	--CRUD ACTIONS
		hostRoomName = (t_hostList[hostList].text) --Host Name Selected
		hostIP = (t_hostList[hostList].address) --Host IP Address Selected
		if crudHostScreen == true then f_crudHostScreen() end
		if editHostScreen == true then f_editHost() end
	--READ DATA
		if crudHostOption == 2 then
			f_crudHostReset()
			onlinegame = true
			script.options.f_onlineDefault()
			script.options.f_netsaveCfg()
			data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
			cancel = f_databaseConnect()
			if not cancel then
				synchronize()
				math.randomseed(sszRandom())
				script.options.f_onlineCfg()
			end
			exitNetPlay()
			exitReplay()
			commandBufReset(p1Cmd, 1)
			f_saveReplay()
	--UPDATE DATA
		elseif crudHostOption == 3 then
			f_crudHostReset()
			editHostRoom = true --To Update Data
			editHostScreen = true
	--DELETE DATA
		elseif crudHostOption == 1 then
			f_confirmMenu()
		end
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		if commandGetState(p1Cmd, 'holdu') then
			bufd = 0
			bufu = bufu + 1
		elseif commandGetState(p1Cmd, 'holdd') then
			bufu = 0
			bufd = bufd + 1
		else
			bufu = 0
			bufd = 0
		end
		--exitNetPlay()
    	--exitReplay()
		cmdInput()
		refresh()
	end
end

--;===========================================================
--; CRUD MENU
--;===========================================================
function f_crudHostScreen()
	if crudHostOption ~= 1 then
		cmdInput()
		--Cursor Logic
		if commandGetState(p1Cmd, 'u') then
			sndPlay(sndSys, 100, 0)
			crudHostRow = crudHostRow - 1
			crudHostCursorU = crudHostCursorD
		elseif commandGetState(p1Cmd, 'd') then
			sndPlay(sndSys, 100, 0)
			crudHostRow = crudHostRow + 1
			crudHostCursorD = crudHostCursorU
		end
		if crudHostRow < 1 then
			crudHostRow = 2
		elseif crudHostRow > 2 then
			crudHostRow = 1
		end
		if crudHostRow == 1 then
			if commandGetState(p1Cmd, 'l') then
				sndPlay(sndSys, 100, 0)
				crudHostCursorU = crudHostCursorU - 1
				crudHostCursorD = crudHostCursorD - 1
			elseif commandGetState(p1Cmd, 'r') then
				sndPlay(sndSys, 100, 0)
				crudHostCursorU = crudHostCursorU + 1
				crudHostCursorD = crudHostCursorD + 1
			end
		elseif crudHostRow == 2 then
			if commandGetState(p1Cmd, 'l') then
				sndPlay(sndSys, 100, 0)
				crudHostCursorD = crudHostCursorD - 1
				crudHostCursorU = crudHostCursorU - 1
			elseif commandGetState(p1Cmd, 'r') then
				sndPlay(sndSys, 100, 0)
				crudHostCursorD = crudHostCursorD + 1
				crudHostCursorU = crudHostCursorU + 1
			end
		end
		if crudHostCursorU < 1 then
			crudHostCursorU = #t_crudHostOptionU
		elseif crudHostCursorU > #t_crudHostOptionU then
			crudHostCursorU = 1
		end
		if crudHostCursorD < 1 then
			crudHostCursorD = #t_crudHostOptionD
		elseif crudHostCursorD > #t_crudHostOptionD then
			crudHostCursorD = 1
		end
		--ACTIONS
		if esc() or commandGetState(p1Cmd, 'e') then
			sndPlay(sndSys, 100, 2)
			f_crudHostReset()
		--BUTTON SELECTED
		elseif btnPalNo(p1Cmd) > 0 then
			--DELETE HOST ADDRESS
			if crudHostCursorU == 1 and crudHostRow == 1 then
				sndPlay(sndSys, 100, 1)
				f_confirmReset()
				crudHostOption = 1
			--JOIN TO HOST ADDRESS
			elseif crudHostCursorU == 2 and crudHostRow == 1 then
				sndPlay(sndSys, 100, 1)
				crudHostOption = 2
				crudHostScreen = false
			--EDIT HOST ADDRESS
			elseif crudHostCursorD == 1 and crudHostRow == 2 then
				sndPlay(sndSys, 100, 1)
				crudHostOption = 3
				crudHostScreen = false
			--BACK
			elseif crudHostCursorD == 2 and crudHostRow == 2 then
				sndPlay(sndSys, 100, 2)
				f_crudHostReset()
			end
		end
	end
	--Draw Crud Window BG
	animDraw(crudHostWindowBG)
	animUpdate(crudHostWindowBG)
	--Draw Crud Title
	textImgSetText(txt_crudTitle, hostRoomName.." ROOM")
	textImgDraw(txt_crudTitle)
	--Draw Input Hints Panel
	if crudHostOption ~= 1 then drawCrudHostInputHints() end
	--Draw Crud Menu Text
	for i=1, #t_crudHostOptionU do
		if i == crudHostCursorU and crudHostRow == 1 then
			bank = 5
		else
			bank = 0
		end
		t_crudHostOptionU[i].id = createTextImg(jgFnt, bank, 0, t_crudHostOptionU[i].text, 12+i*100, 170)
		textImgDraw(t_crudHostOptionU[i].id)
	end
	for i=1, #t_crudHostOptionD do
		if i == crudHostCursorD and crudHostRow == 2 then
			bank = 5
		else
			bank = 0
		end
		t_crudHostOptionD[i].id = createTextImg(jgFnt, bank, 0, t_crudHostOptionD[i].text, 12+i*100, 190)
		textImgDraw(t_crudHostOptionD[i].id)
	end
	if crudHostOption ~= 1 then
		--Draw Cursors
		if crudHostRow == 1 then
			animSetWindow(cursorBox, -16+crudHostCursorU*100,158, 55,16)
			f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
			animDraw(f_animVelocity(cursorBox, -1, -1))
		elseif crudHostRow == 2 then
			animSetWindow(cursorBox, -16+crudHostCursorD*100,178, 55,16)
			f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
			animDraw(f_animVelocity(cursorBox, -1, -1))
		end
	end
end

function f_crudHostReset()
	crudHostScreen = false
	crudHostOption = 0
	--Cursor pos in JOIN
	crudHostRow = 1
	crudHostCursorU = 2
	crudHostCursorD = 2
end

--;===========================================================
--; CREATE/UPDATE HOST DATA
--;===========================================================
function f_editHost()
	cmdInput()
	--ENTER HOST NAME
	if not doneName then
		if commandGetState(p1Cmd, 'r') then
			sndPlay(sndSys, 100, 0)
			editHostMenu = editHostMenu + 1
		elseif commandGetState(p1Cmd, 'l') then
			sndPlay(sndSys, 100, 0)
			editHostMenu = editHostMenu - 1
		end
		if editHostMenu < 1 then editHostMenu = 2 elseif editHostMenu > 2 then editHostMenu = 1 end
		editHostName = inputText('',true)
		if clipboardPaste() then
			if string.match(getClipboardText(),'^(.*)') then
				setInputText(getClipboardText())
			else
				sndPlay(sndSys, 100, 5)
			end
		end
		if editHostName:len() > 5 then
			editHostName = editHostName:sub(1,16)
			setInputText(editHostName)
		end
		if editHostName ~= '' and editHostName ~= nil then
			if editHostName:match('^"*(%")$') then
				editHostName = editHostName:gsub('^("*)[%"]$','%1')
				setInputText(editHostName)
			end
		end
		--ACTIONS
		if esc() then
			sndPlay(sndSys, 100, 2)
			f_editHostReset()
		elseif commandGetState(p1Cmd, 'w') then
			--BACK
			if editHostMenu == 1 then
				sndPlay(sndSys, 100, 2)
				f_editHostReset()
			--SAVE NAME
			elseif editHostMenu == 2 then
				if editHostName ~= '' and editHostName ~= nil then
					clearInputText()
					sndPlay(sndSys, 100, 1)
					hostName = (tostring(editHostName))
					doneName = true
				else
					sndPlay(sndSys, 100, 5)
				end
			end
		end
		--Draw Fade BG
		animDraw(fadeWindowBG)
		--Draw Name Window BG
		animDraw(textWindowBG)
		animUpdate(textWindowBG)
		--Draw Name Window Title
		textImgDraw(txt_clientName)
		--Draw Name Text
		textImgSetText(txt_ip,editHostName)
		textImgDraw(txt_ip)
		if textBar%60 < 30 then
			textImgPosDraw(txt_bar, 160+(textImgGetWidth(txt_ip)*0.5)+(textImgGetWidth(txt_ip)>0 and 2 or 0), 134)
		end
		--Draw Button Option Text
		for i=1, #t_editOption do
			if i == editHostMenu then
				textImgSetBank(t_editOption[i].id, 5)
			else
				textImgSetBank(t_editOption[i].id, 0)
			end
			textImgDraw(t_editOption[i].id)
		end
		--Draw Cursor
		animSetWindow(cursorBox, -9+editHostMenu*96,141, 48.5,13)
		f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
		animDraw(f_animVelocity(cursorBox, -1, -1))
		--Draw Hint Info
		textImgDraw(txt_titleFt)
		textImgSetText(txt_titleFt, "COPIED TEXT CAN BE PASTED WITH CTRL V")
	--ENTER HOST IP ADDRESS
	else
		if commandGetState(p1Cmd, 'r') then
			sndPlay(sndSys, 100, 0)
			editHostMenu = editHostMenu + 1
		elseif commandGetState(p1Cmd, 'l') then
			sndPlay(sndSys, 100, 0)
			editHostMenu = editHostMenu - 1
		end
		if editHostMenu < 1 then editHostMenu = 2 elseif editHostMenu > 2 then editHostMenu = 1 end
		hostAddress = inputText('num',true)
		if clipboardPaste() then
			if string.match(getClipboardText(),'^%d%d?%d?%.%d%d?%d?%.%d%d?%d?%.%d%d?%d?$') then
				setInputText(getClipboardText())
			elseif string.match(getClipboardText(),'^localhost$') then
				setInputText(getClipboardText())
			else
				sndPlay(sndSys, 100, 5)
			end
		end
		if hostAddress:match('^%.') then
			hostAddress = ''
			setInputText(hostAddress)
		elseif hostAddress:len() > 15 then
			hostAddress = hostAddress:sub(1,15)
			setInputText(hostAddress)
		elseif hostAddress:match('%.%.+') then
			hostAddress = hostAddress:gsub('%.%.+','.')
			setInputText(hostAddress)
		elseif hostAddress:match('%d%d%d%d+') then
			hostAddress = hostAddress:gsub('(%d%d%d)%d+','%1')
			setInputText(hostAddress)
		elseif hostAddress:match('%d+%.%d+%.%d+%.%d+%.') then
			hostAddress = hostAddress:gsub('(%d+%.%d+%.%d+%.%d+)%.','%1')
			setInputText(hostAddress)
		end
		--ACTIONS
		if esc() then
			sndPlay(sndSys, 100, 2)
			f_editHostReset()
		--BUTTON SELECTED
		elseif btnPalNo(p1Cmd) > 0 then
			--BACK
			if editHostMenu == 1 then
				sndPlay(sndSys, 100, 2)
				f_editHostReset()
			--ENTER IP
			elseif editHostMenu == 2 then
				if hostAddress:match('^%d%d?%d?%.%d%d?%d?%.%d%d?%d?%.%d%d?%d?$') then
					doneAddress = true
				elseif hostAddress:match('^localhost$') then
					doneAddress = true
				else
					sndPlay(sndSys, 100, 5)
				end
			end
		end
		--Draw Fade BG
		animDraw(fadeWindowBG)
		--Draw IP Window BG
		animDraw(textWindowBG)
		animUpdate(textWindowBG)
		--Draw IP Window Title
		textImgSetText(txt_client, "Enter Host\'s IPv4")
		textImgDraw(txt_client)
		--Draw IP Text
		textImgSetText(txt_ip,hostAddress)
		textImgDraw(txt_ip)
		if textBar%60 < 30 then
			textImgPosDraw(txt_bar, 160+(textImgGetWidth(txt_ip)*0.5)+(textImgGetWidth(txt_ip)>0 and 2 or 0), 134)
		end
		--Draw Button Option Text
		for i=1, #t_editOption do
			if i == editHostMenu then
				textImgSetBank(t_editOption[i].id, 5)
			else
				textImgSetBank(t_editOption[i].id, 0)
			end
			textImgDraw(t_editOption[i].id)
		end
		--Draw Cursor
		animSetWindow(cursorBox, -9+editHostMenu*96,141, 48.5,13)
		f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
		animDraw(f_animVelocity(cursorBox, -1, -1))
		--Draw Hint Info
		textImgDraw(txt_titleFt)
		textImgSetText(txt_titleFt, "COPIED IP CAN BE PASTED WITH CTRL V")
	end
	--SAVE ALL DATA
	if doneAddress == true then
		sndPlay(sndSys, 100, 1)
		if editHostRoom == true then host_rooms.IP[hostRoomName] = nil end --To Update Data
		host_rooms.IP[hostName] = hostAddress
		t_tmp = {}
		for i = 1, #t_hostList do
			if i < #t_hostList then
				t_tmp[i] = t_hostList[i]
			else
				t_tmp[i] = {id = textImgNew(), text = hostName, address = hostAddress}
				t_tmp[i + 1] = t_hostList[i]
			end
		end
		t_hostList = t_tmp
		local file = io.open(saveHostRoomPath,"w+")
		file:write(json.encode(host_rooms, {indent = true}))
		file:close()
		f_hostTable() --Refresh
		f_editHostReset()
	end
	cmdInput()
end

function f_editHostReset()
	clearInputText()
	editHostScreen = false
	editHostRoom = false
	doneAddress = false
	doneName = false
	editHostName = ""
	hostAddress = ""
	textBar = 0
	editHostMenu = 2 --Cursor pos in ENTER
end

--;===========================================================
--; READ LOCAL DATABASE TO CONNECTING MENU
--;===========================================================
function f_databaseConnect()
	textImgSetText(txt_clientTitle, hostRoomName.."'s ROOM")
	cmdInput()
	sndPlay(sndSys, 100, 1)
	joinExit = false
	enterNetPlay(hostIP) --Connect to entered IP address
	netPlayer = "Client"
	textImgSetText(txt_connecting, "Now connecting to ["..hostIP.."]")
	while not connected() do
		--CANCEL CONNECTION
		if esc() or commandGetState(p1Cmd, 'e') then
			data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
			sndPlay(sndSys, 100, 2)
			netPlayer = ""
			joinExit = true
			return true
		end
		--Draw Connecting BG
		animDraw(f_animVelocity(commonBG0, -1, -1))
		--Draw Connecting Title
		textImgDraw(txt_clientTitle)
		--Draw Window BG
		animDraw(joinWindowBG)
		animUpdate(joinWindowBG)
		--Draw Port Info
		textImgSetText(txt_netPort, "Netplay Port ["..getListenPort().."]")
		textImgDraw(txt_netPort)
		--Draw Connecting Info
		textImgDraw(txt_connecting)
		--Draw Cancel Button
		textImgDraw(txt_cancel)
		--Draw Cursor
		animSetWindow(cursorBox, 87,155, 144,13)
		f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
		animDraw(f_animVelocity(cursorBox, -1, -1))
		--Draw Animated Icon
		animDraw(wirelessBG)
		animUpdate(wirelessBG)
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		cmdInput()
		refresh()
	end
	return false
end

--;===========================================================
--; LOBBY MENU
--;===========================================================
function f_mainLobby()
	cmdInput()
	local cursorPosY = 0
	local moveTxt = 0
	local mainLobby = 1
	local bufu = 0
	local bufd = 0
	local bufr = 0
	local bufl = 0
	local cancel = false
	while true do
		--assert(loadfile(saveTempPath))()
		if esc() or commandGetState(p1Cmd, 'e') or data.replayDone == true then
			sndPlay(sndSys, 100, 2)
			data.replayDone = false
			f_saveTemp()
			break
		end
		if commandGetState(p1Cmd, 'u') or (commandGetState(p1Cmd, 'holdu') and bufu >= 30) then
			sndPlay(sndSys, 100, 0)
			mainLobby = mainLobby - 1
		elseif commandGetState(p1Cmd, 'd') or (commandGetState(p1Cmd, 'holdd') and bufd >= 30) then
			sndPlay(sndSys, 100, 0)
			mainLobby = mainLobby + 1
		end
		if mainLobby < 1 then
			mainLobby = #t_mainLobby
			if #t_mainLobby > 5 then
				cursorPosY = 5
			else
				cursorPosY = #t_mainLobby-1
			end
		elseif mainLobby > #t_mainLobby then
			mainLobby = 1
			cursorPosY = 0
		elseif (commandGetState(p1Cmd, 'u') or (commandGetState(p1Cmd, 'holdu') and bufu >= 30)) and cursorPosY > 0 then
			cursorPosY = cursorPosY - 1
		elseif (commandGetState(p1Cmd, 'd') or (commandGetState(p1Cmd, 'holdd') and bufd >= 30)) and cursorPosY < 5 then
			cursorPosY = cursorPosY + 1
		end
		if cursorPosY == 5 then
			moveTxt = (mainLobby - 6) * 13
		elseif cursorPosY == 0 then
			moveTxt = (mainLobby - 1) * 13
		end
		if #t_mainLobby <= 5 then
			maxmainLobby = #t_mainLobby
		elseif mainLobby - cursorPosY > 0 then
			maxmainLobby = mainLobby + 5 - cursorPosY
		else
			maxmainLobby = 5
		end
	--Enter Actions
		if btnPalNo(p1Cmd) > 0 then
			f_default()
			if replaygame == true then setGameMode('replay') end
			data.p2In = 2
			data.p2Faces = true
			data.coop = true
			data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
			sndPlay(sndSys, 100, 1)
		--ONLINE VERSUS
			if mainLobby == 1 then
				data.coop = false
				data.stageMenu = true
				setHomeTeam(1)
				data.gameMode = "versus"
				data.rosterMode = "versus"
				if data.ftcontrol > 0 then
					textImgSetText(txt_mainSelect, "ONLINE RANKED VERSUS")
				else
					textImgSetText(txt_mainSelect, "ONLINE VERSUS")
				end
				f_selectSimple()
		--ONLINE TRAINING
			elseif mainLobby == 2 then
				setRoundTime(-1)
				data.p1TeamMenu = {mode = 0, chars = 1}
				data.p2TeamMenu = {mode = 0, chars = 1}
				data.coop = false
				data.stageMenu = true
				data.versusScreen = false
				data.gameMode = "training"
				data.rosterMode = "training"
				textImgSetText(txt_mainSelect, "ONLINE TRAINING")
				f_selectSimple()
		--ONLINE ARCADE	
			elseif mainLobby == 3 then
				data.serviceScreen = true
				data.gameMode = "arcade"
				data.rosterMode = "arcade"
				textImgSetText(txt_mainSelect, "ONLINE ARCADE COOPERATIVE")
                f_selectAdvance()
		--ONLINE TOWER
			elseif mainLobby == 4 then
				--if data.debugMode then f_loadTowers() end
				if #t_selTower ~= 0 then
					data.gameMode = "tower"
					data.rosterMode = "tower"
					--data.arcadeIntro = true
					data.arcadeEnding = true
					textImgSetText(txt_mainSelect, "ONLINE TOWER COOPERATIVE")
					f_selectAdvance()
				end
		--ONLINE SURVIVAL	
			elseif mainLobby == 5 then
				setRoundsToWin(1)
				data.gameMode = "survival"
				data.rosterMode = "survival"
				textImgSetText(txt_mainSelect, "ONLINE SURVIVAL COOPERATIVE")
				f_selectAdvance()
		--ONLINE ENDLESS
			elseif mainLobby == 6 then
				data.gameMode = "endless"
				data.rosterMode = "endless"
				textImgSetText(txt_mainSelect, "ONLINE ENDLESS COOPERATIVE")
				f_selectAdvance()
		--ONLINE BOSS RUSH
			elseif mainLobby == 7 then
				if #t_bossChars ~= 0 then
					data.gameMode = "bossrush"
					data.rosterMode = "boss"
					textImgSetText(txt_mainSelect, "ONLINE BOSS RUSH COOPERATIVE")
					f_selectAdvance()
				end
		--ONLINE BONUS RUSH
			elseif mainLobby == 8 then
				if #t_bonusChars ~= 0 then
					setRoundsToWin(1)
					data.versusScreen = false
					data.gameMode = "bonusrush"
					data.rosterMode = "bonus"
					textImgSetText(txt_mainSelect, "ONLINE BONUS RUSH COOPERATIVE")
					f_selectAdvance()
				end
		--ONLINE TIME RUSH
			elseif mainLobby == 9 then
				setRoundTime(3600)
				setRoundsToWin(1)
				data.gameMode = "allroster"
				data.rosterMode = "timerush"
				textImgSetText(txt_mainSelect, "ONLINE TIME RUSH COOPERATIVE")
				f_selectAdvance()
		--[[
		--ONLINE TIME ATTACK
			elseif mainLobby == 10 then
				setRoundsToWin(1)
				data.gameMode = "allroster"
				data.rosterMode = "timeattack"
				textImgSetText(txt_mainSelect, "ONLINE TIME ATTACK COOPERATIVE")
				f_selectAdvance()
		--ONLINE SCORE ATTACK
			elseif mainLobby == 11 then
				data.gameMode = "allroster"
				data.rosterMode = "scoreattack"
				textImgSetText(txt_mainSelect, "ONLINE SCORE ATTACK COOPERATIVE")
				f_selectAdvance()
		]]
		--ONLINE VS X KUMITE
			elseif mainLobby == 10 then
				setRoundsToWin(1)
				data.gameMode = "vskumite"
				data.rosterMode = "vskumite"
				textImgSetText(txt_mainSelect, "ONLINE "..getKumiteData().." COOPERATIVE")
				f_selectAdvance()
		--ONLINE SUDDEN DEATH
			elseif mainLobby == 11 then
				setRoundTime(1000)
				setLifeMul(0)
				setRoundsToWin(1)
				data.gameMode = "allroster"
				data.rosterMode = "suddendeath"
				textImgSetText(txt_mainSelect, "ONLINE SUDDEN DEATH COOPERATIVE")
				f_selectAdvance()
		--ONLINE SETTINGS
			elseif mainLobby == #t_mainLobby then
				script.options.f_onlineCfg()
			end
		end
		drawBottomMenuSP()
		for i=1, #t_mainLobby do
			if i == mainLobby then
				bank = 5
			else
				bank = 0
			end
			textImgDraw(f_updateTextImg(t_mainLobby[i].id, jgFnt, bank, 0, t_mainLobby[i].text, 159, 122+i*13-moveTxt))
		end
		animSetWindow(cursorBox, 0,125+cursorPosY*13, 316,13)
		f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
		animDraw(f_animVelocity(cursorBox, -1, -1))
		drawMiddleMenuSP()
		textImgDraw(txt_gameFt)
		textImgSetText(txt_gameFt, "ONLINE MENU")
		textImgDraw(txt_version)
		f_sysTime()
		if netPlayer == "Host" then
			t_mainLobby[1].text = "VERSUS PLAYER 2"
		elseif netPlayer == "Client" then
			t_mainLobby[1].text = "VERSUS PLAYER 1"
		end
		t_mainLobby[10].text = getKumiteData()
		if maxmainLobby > 6 then
			animDraw(menuArrowUp)
			animUpdate(menuArrowUp)
		end
		if #t_mainLobby > 6 and maxmainLobby < #t_mainLobby then
			animDraw(menuArrowDown)
			animUpdate(menuArrowDown)
		end
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		if commandGetState(p1Cmd, 'holdu') then
			bufd = 0
			bufu = bufu + 1
		elseif commandGetState(p1Cmd, 'holdd') then
			bufu = 0
			bufd = bufd + 1
		else
			bufu = 0
			bufd = 0
		end		
		cmdInput()
		refresh()
	end
end

--;===========================================================
--; UNLOCK INFO SCREEN
--;===========================================================
function f_secret()
	local i = 0
	txt = "COMPLETE THE ARCADE MODE TO UNLOCK THIS FEATURE!"
	cmdInput()
	while true do
		if btnPalNo(p1Cmd) > 0 or btnPalNo(p2Cmd) > 0 then
			cmdInput()
			sndPlay(sndSys, 100, 2)
			data.fadeTitle = f_fadeAnim(50, 'fadein', 'black', sprFade)
			break
		end
        i = i + 1
        f_textRender(txt_msgMenu, txt, i, 20, 178, 15, 1.8, 35)
        animDraw(data.fadeTitle)
        animUpdate(data.fadeTitle)
		cmdInput()
        refresh()
    end
end

--;===========================================================
--; COMING SOON INFO SCREEN
--;===========================================================
function f_comingSoon()
	f_resetMenuInputs()
	local i = 0
	txt = "THIS FEATURE WILL BE AVAILABLE COMING SOON..."
	cmdInput()
	while true do
		if btnPalNo(p1Cmd) > 0 or btnPalNo(p2Cmd) > 0 then
			cmdInput()
			sndPlay(sndSys, 100, 2)
			data.fadeTitle = f_fadeAnim(50, 'fadein', 'black', sprFade)
			break
		end
        i = i + 1
        f_textRender(txt_msgMenu, txt, i, 20, 178, 15, 1.4, 35)
        animDraw(data.fadeTitle)
        animUpdate(data.fadeTitle)
		cmdInput()
        refresh()
    end
end

--;===========================================================
--; INFO MENU SCREEN
--;===========================================================
function f_infoMenu()
	cmdInput()
	--Draw Fade BG
	animDraw(fadeWindowBG)
	--Draw Menu BG
	animDraw(infoWindowBG)
	animUpdate(infoWindowBG)
	--Draw Info Text
	if charsInfo == true then
		textImgSetScale(txt_info, 0.56, 0.56)
		f_textRender(txt_info, "NO CHARACTERS FOUND IN SELECT.DEF", 0, 160, 125, 10, 0, 25)
	elseif stagesInfo == true then
		textImgSetScale(txt_info, 0.60, 0.60)
		f_textRender(txt_info, "NO STAGES FOUND IN SELECT.DEF", 0, 160, 125, 10, 0, 25)
	elseif configInfo == true then
		textImgSetScale(txt_info, 0.60, 0.60)
		f_textRender(txt_info, "NO ARCADE/SURVIVAL CONFIG FOUND IN SELECT.DEF", 0, 160, 125, 10, 0, 25)
	elseif towerInfo == true then
		textImgSetScale(txt_info, 0.60, 0.60)
		f_textRender(txt_info, "NO TOWERS FOUND IN SELECT.DEF", 0, 160, 125, 10, 0, 25)
	elseif vnInfo == true then
		textImgSetScale(txt_info, 0.60, 0.60)
		f_textRender(txt_info, "NO VISUAL NOVELS FOUND IN SELECT.DEF", 0, 160, 125, 10, 0, 25)
	elseif vnDataInfo == true then
		textImgSetScale(txt_info, 0.70, 0.70)
		f_textRender(txt_info, "NO SAVED GAMES FOUND.", 0, 160, 130, 10, 0, 25)
	elseif bossInfo == true then
		textImgSetScale(txt_info, 0.60, 0.60)
		f_textRender(txt_info, "NO BOSSES FOUND IN SELECT.DEF", 0, 160, 125, 10, 0, 25)
	elseif missionInfo == true then
		textImgSetScale(txt_info, 0.60, 0.60)
		f_textRender(txt_info, "NO MISSIONS FOUND IN SCREENPACK.LUA", 0, 160, 125, 10, 0, 25)
	elseif eventInfo == true then
		textImgSetScale(txt_info, 0.60, 0.60)
		f_textRender(txt_info, "NO EVENTS FOUND IN SCREENPACK.LUA", 0, 160, 125, 10, 0, 25)
	elseif bonusInfo == true then
		textImgSetScale(txt_info, 0.60, 0.60)
		f_textRender(txt_info, "NO BONUSES FOUND IN SELECT.DEF", 0, 160, 125, 10, 0, 25)
	elseif stviewerInfo == true then
		textImgSetScale(txt_info, 0.60, 0.60)
		f_textRender(txt_info, "NO STAGE VIEWER FOUND IN SELECT.DEF", 0, 160, 125, 10, 0, 25)
	elseif licenseInfo == true then
		textImgSetScale(txt_info, 0.60, 0.60)
		f_textRender(txt_info, "NO LICENSES FOUND IN SCREENPACK.LUA", 0, 160, 125, 10, 0, 25)
	elseif resolutionInfo == true then
		textImgSetScale(txt_info, 0.56, 0.56)
		f_textRender(txt_info, "SET A 16:9 RESOLUTION TO AVOID DESYNC", 0, 160, 125, 10, 0, 25)
	elseif firstRunInfo == true then
		textImgSetScale(txt_info, 0.60, 0.60)
		f_textRender(txt_info, "WELCOME TO IKEMEN PLUS ULTRA      ENGINE!", 0, 160, 125, 8.8, 0, 36)
	end
	--Draw Ok Text
	textImgDraw(txt_ok)
	--Draw Cursor
	animSetWindow(cursorBox, 87,141, 144,13)
	f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
	animDraw(f_animVelocity(cursorBox, -1, -1))
	--Draw Info Title Text
	textImgDraw(txt_infoTitle)
	--Draw Input Hints Panel
	drawInfoInputHints()
	--Actions
	if btnPalNo(p1Cmd) > 0 or btnPalNo(p2Cmd) > 0 then
		sndPlay(sndSys, 100, 2)
		if firstRunInfo and stats.firstRun then
			stats.firstRun = false
			f_saveStats()
		end
		f_infoReset()
	end
	cmdInput()
end

function f_infoReset()
	infoScreen = false
	charsInfo = false
	stagesInfo = false
	configInfo = false
	towerInfo = false
	vnInfo = false
	vnDataInfo = false
	bossInfo = false
	missionInfo = false
	eventInfo = false
	bonusInfo = false
	stviewerInfo = false
	licenseInfo = false
	resolutionInfo = false
end

--;===========================================================
--; EXIT MENU
--;===========================================================
t_exitMenu = {
	{id = textImgNew(), text = "CLOSE ENGINE"},
	{id = textImgNew(), text = "RESTART ENGINE"},
}
function f_attractExitItem()
	if data.attractMode == true and infoScreen == false then
		table.insert(t_exitMenu,1,{id = textImgNew(), text = "OPTIONS"})
	end
end

function f_exitMenu()
	cmdInput()
	local cursorPosY = 0
	local moveTxt = 0
	local exitMenu = 1
	local bufu = 0
	local bufd = 0
	local bufr = 0
	local bufl = 0
	if charsInfo or stagesInfo or configInfo then playBGM(bgmTitle) end
	f_exitReset()
	while true do
		if not exitScreen and not infoScreen then
			if commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u') or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30) then
				sndPlay(sndSys, 100, 0)
				exitMenu = exitMenu - 1
			elseif commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd') or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30) then
				sndPlay(sndSys, 100, 0)
				exitMenu = exitMenu + 1
			end
			if exitMenu < 1 then
				exitMenu = #t_exitMenu
				if #t_exitMenu > 4 then
					cursorPosY = 4
				else
					cursorPosY = #t_exitMenu-1
				end
			elseif exitMenu > #t_exitMenu then
				exitMenu = 1
				cursorPosY = 0
			elseif ((commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u')) or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30)) and cursorPosY > 0 then
				cursorPosY = cursorPosY - 1
			elseif ((commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd')) or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30)) and cursorPosY < 4 then
				cursorPosY = cursorPosY + 1
			end
			if cursorPosY == 4 then
				moveTxt = (exitMenu - 5) * 13
			elseif cursorPosY == 0 then
				moveTxt = (exitMenu - 1) * 13
			end
		--Enter Actions
			if btnPalNo(p1Cmd) > 0 or btnPalNo(p2Cmd) > 0 then
				restartEngine = false
			--EXIT FOR ATTRACT MODE (NO CONTENT)
				if exitMenu == 1 and data.attractMode == true and t_selChars == nil then
					sndPlay(sndSys, 100, 1)
					exitScreen = true
				elseif exitMenu == 1 and data.attractMode == true and t_selStages == nil then
					sndPlay(sndSys, 100, 1)
					exitScreen = true
			--RESTART FOR ATTRACT MODE (NO CONTENT)
				elseif exitMenu == 2 and data.attractMode == true and t_selChars == nil then
					sndPlay(sndSys, 100, 1)
					restartEngine = true
					exitScreen = true
				elseif exitMenu == 2 and data.attractMode == true and t_selStages == nil then
					sndPlay(sndSys, 100, 1)
					restartEngine = true
					exitScreen = true
			--OPTIONS FOR ATTRACT MODE
				elseif exitMenu == 1 and data.attractMode == true and #t_selChars ~= 0 and #t_selStages ~= 0 then
					sndPlay(sndSys, 100, 1)
					onlinegame = false
					assert(loadfile(saveCfgPath))()
					script.options.f_mainCfg()
			--EXIT FOR ATTRACT MODE
				elseif exitMenu == 2 and data.attractMode == true and #t_selChars ~= 0 and #t_selStages ~= 0 then
					sndPlay(sndSys, 100, 1)
					exitScreen = true
			--RESTART FOR ATTRACT MODE
				elseif exitMenu == 3 and data.attractMode == true then
					sndPlay(sndSys, 100, 1)
					restartEngine = true
					exitScreen = true
			--NORMAL EXIT
				elseif exitMenu == 1 and data.attractMode == false then
					sndPlay(sndSys, 100, 1)
					exitScreen = true
			--NORMAL RESTART
				elseif exitMenu == 2 and data.attractMode == false then
					sndPlay(sndSys, 100, 1)
					restartEngine = true
					exitScreen = true
				end
		--BACK
			elseif commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then
				sndPlay(sndSys, 100, 2)
				break
			end
		end
		drawBottomMenuSP()
		for i=1, #t_exitMenu do
			if i == exitMenu then
				bank = 5
			else
				bank = 0
			end
			textImgDraw(f_updateTextImg(t_exitMenu[i].id, jgFnt, bank, 0, t_exitMenu[i].text, 159, 145+i*13-moveTxt))
		end
		if infoScreen then
			table.remove(t_exitMenu,3) --Remove Option 3 in table if characters or stages are not detected
		end
		if not exitScreen and not infoScreen then
			animSetWindow(cursorBox, 0,148+cursorPosY*13, 316,13)
			f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
			animDraw(f_animVelocity(cursorBox, -1, -1))
		end
		drawMiddleMenuSP()
		textImgDraw(txt_titleFt)
		if not exitScreen and not infoScreen then textImgSetText(txt_titleFt, "CLOSE OR RESTART ENGINE") end
		f_sysTime()
		if exitScreen then f_closeMenu() end --Show Exit Screen Message
		if infoScreen then
			f_infoMenu() --Show Info Screen Message
		else
			drawMenuInputHints()
		end
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		if commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu') then
			bufd = 0
			bufu = bufu + 1
		elseif commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd') then
			bufu = 0
			bufd = bufd + 1
		else
			bufu = 0
			bufd = 0
		end
		cmdInput()
		refresh()
	end
end

--;===========================================================
--; CLOSE/RESTART MESSAGE
--;===========================================================
function f_closeMenu()
	cmdInput()
	--Cursor Position
	if commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u') then
		sndPlay(sndSys, 100, 0)
		closeMenu = closeMenu - 1
	elseif commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd') then
		sndPlay(sndSys, 100, 0)
		closeMenu = closeMenu + 1
	end
	if closeMenu < 1 then
		closeMenu = #t_closeMenu
		if #t_closeMenu > 4 then
			cursorPosYExit = 4
		else
			cursorPosYExit = #t_closeMenu-1
		end
	elseif closeMenu > #t_closeMenu then
		closeMenu = 1
		cursorPosYExit = 0
	elseif commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u') and cursorPosYExit > 0 then
		cursorPosYExit = cursorPosYExit - 1
	elseif commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd') and cursorPosYExit < 4 then
		cursorPosYExit = cursorPosYExit + 1
	end
	if cursorPosYExit == 4 then
		moveTxtExit = (closeMenu - 5) * 13
	elseif cursorPosYExit == 0 then
		moveTxtExit = (closeMenu - 1) * 13
	end
	--Draw Fade BG
	animDraw(fadeWindowBG)
	--Draw Menu BG
	animDraw(exitWindowBG)
	animUpdate(exitWindowBG)
	--Draw Title
	textImgDraw(txt_question)
	--Draw Table Text
	for i=1, #t_closeMenu do
		if i == closeMenu then
			bank = 5
		else
			bank = 0
		end
		textImgDraw(f_updateTextImg(t_closeMenu[i].id, jgFnt, bank, 0, t_closeMenu[i].text, 159, 120+i*13-moveTxtExit))
	end
	--Draw Cursor
	animSetWindow(cursorBox, 87,123+cursorPosYExit*13, 144,13)
	f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
	animDraw(f_animVelocity(cursorBox, -1, -1))
	--Draw Bottom Text
	textImgDraw(txt_titleFt)
	if restartEngine == true then
		textImgSetText(txt_titleFt, "THE ENGINE WILL BE RESTARTED")
	else
		textImgSetText(txt_titleFt, "THE ENGINE WILL BE CLOSED")
	end
	--Actions
	if esc() or commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then
		sndPlay(sndSys, 100, 2)
		f_exitReset()
	elseif btnPalNo(p1Cmd) > 0 or btnPalNo(p2Cmd) > 0 then
		--YES
		if closeMenu == 1 then
		    f_playTime()
			if restartEngine == true then
				sszReload()
			end
			os.exit()
		--NO
		else
			sndPlay(sndSys, 100, 2)
		end
		f_exitReset()
	end
	cmdInput()
end

function f_exitReset()
	exitScreen = false
	moveTxtExit = 0
	--Cursor pos in YES
	cursorPosYExit = 0
	closeMenu = 1
end

--;===========================================================
--; CONFIRM SCREEN
--;===========================================================
function f_confirmMenu()
	cmdInput()
--Cursor Position
	if commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u') then
		sndPlay(sndSys, 100, 0)
		confirmMenu = confirmMenu - 1
	elseif commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd') then
		sndPlay(sndSys, 100, 0)
		confirmMenu = confirmMenu + 1
	end
	if confirmMenu < 1 then
		confirmMenu = #t_confirmMenu
		if #t_confirmMenu > 4 then
			cursorPosYConfirm = 4
		else
			cursorPosYConfirm = #t_confirmMenu-1
		end
	elseif confirmMenu > #t_confirmMenu then
		confirmMenu = 1
		cursorPosYConfirm = 0
	elseif (commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u')) and cursorPosYConfirm > 0 then
		cursorPosYConfirm = cursorPosYConfirm - 1
	elseif (commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd')) and cursorPosYConfirm < 4 then
		cursorPosYConfirm = cursorPosYConfirm + 1
	end
	if cursorPosYConfirm == 4 then
		moveTxtConfirm = (confirmMenu - 5) * 13
	elseif cursorPosYConfirm == 0 then
		moveTxtConfirm = (confirmMenu - 1) * 13
	end
--Draw Fade BG
	animDraw(fadeWindowBG)
--Draw Menu BG
	animDraw(confirmWindowBG)
	animUpdate(confirmWindowBG)
--Draw Title
	textImgDraw(txt_confirmQuestion)
--Draw Table Text
	for i=1, #t_confirmMenu do
		if i == confirmMenu then
			bank = 5
		else
			bank = 0
		end
		textImgDraw(f_updateTextImg(t_confirmMenu[i].id, jgFnt, bank, 0, t_confirmMenu[i].text, 159, 120+i*13-moveTxtConfirm))
	end
--Draw Cursor
	animSetWindow(cursorBox, 87,123+cursorPosYConfirm*13, 144,13)
	f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
	animDraw(f_animVelocity(cursorBox, -1, -1))
--Draw Input Hints Panel
	drawConfirmInputHints()
--Actions
	if esc() or commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then
		sndPlay(sndSys, 100, 2)
		f_confirmReset()
	elseif btnPalNo(p1Cmd) > 0 or btnPalNo(p2Cmd) > 0 then
	--YES
		if confirmMenu == 1 then
			sndPlay(sndSys, 100, 1)
		--DELETE HOST DATA
			if crudHostOption == 1 then
				f_crudHostReset()
				host_rooms.IP[hostRoomName] = nil
				t_tmp = {}
				for i = 1, #t_hostList do
					if i ~= hostList then
					t_tmp[#t_tmp + 1] = t_hostList[i]
					end
				end
				t_hostList = t_tmp
				local file = io.open(saveHostRoomPath,"w+")
				file:write(json.encode(host_rooms, {indent = true}))
				file:close()
				f_hostTable() --Refresh
		--OTHERS
			else
				deleteReplay = true --For Replay Menu
				tourneyBack = true --For Tournament Menu
				exitAbyss = true --For Abyss Menu
			end
	--NO
		else
			crudHostOption = 0
			sndPlay(sndSys, 100, 2)
		end
		f_confirmReset()
	end
	cmdInput()
end

function f_confirmReset()
	confirmScreen = false
	moveTxtConfirm = 0
	--Cursor pos in NO
	cursorPosYConfirm = 1
	confirmMenu = 2
end

--;===========================================================
--; F1 MESSAGE
--;===========================================================
function f_infoboxMenu()
	cmdInput()
	--Draw Fade BG
	animDraw(fadeWindowBG)
	--Draw Info Text
	f_textRender(infoboxCfg, txt_infobox, 0, 2, 10, 8.8, 0, -1)
	--Actions
	if esc() or btnPalNo(p1Cmd) > 0 or btnPalNo(p2Cmd) > 0 or
	commandGetState(p1Cmd, 'e') or commandGetState(p1Cmd, 'u') or commandGetState(p1Cmd, 'd') or commandGetState(p1Cmd, 'l') or commandGetState(p1Cmd, 'r') or
	commandGetState(p2Cmd, 'e') or commandGetState(p2Cmd, 'u') or commandGetState(p2Cmd, 'd') or commandGetState(p2Cmd, 'l') or commandGetState(p2Cmd, 'r') 
	then
		--sndPlay(sndSys, 100, 2)
		f_infoboxReset()
	end
	cmdInput()
end

function f_infoboxReset()
	infoboxScreen = false
end

--;===========================================================
--; SIDE SELECT
--;===========================================================
function f_sideSelect()
	--controller icon config
	local p1gamepadPosY = 86.5
	local p2gamepadPosY = 150
	local gamepadScale = 0.10
	--text config
	local p1txtPosY = 88
	local p2txtPosY = 152
	local txtScale = 0.7
	local txtFont = font13
	local txtP1name = "PLAYER 1"
	local txtP2name = "PLAYER 2"
	local txtP1color = 0
	local txtP2color = 1
	--arrows confg
	local p1arrowPosY = 107.5
	local p2arrowPosY = 167.5
	local arrowScale = 0.5
	--Center X Position
	local gamepadPosXcenter = 122
	local txtPosXcenter = 159
	local arrowLposXcenter = 104
	local arrowRposXcenter = 205
	--Left X Position
	local gamepadPosXleft = 5
	local txtPosXleft = 42
	local arrowRposXleft = 88.5
	--Right X Position
	local gamepadPosXright = 240
	local txtPosXright = 277
	local arrowLposXright = 220
	local function f_cpuL() f_drawQuickText(txt_sideCPU, font14, 0, 0, "CPU", txtPosXleft, 120) end
	local function f_cpuR() f_drawQuickText(txt_sideCPU, font14, 0, 0, "CPU", txtPosXright, 120) end
	cmdInput() --Read Inputs
	--P1 Cursor Position
	if commandGetState(p1Cmd, 'l') then
		if p1Side > -1 then
			sndPlay(sndSys, 100, 0)
			p1Side = p1Side - 1
		end
		sideWarning = false
	elseif commandGetState(p1Cmd, 'r') then
		if p1Side < 1 then
			sndPlay(sndSys, 100, 0)
			p1Side = p1Side + 1
		end
		sideWarning = false
	end
	--P2 Cursor Position
	if commandGetState(p2Cmd, 'l') then
		if p2Side > -1 then
			sndPlay(sndSys, 100, 0)
			p2Side = p2Side - 1
		end
		sideWarning = false
	elseif commandGetState(p2Cmd, 'r') then
		if p2Side < 1 then
			sndPlay(sndSys, 100, 0)
			p2Side = p2Side + 1
		end
		sideWarning = false
	end
	--Draw Fade BG
	animDraw(fadeWindowBG)
	--Draw Screen Title
	textImgDraw(txt_sideTitle)
	--Draw Side Texts
	f_drawQuickText(txt_sideInfo, font6, 0, 0, "LEFT SIDE", 42, 25, 0.9, 0.9)
	f_drawQuickText(txt_sideInfo, font6, 0, 0, "RIGHT SIDE", 277, 25, 0.9, 0.9)
	--CPU VS CPU
	if p1Side == 0 and p2Side == 0 then
		f_cpuL()
		f_cpuR()
	end
	--P1 & P2 VS CPU
	if p1Side == -1 and p2Side == -1 then
		f_cpuR()
	end
	--CPU VS P1 & P2 (Not available yet)
	if p1Side == 1 and p2Side == 1 then
		f_cpuL()
	end
	--P1 VS CPU
	if p1Side == -1 and p2Side == 0 then
		f_cpuR()
	end
	--P2 VS CPU
	if p2Side == -1 and p1Side == 0 then
		f_cpuR()
	end
	--CPU VS P1
	if p2Side == 0 and p1Side == 1 then
		f_cpuL()
	end
	--CPU VS P2
	if p1Side == 0 and p2Side == 1 then
		f_cpuL()
	end
	--Draw Lifebars
	f_drawQuickSpr(lifebarsImg, 3.5, 30, 0.25, 0.25, 200)
	--Draw P1 Assets
	if p1Side == 0 then --Draw in Middle
		f_drawQuickSpr(gamepadIcon, gamepadPosXcenter, p1gamepadPosY, gamepadScale, gamepadScale) --Gamepad
		f_drawQuickSpr(sideSelArrowLeft, arrowLposXcenter, p1arrowPosY, arrowScale, arrowScale) --Left Arrow
		f_drawQuickSpr(sideSelArrowRight, arrowRposXcenter, p1arrowPosY, arrowScale, arrowScale) --Right Arrow
		f_drawQuickText(txt_sidePNo, txtFont, txtP1color, 0, txtP1name, txtPosXcenter, p1txtPosY, txtScale, txtScale) --Player ID
	elseif p1Side == -1 then --Draw in Left
		f_drawQuickSpr(gamepadIcon, gamepadPosXleft, p1gamepadPosY, gamepadScale, gamepadScale) --Gamepad
		f_drawQuickSpr(sideSelArrowRight, arrowRposXleft, p1arrowPosY, arrowScale, arrowScale) --Right Arrow
		f_drawQuickText(txt_sidePNo, txtFont, txtP1color, 0, txtP1name, txtPosXleft, p1txtPosY, txtScale, txtScale) --Player ID
	elseif p1Side == 1 then --Draw in Right
		f_drawQuickSpr(gamepadIcon, gamepadPosXright, p1gamepadPosY, gamepadScale, gamepadScale) --Gamepad
		f_drawQuickSpr(sideSelArrowLeft, arrowLposXright, p1arrowPosY, arrowScale, arrowScale) --Left Arrow
		f_drawQuickText(txt_sidePNo, txtFont, txtP1color, 0, txtP1name, txtPosXright, p1txtPosY, txtScale, txtScale) --Player ID
	end
	--Draw P2 Assets
	if p2Side == 0 then
		f_drawQuickSpr(gamepadIcon, gamepadPosXcenter, p2gamepadPosY, gamepadScale, gamepadScale)
		f_drawQuickSpr(sideSelArrowLeft, arrowLposXcenter, p2arrowPosY, arrowScale, arrowScale)
		f_drawQuickSpr(sideSelArrowRight, arrowRposXcenter, p2arrowPosY, arrowScale, arrowScale)
		f_drawQuickText(txt_sidePNo, txtFont, txtP2color, 0, txtP2name, txtPosXcenter, p2txtPosY, txtScale, txtScale)
	elseif p2Side == -1 then
		f_drawQuickSpr(gamepadIcon, gamepadPosXleft, p2gamepadPosY, gamepadScale, gamepadScale)
		f_drawQuickSpr(sideSelArrowRight, arrowRposXleft, p2arrowPosY, arrowScale, arrowScale)
		f_drawQuickText(txt_sidePNo, txtFont, txtP2color, 0, txtP2name, txtPosXleft, p2txtPosY, txtScale, txtScale)
	elseif p2Side == 1 then
		f_drawQuickSpr(gamepadIcon, gamepadPosXright, p2gamepadPosY, gamepadScale, gamepadScale)
		f_drawQuickSpr(sideSelArrowLeft, arrowLposXright, p2arrowPosY, arrowScale, arrowScale)
		f_drawQuickText(txt_sidePNo, txtFont, txtP2color, 0, txtP2name, txtPosXright, p2txtPosY, txtScale, txtScale)
	end
	--Draw Input Hint Panel
	drawSideInputHints()
	--Draw Side Warning Message
	if sideWarning then
		textImgDraw(txt_sideWarning)
		data.p2In = 2 --Keep Active Player 2 Control
	end
--Actions
	--Back
	if esc() or commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then
		sndPlay(sndSys, 100, 2)
		f_sideReset()
	--Confirm
	elseif btnPalNo(p1Cmd) > 0 or btnPalNo(p2Cmd) > 0 then
	--Load Common Modes Config
		if menuSelect == "quick match" then randomModeCfg()
		elseif menuSelect == "free battle" then freeModeCfg()
		elseif menuSelect == "arcade" then arcadeCfg()
		elseif menuSelect == "tower" then towerCfg()
		elseif menuSelect == "survival" then survivalCfg()
		elseif menuSelect == "abyss" then abyssCfg()
		elseif menuSelect == "boss" then bossCfg()
		elseif menuSelect == "boss rush" then bossrushCfg()
		elseif menuSelect == "bonus" then bonusCfg()
		elseif menuSelect == "bonus rush" then bonusrushCfg()
		elseif menuSelect == "time rush" then timerushCfg()
		elseif menuSelect == "time attack" then timeattackCfg()
		elseif menuSelect == "score attack" then scoreattackCfg()
		elseif menuSelect == "kumite" then kumiteCfg()
		elseif menuSelect == "sudden death" then suddenCfg()
		elseif menuSelect == "endless" then endlessCfg()
		end
--Reference: -1 (Left Side), 0 (No Side/CPU), 1 (Right Side)
	--CPU VS CPU
		if p1Side == 0 and p2Side == 0 then
			if menuSelect == "quick match" then randomCPUvsCPU()
			elseif menuSelect == "free battle" then freeCPUvsCPU()
			elseif menuSelect == "arcade" then arcadeCPUvsCPU()
			elseif menuSelect == "tower" then towerCPUvsCPU()
			elseif menuSelect == "survival" then survivalCPUvsCPU()
			elseif menuSelect == "abyss" then abyssCPUvsCPU()
			elseif menuSelect == "boss" then bossCPUvsCPU()
			elseif menuSelect == "boss rush" then bossrushCPUvsCPU()
			elseif menuSelect == "time rush" then timerushCPUvsCPU()
			elseif menuSelect == "time attack" then timeattackCPUvsCPU()
			elseif menuSelect == "score attack" then scoreattackCPUvsCPU()
			elseif menuSelect == "kumite" then kumiteCPUvsCPU()
			elseif menuSelect == "sudden death" then suddenCPUvsCPU()
			elseif menuSelect == "endless" then endlessCPUvsCPU()
			end
			if menuSelect ~= "bonus rush" and menuSelect ~= "bonus" then
				sideSelected = true
			else--if you are in bonus rush mode then
				sndPlay(sndSys, 100, 5)
				sideWarning = true
			end
		end
	--P1 VS CPU
		if p1Side == -1 and p2Side == 0 then
			if menuSelect == "quick match" then	randomHumanvsCPU()
			elseif menuSelect == "free battle" then freeHumanvsCPU()
			elseif menuSelect == "arcade" then arcadeHumanvsCPU()
			elseif menuSelect == "tower" then towerHumanvsCPU()
			elseif menuSelect == "survival" then survivalHumanvsCPU()
			elseif menuSelect == "abyss" then abyssHumanvsCPU()
			elseif menuSelect == "boss" then bossHumanvsCPU()
			elseif menuSelect == "boss rush" then bossrushHumanvsCPU()
			elseif menuSelect == "bonus" then bonusHumanvsCPU()
			elseif menuSelect == "bonus rush" then bonusrushHumanvsCPU()
			elseif menuSelect == "time rush" then timerushHumanvsCPU()
			elseif menuSelect == "time attack" then timeattackHumanvsCPU()
			elseif menuSelect == "score attack" then scoreattackHumanvsCPU()
			elseif menuSelect == "kumite" then kumiteHumanvsCPU()
			elseif menuSelect == "sudden death" then suddenHumanvsCPU()
			elseif menuSelect == "endless" then endlessHumanvsCPU()
			end
			sideSelected = true
		end
	--P2 VS CPU
		if p2Side == -1 and p1Side == 0 then
			P2overP1 = true --Detects Player 2 Control
			if menuSelect == "quick match" then	randomHumanvsCPU()
			elseif menuSelect == "free battle" then freeHumanvsCPU()
			elseif menuSelect == "arcade" then arcadeHumanvsCPU()
			elseif menuSelect == "tower" then towerHumanvsCPU()
			elseif menuSelect == "survival" then survivalHumanvsCPU()
			elseif menuSelect == "abyss" then abyssHumanvsCPU()
			elseif menuSelect == "boss" then bossHumanvsCPU()
			elseif menuSelect == "boss rush" then bossrushHumanvsCPU()
			elseif menuSelect == "bonus" then bonusHumanvsCPU()
			elseif menuSelect == "bonus rush" then bonusrushHumanvsCPU()
			elseif menuSelect == "time rush" then timerushHumanvsCPU()
			elseif menuSelect == "time attack" then timeattackHumanvsCPU()
			elseif menuSelect == "score attack" then scoreattackHumanvsCPU()
			elseif menuSelect == "kumite" then kumiteHumanvsCPU()
			elseif menuSelect == "sudden death" then suddenHumanvsCPU()
			elseif menuSelect == "endless" then endlessHumanvsCPU()
			end
			sideSelected = true
		end
	--CPU VS P1
		if p2Side == 0 and p1Side == 1 then
			if menuSelect == "quick match" then	randomCPUvsHuman()
			elseif menuSelect == "free battle" then freeCPUvsHuman()
			elseif menuSelect == "arcade" then arcadeCPUvsHuman()
			elseif menuSelect == "tower" then towerCPUvsHuman()
			elseif menuSelect == "survival" then survivalCPUvsHuman()
			elseif menuSelect == "abyss" then abyssCPUvsHuman()
			elseif menuSelect == "boss" then bossCPUvsHuman()
			elseif menuSelect == "boss rush" then bossrushCPUvsHuman()
			elseif menuSelect == "bonus" then bonusCPUvsHuman()
			elseif menuSelect == "bonus rush" then bonusrushCPUvsHuman()
			elseif menuSelect == "time rush" then timerushCPUvsHuman()
			elseif menuSelect == "time attack" then timeattackCPUvsHuman()
			elseif menuSelect == "score attack" then scoreattackCPUvsHuman()
			elseif menuSelect == "kumite" then kumiteCPUvsHuman()
			elseif menuSelect == "sudden death" then suddenCPUvsHuman()
			elseif menuSelect == "endless" then endlessCPUvsHuman()
			end
			sideSelected = true
		end
	--CPU VS P2
		if p1Side == 0 and p2Side == 1 then
			P2overP1 = true --Detects Player 2 Control
			if menuSelect == "quick match" then	randomCPUvsHuman()
			elseif menuSelect == "free battle" then freeCPUvsHuman()
			elseif menuSelect == "arcade" then arcadeCPUvsHuman()
			elseif menuSelect == "tower" then towerCPUvsHuman()
			elseif menuSelect == "survival" then survivalCPUvsHuman()
			elseif menuSelect == "abyss" then abyssCPUvsHuman()
			elseif menuSelect == "boss" then bossCPUvsHuman()
			elseif menuSelect == "boss rush" then bossrushCPUvsHuman()
			elseif menuSelect == "bonus" then bonusCPUvsHuman()
			elseif menuSelect == "bonus rush" then bonusrushCPUvsHuman()
			elseif menuSelect == "time rush" then timerushCPUvsHuman()
			elseif menuSelect == "time attack" then timeattackCPUvsHuman()
			elseif menuSelect == "score attack" then scoreattackCPUvsHuman()
			elseif menuSelect == "kumite" then kumiteCPUvsHuman()
			elseif menuSelect == "sudden death" then suddenCPUvsHuman()
			elseif menuSelect == "endless" then endlessCPUvsHuman()
			end
			sideSelected = true
		end
	--P1 VS P2
		if p1Side == -1 and p2Side == 1 then
			if menuSelect == "quick match" then randomHumanvsHuman()
			elseif menuSelect == "free battle" then freeHumanvsHuman()
			end
			if menuSelect == "quick match" or menuSelect == "free battle" then
				sideSelected = true
			else--if you are not in free versus or quick match modes then
				sndPlay(sndSys, 100, 5)
				sideWarning = true
			end
		end
	--P2 VS P1
		if p2Side == -1 and p1Side == 1 then
			P2overP1 = true
			if menuSelect == "quick match" then randomHumanvsHuman()
			elseif menuSelect == "free battle" then freeHumanvsHuman()
			end
			if menuSelect == "quick match" or menuSelect == "free battle" then
				sideSelected = true
			else--if you are not in free versus or quick match modes then
				sndPlay(sndSys, 100, 5)
				P2overP1 = false
				sideWarning = true
			end
		end
	--P1&P2 VS CPU [CO-OP MODE]
		if p1Side == -1 and p2Side == -1 then
			--if menuSelect == "quick match" then randomP1P2vsCPU()
			--elseif menuSelect == "free battle" then freeP1P2vsCPU()
			if menuSelect == "arcade" then arcadeP1P2vsCPU()
			elseif menuSelect == "tower" then towerP1P2vsCPU()
			elseif menuSelect == "survival" then survivalP1P2vsCPU()
			elseif menuSelect == "abyss" then abyssP1P2vsCPU()
			elseif menuSelect == "boss rush" then bossrushP1P2vsCPU()
			elseif menuSelect == "bonus rush" then bonusrushP1P2vsCPU()
			elseif menuSelect == "time rush" then timerushP1P2vsCPU()
			elseif menuSelect == "time attack" then timeattackP1P2vsCPU()
			elseif menuSelect == "score attack" then scoreattackP1P2vsCPU()
			elseif menuSelect == "kumite" then kumiteP1P2vsCPU()
			elseif menuSelect == "sudden death" then suddenP1P2vsCPU()
			elseif menuSelect == "endless" then endlessP1P2vsCPU()
			end
			if menuSelect ~= "quick match" and menuSelect ~= "free battle" and menuSelect ~= "bonus" and menuSelect ~= "boss" then
				sideSelected = true
			else
				sndPlay(sndSys, 100, 5)
				sideWarning = true
			end
		end
	--CPU VS P1&P2 [CO-OP MODE] (Not available yet)
		if p1Side == 1 and p2Side == 1 then
			--if menuSelect == "quick match" then randomCPUvsP1P2()
			--elseif menuSelect == "free battle" then freeCPUvsP1P2()
			if menuSelect == "arcade" then arcadeCPUvsP1P2()
			elseif menuSelect == "tower" then towerCPUvsP1P2()
			elseif menuSelect == "survival" then survivalCPUvsP1P2()
			elseif menuSelect == "abyss" then abyssCPUvsP1P2()
			elseif menuSelect == "boss rush" then bossrushCPUvsP1P2()
			elseif menuSelect == "bonus rush" then bonusrushCPUvsP1P2()
			elseif menuSelect == "time rush" then timerushCPUvsP1P2()
			elseif menuSelect == "time attack" then timeattackCPUvsP1P2()
			elseif menuSelect == "score attack" then scoreattackCPUvsP1P2()
			elseif menuSelect == "kumite" then kumiteCPUvsP1P2()
			elseif menuSelect == "sudden death" then suddenCPUvsP1P2()
			elseif menuSelect == "endless" then endlessCPUvsP1P2()
			end
			if menuSelect ~= "quick match" and menuSelect ~= "free battle" and menuSelect ~= "bonus" and menuSelect ~= "boss" then
				sideSelected = true
			else
				sndPlay(sndSys, 100, 5)
				sideWarning = true
			end
		end
		if sideSelected then f_sideReset() end
	end
	cmdInput()
end

function f_sideReset()
	sideScreen = false
	sideSelected = false
	sideWarning = false
	p1Side = 0 --P1 Cursor pos in Middle
	p2Side = 0 --P2 Cursor pos in Middle
end

--;===========================================================
--; INTERMISSION (SECRET FIGHT)
--;===========================================================
function f_intermission() --Secret Fight Intro
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	playBGM("sound/system/Intermission.mp3")
	local intermissionTime = 0
	local intermissionTxt = f_extractText(txt_intermissionBox)
	local black = 0 --alphaS
	local charPortrait = false
	local charAnim = false
	secretSel = t_secretChallenger[math.random(#t_secretChallenger)].cel --pick a random intermission char
	secretChar = t_selChars[secretSel+1] --use previous selection to get table position
	local scaleData = nil
	if secretChar.intermissionSprScale ~= nil then
		scaleData = secretChar.intermissionSprScale
	else
		scaleData = "1.0,1.0"
	end
	local xPortScale, yPortScale = scaleData:match('^([^,]-)%s*,%s*(.-)$')
	if secretChar.sffData ~= nil and secretChar.stand ~= nil then
		charAnim = f_animFromTable(secretChar['stand'], secretChar.sffData, 160, 180, secretChar.xscale, secretChar.yscale, 0, 1, black)
	end
	if secretChar.sffData ~= nil and secretChar.intermissionSpr ~= nil then
		charPortrait = f_animFromTable(secretChar['intermissionSpr'], secretChar.sffData, 0, 40, xPortScale, yPortScale, 0, 1, black)
	end
	while true do
		if intermissionTime == 500 then
			--cmdInput()
			break
		end
		intermissionTime = intermissionTime + 1
		--Draw BG Assets
		animDraw(f_animVelocity(intermissionBG0, -1, -1))
		--animDraw(f_animVelocity(intermissionBG1, -1, -1))
		animDraw(intermissionBG2)
		animDraw(f_animVelocity(intermissionWindowSlideU, -1.5, 0))
		animDraw(f_animVelocity(intermissionWindowSlideD, 1.5, 0))
		--Draw Warning Text
		textImgDraw(f_textVelocity(txt_warningInterU, -1.5, 0))
		textImgDraw(f_textVelocity(txt_warningInterD, 1.2, 0))
		--Draw Approaching Text
		for i = 1, #intermissionTxt do
			textImgDraw(f_updateTextImg(textImgNew(), jgFnt, 5, 0, intermissionTxt[i], 255, 115 + 12 * (i - 1)))
		end
	--Draw Character Portraits
		if data.charPresentation == "Portrait" or data.charPresentation == "Mixed" then
			if charPortrait then
				animDraw(charPortrait)
				animUpdate(charPortrait)
			end
		end
	--Draw Character Sprite Animations
		if data.charPresentation == "Sprite" or data.charPresentation == "Mixed" then
			if charAnim then
				animDraw(charAnim)
				animUpdate(charAnim)
			end
		end
		--animDraw(data.fadeTitle)
		--animUpdate(data.fadeTitle)
		cmdInput()
		refresh()
	end
end

function f_getIntermission()
t_secretChallenger = {} --If you use a char that can appear in the intermission, this table will guarantee when randomizing it you fight against another
for i, c in ipairs(t_intermissionChars) do --Read all table items and save each value in c var
	local intermissionChar = c['path'] --Create variable with name from t_intermissionChars now stored in c var (Since it is in a for, the name will be different in each loop)
	if getPlayerSide() == "p1left" or getPlayerSide() == "p2left" then
		selectaChar = data.t_p1selected[1]['path'] --Create another variable with the first name from data.t_p1selected (Your Selected Character)
	elseif getPlayerSide() == "p1right" or getPlayerSide() == "p2right" then
		selectaChar = data.t_p2selected[1]['path']
	end
	if intermissionChar ~= selectaChar then --Compare both names stored in previous vars and if the names are differents:
	--Add only different intermission chars from the one you are using in this table
		table.insert(t_secretChallenger, {['cel'] = t_charAdd[intermissionChar], ['name'] = t_selChars[t_charAdd[intermissionChar]+1].name, ['displayname'] = t_selChars[t_charAdd[intermissionChar]+1].displayname, ['path'] = intermissionChar, ['author'] = t_selChars[t_charAdd[intermissionChar]+1].author})
	end
end
if data.debugLog then f_printTable(t_secretChallenger, "save/debug/t_secretChallenger.txt") end
end

function f_secretFight()
	--Load Side Player Data
	if getPlayerSide() == "p1left" or getPlayerSide() == "p2left" then
		keepLSide = true
	elseif getPlayerSide() == "p1right" or getPlayerSide() == "p2right" then
		keepRSide = true
	end
	f_default()
	data.rosterMode = "versus"
	data.gameMode = "intermission"
	setGameMode('intermission')
	setRoundTime(-1)
	data.victoryscreen = false
	--ARCADE PLAYER IS IN LEFT SIDE - SECRET CHALLENGER COMES FROM RIGHT SIDE
	if keepLSide then
		data.p1TeamMenu = {mode = 0, chars = 1} --{mode = p1RestoreTeamMode, chars = p1RestoreCharsNo}
		data.p2TeamMenu = {mode = 0, chars = 1}
		data.p1Char = {data.t_p1selected[1].path} --Get previous Arcade Character Selected
		data.p2Char = {secretChar.char} --Set intermission rival
		data.p1Pal = data.t_p1selected[1].pal --Get previous Palette Selected
		data.p2Pal = 1
		if P2overP1 then
			remapInput(1, 2)
		end
		data.p2In = 1
--ARCADE PLAYER IS IN RIGHT SIDE - SECRET CHALLENGER COMES FROM LEFT SIDE
	elseif keepRSide then
		data.p1TeamMenu = {mode = 0, chars = 1}
		data.p2TeamMenu = {mode = 0, chars = 1} --{mode = p2RestoreTeamMode, chars = p2RestoreCharsNo}
		data.p1Char = {secretChar.char}
		data.p2Char = {data.t_p2selected[1].path}
		data.p1Pal = 1
		data.p2Pal = data.t_p2selected[1].pal
		remapInput(1, 2)
		if not P2overP1 then
			remapInput(2, 1)
		end
		setPlayerSide('p1right')
		data.p1In = 2
		data.p2In = 2
	end
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	f_selectSimple()
	if getPlayerSide() == "p1right" then --Player 1 in Right Side
		if winner == 2 then --Save progress only if you win
			secretTarget = data.t_p1selected --store character data to use for unlocking purposes
			f_secretProgress()
		end
	else --Player 1 in Left Side
		if winner == 1 then
			secretTarget = data.t_p2selected
			f_secretProgress()
		end
	end
end

function f_secretProgress()
local goukiName = "Shin Gouki"
local unlockScreen = t_selChars[secretTarget[1].cel+1]
--Show Unlock Screen if is available
if unlockScreen.UnlockStoryboard ~= nil and io.open(unlockScreen.UnlockStoryboard or '','r') ~= nil then
	f_storyboard(unlockScreen.UnlockStoryboard)
elseif unlockScreen.UnlockVideo ~= nil and io.open(unlockScreen.UnlockVideo or '','r') ~= nil then
	playVideo(unlockScreen.UnlockVideo)
end
if secretTarget[1].displayname == goukiName then stats.unlocks.chars.gouki = true end --Unlock Shin Gouki if you defeat him in arcade intermission
secretTarget = "" --Reset Var
f_saveStats()
end

--;===========================================================
--; CHARACTER SELECT CONFIG
--;===========================================================
--Icon for random select
function f_randomSlot()
cellRandomSprGroup = 151 --System.def cell.random.spr for Group
cellRandomSprIndex = 0 --System.def cell.random.spr for Index
cellRandomSprScaleX = data.cellScaleX
cellRandomSprScaleY = data.cellScaleY
setRandomSpr(sprSys, cellRandomSprGroup, cellRandomSprIndex, cellRandomSprScaleX, cellRandomSprScaleY) --Random Icon
cellRandomSwitchTime = 4 --Time to wait before changing to another random portrait (TODO)
end

function f_rosterReset()
	selectRows = data.selectRows --Get Number of Character Select Rows
	selectColumns = data.selectColumns --Get Number of Character Select Columns
	offsetRows = data.offsetRows --Get Number of Character Select Hidden Rows Slots
	offsetColumns = data.offsetColumns --Get Number of Character Select Hidden Columns Slots (TODO)
	setSelColRow(selectColumns, selectRows)
	--let cursor wrap around
	wrappingX = data.wrappingX --System.def: wrapping for X (true = 1, false = 0)
	wrappingY = data.wrappingY --System.def: wrapping for Y (true = 1, false = 0)
	--Position to draw to
	if data.p2Faces and data.selectType == "Advanced" then --When you play in Multiplayer and Roster Type is like BlazBlue Cross Tag Battle the roster will be divided into 2 and the 2nd player can choose without the screen being cut
		p1FaceX = data.p1FaceX --System.def: pos for X (Left Side)
		p1FaceY = data.p1FaceY --System.def: pos for Y (Left Side)
		p2FaceX = data.p2FaceX --System.def: pos for X (Right Side)
		p2FaceY = data.p2FaceY --System.def: pos for Y (Right Side)
	else --When you play in Single Player or Roster Type is Simple Type
		if data.selectType == "Simple" then
			p1FaceX = data.p1FaceX
			p1FaceY = data.p1FaceY
		elseif data.selectType == "Advanced" then --Custom Positions for Single Play in Advanced Roster Type (TODO: Also configurate this via options)
			p1FaceX = 90
			p1FaceY = data.p1FaceY
		end
		--if not data.p1SelectMenu then
			p2FaceX = data.p1FaceX
			p2FaceY = data.p1FaceY
		--end
		if data.selectType == "Simple" then
			offsetRows = 0
			offsetColumns = 0
		end
	end
	--Empty Cells
	showemptyboxes = true --TODO
	moveoveremptyboxes = false --allow cursor to move over empty boxes (TODO)
	--Size of each cell (in pixels)
	cellSizeX = data.cellSizeX --System.def: cell.size for X
	cellSizeY = data.cellSizeY --System.def: cell.size for Y
	--Space between each cell
	cellSpacingX = data.cellSpacingX --System.def: cell.spacing for X
	cellSpacingY = data.cellSpacingY --System.def: cell.spacing for Y
	setSelCellSize(cellSizeX+cellSpacingX, cellSizeY+cellSpacingY) --Slot Size
	setSelCellScale(data.cellScaleX, data.cellScaleY) --Slot Scale (System.def: cell.bg.scale)
	f_randomSlot()
end

function f_p1sideReset()
p1Cell = nil
p1Portrait = nil
p1memberPreview = nil
f_p1randomReset()
data.t_p1selected = {}
p1TeamEnd = false
p1CharEnd = false
p1PalEnd = false
p1HandicapEnd = false
p1SelEnd = false
p1BG = false
p1SelBack = false
p1TeamBack = true
p1PalSel = 1
p1HandicapSel = 1
p1HandicapCursorPosY = 1
p1HandicapMoveTxt = 0
randomP1Rematch = false
end

function f_p1randomReset()
p1member1Random = false
p1member2Random = false
p1member3Random = false
p1member4Random = false
end

function f_p2sideReset()
p2coopReady = false
p2Cell = nil
p2Portrait = nil
p2memberPreview = nil
f_p2randomReset()
data.t_p2selected = {}
p2TeamEnd = false
p2CharEnd = false
p2PalEnd = false
p2HandicapEnd = false
p2SelEnd = false
p2BG = false
p2SelBack = false
p2TeamBack = true
p2PalSel = 1
p2HandicapSel = 1
p2HandicapCursorPosY = 1
p2HandicapMoveTxt = 0
randomP2Rematch = false
end

function f_p2randomReset()
p2coopRandom = false
p2member1Random = false
p2member2Random = false
p2member3Random = false
p2member4Random = false
end

function f_stageSelectReset()
stageMenuActive = false
exclusiveStageMenu = false
stageChosen = false
stageSelect = true
songSelect = false
p1stage = false
p2stage = false
p1autoSlot = false
p2autoSlot = false
p1song = false
p2song = false
stageAnnouncer = false
announcerTimer = 0
randomStageRematch = false
end

function f_selectReset()
	commandBufReset(p1Cmd)
	commandBufReset(p2Cmd)
	f_rosterReset()
	f_p1sideReset()
	f_p2sideReset()
	selectStart()
	f_stageSelectReset()
	if data.p2In == 1 then
		p2TeamEnd = true
		p2SelEnd = true
	end
	if data.p1In == 2 and data.p2In == 2 then
		p1TeamEnd = true
		p1SelEnd = true
	end
	--if not data.p1SelectMenu then
		--p1SelEnd = true
	--end
	if not data.p2SelectMenu then
		p2SelEnd = true
	end
	keepLSide = false
	keepRSide = false
	selScreenEnd = false
	stageEnd = false
	charSelect = true
	p1numChars = 1
	p2numChars = 1
	p1teamMode = 0
	p2teamMode = 0
	p1numTurns = 2
	p2numTurns = 2
	p1numSimul = 2
	p2numSimul = 2
	matchNo = 0
	setMatchNo(matchNo)
	rematchEnd = false
	battleOption = 0
	battleOption2 = 0
	backScreen = false
	back = false
	serviceBack = false
end

function f_selectInit()
	p1SelX = data.p1SelX --System.def: p1CursorStartcell for X
	p1SelY = data.p1SelY --System.def: p1CursorStartcell for Y
	p2SelX = data.p2SelX --System.def: p2CursorStartcell for X
	p2SelY = data.p2SelY --System.def: p2CursorStartcell for Y
	p1FaceOffset = 0
	p2FaceOffset = 0
	p1OffsetRow = 0
	p2OffsetRow = 0
	p1OffsetColumn = 0
	p2OffsetColumn = 0
	back = false
	--Quick Scrolling Vars
	bufTmu = 0
	bufTmd = 0
	bufTmr = 0
	bufTml = 0
	
	bufTm2u = 0
	bufTm2d = 0
	bufTm2r = 0
	bufTm2l = 0
	--
	bufSelu = 0
	bufSeld = 0
	bufSelr = 0
	bufSell = 0
	
	bufSel2u = 0
	bufSel2d = 0
	bufSel2r = 0
	bufSel2l = 0
	--
	bufPalu = 0
	bufPald = 0
	bufPalr = 0
	bufPall = 0
	
	bufPal2u = 0
	bufPal2d = 0
	bufPal2r = 0
	bufPal2l = 0
	--
	bufHandu = 0
	bufHandd = 0
	bufHandr = 0
	bufHandl = 0
	
	bufHand2u = 0
	bufHand2d = 0
	bufHand2r = 0
	bufHand2l = 0
	--
	bufStageu = 0
	bufStaged = 0
	bufStager = 0
	bufStagel = 0
	--Timers
	selectSeconds = data.selectTime
	stageSeconds = data.stageTime
	rematchSeconds = data.rematchTime
	serviceSeconds = data.serviceTime
	destinySeconds = data.destinyTime
	selectTimer = selectSeconds*gameTick --Set time for Character Select
	stageTimer = stageSeconds*gameTick --Set time for Stage Select
	rematchTimer = rematchSeconds*gameTick --Set time for Rematch Option
	serviceTimer = serviceSeconds*gameTick --Set time for Service Option
	destinyTimer = destinySeconds*gameTick --Set time for Tower/Destiny Select
	if data.rosterAdvanced == true and data.stageMenu == false then
		--For Advanced Modes without Stage Select
	else
		stageList = 0
	end
	musicList = 0
	gameNo = 0
	bossNo = 0
	bonusNo = 0
	p1Wins = 0
	p2Wins = 0
	winner = 0
	winCnt = 0
	looseCnt = 0
	clearTime = 0
	matchTime = 0
	waitingTowerSel = false
end

function f_setRounds()
	local roundsToWin = data.roundsNum --Use default rounds saved in settings
	if (data.p1In == 2 and data.p2In == 2) then --Player 1 in player 2 (right) side
	--Set New Rounds To Win from select.def chars section
		if t_selChars[data.t_p1selected[1].cel+1].rounds ~= nil then
			roundsToWin = t_selChars[data.t_p1selected[1].cel+1].rounds
		end
	else
		if t_selChars[data.t_p2selected[1].cel+1].rounds ~= nil then
			roundsToWin = t_selChars[data.t_p2selected[1].cel+1].rounds
		end
	end
	setRoundsToWin(roundsToWin)
end

function f_setRoundTime()
	local roundTime = data.roundTime --Use default time saved in settings
	--Set New Time from select.def ExtraStages section
	--if t_selStages[stageNo].roundtime ~= nil then
		--roundTime = t_selChars[stageNo].roundtime
	--end
	if (data.p1In == 2 and data.p2In == 2) then --Player 1 in player 2 (right) side
	--Set New Time from select.def chars section
		if t_selChars[data.t_p1selected[1].cel+1].roundtime ~= nil then
			roundTime = t_selChars[data.t_p1selected[1].cel+1].roundtime
		end
	else
		if t_selChars[data.t_p2selected[1].cel+1].roundtime ~= nil then
			roundTime = t_selChars[data.t_p2selected[1].cel+1].roundtime
		end
	end
	setRoundTime(roundTime * 60)
end

function f_setZoom()
	local zoom = data.zoomActive
	if (data.p1In == 2 and data.p2In == 2) then --Player 1 in player 2 (right) side
		if t_selChars[data.t_p1selected[1].cel+1].zoom ~= nil then
			if t_selChars[data.t_p1selected[1].cel+1].zoom == 1 then
				zoom = true
			else
				zoom = false
			end
		elseif t_selStages[stageNo].zoom ~= nil then
			if t_selChars[stageNo].zoom == 1 then
				zoom = true
			else
				zoom = false
			end
		end
	else
		if t_selChars[data.t_p2selected[1].cel+1].zoom ~= nil then
			if t_selChars[data.t_p2selected[1].cel+1].zoom == 1 then
				zoom = true
			else
				zoom = false
			end
		elseif t_selStages[stageNo].zoom ~= nil then
			if t_selChars[stageNo].zoom == 1 then
				zoom = true
			else
				zoom = false
			end
		end
	end
	setZoom(zoom)
	local zoomMin = data.zoomMin
	if t_selStages[stageNo].zoommin ~= nil then
		zoomMin = t_selStages[stageNo].zoommin
	end
	setZoomMin(zoomMin)
	local zoomMax = data.zoomMax
	if t_selStages[stageNo].zoommax ~= nil then
		zoomMax = t_selStages[stageNo].zoommax
	end
	setZoomMax(zoomMax)
	local zoomSpeed = data.zoomSpeed
	if t_selStages[stageNo].zoomspeed ~= nil then
		zoomSpeed = t_selStages[stageNo].zoomspeed
	end
	setZoomSpeed(zoomSpeed)
end

function f_makeRoster()
	t_roster = {}
	local t = {}
	local cnt = 0
--Arcade
	if data.gameMode == "arcade" then
		if (data.p1In == 2 and data.p2In == 2) then --Player 1 in player 2 (right) side
			if p1teamMode == 0 then --Single
				t = t_selOptions.arcademaxmatches
			else --Team
				t = t_selOptions.teammaxmatches
			end
		else
			if p2teamMode == 0 then --Single
				t = t_selOptions.arcademaxmatches
			else --Team
				t = t_selOptions.teammaxmatches
			end
		end
		for i=1, #t do --for each order number
			if (data.p1In == 2 and data.p2In == 2) then --Player 1 in player 2 (right) side
				cnt = t[i] * p1numChars --set amount of matches to get from the table
			else
				cnt = t[i] * p2numChars --set amount of matches to get from the table
			end
			if cnt > 0 and t_orderChars[i] ~= nil then --if it's more than 0 and there are characters with such order
				while cnt > 0 do --do the following until amount of matches for particular order is reached
					f_shuffleTable(t_orderChars[i]) --randomize characters table
					for j=1, #t_orderChars[i] do --loop through chars associated with that particular order
						t_roster[#t_roster+1] = t_orderChars[i][j] --and add such character into new table
						cnt = cnt - 1
						if cnt == 0 then --but only if amount of matches for particular order has not been reached yet
							break
						end
					end
				end
			end
		end
--Survival / Boss Rush / Bonus Rush / All Roster / Abyss / Endless
	else
		if data.gameMode == "survival" or data.gameMode == "allroster" or data.gameMode == "abyss" or data.gameMode == "endless" then
			t = t_randomChars
			cnt = #t
			local i = 0
			if (data.p1In == 2 and data.p2In == 2) then --Player 1 in player 2 (right) side
				while cnt / p1numChars ~= math.ceil(cnt / p1numChars) do --not integer
					i = i + 1
					cnt = #t + i
				end
			else
				while cnt / p2numChars ~= math.ceil(cnt / p2numChars) do --not integer
					i = i + 1
					cnt = #t + i
				end
			end
		elseif data.gameMode == "bossrush" or data.gameMode == "bonusrush" then
			if data.gameMode == "bossrush" then t = t_bossChars
			elseif data.gameMode == "bonusrush" then t = t_bonusChars
			end
			cnt = #t
			local i = 0
			if (data.p1In == 2 and data.p2In == 2) then
				while cnt / p1numChars ~= math.ceil(cnt / p1numChars) do
					i = i + 1
					cnt = #t + i
				end
			else
				while cnt / p2numChars ~= math.ceil(cnt / p2numChars) do
					i = i + 1
					cnt = #t + i
				end
			end
		elseif data.gameMode == 'vskumite' then
			t = t_randomChars
			if (data.p1In == 2 and data.p2In == 2) then
				cnt = data.kumite * p1numChars
			else
				cnt = data.kumite * p2numChars
			end
		end
		while cnt > 0 do
			f_shuffleTable(t)
			for i=1, #t do
				t_roster[#t_roster+1] = t[i]
				cnt = cnt - 1
				if cnt == 0 then
					break
				end
			end
		end
	end
	if data.debugLog then f_printTable(t_roster, "save/debug/t_roster.txt") end
end

function f_aiRamp()
	local start_match = 0
	local start_diff = 0
	local end_match = 0
	local end_diff = 0
	t_aiRamp = {}
	--Arcade
	if data.gameMode == "arcade" or data.gameMode == "tower" then
		if (data.p1In == 2 and data.p2In == 2) then --Player 1 in player 2 (right) side
			if p1teamMode == 0 then --Single
				start_match = t_selOptions.arcadestart.wins
				start_diff = t_selOptions.arcadestart.offset
				end_match =  t_selOptions.arcadeend.wins
				end_diff = t_selOptions.arcadeend.offset
			else --Team
				start_match = t_selOptions.teamstart.wins
				start_diff = t_selOptions.teamstart.offset
				end_match =  t_selOptions.teamend.wins
				end_diff = t_selOptions.teamend.offset
			end
		else
			if p2teamMode == 0 then --Single
				start_match = t_selOptions.arcadestart.wins
				start_diff = t_selOptions.arcadestart.offset
				end_match =  t_selOptions.arcadeend.wins
				end_diff = t_selOptions.arcadeend.offset
			else --Team
				start_match = t_selOptions.teamstart.wins
				start_diff = t_selOptions.teamstart.offset
				end_match =  t_selOptions.teamend.wins
				end_diff = t_selOptions.teamend.offset
			end
		end
	elseif data.gameMode == "survival" then
		start_match = t_selOptions.survivalstart.wins
		start_diff = t_selOptions.survivalstart.offset
		end_match =  t_selOptions.survivalend.wins
		end_diff = t_selOptions.survivalend.offset
	end
	local startAI = data.difficulty + start_diff
	if startAI > 8 then
		startAI = 8
	elseif startAI < 1 then
		startAI = 1
	end
	local endAI = data.difficulty + end_diff
	if endAI > 8 then
		endAI = 8
	elseif endAI < 1 then
		endAI = 1
	end
	for i=1, lastMatch do
		if i-1 <= start_match then
			t_aiRamp[#t_aiRamp+1] = startAI
		elseif i-1 <= end_match then
			local curMatch = i - (start_match + 1)
			t_aiRamp[#t_aiRamp+1] = math.floor(curMatch * (endAI - startAI) / (end_match - start_match) + startAI)
		else
			t_aiRamp[#t_aiRamp+1] = endAI
		end
	end
	if data.debugLog then f_printTable(t_aiRamp, "save/debug/t_aiRamp.txt") end
end

function f_difficulty(player, offset)
	local t = {}
	if player % 2 ~= 0 then --odd value
		pos = math.floor(player / 2 + 0.5)
		t = t_selChars[data.t_p1selected[pos].cel+1]
	else --even value
		pos = math.floor(player / 2)
		t = t_selChars[data.t_p2selected[pos].cel+1]
	end
	if t.ai ~= nil then
		return t.ai
	else
		return data.difficulty + offset
	end
end

function f_tagMode(player, tagset)
	local t = {}
	if player % 2 ~= 0 then --odd value
		pos = math.floor(player / 2 + 0.5)
		t = t_selChars[data.t_p1selected[pos].cel+1]
	else --even value
		pos = math.floor(player / 2)
		t = t_selChars[data.t_p2selected[pos].cel+1]
	end
	if t.tag ~= nil then
		return t.tag
	else
		return data.tagmode + tagset
	end
end

function f_aiLevel()
	--Offset
	local offset = 0
	local tagset = 0
	--[[
	local tagSystem = 0
		if tagSystem == 0 then
			setTag(1, f_tagMode(1, tagset))
			setTag(2, f_tagMode(2, tagset))
			setTag(3, f_tagMode(3, tagset))
			setTag(4, f_tagMode(4, tagset))
		end
	]]
	if data.aiRamping and data.gameMode == "arcade" or data.gameMode == "tower" or data.gameMode == "survival" then
		offset = t_aiRamp[matchNo] - data.difficulty
	end
	--Coop
	if data.coop then
		setCom(1, 0)
		setCom(2, f_difficulty(2, offset))
		setCom(3, 0)
		setTag(1, f_tagMode(1, tagset))
		setTag(2, f_tagMode(2, tagset))
		setTag(3, f_tagMode(3, tagset))
		if not restoreTeam then
			setCom(4, f_difficulty(4, offset))
			setTag(4, f_tagMode(4, tagset))
		end
	else
		--Player 1
		if p1teamMode == 0 then --Single
			if data.p1In == 1 and not data.aiFight then
				setCom(1, 0)
				setTag(1, f_tagMode(1, tagset))
			else
				setCom(1, f_difficulty(1, offset))
				setTag(1, f_tagMode(1, tagset))
			end
		elseif p1teamMode == 1 then --Simul
			if data.simulType == "Tag" then
				for i=1, p1numChars*2 do
					if i % 2 ~= 0 then --odd value
						if data.p1In == 1 and data.aiFight == false and data.tagmode == 1 then
							setCom(i, 0)
							remapInput(i,1)
							setTag(i, f_tagMode(i, tagset))
						else
							setCom(1, f_difficulty(i, offset))
							setCom(i, f_difficulty(i, offset))
							setTag(i, f_tagMode(i, tagset))
						end
					end
				end
			else --data.simulType == "Assist"
				if data.p1In == 1 and not data.aiFight then
					setCom(1, 0)
					setTag(1, f_tagMode(1, tagset))
				else
					setCom(1, f_difficulty(1, offset))
					setTag(1, f_tagMode(1, tagset))
				end
				for i=3, p1numChars*2 do
					if i % 2 ~= 0 then
						setCom(i, f_difficulty(i, offset))
						setTag(i, f_tagMode(i, tagset))
					end
				end
			end
		elseif p1teamMode == 2 then --Turns
			for i=1, p1numChars*2 do
				if i % 2 ~= 0 then
					if data.p1In == 1 and not data.aiFight then
						setCom(i, 0)
						setTag(i, f_tagMode(i, tagset))
					else
						setCom(i, f_difficulty(i, offset))
						setTag(i, f_tagMode(i, tagset))
					end
				end
			end
		end
		--Player 2
		if p2teamMode == 0 then --Single
			if data.p2In == 2 and not data.aiFight then
				setCom(2, 0)
				setTag(2, f_tagMode(2, tagset))
			else
				setCom(2, f_difficulty(2, offset))
				setTag(2, f_tagMode(2, tagset))
			end
		elseif p2teamMode == 1 then --Simul
			if data.simulType == "Tag" then
				for i=2, p2numChars*2 do
					if i % 2 == 0 then --even value
						if data.p2In == 2 and not data.aiFight and data.tagmode == 1 then
							setCom(i, 0)
							remapInput(i,2)
							setTag(i, f_tagMode(i, tagset))
						else
							setCom(i, f_difficulty(i, offset))
							setTag(i, f_tagMode(i, tagset))
						end
					end
				end
			else --data.simulType == "Assist"
				if data.p2In == 2 and not data.aiFight then
					setCom(2, 0)
					setTag(2, f_tagMode(2, tagset))
				else
					setCom(2, f_difficulty(2, offset))
					setTag(2, f_tagMode(2, tagset))
				end
				for i=4, p2numChars*2 do
					if i % 2 == 0 then
						setCom(i, f_difficulty(i, offset))
						setTag(i, f_tagMode(i, tagset))
					end
				end
			end
		elseif p2teamMode == 2 then --Turns
			for i=2, p2numChars*2 do
				if i % 2 == 0 then
					if data.p2In == 2 and not data.aiFight then
						setCom(i, 0)
						--setTag(i, f_tagMode(i, tagset))
					else
						setCom(i, f_difficulty(i, offset))
						--setTag(i, f_tagMode(i, tagset))
					end
				end
			end
		end
	end
end

function f_selectChar(player, t)
	for i=1, #t do
		selectChar(player, t[i].cel, t[i].pal)
	--Set Handicaps that cannont be asigned via debug.lua
		if data.gameMode == "versus" or data.ftcontrol > 0 then
			if t_handicapSelect[t[i].handicap].service == "unlimitedpower" then
				--setPowerUnlimited(player, true)
				if player == 1 then
					setPowerStateP1(666) --temporarily Reusing Training Service
				elseif player == 2 then
					setPowerStateP2(666)
				end
			end
	--Set Abyss Mode Special Attributes
		elseif data.gameMode == "abyss" then
		--[[
			if then
				setAutoguard(player, true)
			elseif then
				
			end
		]]
		end
	end
--Transfer data.t_p1selected and data.t_p2selected to p1Dat and p2Dat (global access tables) in order to access in pause menu or debug.lua scripts
	if player == 1 then
		--p1Dat = {}
		p1Dat = t
	elseif player == 2 then
		--p2Dat = {}
		p2Dat = t
	end
	f_savePlayerDat()
end

function f_findCelYAdd(selY, faceOffset, offsetRow)
	selY = selY + 1
	if selY >= selectRows+offsetRows then
		if wrappingY then
			faceOffset = 0
			offsetRow = 0
			selY = 0
		else
			selY = selY - 1
		end
	elseif selY >= selectRows+offsetRow then
		faceOffset = faceOffset + selectColumns
		offsetRow = offsetRow + 1
	end
	return selY, faceOffset, offsetRow
end

function f_findCelYSub(selY, faceOffset, offsetRow)
	selY = selY - 1
	if selY < 0 then
		if wrappingY then
			faceOffset = offsetRows * selectColumns
			offsetRow = offsetRows
			selY = selectRows + offsetRows - 1
		else
			selY = selY + 1
		end
	elseif selY < offsetRow then
		faceOffset = faceOffset - selectColumns
		offsetRow = offsetRow - 1
	end
	return selY, faceOffset, offsetRow
end

function f_findCelXAdd(selX, wrapX)
	selX = selX + 1
	if selX >= selectColumns then
		if wrapX then
			selX = 0
		else
			selX = selX - 1
		end
	end
	return selX
end

function f_findCelXSub(selX, wrapX)
	selX = selX - 1
	if selX < 0 then
		if wrapX then
			selX = selectColumns - 1
		else
			selX = selX + 1
		end
	end
	return selX
end

--[[ Unfinished Hidden Columns Functions
function f_findCelXAdd(selX, faceOffset, offsetColumn)
	selX = selX + 1
	if selX >= selectColumns+offsetColumns then
		if wrappingX then
			faceOffset = 0
			offsetColumn = 0
			selX = 0
		else
			selX = selX - 1
		end
	elseif selX >= selectColumns+offsetColumn then
		faceOffset = faceOffset + selectRows
		offsetColumn = offsetColumn + 1
	end
	return selX, faceOffset, offsetColumn
end

function f_findCelXSub(selX, faceOffset, offsetColumn)
	selX = selX - 1
	if selX < 0 then
		if wrappingX then
			faceOffset = offsetColumns * selectRows
			offsetColumn = offsetColumns
			selX = selectColumns + offsetColumns - 1
		else
			selX = selX + 1
		end
	elseif selX < offsetColumn then
		faceOffset = faceOffset - selectRows
		offsetColumn = offsetColumn - 1
	end
	return selX, faceOffset, offsetColumn
end
]]

function f_winCoins()
	if not onlinegame then	
		if coinSystem then
			stats.coins = stats.coins + 5 --Earn 5 Coins by Win :)
			--sndPlay(sndSys, 200, 0) --Coin Earned Song
			f_saveStats()
		else
			--Do nothing and don't lose or win coins
		end
	else
		--Do nothing and don't lose or win coins
	end
end

function f_loseCoins()
	if coinSystem then
		if stats.coins < 1 then
			stats.coins = 0
		elseif stats.coins >= 1 then
			stats.coins = stats.coins - 1 --Lose 1 Coin by be defeated :c
			f_saveStats()
		end
	else
		--Do nothing and don't lose or win coins
	end
end

--Services/Handicaps Reset
function f_resetHandicaps()
setService("")
if not data.autoguard then
	for i=1, 8 do setAutoguard(i, false) end
end
setLifeStateP1(-1)
setLifeStateP2(-1)
setPowerStateP1(-1)
setPowerStateP2(-1)
end

--;===========================================================
--; BACK TO MAIN MENU
--;===========================================================
function f_backMenu()
	cmdInput()
	--Cursor position
	if commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u') then
		sndPlay(sndSys, 100, 0)
		backMenu = backMenu - 1
	elseif commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd') then
		sndPlay(sndSys, 100, 0)
		backMenu = backMenu + 1
	end
	if backMenu < 1 then
		backMenu = #t_backMenu
		if #t_backMenu > 4 then
			cursorPosYBack = 4
		else
			cursorPosYBack = #t_backMenu-1
		end
	elseif backMenu > #t_backMenu then
		backMenu = 1
		cursorPosYBack = 0
	elseif (commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u')) and cursorPosYBack > 0 then
		cursorPosYBack = cursorPosYBack - 1
	elseif (commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd')) and cursorPosYBack < 4 then
		cursorPosYBack = cursorPosYBack + 1
	end
	if cursorPosYBack == 4 then
		moveTxtBack = (backMenu - 5) * 13
	elseif cursorPosYBack == 0 then
		moveTxtBack = (backMenu - 1) * 13
	end
	--Draw Fade BG
	animDraw(fadeWindowBG)
	--Draw Menu BG
	animDraw(backWindowBG)
	animUpdate(backWindowBG)
	--Draw Title
	textImgDraw(txt_backquestion)
	--Draw Table Text
	for i=1, #t_backMenu do
		if i == backMenu then
			bank = 5
		else
			bank = 0
		end
		textImgDraw(f_updateTextImg(t_backMenu[i].id, jgFnt, bank, 0, t_backMenu[i].text, 159, 120+i*13-moveTxtBack))
	end
	--Draw Cursor
	animSetWindow(cursorBox, 87,123+cursorPosYBack*13, 144,13)
	f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
	animDraw(f_animVelocity(cursorBox, -1, -1))
	--Draw Input Hints Panel
	drawConfirmInputHints()
	--Actions
	if btnPalNo(p1Cmd) > 0 or btnPalNo(p2Cmd) > 0 then
		--YES
		if backMenu == 1 then
			sndPlay(sndSys, 100, 2)
			commandBufReset(p1Cmd)
			commandBufReset(p2Cmd)
			data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
			if waitingTowerSel then
				data.tempBack = true
			else
				f_resetHandicaps()
				back = true
			end
		--NO
		else
			sndPlay(sndSys, 100, 1)
			commandBufReset(p1Cmd)
			commandBufReset(p2Cmd)
			if waitingTowerSel then
				
			else
				if data.gameMode == "arcade" or data.gameMode == "tower" then --Fixed issue in Back Menu from Character Select when selecting NO option in Arcade Mode: https://user-images.githubusercontent.com/18058378/260328520-85c78494-7586-4bfe-acd1-cd703d9e3548.png
					--f_rosterReset() --Delete?
					if (data.p1In == 2 and data.p2In == 2) then --Player 1 in player 2 (right) side
						p2Cell = nil
						p2Portrait = nil
						data.t_p2selected = {}
						p2PalEnd = false
						p2SelEnd = false
					else
						p1Cell = nil
						p1Portrait = nil
						data.t_p1selected = {}
						p1PalEnd = false
						p1SelEnd = false
					end
					if data.coop then
						p2Cell = nil
						p2Portrait = nil
						data.t_p2selected = {}
						p2PalEnd = false
						p2SelEnd = false
					end
				else
					f_selectReset()
				end
				if data.rosterAdvanced == true and data.stageMenu == false then stageEnd = true end
			end
			back = false
		end
		f_backReset()
	end
	cmdInput()
end

function f_backReset()
	backScreen = false
	moveTxtBack = 0
	--Cursor pos in YES
	cursorPosYBack = 0
	backMenu = 1
end

function f_exitOnline()
	while true do
		back = true
		break
		cmdInput()
		refresh()
	end
end

function f_resetP2CoopInput()
	if onlinegame and data.coop then
		for i=1, p1numChars+p2numChars do
			setCom(i, 0) --Fix player 2 control lose when exit from online mode, reconnects and re-enter in Co-Op Mode
		end
	end
end

function f_resetMenuAssets()
	if data.attractMode == true then playBGM(bgmTitle) else	f_menuMusic() end
	exitAbyss = true
	backtomenu = false --Restart special back for Challenger Mode
	data.tempBack = false
	f_saveTemp()
	f_resetMenuInputs()
end

function f_exitSelect() --For Simple/Story Select
--Right Side have control in Char Select (CPU Vs Human)
	if (data.p1In == 2 and data.p2In == 2) then
		if p2TeamBack == true then
			if backScreen == false then sndPlay(sndSys, 100, 2) end
			backScreen = true
		end
--Left Side have control in Char Select (Human Vs CPU)
	elseif (data.p2In == 1 or data.p2In == 0) then
		if p1TeamBack == true then
			if backScreen == false then sndPlay(sndSys, 100, 2) end
			backScreen = true
		end
--Left Side and Right Side have control in Char Select (Human Vs Human)
	elseif data.p1In == 1 and data.p2In == 2 then
		if p1TeamBack == true and p2TeamBack == true then
			if backScreen == false then sndPlay(sndSys, 100, 2) end
			backScreen = true
		end
	end
end

function f_exitSelect2() --For Advanced Select
--Right Side have control in Char Select (CPU Vs Human)
	if (data.p1In == 2 and data.p2In == 2) then
		if p2TeamBack == true then
			if backScreen == false then sndPlay(sndSys, 100, 2) end
			backScreen = true
		end
--Left Side have control in Char Select (Human Vs CPU)
	else
		if p1TeamBack == true then
			if backScreen == false then sndPlay(sndSys, 100, 2) end
			backScreen = true
		end
	end
end

function f_exitSelect3() --For Advanced Select after Continue Screen
	if backScreen == false then sndPlay(sndSys, 100, 2) end
	backScreen = true
end

function f_exitToMainMenu() --For Advanced Select
	data.tempBack = false
	f_saveTemp()
	exitAbyss = true
	if data.attractMode == true then playBGM(bgmTitle) else	f_menuMusic() end
	f_resetMenuInputs()
	f_resetMenuArrowsPos()
end

function validCells()
--[[
If added columns and rows are more than inserted characters. Don't start char select because while you are scrolling
at some point you will have a error message related with this and well, we can notify to the user about it with an informative message..
]]
	if (data.selectColumns+data.offsetColumns)*(data.selectRows+data.offsetRows) > #t_selChars then
		return false --Config Not Valid
	else
		return true  --Config Valid
	end
end

txt_msgIce = createTextImg(jgFnt, 0, 1, "", 0, 0)
txt_charsNumpa = createTextImg(jgFnt, 0, 1, "("..#t_selChars..")", 250, 235)
txt_cellIssue = [[
 INVALID CHARACTER SELECT CELLS CONFIG!

GO TO: OPTIONS ->
   SYSTEM SETTINGS ->
      CHARACTER SELECT SETTINGS ->
         [EDIT ROSTER]

AND MAKE SURE THAT:
		   
[ROWS] ADDED + [HIDDEN ROWS] ADDED
MULTIPLIED(*) BY THE NUMBER OF
[COLUMNS] ADDED + [HIDDEN COLUMNS] ADDED

IS NOT GREATER (>) THAN THE NUMBER OF
CHARACTERS SLOTS ADDED IN SELECT.DEF
]]
function f_invalidCells()
	cmdInput()
	while true do
		if esc() or btnPalNo(p1Cmd) > 0 or btnPalNo(p2Cmd) > 0 then
			sndPlay(sndSys, 100, 2)
			data.fadeTitle = f_fadeAnim(50, 'fadein', 'black', sprFade)
			break
		end
        f_textRender(txt_msgIce, txt_cellIssue, 0, 2, 10, 15, 0, -1)
        textImgDraw(txt_charsNumpa)
		animDraw(data.fadeTitle)
        animUpdate(data.fadeTitle)
		cmdInput()
		refresh()
	end
end

--;===========================================================
--; CHARACTER SELECT SCREEN
--;===========================================================
function f_selectScreen()
--Draw Character Select Last Match Backgrounds
	if matchNo == lastMatch then
		animDraw(f_animVelocity(selectHardBG0, -1, -1)) --Draw Red BG for Final Battle
--Draw Character Select Normal Matchs Backgrounds
	else
		--Draw Black BG only for Tower/Abyss Mode
		if data.gameMode == "tower" or data.gameMode == "abyss" then
			animDraw(f_animVelocity(selectTowerBG0, -1, -1))
		--Draw Red BG for Special Modes
		elseif data.gameMode == "bossrush" or data.gameMode == "singleboss" or data.rosterMode == "suddendeath" or data.gameMode == "intermission" then
			animDraw(f_animVelocity(selectHardBG0, -1, -1))
		--Draw Blue BG for Normal Modes
		else
			animDraw(f_animVelocity(commonBG0, -1, -1))
		end
	end
--Player 1 Selection		
	if not p1TeamEnd then
		f_p1TeamMenu() --Team Mode Select
	elseif data.p1In > 0 or data.p1Char ~= nil then
		f_p1SelectMenu() --Character Select
		if (data.p1In == 2 and data.p2In == 2) then
			--Draw VS Single Bosses Portraits if you are playing in Right Side
			if data.gameMode == "singleboss" then
				if data.charPresentation == "Portrait" or data.charPresentation == "Mixed" then
					animDraw(f_animVelocity(charBG2, 2, 0))
					drawPortrait(data.t_p1selected[1].cel, 0, 20, 1, 1)
				end
				if data.charPresentation == "Sprite" or data.charPresentation == "Mixed" then
					for j=#data.t_p1selected, 1, -1 do
						--f_drawCharAnim(t_selChars[data.t_p1selected[j].cel+1], 'p1AnimStand', 100, 158, data.t_p1selected[j].up) --Stand Animation
						f_drawCharAnim(t_selChars[data.t_p1selected[j].cel+1], 'p1AnimWin', 100, 158, data.t_p1selected[j].up) --Selected/Win Animation
					end
				end
				--Draw Author Info Text
				if data.charInfo == "Author" then
					if t_selChars[data.t_p1selected[1].cel+1].author ~= nil then
						textImgSetText(txt_p1Author, txt_authorText..t_selChars[data.t_p1selected[1].cel+1].author)
						textImgDraw(txt_p1Author)
					end
				end
			end
			--Draw VS Single Bonus Portraits
			if data.gameMode == "singlebonus" then
				if data.charPresentation == "Portrait" or data.charPresentation == "Mixed" then
					animDraw(f_animVelocity(charBG2, 2, 0))
					drawPortrait(data.t_p1selected[1].cel, 0, 20, 1, 1)
				end
				--Draw Author Info Text
				if data.charInfo == "Author" then
					if t_selChars[data.t_p1selected[1].cel+1].author ~= nil then
						textImgSetText(txt_p1Author, txt_authorText..t_selChars[data.t_p1selected[1].cel+1].author)
						textImgDraw(txt_p1Author)
					end
				end
			end
		end
	end
--Player 2 Selection
	if not p2TeamEnd then
		if data.gameMode == "tourney" and not tourneyCharSel then
			p2TeamEnd = true
		else
			f_p2TeamMenu()
		end
	elseif data.p2In > 0 or data.p2Char ~= nil then
		if data.gameMode == "tourney" and not tourneyCharSel then
			p2SelEnd = true
		else
			f_p2SelectMenu()
			if (data.p1In ~= 2 and data.p2In ~= 2) then
				--Draw VS Single Bosses Portraits if you are playing in Left Side
				if data.gameMode == "singleboss" then
					if data.charPresentation == "Portrait" or data.charPresentation == "Mixed" then
						animDraw(f_animVelocity(charBG3, 2, 0))
						drawPortrait(data.t_p2selected[1].cel, 320, 20, -1, 1)
					end
					if data.charPresentation == "Sprite" or data.charPresentation == "Mixed" then
						for j=#data.t_p2selected, 1, -1 do
							--f_drawCharAnim(t_selChars[data.t_p2selected[j].cel+1], 'p2AnimStand', 220, 158, data.t_p2selected[j].up) --Stand Animation
							f_drawCharAnim(t_selChars[data.t_p2selected[j].cel+1], 'p2AnimWin', 220, 158, data.t_p2selected[j].up) --Selected/Win Animation
						end
					end
					--Draw Author Info Text
					if data.charInfo == "Author" then
						if t_selChars[data.t_p2selected[1].cel+1].author ~= nil then
							textImgSetText(txt_p2Author, txt_authorText..t_selChars[data.t_p2selected[1].cel+1].author)
							textImgDraw(txt_p2Author)
						end
					end
				end
				--Draw VS Single Bonus Portraits
				if data.gameMode == "singlebonus" then
					if data.charPresentation == "Portrait" or data.charPresentation == "Mixed" then
						animDraw(f_animVelocity(charBG3, 2, 0))
						drawPortrait(data.t_p2selected[1].cel, 320, 20, -1, 1)
					end
					--Draw Author Info Text
					if data.charInfo == "Author" then
						if t_selChars[data.t_p2selected[1].cel+1].author ~= nil then
							textImgSetText(txt_p2Author, txt_authorText..t_selChars[data.t_p2selected[1].cel+1].author)
							textImgDraw(txt_p2Author)
						end
					end
				end
			end
		end
	end
--Cells
	if not stageMenuActive then
		if data.p2Faces and data.selectType == "Advanced" then
			animDraw(f_animVelocity(selectBG1a, -1, 0))
			animSetWindow(selectBG1a, 0, 0, 147, 219)
			animDraw(f_animVelocity(selectBG1b, -1, 0))
			animSetWindow(selectBG1b, 173, 0, 147, 219)
		else
			animDraw(f_animVelocity(selectBG1c, -1, 0))
			animSetWindow(selectBG1c, 85, 0, 151, 239)
			--animSetWindow(selectBG1c, 85, 0, 151, 239)
		end
	end
	animDraw(f_animVelocity(selectBG2a, -1, 0))
	animDraw(f_animVelocity(selectBG2b, -3, 0))
	animDraw(f_animVelocity(selectBG2c, -6, 0))
	if not exclusiveStageMenu then
		textImgSetPos(txt_mainSelect, 159, 13)
		textImgDraw(txt_mainSelect)
	end
	if not stageMenuActive then
		drawFace(p1FaceX, p1FaceY, p1FaceOffset) --Draw Character Face Portrait
		for i=0, selectColumns-1 do
			for j=0, selectRows-1 do
				animPosDraw(selectCell, p1FaceX+i*(cellSizeX+cellSpacingX), p1FaceY+j*(cellSizeY+cellSpacingY)) --Draw cell sprite for each selectColumns and selectRow
				animSetScale(selectCell, data.cellScaleX, data.cellScaleY)
				--[[Draw Locked Icon
				if t_unlockLua.chars[t_selChars[(p1SelX+selectColumns*p1SelY)+1].char] ~= nil and not onlinegame then
					animPosDraw(cellLock, p1FaceX+i*(cellSizeX+cellSpacingX), p1FaceY+j*(cellSizeY+cellSpacingY)) --Draw Lock Icon if the character is locked
				end
				]]
			end
		end
		if (data.p2Faces and data.selectType == "Advanced") or not data.p1SelectMenu then
			drawFace(p2FaceX, p2FaceY, p2FaceOffset)
			for i=0, selectColumns-1 do
				for j=0, selectRows-1 do
					animPosDraw(selectCell, p2FaceX+i*(cellSizeX+cellSpacingX), p2FaceY+j*(cellSizeY+cellSpacingY))
					animSetScale(selectCell, data.cellScaleX, data.cellScaleY)
				end
			end
		end
		--Draw Active Cursors
		if p1TeamEnd and not p1SelEnd then
			animPosDraw(p1ActiveCursor, p1FaceX+p1SelX*(cellSizeX+cellSpacingX), p1FaceY+(p1SelY-p1OffsetRow)*(cellSizeY+cellSpacingY))
			animSetScale(p1ActiveCursor, data.cellScaleX, data.cellScaleY)
		end
		if p2TeamEnd and not p2SelEnd then
			animPosDraw(p2ActiveCursor, p2FaceX+p2SelX*(cellSizeX+cellSpacingX), p2FaceY+(p2SelY-p2OffsetRow)*(cellSizeY+cellSpacingY))
			animSetScale(p2ActiveCursor, data.cellScaleX, data.cellScaleY)
		end
	end
--Character Select Timer
	if data.gameMode == "arcade" or data.gameMode == "tower" or data.ftcontrol > 0 or data.attractMode == true then
		charTimeNumber = selectTimer/gameTick --Convert Ticks to Seconds
		nodecimalCharTime = string.format("%.0f",charTimeNumber) --Delete Decimals
		textImgSetText(txt_charTime, nodecimalCharTime)
		if selectTimer > 0 then
			if not backScreen then selectTimer = selectTimer - 0.5 end --Activate Character Select Timer
			textImgDraw(txt_charTime)
		else --when selectTimer <= 0
			
		end
	end
--Win Count
	if (data.gameMode == "versus" or data.gameMode == "tourney") and data.vsDisplayWin == true then
		textImgSetText(txt_p1Wins, "WINS: " .. p1Wins)
		textImgSetText(txt_p2Wins, "WINS: " .. p2Wins)
		textImgDraw(txt_p1Wins)
		textImgDraw(txt_p2Wins)
	end
--Palette Select
	if data.palType == "Modern" then
		--Player1
		if p1CharEnd and not p1PalEnd then
			cmdInput() --Remove to allow player 2 move his cursor during player 1 pal select
			f_p1SelectPal()
		end
		--Player2
		if p2CharEnd and not p2PalEnd then
			cmdInput() --Remove to allow player 1 move his cursor during player 2 pal select
			f_p2SelectPal()
		end
	end
--Handicap Select
	if data.gameMode == "versus" or data.ftcontrol == -1 then
		--Player1
		if p1PalEnd and not p1HandicapEnd then
			cmdInput()
			f_p1SelectHandicap()
		end
		--Player2
		if p2PalEnd and not p2HandicapEnd then
			cmdInput()
			f_p2SelectHandicap()
		end
	end
--Stage select
	if p1SelEnd and p2SelEnd then
		charSelect = false
		selectTimer = 0 --Disappear Char Select Timer to don't disturb Stage Timer
		if not stageEnd then
			if data.gameMode ~= "tourney" then
				f_selectStage()
			else
				stageMenuActive = false
				exclusiveStageMenu = false
				selScreenEnd = true
			end
		else
			stageMenuActive = false
			exclusiveStageMenu = false
			selScreenEnd = true
		end
	end
--Activate Stage Announcer Timer
	if stageAnnouncer == true then
		announcerTimer = announcerTimer + 1
	end
--Deselect Character for Left Side
	if data.coop then
		if commandGetState(p1Cmd, 'e') and p1SelEnd then
			sndPlay(sndSys, 100, 2)
			p1SelEnd = false
			data.t_p1selected = {}
			p1memberPreview = 1
			f_p1randomReset()
		end
	else
		--[[
		if commandGetState(p1Cmd, 'e') and p1SelEnd and charSelect == true then
			sndPlay(sndSys, 100, 2)
			p1SelEnd = false
			data.t_p1selected = {}
			p1memberPreview = 1
			f_p1randomReset()
			if data.p2In == 1 then
				p2TeamEnd = true
				p2SelEnd = true
				p2Portrait = nil
				p2memberPreview = 1
				f_p2randomReset()
			end
		end
		]]
	end
--Deselect Character for Right Side
	if data.p2In == 2 then
		if data.coop then
			if commandGetState(p2Cmd, 'e') and p2SelEnd then
				sndPlay(sndSys, 100, 2)
				--if data.p2In == 2 then
					p2SelEnd = false
				--end
				data.t_p2selected = {}
				--p2memberPreview = 1
				f_p2randomReset()
				p2coopReady = false
			end
		else
			--[[
			if commandGetState(p2Cmd, 'e') and p2SelEnd and charSelect == true then 
				sndPlay(sndSys, 100, 2)
				--if data.p2In == 2 then
					p2SelEnd = false
				--end
				data.t_p2selected = {}
				p2memberPreview = 1
				f_p2randomReset()
			end
			]]
		end
	end
--Show Back Menu
	if backScreen then
		if onlinegame == false then
			f_backMenu()
		elseif onlinegame == true then
			f_exitOnline()
		end
	else
		if not stageMenuActive then
			drawSelectInputHints()
		else
			drawStageInputHints()
		end
	end
	animDraw(data.fadeSelect)
	animUpdate(data.fadeSelect)
	animDraw(data.fadeTitle)
	animUpdate(data.fadeTitle)
	cmdInput()
	refresh()
end

--;===========================================================
--; PLAYER 1 TEAM SELECT
--;===========================================================
function f_p1TeamMenu()
	if data.coop then --Simul coop
		p1teamMode = 1
		p1numChars = 2
		setTeamMode(1, p1teamMode, p1numChars)
		p1TeamEnd = true
		p1BG = true
		p1memberPreview = 1
	elseif data.p1TeamMenu ~= nil then
		p1numChars = data.p1TeamMenu.chars
		p1teamMode = data.p1TeamMenu.mode
		setTeamMode(1, p1teamMode, p1numChars)
		p1TeamEnd = true
		p1BG = true
		p1memberPreview = 1
	else
		--Back logic when you are selecting CPU Team Mode in CPU Vs Human
		if commandGetState(p2Cmd, 'e') and (data.p1In == 2 and data.p2In == 2) then --p2Cmd because human is in right side
			if p1TeamBack == true then
				if (data.p1In == 2 and data.p2In == 2) then
					sndPlay(sndSys, 100, 2)
					f_p1sideReset()
					p1TeamEnd = true
					p1SelEnd = true
					f_p2sideReset()
					p2TeamEnd = true
					p2BG = true
					p2memberPreview = 1
					p2SelBack = true
					p2TeamBack = false
				end
			end
		end
		if backScreen == false then
			if commandGetState(p1Cmd, 'u') or (commandGetState(p1Cmd, 'holdu') and bufTmu >= 30) then
				sndPlay(sndSys, 100, 0)
				p1teamMode = p1teamMode - 1
				if p1teamMode < 0 then p1teamMode = #t_p1selTeam-1 end
				if bufTml then bufTml = 0 end
				if bufTmr then bufTmr = 0 end
			elseif commandGetState(p1Cmd, 'd') or (commandGetState(p1Cmd, 'holdd') and bufTmd >= 30) then
				sndPlay(sndSys, 100, 0)
				p1teamMode = p1teamMode + 1
				if p1teamMode > #t_p1selTeam-1 then p1teamMode = 0 end
				if bufTml then bufTml = 0 end
				if bufTmr then bufTmr = 0 end
			elseif p1teamMode == 1 then --Simul
				if commandGetState(p1Cmd, 'l') or (commandGetState(p1Cmd, 'holdl') and bufTml >= 30) then
					if commandGetState(p1Cmd, 'l') and p1numSimul > 2 then sndPlay(sndSys, 100, 0) end
					p1numSimul = p1numSimul - 1
					if p1numSimul < 2 then p1numSimul = 2 end
					if bufTmu then bufTmu = 0 end
					if bufTmd then bufTmd = 0 end
				elseif commandGetState(p1Cmd, 'r') or (commandGetState(p1Cmd, 'holdr') and bufTmr >= 30) then
					if commandGetState(p1Cmd, 'r') and p1numSimul < data.numSimul then sndPlay(sndSys, 100, 0) end
					p1numSimul = p1numSimul + 1
					if p1numSimul > data.numSimul then p1numSimul = data.numSimul end
					if bufTmu then bufTmu = 0 end
					if bufTmd then bufTmd = 0 end
				end
				if commandGetState(p1Cmd, 'holdr') then
					bufTml = 0
					bufTmr = bufTmr + 1
				elseif commandGetState(p1Cmd, 'holdl') then
					bufTmr = 0
					bufTml = bufTml + 1
				else
					bufTmr = 0
					bufTml = 0
				end
			elseif p1teamMode == 2 then --Turns
				if commandGetState(p1Cmd, 'l') or (commandGetState(p1Cmd, 'holdl') and bufTml >= 30) then
					if commandGetState(p1Cmd, 'l') and p1numTurns > 2 then sndPlay(sndSys, 100, 0) end
					p1numTurns = p1numTurns - 1
					if p1numTurns < 2 then p1numTurns = 2 end
					if bufTmu then bufTmu = 0 end
					if bufTmd then bufTmd = 0 end
				elseif commandGetState(p1Cmd, 'r') or (commandGetState(p1Cmd, 'holdr') and bufTmr >= 30) then
					if commandGetState(p1Cmd, 'r') and p1numTurns < data.numTurns then sndPlay(sndSys, 100, 0) end
					p1numTurns = p1numTurns + 1
					if p1numTurns > data.numTurns then p1numTurns = data.numTurns end
					if bufTmu then bufTmu = 0 end
					if bufTmd then bufTmd = 0 end
				end
				if commandGetState(p1Cmd, 'holdr') then
					bufTml = 0
					bufTmr = bufTmr + 1
				elseif commandGetState(p1Cmd, 'holdl') then
					bufTmr = 0
					bufTml = bufTml + 1
				else
					bufTmr = 0
					bufTml = 0
				end
			end
			if commandGetState(p1Cmd, 'holdu') then
				bufTmd = 0
				bufTmu = bufTmu + 1
			elseif commandGetState(p1Cmd, 'holdd') then
				bufTmu = 0
				bufTmd = bufTmd + 1
			else
				bufTmu = 0
				bufTmd = 0
			end
		end
		if data.p1In == 2 then
			textImgDraw(IASelTmTxt)
		elseif data.rosterMode == "cpu" then
			textImgDraw(IASelTmTxt)
		else
			textImgDraw(p1SelTmTxt)
		end
		for i=1, #t_p1selTeam do
			if i == p1teamMode + 1 then
				textImgSetBank(t_p1selTeam[i].id, 3)
			else
				textImgSetBank(t_p1selTeam[i].id, 0)
			end
			textImgDraw(t_p1selTeam[i].id)
		end
		--Only appears until you select a team mode
		animUpdate(p1TmIcon)
		animDraw(p1EmptyIcon)
	    animUpdate(p1EmptyIcon)
	    animDraw(p1EmptyIcon2)
		animUpdate(p1EmptyIcon2)
		animDraw(p1EmptyIcon3)
		animUpdate(p1EmptyIcon3)
		animDraw(p1EmptyIcon4)
		animUpdate(p1EmptyIcon4)
		animDraw(p1EmptyIcon5)
		animUpdate(p1EmptyIcon5)
		animDraw(p1EmptyIcon6)
		animUpdate(p1EmptyIcon6)
		animDraw(p1EmptyIcon7)
		animUpdate(p1EmptyIcon7)
		animDraw(p1EmptyIcon8)
		animUpdate(p1EmptyIcon8)
		for i=1, p1numSimul do
			animPosDraw(p1TmIcon, 74 + i*6, 66)
		end
		for i=1, p1numTurns do
			animPosDraw(p1TmIcon, 74 + i*6, 81)
		end
		animUpdate(p1TmCursor)
		animPosDraw(p1TmCursor, 10, 50 + p1teamMode*15)
		if btnPalNo(p1Cmd) > 0 or selectTimer == 0 then
			sndPlay(sndSys, 100, 1)
			if p1teamMode == 0 then --Single
				p1numChars = 1
			elseif p1teamMode == 1 then --Simul
				p1numChars = p1numSimul
			elseif p1teamMode == 2 then --Turns
				p1numChars = p1numTurns
			end
			setTeamMode(1, p1teamMode, p1numChars)
			p1TeamEnd = true
			p1BG = true
			p1memberPreview = 1
			p1SelBack = true
			p1TeamBack = false
			cmdInput()
		end
	end
end

--;===========================================================
--; PLAYER 1 CHARACTER SELECTING
--;===========================================================
function f_p1SelectMenu()
--Load P1 Custom Character
	if data.p1Char ~= nil then
		local t_p1CharID = {} --Create new table to store data.p1Char information and avoid overwrite that data
		for i, v in ipairs(data.p1Char) do
			t_p1CharID[i] = string.lower(v) --Convert each element to lowercase to avoid issues
		end
		for item=1, #t_p1CharID do
			t_p1CharID[item] = t_charAdd[t_p1CharID[item]] --Convert each element to character ID
		end
		local t = {}
		for i=1, #t_p1CharID do
			local updateAnim = false
			if t[t_p1CharID[i]] == nil then
				updateAnim = true
				t[t_p1CharID[i]] = ''
			end
			if data.p1Pal ~= nil then --Set Manual Palette
				data.t_p1selected[i] = {['cel'] = t_p1CharID[i], ['pal'] = data.p1Pal, ['handicap'] = p1HandicapSel, ['up'] = updateAnim, ['name'] = t_selChars[t_p1CharID[i]+1].name, ['displayname'] = t_selChars[t_p1CharID[i]+1].displayname, ['path'] = t_selChars[t_p1CharID[i]+1].char, ['author'] = t_selChars[t_p1CharID[i]+1].author}
			else
				data.t_p1selected[i] = {['cel'] = t_p1CharID[i], ['pal'] = math.random(1,12), ['handicap'] = p1HandicapSel, ['up'] = updateAnim, ['name'] = t_selChars[t_p1CharID[i]+1].name, ['displayname'] = t_selChars[t_p1CharID[i]+1].displayname, ['path'] = t_selChars[t_p1CharID[i]+1].char, ['author'] = t_selChars[t_p1CharID[i]+1].author}
			end
			if data.debugLog then f_printTable(data.t_p1selected, "save/debug/data.t_p1selected.txt") end
		end
		p1Portrait = t_p1CharID[1]
		--local numChars = p1numChars
		--if data.coop then numChars = 1 end
		p1SelEnd = true
--Skip P1 Character Select
	elseif not data.p1SelectMenu then
		if data.gameMode == "challenger" then
			data.t_p1selected = t_p1selectedTemp --Get previous arcade selected characters
			if data.debugLog then f_printTable(data.t_p1selected, "save/debug/data.t_p1selected.txt") end
		end
		p1SelEnd = true
--Start P1 Character Select
	else
		if not exclusiveStageMenu then
			if data.charPresentation == "Portrait" or data.charPresentation == "Mixed" then
				if p1BG == true then animDraw(f_animVelocity(charBG2, -2, 0)) end --Draw P1 Portrait BG
			end
		end
		local numChars = p1numChars
		local alphaS = 200
		if data.coop then numChars = 1 end
		if p1Cell then
		--Waiting Selection
			if numChars ~= #data.t_p1selected then
				local updateAnim = true
				for i=1, #data.t_p1selected do
					if data.t_p1selected[i].cel == p1Cell then 
						updateAnim = false
					end
				end
			--Cursor in Random Select Slot
				if getCharName(p1Cell) == "Random" then
					--sndPlay(sndSys, 100, 0) --Play Cursor SFX...
				--DRAW RANDOM PORTRAITS
					if data.charPresentation == "Portrait" or data.charPresentation == "Mixed" then
						--drawPortrait(t_randomChars[math.random(#t_randomChars)], 0+60*(#data.t_p1selected-1), 20, 1, 1) --Draw P1 RANDOM PREVIEW Portrait with automatic X position for all members (instead of use p1numChars logic)
					--SINGLE MODE
						if p1numChars == 1 then
							if data.randomPortrait == "Simple" or data.randomPortrait == "Fixed" then
								f_drawQuickSpr(p1randomPortrait, 0, 20)
							elseif data.randomPortrait == "Roulette" then --Draw P1 RANDOM PREVIEW Portrait (showing all characters loaded)
								drawPortrait(t_randomChars[math.random(#t_randomChars)], 0, 20, 1, 1)
							end
					--TEAM MODE WITH 2 MEMBERS
						elseif p1numChars == 2 then
						--Draw P1 Member 1 RANDOM PREVIEW Portrait
							if p1memberPreview == 1 then
								if data.randomPortrait == "Simple" or data.randomPortrait == "Fixed" then
									if data.charPresentation == "Portrait" then
										f_drawQuickSpr(p1randomPortrait, 0, 20, 1, 0.5)
									elseif data.charPresentation == "Mixed" then
										f_drawQuickSpr(p1randomPortrait, 0, 20, 0.5, 0.5)
									end
								elseif data.randomPortrait == "Roulette" then
									if data.charPresentation == "Portrait" then
										drawPortrait(t_randomChars[math.random(#t_randomChars)], 0, 20, 1, 0.5)
									elseif data.charPresentation == "Mixed" then
										drawPortrait(t_randomChars[math.random(#t_randomChars)], 0, 20, 0.5, 0.5)
									end
								end
							end
						--Draw P1 Member 2 RANDOM PREVIEW Portrait
							if p1memberPreview == 2 then
								if data.randomPortrait == "Simple" or data.randomPortrait == "Fixed" then
									if data.charPresentation == "Portrait" then
										f_drawQuickSpr(p1randomPortrait, 0, 90, 1, 0.5)
									elseif data.charPresentation == "Mixed" then
										f_drawQuickSpr(p1randomPortrait, 0, 90, 0.5, 0.5)
									end
								elseif data.randomPortrait == "Roulette" then
									if data.charPresentation == "Portrait" then
										drawPortrait(t_randomChars[math.random(#t_randomChars)], 0, 90, 1, 0.5)
									elseif data.charPresentation == "Mixed" then
										drawPortrait(t_randomChars[math.random(#t_randomChars)], 0, 90, 0.5, 0.5)
									end
								end
							end
					--TEAM MODE WITH 3 MEMBERS
						elseif p1numChars == 3 then
						--Draw P1 Member 1 RANDOM PREVIEW Portrait
							if p1memberPreview == 1 then
								if data.randomPortrait == "Simple" or data.randomPortrait == "Fixed" then
									if data.charPresentation == "Portrait" then
										f_drawQuickSpr(p1randomPortrait, 0, 20, 1, 0.5)
									elseif data.charPresentation == "Mixed" then
										f_drawQuickSpr(p1randomPortrait, 30, 20, 0.5, 0.5)
									end
								elseif data.randomPortrait == "Roulette" then
									if data.charPresentation == "Portrait" then
										drawPortrait(t_randomChars[math.random(#t_randomChars)], 0, 20, 1, 0.5)
									elseif data.charPresentation == "Mixed" then
										drawPortrait(t_randomChars[math.random(#t_randomChars)], 30, 20, 0.5, 0.5)
									end
								end
							end
						--Draw P1 Member 2 RANDOM PREVIEW Portrait
							if p1memberPreview == 2 then
								if data.randomPortrait == "Simple" or data.randomPortrait == "Fixed" then
									f_drawQuickSpr(p1randomPortrait, 0, 90, 0.5, 0.5)
								elseif data.randomPortrait == "Roulette" then
									drawPortrait(t_randomChars[math.random(#t_randomChars)], 0, 90, 0.5, 0.5)
								end
							end
						--Draw P1 Member 3 RANDOM PREVIEW Portrait
							if p1memberPreview == 3 then
								if data.randomPortrait == "Simple" or data.randomPortrait == "Fixed" then
									f_drawQuickSpr(p1randomPortrait, 60, 90, 0.5, 0.5)
								elseif data.randomPortrait == "Roulette" then
									drawPortrait(t_randomChars[math.random(#t_randomChars)], 60, 90, 0.5, 0.5)
								end
							end
					--TEAM MODE WITH 4 MEMBERS
						elseif p1numChars == 4 then
						--Draw P1 Member 1 RANDOM PREVIEW Portrait
							if p1memberPreview == 1 then
								if data.randomPortrait == "Simple" or data.randomPortrait == "Fixed" then
									f_drawQuickSpr(p1randomPortrait, 0, 20, 0.5, 0.5)
								elseif data.randomPortrait == "Roulette" then
									drawPortrait(t_randomChars[math.random(#t_randomChars)], 0, 20, 0.5, 0.5)
								end
							end
						--Draw P1 Member 2 RANDOM PREVIEW Portrait
							if p1memberPreview == 2 then
								if data.randomPortrait == "Simple" or data.randomPortrait == "Fixed" then
									f_drawQuickSpr(p1randomPortrait, 60, 20, 0.5, 0.5)
								elseif data.randomPortrait == "Roulette" then
									drawPortrait(t_randomChars[math.random(#t_randomChars)], 60, 20, 0.5, 0.5)
								end
							end
						--Draw P1 Member 3 RANDOM PREVIEW Portrait
							if p1memberPreview == 3 then
								if data.randomPortrait == "Simple" or data.randomPortrait == "Fixed" then
									f_drawQuickSpr(p1randomPortrait, 0, 90, 0.5, 0.5)
								elseif data.randomPortrait == "Roulette" then
									drawPortrait(t_randomChars[math.random(#t_randomChars)], 0, 90, 0.5, 0.5)
								end
							end
						--Draw P1 Member 4 RANDOM PREVIEW Portrait
							if p1memberPreview == 4 then
								if data.randomPortrait == "Simple" or data.randomPortrait == "Fixed" then
									f_drawQuickSpr(p1randomPortrait, 60, 90, 0.5, 0.5)
								elseif data.randomPortrait == "Roulette" then
									drawPortrait(t_randomChars[math.random(#t_randomChars)], 60, 90, 0.5, 0.5)
								end
							end
					--TEAM MODE WITH MORE THAN 4 MEMBERS (UNUSED)
						--[[
						else
							if data.randomPortrait == "Simple" or data.randomPortrait == "Fixed" then
								f_drawQuickSpr(p1randomPortrait, 125, 16, 0.5, 0.5)
							elseif data.randomPortrait == "Roulette" then
								drawPortrait(t_randomChars[math.random(#t_randomChars)], 125, 16, 0.5, 0.5) --Draw RANDOM portrait preview out of BG Position
							end
						]]
						end
					end
				--DRAW RANDOM SPRITE ANIMATIONS
					if data.charPresentation == "Sprite" or data.charPresentation == "Mixed" then
						if data.charPresentation == "Sprite" then
							if data.coop then
								if data.randomPortrait == "Simple" or data.randomPortrait == "Fixed" then
									f_drawQuickSpr(p1randomSprite, 20, 75)
								elseif data.randomPortrait == "Roulette" then
									f_drawCharAnim(t_selChars[math.random(#t_randomChars)], 'p1AnimStand', 40, 164, true)
								end
							else
								if data.randomPortrait == "Simple" or data.randomPortrait == "Fixed" then
									f_drawQuickSpr(p1randomSprite, 20 + 28*#data.t_p1selected, 75)
								elseif data.randomPortrait == "Roulette" then
									--Draw P1 RANDOM PREVIEW stand animation with automatic X position for all members (instead of use p1numChars logic)
									f_drawCharAnim(t_selChars[math.random(#t_randomChars)], 'p1AnimStand', 40 + 28*#data.t_p1selected, 164, true)
								end
							end
						elseif data.charPresentation == "Mixed" then
							if data.randomPortrait == "Roulette" then
							--SINGLE MODE
								if p1numChars == 1 then
									f_drawCharAnim(t_selChars[math.random(#t_randomChars)], 'p1AnimStand', 30, 158, true) --Draw P1 RANDOM PREVIEW stand anim (true means that always will be in a loop updateAnim)
							--TEAM MODE WITH 2 MEMBERS
								elseif p1numChars == 2 then
									if p1memberPreview == 1 then f_drawCharAnim(t_selChars[math.random(#t_randomChars)], 'p1AnimStand', 90, 90, true, 0.5, 0.5) end --0.5,0.5 is the animation scale
									if p1memberPreview == 2 then f_drawCharAnim(t_selChars[math.random(#t_randomChars)], 'p1AnimStand', 90, 158, true, 0.5, 0.5) end --Draw P1 Member 2 RANDOM PREVIEW Stand Anim
							--TEAM MODE WITH 3 MEMBERS
								elseif p1numChars == 3 then
									if p1memberPreview == 1 then f_drawCharAnim(t_selChars[math.random(#t_randomChars)], 'p1AnimStand', 40, 89, true, 0.5, 0.5) end --Draw P1 Member 1 RANDOM PREVIEW Stand Anim
									if p1memberPreview == 2 then f_drawCharAnim(t_selChars[math.random(#t_randomChars)], 'p1AnimStand', 10, 158, true, 0.5, 0.5) end --Draw P1 Member 2 RANDOM PREVIEW Stand Anim
									if p1memberPreview == 3 then f_drawCharAnim(t_selChars[math.random(#t_randomChars)], 'p1AnimStand', 70, 158, true, 0.5, 0.5) end --Draw P1 Member 3 RANDOM PREVIEW Stand Anim
							--TEAM MODE WITH 4 MEMBERS
								elseif p1numChars == 4 then
									if p1memberPreview == 1 then f_drawCharAnim(t_selChars[math.random(#t_randomChars)], 'p1AnimStand', 10, 89, true, 0.5, 0.5) end --Draw P1 Member 1 RANDOM PREVIEW Stand Anim
									if p1memberPreview == 2 then f_drawCharAnim(t_selChars[math.random(#t_randomChars)], 'p1AnimStand', 70, 89, true, 0.5, 0.5) end --Draw P1 Member 2 RANDOM PREVIEW Stand Anim
									if p1memberPreview == 3 then f_drawCharAnim(t_selChars[math.random(#t_randomChars)], 'p1AnimStand', 10, 158, true, 0.5, 0.5) end --Draw P1 Member 3 RANDOM PREVIEW Stand Anim
									if p1memberPreview == 4 then f_drawCharAnim(t_selChars[math.random(#t_randomChars)], 'p1AnimStand', 70, 158, true, 0.5, 0.5) end --Draw P1 Member 4 RANDOM PREVIEW Stand Anim
							--TEAM MODE WITH MORE THAN 4 MEMBERS (UNUSED)
								--else
									--f_drawCharAnim(t_selChars[math.random(#t_randomChars)], 'p1AnimStand', 132, 85, true, 0.5, 0.5) --Draw RANDOM Stand Animation preview out of BG Position
								end
							end
						end
					end
			--Cursor in Character Slot
				else
				--DRAW PORTRAITS
					if data.charPresentation == "Portrait" or data.charPresentation == "Mixed" then
						if p1Portrait then --To avoid issues when draw Portrait after continue/service screen
							--drawPortrait(p1Portrait, 0+60*(#data.t_p1selected-1), 20, 1, 1) --Draw P1 PREVIEW Portrait with automatic X position for all members (instead of use p1numChars logic)
						--SINGLE MODE
							if p1numChars == 1 then
								drawPortrait(p1Portrait, 0, 20, 1, 1) --Draw P1 Member 1 PREVIEW Portrait
						--TEAM MODE WITH 2 MEMBERS
							elseif p1numChars == 2 then
							--Draw P1 Member 1 PREVIEW Portrait
								if p1memberPreview == 1 then
									if data.charPresentation == "Portrait" then
										drawPortrait(p1Portrait, 0, 20, 1, 0.5)
									elseif data.charPresentation == "Mixed" then
										drawPortrait(p1Portrait, 0, 20, 0.5, 0.5)
									end
								end
							--Draw P1 Member 2 PREVIEW Portrait
								if p1memberPreview == 2 then
									if data.charPresentation == "Portrait" then
										drawPortrait(p1Portrait, 0, 90, 1, 0.5)
									elseif data.charPresentation == "Mixed" then
										drawPortrait(p1Portrait, 0, 90, 0.5, 0.5)
									end
								end
						--TEAM MODE WITH 3 MEMBERS
							elseif p1numChars == 3 then
							--Draw P1 Member 1 PREVIEW Portrait
								if p1memberPreview == 1 then
									if data.charPresentation == "Portrait" then
										drawPortrait(p1Portrait, 0, 20, 1, 0.5)
									elseif data.charPresentation == "Mixed" then
										drawPortrait(p1Portrait, 30, 20, 0.5, 0.5)
									end
								end
								if p1memberPreview == 2 then drawPortrait(p1Portrait, 0, 90, 0.5, 0.5) end --Draw P1 Member 2 PREVIEW Portrait
								if p1memberPreview == 3 then drawPortrait(p1Portrait, 60, 90, 0.5, 0.5) end --Draw P1 Member 3 PREVIEW Portrait
						--TEAM MODE WITH 4 MEMBERS
							elseif p1numChars == 4 then
								if p1memberPreview == 1 then drawPortrait(p1Portrait, 0, 20, 0.5, 0.5) end --Draw P1 Member 1 PREVIEW Portrait
								if p1memberPreview == 2 then drawPortrait(p1Portrait, 60, 20, 0.5, 0.5) end --Draw P1 Member 2 PREVIEW Portrait
								if p1memberPreview == 3 then drawPortrait(p1Portrait, 0, 90, 0.5, 0.5) end --Draw P1 Member 3 PREVIEW Portrait
								if p1memberPreview == 4 then drawPortrait(p1Portrait, 60, 90, 0.5, 0.5) end --Draw P1 Member 4 PREVIEW Portrait
						--TEAM MODE WITH MORE THAN 4 MEMBERS (UNUSED)
							--else
								--drawPortrait(p1Portrait, 125, 16, 0.5, 0.5) --Draw portrait preview out of BG Position
							end
						end
					end
				--DRAW SPRITE ANIMATIONS
					if data.charPresentation == "Sprite" or data.charPresentation == "Mixed" then
						if data.charPresentation == "Sprite" then
							if data.coop then
								f_drawCharAnim(t_selChars[p1Cell+1], 'p1AnimStand', 40, 164, true)
							else
								--Draw P1 Member 1 PREVIEW Stand Animation with automatic X position for all members (instead of use p1numChars logic)
								f_drawCharAnim(t_selChars[p1Cell+1], 'p1AnimStand', 40 + 28*#data.t_p1selected, 164, true)
							end
						elseif data.charPresentation == "Mixed" then
						--SINGLE MODE
							if p1numChars == 1 then
								f_drawCharAnim(t_selChars[p1Cell+1], 'p1AnimStand', 30, 158, true, 1, 1) --Draw P1 Member 1 PREVIEW Stand Anim
						--TEAM MODE WITH 2 MEMBERS
							elseif p1numChars == 2 then
								if p1memberPreview == 1 then f_drawCharAnim(t_selChars[p1Cell+1], 'p1AnimStand', 90, 90, true, 0.5, 0.5) end --Draw P1 Member 1 PREVIEW Stand Anim
								if p1memberPreview == 2 then f_drawCharAnim(t_selChars[p1Cell+1], 'p1AnimStand', 90, 158, true, 0.5, 0.5) end --Draw P1 Member 2 PREVIEW Stand Anim
						--TEAM MODE WITH 3 MEMBERS
							elseif p1numChars == 3 then
								if p1memberPreview == 1 then f_drawCharAnim(t_selChars[p1Cell+1], 'p1AnimStand', 40, 89, true, 0.5, 0.5) end --Draw P1 Member 1 PREVIEW Stand Anim
								if p1memberPreview == 2 then f_drawCharAnim(t_selChars[p1Cell+1], 'p1AnimStand', 10, 158, true, 0.5, 0.5) end --Draw P1 Member 2 PREVIEW Stand Anim
								if p1memberPreview == 3 then f_drawCharAnim(t_selChars[p1Cell+1], 'p1AnimStand', 70, 158, true, 0.5, 0.5) end --Draw P1 Member 3 PREVIEW Stand Anim
						--TEAM MODE WITH 4 MEMBERS
							elseif p1numChars == 4 then
								if p1memberPreview == 1 then f_drawCharAnim(t_selChars[p1Cell+1], 'p1AnimStand', 10, 89, true, 0.5, 0.5) end --Draw P1 Member 1 PREVIEW Stand Anim
								if p1memberPreview == 2 then f_drawCharAnim(t_selChars[p1Cell+1], 'p1AnimStand', 70, 89, true, 0.5, 0.5) end --Draw P1 Member 2 PREVIEW Stand Anim
								if p1memberPreview == 3 then f_drawCharAnim(t_selChars[p1Cell+1], 'p1AnimStand', 10, 158, true, 0.5, 0.5) end --Draw P1 Member 3 PREVIEW Stand Anim
								if p1memberPreview == 4 then f_drawCharAnim(t_selChars[p1Cell+1], 'p1AnimStand', 70, 158, true, 0.5, 0.5) end --Draw P1 Member 4 PREVIEW Stand Anim
						--TEAM MODE WITH MORE THAN 4 MEMBERS (UNUSED)
							--else
								--f_drawCharAnim(t_selChars[p1Cell+1], 'p1AnimStand', 132, 85, true, 0.5, 0.5) --Draw Stand Animation preview out of BG Position
							end
						end
					end
				--DRAW LOCKED CHAR STUFF
					if t_unlockLua.chars[t_selChars[p1Cell+1].char] ~= nil and not onlinegame then --If the character is locked draw special stuff
						if data.charPresentation == "Portrait" or data.charPresentation == "Mixed" then
						--SINGLE MODE
							if p1numChars == 1 then
								f_drawQuickSpr(p1portraitLockWindowBG, 0, 20, 120, 140, 256, 102)
								f_drawQuickSpr(p1portraitLock, 24.5, 50, 0.20, 0.20)
						--TEAM MODE WITH 2 MEMBERS
							elseif p1numChars == 2 then
								if p1memberPreview == 1 then
									f_drawQuickSpr(p1portraitLockWindowBG, 0, 20, 120, 70, 256, 102)
									f_drawQuickSpr(p1portraitLock, 42, 36, 0.10, 0.10)
								elseif p1memberPreview == 2 then
									f_drawQuickSpr(p1portraitLockWindowBG, 0, 90, 120, 70, 256, 102)
									f_drawQuickSpr(p1portraitLock, 42, 106, 0.10, 0.10)
								end
						--TEAM MODE WITH 3 MEMBERS
							elseif p1numChars == 3 then
								if p1memberPreview == 1 then
									f_drawQuickSpr(p1portraitLockWindowBG, 0, 20, 120, 70, 256, 102)
									f_drawQuickSpr(p1portraitLock, 42, 36, 0.10, 0.10)
								elseif p1memberPreview == 2 then
									f_drawQuickSpr(p1portraitLockWindowBG, 0, 90, 60, 70, 256, 102)
									f_drawQuickSpr(p1portraitLock, 12, 106, 0.10, 0.10)
								elseif p1memberPreview == 3 then
									f_drawQuickSpr(p1portraitLockWindowBG, 60, 90, 60, 70, 256, 102)
									f_drawQuickSpr(p1portraitLock, 72, 106, 0.10, 0.10)
								end
						--TEAM MODE WITH 4 MEMBERS
							elseif p1numChars == 4 then
								if p1memberPreview == 1 then
									f_drawQuickSpr(p1portraitLockWindowBG, 0, 20, 60, 70, 256, 102)
									f_drawQuickSpr(p1portraitLock, 12, 36, 0.10, 0.10)
								elseif p1memberPreview == 2 then
									f_drawQuickSpr(p1portraitLockWindowBG, 60, 20, 60, 70, 256, 102)
									f_drawQuickSpr(p1portraitLock, 72, 36, 0.10, 0.10)
								elseif p1memberPreview == 3 then
									f_drawQuickSpr(p1portraitLockWindowBG, 0, 90, 60, 70, 256, 102)
									f_drawQuickSpr(p1portraitLock, 12, 106, 0.10, 0.10)
								elseif p1memberPreview == 4 then
									f_drawQuickSpr(p1portraitLockWindowBG, 60, 90, 60, 70, 256, 102)
									f_drawQuickSpr(p1portraitLock, 72, 106, 0.10, 0.10)
								end
							end
						elseif data.charPresentation == "Sprite" then
							f_drawQuickSpr(p1portraitLock, 20 + 28*#data.t_p1selected, 75, 0.15, 0.15)
						end
					end
				end
			end
		--When a Character is Selected
			for j=#data.t_p1selected, 1, -1 do
			--DRAW PORTRAITS
				if not exclusiveStageMenu then
					if data.charPresentation == "Portrait" or data.charPresentation == "Mixed" then
						--drawPortrait(data.t_p1selected[j].cel, 0+60*(j-1), 20, 1, 1) --Draw P1 SELECTED Portrait with automatic X position for all members (instead of use p1numChars logic)
					--SINGLE MODE
						if p1numChars == 1 then
							if data.randomPortrait == "Fixed" and p1member1Random == true then
								f_drawQuickSpr(p1randomPortrait, 0, 20)
							else
								drawPortrait(data.t_p1selected[1].cel, 0, 20, 1, 1)
							end
					--TEAM MODE WITH 2 MEMBERS
						elseif p1numChars == 2 then
						--Draw P1 Member 2 SELECTED Portrait
							if j == 2 then
								if data.randomPortrait == "Fixed" and p1member2Random == true then
									if data.charPresentation == "Portrait" then
										f_drawQuickSpr(p1randomPortrait, 0, 90, 1, 0.5)
									elseif data.charPresentation == "Mixed" then
										f_drawQuickSpr(p1randomPortrait, 0, 90, 0.5, 0.5)
									end
								else
									if data.charPresentation == "Portrait" then
										drawPortrait(data.t_p1selected[2].cel, 0, 90, 1, 0.5)
									elseif data.charPresentation == "Mixed" then
										drawPortrait(data.t_p1selected[2].cel, 0, 90, 0.5, 0.5)
									end
								end
							end
							--remember that lastest draw have priority on screen
						--Draw P1 Member 1 SELECTED Portrait
							if data.randomPortrait == "Fixed" and p1member1Random == true then
								if data.charPresentation == "Portrait" then
									f_drawQuickSpr(p1randomPortrait, 0, 20, 1, 0.5)
								elseif data.charPresentation == "Mixed" then
									f_drawQuickSpr(p1randomPortrait, 0, 20, 0.5, 0.5)
								end
							else
								if data.charPresentation == "Portrait" then
									drawPortrait(data.t_p1selected[1].cel, 0, 20, 1, 0.5)
								elseif data.charPresentation == "Mixed" then
									drawPortrait(data.t_p1selected[1].cel, 0, 20, 0.5, 0.5)
								end
							end
					--TEAM MODE WITH 3 MEMBERS
						elseif p1numChars == 3 then
						--Draw P1 Member 3 SELECTED Portrait
							if j == 3 then
								if data.randomPortrait == "Fixed" and p1member3Random == true then
									f_drawQuickSpr(p1randomPortrait, 60, 90, 0.5, 0.5)
								else
									drawPortrait(data.t_p1selected[3].cel, 60, 90, 0.5, 0.5)
								end
							end
						--Draw P1 Member 2 SELECTED Portrait
							if j == 2 then
								if data.randomPortrait == "Fixed" and p1member2Random == true then
									f_drawQuickSpr(p1randomPortrait, 0, 90, 0.5, 0.5)
								else
									drawPortrait(data.t_p1selected[2].cel, 0, 90, 0.5, 0.5)
								end
							end
						--Draw P1 Member 1 SELECTED Portrait
							if data.randomPortrait == "Fixed" and p1member1Random == true then
								if data.charPresentation == "Portrait" then
									f_drawQuickSpr(p1randomPortrait, 0, 20, 1, 0.5)
								elseif data.charPresentation == "Mixed" then
									f_drawQuickSpr(p1randomPortrait, 30, 20, 0.5, 0.5)
								end
							else
								if data.charPresentation == "Portrait" then
									drawPortrait(data.t_p1selected[1].cel, 0, 20, 1, 0.5)
								elseif data.charPresentation == "Mixed" then
									drawPortrait(data.t_p1selected[1].cel, 30, 20, 0.5, 0.5)
								end
							end
					--TEAM MODE WITH 4 MEMBERS
						elseif p1numChars == 4 then
						--Draw P1 Member 4 SELECTED Portrait
							if j == 4 then
								if data.randomPortrait == "Fixed" and p1member4Random == true then
									f_drawQuickSpr(p1randomPortrait, 60, 90, 0.5, 0.5)
								else
									drawPortrait(data.t_p1selected[4].cel, 60, 90, 0.5, 0.5)
								end
							end
						--Draw P1 Member 3 SELECTED Portrait
							if j == 3 then
								if data.randomPortrait == "Fixed" and p1member3Random == true then
									f_drawQuickSpr(p1randomPortrait, 0, 90, 0.5, 0.5)
								else
									drawPortrait(data.t_p1selected[3].cel, 0, 90, 0.5, 0.5)
								end
							end
						--Draw P1 Member 2 SELECTED Portrait
							if j == 2 then
								if data.randomPortrait == "Fixed" and p1member2Random == true then
									f_drawQuickSpr(p1randomPortrait, 60, 20, 0.5, 0.5)
								else
									drawPortrait(data.t_p1selected[2].cel, 60, 20, 0.5, 0.5)
								end
							end
						--Draw P1 Member 1 SELECTED Portrait
							if data.randomPortrait == "Fixed" and p1member1Random == true then
								f_drawQuickSpr(p1randomPortrait, 0, 20, 0.5, 0.5)
							else
								drawPortrait(data.t_p1selected[1].cel, 0, 20, 0.5, 0.5)
							end
						end
					end
				--DRAW SPRITE ANIMATIONS
					if data.charPresentation == "Sprite" or data.charPresentation == "Mixed" then
						if data.charPresentation == "Sprite" then
							if data.coop then
								f_drawCharAnim(t_selChars[data.t_p1selected[1].cel+1], 'p1AnimWin', 40, 164, data.t_p1selected[1].up, 1, 1, alphaS) --200 is the alphas value
							else
							--Draw P1 Member 4 SELECTED Animation
								if j == 4 then
									if data.randomPortrait == "Fixed" and p1member4Random == true then
										f_drawQuickSpr(p1randomSprite, 104, 75)
									else
										f_drawCharAnim(t_selChars[data.t_p1selected[4].cel+1], 'p1AnimWin', 124, 164, data.t_p1selected[4].up, 1, 1, alphaS)
									end
								end
							--Draw P1 Member 3 SELECTED Animation
								if j == 3 then
									if data.randomPortrait == "Fixed" and p1member3Random == true then
										f_drawQuickSpr(p1randomSprite, 76, 75)
									else
										f_drawCharAnim(t_selChars[data.t_p1selected[3].cel+1], 'p1AnimWin', 96, 164, data.t_p1selected[3].up, 1, 1, alphaS)
									end
								end
							--Draw P1 Member 2 SELECTED Animation
								if j == 2 then
									if data.randomPortrait == "Fixed" and p1member2Random == true then
										f_drawQuickSpr(p1randomSprite, 48, 75)
									else
										f_drawCharAnim(t_selChars[data.t_p1selected[2].cel+1], 'p1AnimWin', 68, 164, data.t_p1selected[2].up, 1, 1, alphaS)
									end
								end
							--Draw P1 Member 1 SELECTED Animation
								if data.randomPortrait == "Fixed" and p1member1Random == true then
									f_drawQuickSpr(p1randomSprite, 20, 75)
								else
									f_drawCharAnim(t_selChars[data.t_p1selected[1].cel+1], 'p1AnimWin', 40, 164, data.t_p1selected[1].up, 1, 1, alphaS)
								end
								--Draw P1 SELECTED/Win Animation with automatic X position for all members (instead of use p1numChars logic)
								--f_drawCharAnim(t_selChars[data.t_p1selected[j].cel+1], 'p1AnimWin', 40 + 28*(j-1), 164, data.t_p1selected[j].up, 1, 1, alphaS)
							end
						elseif data.charPresentation == "Mixed" then
						--SINGLE MODE
							if p1numChars == 1 then
								if data.randomPortrait == "Fixed" and p1member1Random == true then
									--You can put your own sprite for random select but as also we are using the portrait logic is not necessary
								else
									f_drawCharAnim(t_selChars[data.t_p1selected[1].cel+1], 'p1AnimWin', 30, 158, data.t_p1selected[1].up, 1, 1, alphaS)
								end
						--TEAM MODE WITH 2 MEMBERS
							elseif p1numChars == 2 then
							--Draw P1 Member 2 SELECTED Animation
								if j == 2 then
									if data.randomPortrait == "Fixed" and p1member2Random == true then
										
									else
										f_drawCharAnim(t_selChars[data.t_p1selected[2].cel+1], 'p1AnimWin', 90, 158, data.t_p1selected[2].up, 0.5, 0.5, alphaS)
									end
								end
							--Draw P1 Member 1 SELECTED Animation
								if data.randomPortrait == "Fixed" and p1member1Random == true then
									
								else
									f_drawCharAnim(t_selChars[data.t_p1selected[1].cel+1], 'p1AnimWin', 90, 90, data.t_p1selected[1].up, 0.5, 0.5, alphaS) --The lastest f_drawCharAnim have draw priority on screen
								end
						--TEAM MODE WITH 3 MEMBERS
							elseif p1numChars == 3 then
							--Draw P1 Member 3 SELECTED Animation
								if j == 3 then
									if data.randomPortrait == "Fixed" and p1member3Random == true then
										
									else
										f_drawCharAnim(t_selChars[data.t_p1selected[3].cel+1], 'p1AnimWin', 70, 158, data.t_p1selected[3].up, 0.5, 0.5, alphaS)
									end
								end
							--Draw P1 Member 2 SELECTED Animation
								if j == 2 then
									if data.randomPortrait == "Fixed" and p1member2Random == true then
										
									else
										f_drawCharAnim(t_selChars[data.t_p1selected[2].cel+1], 'p1AnimWin', 10, 158, data.t_p1selected[2].up, 0.5, 0.5, alphaS)
									end
								end
							--Draw P1 Member 1 SELECTED Animation
								if data.randomPortrait == "Fixed" and p1member1Random == true then
									
								else
									f_drawCharAnim(t_selChars[data.t_p1selected[1].cel+1], 'p1AnimWin', 40, 89, data.t_p1selected[1].up, 0.5, 0.5, alphaS)
								end
						--TEAM MODE WITH 4 MEMBERS
							elseif p1numChars == 4 then
							--Draw P1 Member 4 SELECTED Animation
								if j == 4 then
									if data.randomPortrait == "Fixed" and p1member4Random == true then
										
									else
										f_drawCharAnim(t_selChars[data.t_p1selected[4].cel+1], 'p1AnimWin', 70, 158, data.t_p1selected[4].up, 0.5, 0.5, alphaS)
									end
								end
							--Draw P1 Member 3 SELECTED Animation
								if j == 3 then
									if data.randomPortrait == "Fixed" and p1member3Random == true then
										
									else
										f_drawCharAnim(t_selChars[data.t_p1selected[3].cel+1], 'p1AnimWin', 10, 158, data.t_p1selected[3].up, 0.5, 0.5, alphaS)
									end
								end
							--Draw P1 Member 2 SELECTED Animation
								if j == 2 then
									if data.randomPortrait == "Fixed" and p1member2Random == true then
										
									else
										f_drawCharAnim(t_selChars[data.t_p1selected[2].cel+1], 'p1AnimWin', 70, 89, data.t_p1selected[2].up, 0.5, 0.5, alphaS)
									end
								end
							--Draw P1 Member 1 SELECTED Animation
								if data.randomPortrait == "Fixed" and p1member1Random == true then
									
								else
									f_drawCharAnim(t_selChars[data.t_p1selected[1].cel+1], 'p1AnimWin', 10, 89, data.t_p1selected[1].up, 0.5, 0.5, alphaS)
								end
							end
						end
					end
				end
			end
		end
		for j=#data.t_p1selected, 1, -1 do --Again to set priority over sprites
		--DRAW CHARACTER NAMES
			if not exclusiveStageMenu then
				if data.charPresentation == "Portrait" or data.charPresentation == "Mixed" then
				--SINGLE MODE
					if p1numChars == 1 then
						if data.randomPortrait == "Fixed" and p1member1Random == true then
							f_drawQuickText(txt_p1RandomMember1, jgFnt, 5, 1, "RANDOM SELECT 1", 10, 165, 0.8, 0.8)
						else
							f_drawSelectName(txt_p1Name, data.t_p1selected[1], 10, 165)
						end
				--TEAM MODE WITH 2 MEMBERS
					elseif p1numChars == 2 then
					--Draw P1 Member 2 SELECTED Name
						if j == 2 then
							if data.charPresentation == "Portrait" then
								if data.randomPortrait == "Fixed" and p1member2Random == true then
									f_drawQuickText(txt_p1RandomMember2, jgFnt, 5, 1, "RANDOM SELECT 2", 2, 100, 0.8, 0.8)
								else
									f_drawSelectName(txt_p1Name, data.t_p1selected[2], 2, 100)
								end
							elseif data.charPresentation == "Mixed" then
								if data.randomPortrait == "Fixed" and p1member2Random == true then
									f_drawQuickText(txt_p1RandomMember2, jgFnt, 5, 1, "RANDOM SELECT 2", 66, 100, 0.5, 0.5)
								else
									f_drawSelectName(txt_p1Name, data.t_p1selected[2], 66, 100, 0.5, 0.5)
								end
							end
						end
					--Draw P1 Member 1 SELECTED Name
						if data.charPresentation == "Portrait" then
							if data.randomPortrait == "Fixed" and p1member1Random == true then
								f_drawQuickText(txt_p1RandomMember1, jgFnt, 5, 1, "RANDOM SELECT 1", 2, 88, 0.8, 0.8)
							else
								f_drawSelectName(txt_p1Name, data.t_p1selected[1], 2, 88)
							end
						elseif data.charPresentation == "Mixed" then
							if data.randomPortrait == "Fixed" and p1member1Random == true then
								f_drawQuickText(txt_p1RandomMember1, jgFnt, 5, 1, "RANDOM SELECT 1", 66, 30, 0.5, 0.5)
							else
								f_drawSelectName(txt_p1Name, data.t_p1selected[1], 66, 30, 0.5, 0.5)
							end
						end
				--TEAM MODE WITH 3 MEMBERS
					elseif p1numChars == 3 then
					--Draw P1 Member 3 SELECTED Name
						if j == 3 then
							if data.randomPortrait == "Fixed" and p1member3Random == true then
								f_drawQuickText(txt_p1RandomMember3, jgFnt, 5, 1, "RANDOM SELECT 3", 66, 100, 0.5, 0.5)
							else
								f_drawSelectName(txt_p1Name, data.t_p1selected[3], 66, 100, 0.5, 0.5)
							end
						end
					--Draw P1 Member 2 SELECTED Name
						if j == 2 then
							if data.randomPortrait == "Fixed" and p1member2Random == true then
								f_drawQuickText(txt_p1RandomMember2, jgFnt, 5, 1, "RANDOM SELECT 2", 0, 100, 0.5, 0.5)
							else
								f_drawSelectName(txt_p1Name, data.t_p1selected[2], 0, 100, 0.5, 0.5)
							end
						end
					--Draw P1 Member 1 SELECTED Name
						if data.charPresentation == "Portrait" then
							if data.randomPortrait == "Fixed" and p1member1Random == true then
								f_drawQuickText(txt_p1RandomMember1, jgFnt, 5, 1, "RANDOM SELECT 1", 2, 88, 0.8, 0.8)
							else
								f_drawSelectName(txt_p1Name, data.t_p1selected[1], 2, 88)
							end
						elseif data.charPresentation == "Mixed" then
							if data.randomPortrait == "Fixed" and p1member1Random == true then
								f_drawQuickText(txt_p1RandomMember1, jgFnt, 5, 1, "RANDOM SELECT 1", 30, 30, 0.5, 0.5)
							else
								f_drawSelectName(txt_p1Name, data.t_p1selected[1], 30, 30, 0.5, 0.5)
							end
						end
				--TEAM MODE WITH 4 MEMBERS
					elseif p1numChars == 4 then
					--Draw P1 Member 4 SELECTED Name
						if j == 4 then
							if data.randomPortrait == "Fixed" and p1member4Random == true then
								f_drawQuickText(txt_p1RandomMember4, jgFnt, 5, 1, "RANDOM SELECT 4", 66, 100, 0.5, 0.5)
							else
								f_drawSelectName(txt_p1Name, data.t_p1selected[4], 66, 100, 0.5, 0.5)
							end
						end
					--Draw P1 Member 3 SELECTED Name
						if j == 3 then
							if data.randomPortrait == "Fixed" and p1member3Random == true then
								f_drawQuickText(txt_p1RandomMember3, jgFnt, 5, 1, "RANDOM SELECT 3", 0, 100, 0.5, 0.5)
							else
								f_drawSelectName(txt_p1Name, data.t_p1selected[3], 0, 100, 0.5, 0.5)
							end
						end
					--Draw P1 Member 2 SELECTED Name
						if j == 2 then
							if data.randomPortrait == "Fixed" and p1member2Random == true then
								f_drawQuickText(txt_p1RandomMember2, jgFnt, 5, 1, "RANDOM SELECT 2", 66, 30, 0.5, 0.5)
							else
								f_drawSelectName(txt_p1Name, data.t_p1selected[2], 66, 30, 0.5, 0.5)
							end
						end
					--Draw P1 Member 1 SELECTED Name
						if data.randomPortrait == "Fixed" and p1member1Random == true then
							f_drawQuickText(txt_p1RandomMember1, jgFnt, 5, 1, "RANDOM SELECT 1", 0, 30, 0.5, 0.5)
						else
							f_drawSelectName(txt_p1Name, data.t_p1selected[1], 0, 30, 0.5, 0.5)
						end
					end
				elseif data.charPresentation == "Sprite" then
				--Draw P1 Member 4 SELECTED Name
					if j == 4 then
						if data.randomPortrait == "Fixed" and p1member4Random == true then
							f_drawQuickText(txt_p1RandomMember4, jgFnt, 5, 1, "RANDOM SELECT 4", 12, 166, 0.8, 0.8)
						else
							f_drawSelectName(txt_p1Name, data.t_p1selected[4], 12, 166)
						end
					end
				--Draw P1 Member 3 SELECTED Name
					if j == 3 then
						if data.randomPortrait == "Fixed" and p1member3Random == true then
							f_drawQuickText(txt_p1RandomMember3, jgFnt, 5, 1, "RANDOM SELECT 3", 8, 160, 0.8, 0.8)
						else
							f_drawSelectName(txt_p1Name, data.t_p1selected[3], 8, 160)
						end
					end
				--Draw P1 Member 2 SELECTED Name
					if j == 2 then
						if data.randomPortrait == "Fixed" and p1member2Random == true then
							f_drawQuickText(txt_p1RandomMember2, jgFnt, 5, 1, "RANDOM SELECT 2", 4, 154, 0.8, 0.8)
						else
							f_drawSelectName(txt_p1Name, data.t_p1selected[2], 4, 154)
						end
					end
				--Draw P1 Member 1 SELECTED Name
					if data.randomPortrait == "Fixed" and p1member1Random == true then
						f_drawQuickText(txt_p1RandomMember1, jgFnt, 5, 1, "RANDOM SELECT 1", 0, 148, 0.8, 0.8)
					else
						f_drawSelectName(txt_p1Name, data.t_p1selected[1], 0, 148)
					end
				end
			--DRAW AUTHOR INFO TEXT
				if data.charInfo == "Author" then
					if t_selChars[p1Cell+1].author ~= nil or getCharName(p1Cell) == "Random" then
						if data.charPresentation == "Portrait" or data.charPresentation == "Mixed" then
						--SINGLE MODE
							if p1numChars == 1 then
								if data.randomPortrait == "Fixed" and p1member1Random == true then
									--Keep random author as: ???
								else
									textImgSetText(txt_p1Author, txt_authorText..data.t_p1selected[1].author) --Reveal Random Author
								end
								textImgDraw(txt_p1Author)
						--TEAM MODE WITH 2 MEMBERS
							elseif p1numChars == 2 then
								--Draw P1 Member 2 SELECTED Author
									if j == 2 then
										if data.randomPortrait == "Fixed" and p1member2Random == true then
										--
										else
											textImgSetText(txt_p1Author, txt_authorText..data.t_p1selected[2].author)
											
										end
										textImgScalePosDraw(txt_p1Author, 0, 165, 0.65, 0.65)
									end
								--Draw P1 Member 1 SELECTED Author
									if j == 1 then
										if data.randomPortrait == "Fixed" and p1member1Random == true then
										--
										else
											textImgSetText(txt_p1Author, txt_authorText..data.t_p1selected[1].author)
											
										end
										textImgScalePosDraw(txt_p1Author, 0, 20, 0.65, 0.65)
									end
						--TEAM MODE WITH 3 MEMBERS
							elseif p1numChars == 3 then
							--Draw P1 Member 3 SELECTED Author
								if j == 3 then
									if data.randomPortrait == "Fixed" and p1member3Random == true then
									--
									else
										textImgSetText(txt_p1Author, txt_authorText..data.t_p1selected[3].author)
										
									end
									textImgScalePosDraw(txt_p1Author, 60, 95, 0.5, 0.5)
								end
							--Draw P1 Member 2 SELECTED Author
								if j == 2 then
									if data.randomPortrait == "Fixed" and p1member2Random == true then
									--
									else
										textImgSetText(txt_p1Author, txt_authorText..data.t_p1selected[2].author)
										
									end
									textImgScalePosDraw(txt_p1Author, 0, 165, 0.5, 0.5)
								end
							--Draw P1 Member 1 SELECTED Author
								if j == 1 then
									if data.randomPortrait == "Fixed" and p1member1Random == true then
									--
									else
										textImgSetText(txt_p1Author, txt_authorText..data.t_p1selected[1].author)
									end
									textImgScalePosDraw(txt_p1Author, 0, 25, 0.5, 0.5)
								end
						--TEAM MODE WITH 4 MEMBERS
							elseif p1numChars == 4 then
							--Draw P1 Member 4 SELECTED Author
								if j == 4 then
									if data.randomPortrait == "Fixed" and p1member4Random == true then
									--
									else
										textImgSetText(txt_p1Author, txt_authorText..data.t_p1selected[4].author)
										
									end
									textImgScalePosDraw(txt_p1Author, 60, 95, 0.5, 0.5)
								end
							--Draw P1 Member 3 SELECTED Author
								if j == 3 then
									if data.randomPortrait == "Fixed" and p1member3Random == true then
									--
									else
										textImgSetText(txt_p1Author, txt_authorText..data.t_p1selected[3].author)
										
									end
									textImgScalePosDraw(txt_p1Author, 0, 165, 0.5, 0.5)
								end
							--Draw P1 Member 2 SELECTED Author
								if j == 2 then
									if data.randomPortrait == "Fixed" and p1member2Random == true then
									--
									else
										textImgSetText(txt_p1Author, txt_authorText..data.t_p1selected[2].author)
										
									end
									textImgScalePosDraw(txt_p1Author, 60, 89, 0.5, 0.5)
								end
							--Draw P1 Member 1 SELECTED Author
								if j == 1 then
									if data.randomPortrait == "Fixed" and p1member1Random == true then
									--
									else
										textImgSetText(txt_p1Author, txt_authorText..data.t_p1selected[1].author)
										
									end
									textImgScalePosDraw(txt_p1Author, 0, 25, 0.5, 0.5)
								end
							end
						elseif data.charPresentation == "Sprite" then
							if data.randomPortrait == "Fixed" and p1member1Random == true then
							--
							else
								textImgSetText(txt_p1Author, txt_authorText..data.t_p1selected[j].author)
							end
							textImgPosDraw(txt_p1Author, 0, 20+10*(j-1), 0.65, 0.65)
						end
					end
				end
			end
		end
		--Scroll Logic
		if not p1SelEnd then
			local tmpCelX = p1SelX
			local tmpCelY = p1SelY
			if backScreen == false and not p1CharEnd then
				if commandGetState(p1Cmd, 'u') or (commandGetState(p1Cmd, 'holdu') and bufSelu >= 30) then
					local foundCel = false
					while true do
						if foundCel then
							break
						end
						p1SelY, p1FaceOffset, p1OffsetRow = f_findCelYSub(p1SelY, p1FaceOffset, p1OffsetRow)
						if getCharName(p1SelX+selectColumns*p1SelY) ~= '' then
							foundCel = true
						else
							for i=0, tmpCelX do
								p1SelX = f_findCelXSub(p1SelX, false)
								if getCharName(p1SelX+selectColumns*p1SelY) ~= '' then
									foundCel = true
									break
								end
							end
							if not foundCel then
								p1SelX = tmpCelX
								for i=1, selectColumns-tmpCelX do
									p1SelX = f_findCelXAdd(p1SelX, false)
									if getCharName(p1SelX+selectColumns*p1SelY) ~= '' then
										foundCel = true
										break
									end
								end
								if not foundCel then
									p1SelX = tmpCelX
								end
							end
						end
					end
					if tmpCelY ~= p1SelY or tmpCelX ~= p1SelX then
						sndPlay(sndSys, 100, 0)
					end
				elseif commandGetState(p1Cmd, 'd') or (commandGetState(p1Cmd, 'holdd') and bufSeld >= 30) then
					local foundCel = false
					while true do
						if foundCel then
							break
						end
						p1SelY, p1FaceOffset, p1OffsetRow = f_findCelYAdd(p1SelY, p1FaceOffset, p1OffsetRow)
						if getCharName(p1SelX+selectColumns*p1SelY) ~= '' then
							foundCel = true
						else
							for i=1, selectColumns-tmpCelX do
								p1SelX = f_findCelXAdd(p1SelX, false)
								if getCharName(p1SelX+selectColumns*p1SelY) ~= '' then
									foundCel = true
									break
								end
							end
							if not foundCel then
								p1SelX = tmpCelX
								for i=0, tmpCelX do
									p1SelX = f_findCelXSub(p1SelX, false)
									if getCharName(p1SelX+selectColumns*p1SelY) ~= '' then
										foundCel = true
										break
									end
								end
								if not foundCel then
									p1SelX = tmpCelX
								end
							end
						end
					end
					if tmpCelY ~= p1SelY or tmpCelX ~= p1SelX then
						sndPlay(sndSys, 100, 0)
					end
				elseif commandGetState(p1Cmd, 'l') or (commandGetState(p1Cmd, 'holdl') and bufSell >= 30) then
					while true do
						p1SelX = f_findCelXSub(p1SelX, wrappingX)
						if getCharName(p1SelX+selectColumns*p1SelY) ~= '' then break end
					end
					if tmpCelX ~= p1SelX then
						sndPlay(sndSys, 100, 0)
					end
				elseif commandGetState(p1Cmd, 'r') or (commandGetState(p1Cmd, 'holdr') and bufSelr >= 30) then
					while true do
						p1SelX = f_findCelXAdd(p1SelX, wrappingX)
						if getCharName(p1SelX+selectColumns*p1SelY) ~= '' then break end
					end
					if tmpCelX ~= p1SelX then
						sndPlay(sndSys, 100, 0)
					end
				end
				if commandGetState(p1Cmd, 'holdu') then
					bufSeld = 0
					bufSelu = bufSelu + 1
				elseif commandGetState(p1Cmd, 'holdd') then
					bufSelu = 0
					bufSeld = bufSeld + 1
				elseif commandGetState(p1Cmd, 'holdr') then
					bufSell = 0
					bufSelr = bufSelr + 1
				elseif commandGetState(p1Cmd, 'holdl') then
					bufSelr = 0
					bufSell = bufSell + 1
				else
					bufSelu = 0
					bufSeld = 0
					bufSelr = 0
					bufSell = 0
				end
			end
			p1Cell = p1SelX + selectColumns*p1SelY
			p1Portrait = p1Cell
			--Draw Hidden Rows Cursors
			--[[
			if offsetRows >= 1 and not data.p2Faces then
				animDraw(arrowsUSR)
				animUpdate(arrowsUSR)
				animDraw(arrowsDSR)
				animUpdate(arrowsDSR)
			elseif offsetRows >= 1 and data.p2Faces then
				animDraw(arrowsUMR)
				animUpdate(arrowsUMR)
				animDraw(arrowsDMR)
				animUpdate(arrowsDMR)
			end
			]]
		--Draw Author Info Text Preview
			if data.charInfo == "Author" then
				if t_selChars[p1Cell+1].author ~= nil or getCharName(p1Cell) == "Random" then
					if t_selChars[p1Cell+1].author ~= nil then
						textImgSetText(txt_p1Author, txt_authorText..t_selChars[p1Cell+1].author)
					else --Set Text for Random Select
						textImgSetText(txt_p1Author, txt_authorText.."???")
					end
					textImgScalePosDraw(txt_p1Author, 0, 20, 0.65, 0.65) --Restart text pos
					--textImgDraw(txt_p1Author)
				end
			end
		--Set Preview Character Name
			textImgSetBank(txt_p1Name, 0) --Restart color for not selected character
			textImgSetText(txt_p1Name, f_getName(p1Cell))
			if data.charPresentation == "Portrait" or data.charPresentation == "Mixed" then
				--For Single Mode
				if p1numChars == 1 then
					textImgScalePosDraw(txt_p1Name, 10, 165, 0.8, 0.8)
				--For Team Mode with 2 Players
				elseif p1numChars == 2 then
					if p1memberPreview == 1 then
						if data.charPresentation == "Portrait" then
							textImgScalePosDraw(txt_p1Name, 2, 88, 0.8, 0.8)
						elseif data.charPresentation == "Mixed" then
							textImgScalePosDraw(txt_p1Name, 66, 30, 0.5, 0.5)
						end
					end
					if p1memberPreview == 2 then
						if data.charPresentation == "Portrait" then
							textImgScalePosDraw(txt_p1Name, 2, 100, 0.8, 0.8)
						elseif data.charPresentation == "Mixed" then
							textImgScalePosDraw(txt_p1Name, 66, 100, 0.5, 0.5)
						end
					end
				--For Team Mode with 3 Players
				elseif p1numChars == 3 then
					if p1memberPreview == 1 then
						if data.charPresentation == "Portrait" then
							textImgScalePosDraw(txt_p1Name, 2, 88, 0.8, 0.8)
						elseif data.charPresentation == "Mixed" then
							textImgScalePosDraw(txt_p1Name, 30, 30, 0.5, 0.5)
						end
					end
					if p1memberPreview == 2 then textImgScalePosDraw(txt_p1Name, 0, 100, 0.5, 0.5) end
					if p1memberPreview == 3 then textImgScalePosDraw(txt_p1Name, 66, 100, 0.5, 0.5) end
				--For Team Mode with 4 Players
				elseif p1numChars == 4 then
					if p1memberPreview == 1 then textImgScalePosDraw(txt_p1Name, 0, 30, 0.5, 0.5) end
					if p1memberPreview == 2 then textImgScalePosDraw(txt_p1Name, 66, 30, 0.5, 0.5) end
					if p1memberPreview == 3 then textImgScalePosDraw(txt_p1Name, 0, 100, 0.5, 0.5) end
					if p1memberPreview == 4 then textImgScalePosDraw(txt_p1Name, 66, 100, 0.5, 0.5) end
				end
			elseif data.charPresentation == "Sprite" then
				if p1memberPreview == 1 then
					textImgPosDraw(txt_p1Name, 0, 148)
				elseif p1memberPreview == 2 then
					textImgPosDraw(txt_p1Name, 4, 154)
				elseif p1memberPreview == 3 then
					textImgPosDraw(txt_p1Name, 8, 160)
				elseif p1memberPreview == 4 then
					textImgPosDraw(txt_p1Name, 12, 166)
				end
			end
		--Back to Team Menu Logic
			if (data.p1In == 2 and data.p2In == 2) then --Player 1 in player 2 (right) side
				if commandGetState(p2Cmd, 'e') and p1SelBack == true and not data.coop then
					sndPlay(sndSys, 100, 2)
					f_p1sideReset()
				end
			else
				if commandGetState(p1Cmd, 'e') then
					if serviceBack == true then
						f_p1sideReset()
						p1TeamEnd = true
						p1BG = true
						p1memberPreview = 1
					elseif p1SelBack == true then
						sndPlay(sndSys, 100, 2)
						f_p1sideReset()
					end
				end
			end
			if btnPalNo(p1Cmd) > 0 then
				if t_unlockLua.chars[t_selChars[p1Cell+1].char] == nil or onlinegame then --This character is unlocked
					f_p1Selection()
				elseif t_unlockLua.chars[t_selChars[p1Cell+1].char] ~= nil and not onlinegame then --Character locked if unlock=0 paramvalue is in Character section of select.def
					sndPlay(sndSys, 100, 5)
				end
			elseif selectTimer == 0 then
				if t_unlockLua.chars[t_selChars[p1Cell+1].char] ~= nil and not onlinegame then --Select random character to prevent issues when time to select is over
					p1Cell = t_randomChars[math.random(#t_randomChars)]
				end
				f_p1Selection()
			end
		--When all selections are finished for 1 character
			if p1HandicapEnd and p1PalEnd and p1CharEnd then
				local cel = p1Cell
				if getCharName(cel) == "Random" then
					randomP1Rematch = true
					cel = t_randomChars[math.random(#t_randomChars)] --include exclude chars: cel = math.random(1, #t_randomChars)-1
					if p1memberPreview == 1 then p1member1Random = true	end
					if p1memberPreview == 2 then p1member2Random = true	end
					if p1memberPreview == 3 then p1member3Random = true	end
					if p1memberPreview == 4 then p1member4Random = true	end
				else
					f_p1charAnnouncer() --Character Voice when is selected Example for Player 1 Side
				end
			--Change p1memberPreview on each char selection
				if p1numChars > 1 and not data.coop then --For Team Modes
					if p1memberPreview == 1 then p1memberPreview = 2
					elseif p1memberPreview == 2 then p1memberPreview = 3
					elseif p1memberPreview == 3 then p1memberPreview = 4
					elseif p1memberPreview == 4 then p1memberPreview = 1 --To Restart
					end
				end
			--Store data selected in Tables
				local updateAnim = true
				for i=1, #data.t_p1selected do
					if data.t_p1selected[i].cel == p1Cell then 
						updateAnim = false
					end
				end
				if data.coop then
					data.t_p1selected[1] = {['cel'] = cel, ['name'] = t_selChars[cel+1].name, ['displayname'] = t_selChars[cel+1].displayname, ['path'] = t_selChars[cel+1].char, ['pal'] = p1PalSel, ['handicap'] = p1HandicapSel, ['up'] = updateAnim, ['author'] = t_selChars[cel+1].author}
					p1SelEnd = true
				else
					data.t_p1selected[#data.t_p1selected+1] = {['cel'] = cel, ['name'] = t_selChars[cel+1].name, ['displayname'] = t_selChars[cel+1].displayname, ['path'] = t_selChars[cel+1].char, ['pal'] = p1PalSel, ['handicap'] = p1HandicapSel, ['up'] = updateAnim, ['author'] = t_selChars[cel+1].author}
				--When characters selected are equal to team mode amount selected
					if #data.t_p1selected == p1numChars then
						if data.p2In == 1 and matchNo == 0 then
							p2TeamEnd = false
							p2SelEnd = false
							--commandBufReset(p2Cmd)
						end
						p1SelEnd = true
				--Reset specific char vars for the new member select
					else
						p1HandicapEnd = false
						p1PalEnd = false
						p1CharEnd = false
					end
				end
				if data.debugLog then f_printTable(data.t_p1selected, "save/debug/data.t_p1selected.txt") end
			end
		end
	end
end

--Actions when you select a Character
function f_p1Selection()
	sndPlay(sndSys, 100, 1)
--Classic Palette Select
	if data.palType == "Classic" then
		p1PalSel = btnPalNo(p1Cmd)
		if selectTimer == 0 then p1PalSel = 1 end --Avoid freeze when Character Select timer is over and there is not are a palette selected
		p1PalEnd = true
--Modern Palette Select Random Select Case
	else
		if getCharName(p1Cell) == "Random" then
			p1PalSel = math.random(1,12) --Set Random Palette for random select
			p1PalEnd = true
		end
	end
--No Handicap Allowed
	if data.gameMode ~= "versus" or data.ftcontrol > 0 then
		p1HandicapSel = 1 --Set Normal Handicap as Default
		p1HandicapEnd = true
	end
	p1CharEnd = true
	cmdInput()
end

--;===========================================================
--; PLAYER 1 PALETTE SELECT
--;===========================================================
function f_p1SelectPal()
--Cursor
	if (commandGetState(p1Cmd, 'r') or commandGetState(p1Cmd, 'd') or (commandGetState(p1Cmd, 'holdd') and bufPald >= 30) or (commandGetState(p1Cmd, 'holdr') and bufPalr >= 30)) and p1PalSel <= 11 then --p1PalSel <= Number of your Palette List Limit
		sndPlay(sndSys, 100, 0)
		p1PalSel = p1PalSel + 1
	elseif (commandGetState(p1Cmd, 'l') or commandGetState(p1Cmd, 'u') or (commandGetState(p1Cmd, 'holdu') and bufPalu >= 30) or (commandGetState(p1Cmd, 'holdl') and bufPall >= 30)) and p1PalSel > 1 then --Keep in palette 1 when press left until finish
		sndPlay(sndSys, 100, 0)
		p1PalSel = p1PalSel - 1
	end
	if commandGetState(p1Cmd, 'holdu') then
		bufPald = 0
		bufPalu = bufPalu + 1
	elseif commandGetState(p1Cmd, 'holdd') then
		bufPalu = 0
		bufPald = bufPald + 1
	elseif commandGetState(p1Cmd, 'holdr') then
		bufPall = 0
		bufPalr = bufPalr + 1
	elseif commandGetState(p1Cmd, 'holdl') then
		bufPalr = 0
		bufPall = bufPall + 1
	else
		bufPalu = 0
		bufPald = 0
		bufPalr = 0
		bufPall = 0
	end
--Draw Assets
	animPosDraw(palSelBG, palSelBGP1posX, palSelBGP1posY) --Draw Palette Select BG
	textImgDraw(txt_p1Pal)
	textImgSetText(txt_p1PalNo, p1PalSel.."/12")
	textImgDraw(txt_p1PalNo)
	if p1PalSel > 1 then
		animPosDraw(palSelArrowLeft, palSelArrowLP1posX, palSelArrowLP1posY)
	end
	if p1PalSel <= 11 then
		animPosDraw(palSelArrowRight, palSelArrowRP1posX, palSelArrowRP1posY)
	end
--Confirm Palette
	if btnPalNo(p1Cmd) > 0 or selectTimer == 0 then
		sndPlay(sndSys, 100, 1)
		p1PalEnd = true
		cmdInput()
--Back to Character Selection
	elseif commandGetState(p1Cmd, 'e') then
		sndPlay(sndSys, 100, 2)
		p1CharEnd = false
		cmdInput()
	end
end

--;===========================================================
--; PLAYER 1 HANDICAP SELECT
--;===========================================================
function f_p1SelectHandicap()
	local maxItems = 3
	if commandGetState(p1Cmd, 'u') or (commandGetState(p1Cmd, 'holdu') and bufHandu >= 30) then
		sndPlay(sndSys, 100, 0)
		p1HandicapSel = p1HandicapSel - 1
	elseif commandGetState(p1Cmd, 'd') or (commandGetState(p1Cmd, 'holdd') and bufHandd >= 30) then
		sndPlay(sndSys, 100, 0)
		p1HandicapSel = p1HandicapSel + 1
	end
--Cursor position calculation
	if p1HandicapSel < 1 then
		p1HandicapSel = #t_handicapSelect
		if #t_handicapSelect > maxItems then
			p1HandicapCursorPosY = maxItems
		else
			p1HandicapCursorPosY = #t_handicapSelect
		end
	elseif p1HandicapSel > #t_handicapSelect then
		p1HandicapSel = 1
		p1HandicapCursorPosY = 1
	elseif (commandGetState(p1Cmd, 'u') or (commandGetState(p1Cmd, 'holdu') and bufHandu >= 30)) and p1HandicapCursorPosY > 1 then
		p1HandicapCursorPosY = p1HandicapCursorPosY - 1
	elseif (commandGetState(p1Cmd, 'd') or (commandGetState(p1Cmd, 'holdd') and bufHandd >= 30)) and p1HandicapCursorPosY < maxItems then
		p1HandicapCursorPosY = p1HandicapCursorPosY + 1
	end
	if p1HandicapCursorPosY == maxItems then
		p1HandicapMoveTxt = (p1HandicapSel - maxItems) * 13
	elseif p1HandicapCursorPosY == 1 then
		p1HandicapMoveTxt = (p1HandicapSel - 1) * 13
	end
	if #t_handicapSelect <= maxItems then
		maxP1Handicap = #t_handicapSelect
	elseif p1HandicapSel - p1HandicapCursorPosY > 0 then
		maxP1Handicap = p1HandicapSel + maxItems - p1HandicapCursorPosY
	else
		maxP1Handicap = maxItems
	end
	if commandGetState(p1Cmd, 'holdu') then
		bufHandd = 0
		bufHandu = bufHandu + 1
	elseif commandGetState(p1Cmd, 'holdd') then
		bufHandu = 0
		bufHandd = bufHandd + 1
	elseif commandGetState(p1Cmd, 'holdr') then
		bufHandl = 0
		bufHandr = bufHandr + 1
	elseif commandGetState(p1Cmd, 'holdl') then
		bufHandr = 0
		bufHandl = bufHandl + 1
	else
		bufHandu = 0
		bufHandd = 0
		bufHandr = 0
		bufHandl = 0
	end
--Draw Assets
	animPosDraw(handicapWindowBG, handicapSelBGP1posX, handicapSelBGP1posY) --Draw Handicap Select BG
	textImgDraw(txt_handicapP1) --Draw Title
--Set Color and Text Position
	for i=1, maxP1Handicap do
		if i > p1HandicapSel - p1HandicapCursorPosY then
			if i == p1HandicapSel then
				p1Handbank = 5
			else
				p1Handbank = 0
			end
		--Draw Handicaps Names
			if t_handicapSelect[i].id ~= nil then
				textImgDraw(f_updateTextImg(t_handicapSelect[i].id, jgFnt, p1Handbank, 0, t_handicapSelect[i].text, 76, 168+i*13-p1HandicapMoveTxt, 0.95, 0.95))
			end
		end
	end
--Draw Cursor
	animSetWindow(cursorBox, 4, 158+p1HandicapCursorPosY*13, 145, 13)
	f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
	animDraw(f_animVelocity(cursorBox, -1, -1))
--Draw Arrows
	if maxP1Handicap > maxItems then
		animPosDraw(handicapSelArrowUp, handicapSelArrowUP1posX, handicapSelArrowUP1posY)
	end
	if #t_handicapSelect > maxItems and maxP1Handicap < #t_handicapSelect then
		animPosDraw(handicapSelArrowDown, handicapSelArrowDP1posX, handicapSelArrowDP1posY)
	end
--Confirm Handicap
	if btnPalNo(p1Cmd) > 0 or selectTimer == 0 then
		sndPlay(sndSys, 100, 1)
		p1HandicapEnd = true
		cmdInput()
--Back to Palette Selection
	elseif commandGetState(p1Cmd, 'e') then
		sndPlay(sndSys, 100, 2)
		p1PalEnd = false
		cmdInput()
	end
end

--;===========================================================
--; PLAYER 2 TEAM SELECT
--;===========================================================
function f_p2TeamMenu()
	if data.coop then --Simul co-op
		--if data.gameMode == "tower" then  --Co-Op enemy team for tower mode
			--p2teamMode = 0
			--p2numChars = 2
		--else
			if data.coopenemy == "Single" then --CPU Co-op Players uses Co-Op CPU Team Mode setting.
				p2teamMode = 0
				p2numChars = 2 --Fix AI Fight Error When p2numChars = 1 (Take reference of Arcade Bonus in co-op)
			elseif data.coopenemy == "Simul" then
				p2teamMode = 1
				p2numChars = 2
			elseif data.coopenemy == "Turns" then
				p2teamMode = 2
				p2numChars = 3
			end
		--end
		setTeamMode(2, p2teamMode, p2numChars)
		p2TeamEnd = true
		--p2BG = true
		--p2memberPreview = 1
	elseif data.p2TeamMenu ~= nil then
		p2numChars = data.p2TeamMenu.chars
		p2teamMode = data.p2TeamMenu.mode
		setTeamMode(2, p2teamMode, p2numChars)
		p2TeamEnd = true
		p2BG = true
		p2memberPreview = 1
	else
		--Back logic when you are selecting CPU Team Mode in Human Vs CPU
		if commandGetState(p1Cmd, 'e') and (data.p1In ~= 2 and data.p2In ~= 2) then --p1Cmd because Human is in left side
			if p2TeamBack == true then
				if data.p2In == 1 then
					sndPlay(sndSys, 100, 2)
					f_p2sideReset()
					p2TeamEnd = true
					p2SelEnd = true
					f_p1sideReset()
					p1TeamEnd = true
					p1BG = true
					p1memberPreview = 1
					p1SelBack = true
					p1TeamBack = false
				end
			end
		end
		if backScreen == false then	
			if commandGetState(p2Cmd, 'u') or (commandGetState(p2Cmd, 'holdu') and bufTm2u >= 30) then
				sndPlay(sndSys, 100, 0)
				p2teamMode = p2teamMode - 1
				if p2teamMode < 0 then p2teamMode = #t_p2selTeam-1 end
				if bufTm2l then bufTm2l = 0 end
				if bufTm2r then bufTm2r = 0 end
			elseif commandGetState(p2Cmd, 'd') or (commandGetState(p2Cmd, 'holdd') and bufTm2d >= 30) then
				sndPlay(sndSys, 100, 0)
				p2teamMode = p2teamMode + 1
				if p2teamMode > #t_p2selTeam-1 then p2teamMode = 0 end
				if bufTm2l then bufTm2l = 0 end
				if bufTm2r then bufTm2r = 0 end
			elseif p2teamMode == 1 then --Simul
				if commandGetState(p2Cmd, 'r') or (commandGetState(p2Cmd, 'holdr') and bufTm2r >= 30) then
					if commandGetState(p2Cmd, 'r') and p2numSimul > 2 then sndPlay(sndSys, 100, 0) end
					p2numSimul = p2numSimul - 1
					if p2numSimul < 2 then p2numSimul = 2 end
					if bufTm2u then bufTm2u = 0 end
					if bufTm2d then bufTm2d = 0 end
				elseif commandGetState(p2Cmd, 'l') or (commandGetState(p2Cmd, 'holdl') and bufTm2l >= 30) then
					if commandGetState(p2Cmd, 'l') and p2numSimul < data.numSimul then sndPlay(sndSys, 100, 0) end
					p2numSimul = p2numSimul + 1
					if p2numSimul > data.numSimul then p2numSimul = data.numSimul end
					if bufTm2u then bufTm2u = 0 end
					if bufTm2d then bufTm2d = 0 end
				end
				if commandGetState(p2Cmd, 'holdr') then
					bufTm2l = 0
					bufTm2r = bufTm2r + 1
				elseif commandGetState(p2Cmd, 'holdl') then
					bufTm2r = 0
					bufTm2l = bufTm2l + 1
				else
					bufTm2r = 0
					bufTm2l = 0
				end
			elseif p2teamMode == 2 then --Turns
				if commandGetState(p2Cmd, 'r') or (commandGetState(p2Cmd, 'holdr') and bufTm2r >= 30) then
					if commandGetState(p2Cmd, 'r') and p2numTurns > 2 then sndPlay(sndSys, 100, 0) end
					p2numTurns = p2numTurns - 1
					if p2numTurns < 2 then p2numTurns = 2 end
					if bufTm2u then bufTm2u = 0 end
					if bufTm2d then bufTm2d = 0 end
				elseif commandGetState(p2Cmd, 'l') or (commandGetState(p2Cmd, 'holdl') and bufTm2l >= 30) then
					if commandGetState(p2Cmd, 'l') and p2numTurns < data.numTurns then sndPlay(sndSys, 100, 0) end
					p2numTurns = p2numTurns + 1
					if p2numTurns > data.numTurns then p2numTurns = data.numTurns end
					if bufTm2u then bufTm2u = 0 end
					if bufTm2d then bufTm2d = 0 end
				end
				if commandGetState(p2Cmd, 'holdr') then
					bufTm2l = 0
					bufTm2r = bufTm2r + 1
				elseif commandGetState(p2Cmd, 'holdl') then
					bufTm2r = 0
					bufTm2l = bufTm2l + 1
				else
					bufTm2r = 0
					bufTm2l = 0
				end
			end
			if commandGetState(p2Cmd, 'holdu') then
				bufTm2d = 0
				bufTm2u = bufTm2u + 1
			elseif commandGetState(p2Cmd, 'holdd') then
				bufTm2u = 0
				bufTm2d = bufTm2d + 1
			else
				bufTm2u = 0
				bufTm2d = 0
			end
		end
		if data.p2In == 2 then
			textImgDraw(p2SelTmTxt)
		elseif data.rosterMode == "cpu" then
			textImgDraw(IASelTmTxt2)
		else
			textImgDraw(IASelTmTxt2)
		end
		for i=1, #t_p2selTeam do
			if i == p2teamMode + 1 then
				textImgSetBank(t_p2selTeam[i].id, 1)
			else
				textImgSetBank(t_p2selTeam[i].id, 0)
			end
			textImgDraw(t_p2selTeam[i].id)
		end
		animUpdate(p2TmIcon)
		animDraw(p2EmptyIcon)
		animUpdate(p2EmptyIcon)
		animDraw(p2EmptyIcon2)
		animUpdate(p2EmptyIcon2)
		animDraw(p2EmptyIcon3)
		animUpdate(p2EmptyIcon3)
		animDraw(p2EmptyIcon4)
		animUpdate(p2EmptyIcon4)
		animDraw(p2EmptyIcon5)
		animUpdate(p2EmptyIcon5)
		animDraw(p2EmptyIcon6)
		animUpdate(p2EmptyIcon6)
		animDraw(p2EmptyIcon7)
		animUpdate(p2EmptyIcon7)
		animDraw(p2EmptyIcon8)
		animUpdate(p2EmptyIcon8)
		for i=1, p2numSimul do
			animPosDraw(p2TmIcon, 246 - i*6, 66)
		end
		for i=1, p2numTurns do
			animPosDraw(p2TmIcon, 246 - i*6, 81)
		end
		animUpdate(p2TmCursor)
		animPosDraw(p2TmCursor, 310, 50 + p2teamMode*15)
		if btnPalNo(p2Cmd) > 0 or selectTimer == 0 then
			sndPlay(sndSys, 100, 1)
			if p2teamMode == 0 then --Single
				p2numChars = 1
			elseif p2teamMode == 1 then --Simul
				p2numChars = p2numSimul
			elseif p2teamMode == 2 then --Turns
				p2numChars = p2numTurns
			end
			setTeamMode(2, p2teamMode, p2numChars)
			p2TeamEnd = true
			p2BG = true
			p2memberPreview = 1
			p2SelBack = true
			p2TeamBack = false
			cmdInput()
		end
	end
end

--;===========================================================
--; PLAYER 2 CHARACTER SELECT
--;===========================================================
function f_p2SelectMenu()
	if data.p2Char ~= nil then
		local t_p2CharID = {}
		for i, v in ipairs(data.p2Char) do
			t_p2CharID[i] = string.lower(v)
		end
		for item=1, #t_p2CharID do
			t_p2CharID[item] = t_charAdd[t_p2CharID[item]]
		end
		local t = {}
		for i=1, #t_p2CharID do
			local updateAnim = false
			if t[t_p2CharID[i]] == nil then
				updateAnim = true
				t[t_p2CharID[i]] = ''
			end
			if data.p2Pal ~= nil then
				data.t_p2selected[i] = {['cel'] = t_p2CharID[i], ['pal'] = data.p2Pal, ['handicap'] = p2HandicapSel, ['up'] = updateAnim, ['name'] = t_selChars[t_p2CharID[i]+1].name, ['displayname'] = t_selChars[t_p2CharID[i]+1].displayname, ['path'] = t_selChars[t_p2CharID[i]+1].char, ['author'] = t_selChars[t_p2CharID[i]+1].author}
			else
				data.t_p2selected[i] = {['cel'] = t_p2CharID[i], ['pal'] = math.random(1,12), ['handicap'] = p2HandicapSel, ['up'] = updateAnim, ['name'] = t_selChars[t_p2CharID[i]+1].name, ['displayname'] = t_selChars[t_p2CharID[i]+1].displayname, ['path'] = t_selChars[t_p2CharID[i]+1].char, ['author'] = t_selChars[t_p2CharID[i]+1].author}
			end
			if data.debugLog then f_printTable(data.t_p2selected, "save/debug/data.t_p2selected.txt") end
		end
		p2Portrait = t_p2CharID[1]
		--local numChars = p2numChars
		--local t_selected = data.t_p2selected
		--if data.coop then
			--numChars = 1
			--t_selected = {}
		--end
		p2SelEnd = true
	elseif not data.p2SelectMenu then
		if data.gameMode == "challenger" then
			data.t_p2selected = t_p2selectedTemp --Get previous arcade selected characters
			if data.debugLog then f_printTable(data.t_p2selected, "save/debug/data.t_p2selected.txt") end
		end
		p2SelEnd = true
	else
		if not exclusiveStageMenu then
			if data.charPresentation == "Portrait" or data.charPresentation == "Mixed" then
				if p2BG == true then animDraw(f_animVelocity(charBG3, 2, 0)) end
			end
		end
		local numChars = p2numChars
		local alphaS = 200
		local t_selected = data.t_p2selected
		if data.coop then
			numChars = 1
			t_selected = {} --Reset table to store p2 data to send to data.t_p1selected in co-op modes
		end
		if p2Cell then
			if numChars ~= #t_selected then
				local updateAnim = true
				for i=1, #t_selected do
					if t_selected[i].cel == p2Cell then 
						updateAnim = false
					end
				end
				if getCharName(p2Cell) == "Random" then
					if getCharName(p1Cell) ~= "Random" then --Play Random Cursor SFX only when p1 it is not on the same cell type to overlap the sfx
						--sndPlay(sndSys, 100, 0)
					end
					if data.charPresentation == "Portrait" or data.charPresentation == "Mixed" then
						--drawPortrait(t_randomChars[math.random(#t_randomChars)], 320 - 60*(#t_selected-1), 20, -1, 1)
						if p2numChars == 1 then
							if data.randomPortrait == "Simple" or data.randomPortrait == "Fixed" then
								f_drawQuickSpr(p2randomPortrait, 320, 20)
							elseif data.randomPortrait == "Roulette" then
								drawPortrait(t_randomChars[math.random(#t_randomChars)], 320, 20, -1, 1)
							end
						elseif p2numChars == 2 then
							if data.coop then
								if data.randomPortrait == "Simple" or data.randomPortrait == "Fixed" then
									if data.charPresentation == "Portrait" then
										f_drawQuickSpr(p2randomPortrait, 120, 90, 1, 0.5)
									elseif data.charPresentation == "Mixed" then
										f_drawQuickSpr(p2randomPortrait, 60, 90, 0.5, 0.5)
									end
								elseif data.randomPortrait == "Roulette" then
									if data.charPresentation == "Portrait" then
										drawPortrait(t_randomChars[math.random(#t_randomChars)], 0, 90, 1, 0.5)
									elseif data.charPresentation == "Mixed" then
										drawPortrait(t_randomChars[math.random(#t_randomChars)], 0, 90, 0.5, 0.5)
									end
								end
							else
								if p2memberPreview == 1 then
									if data.randomPortrait == "Simple" or data.randomPortrait == "Fixed" then
										if data.charPresentation == "Portrait" then
											f_drawQuickSpr(p2randomPortrait, 320, 20, 1, 0.5)
										elseif data.charPresentation == "Mixed" then
											f_drawQuickSpr(p2randomPortrait, 320, 20, 0.5, 0.5)
										end
									elseif data.randomPortrait == "Roulette" then
										if data.charPresentation == "Portrait" then
											drawPortrait(t_randomChars[math.random(#t_randomChars)], 320, 20, -1, 0.5)
										elseif data.charPresentation == "Mixed" then
											drawPortrait(t_randomChars[math.random(#t_randomChars)], 320, 20, -0.5, 0.5)
										end
									end
								end
								if p2memberPreview == 2 then
									if data.randomPortrait == "Simple" or data.randomPortrait == "Fixed" then
										if data.charPresentation == "Portrait" then
											f_drawQuickSpr(p2randomPortrait, 320, 90, 1, 0.5)
										elseif data.charPresentation == "Mixed" then
											f_drawQuickSpr(p2randomPortrait, 320, 90, 0.5, 0.5)
										end
									elseif data.randomPortrait == "Roulette" then
										if data.charPresentation == "Portrait" then
											drawPortrait(t_randomChars[math.random(#t_randomChars)], 320, 90, -1, 0.5)
										elseif data.charPresentation == "Mixed" then
											drawPortrait(t_randomChars[math.random(#t_randomChars)], 320, 90, -0.5, 0.5)
										end
									end
								end
							end
						elseif p2numChars == 3 then
							if p2memberPreview == 1 then
								if data.randomPortrait == "Simple" or data.randomPortrait == "Fixed" then
									if data.charPresentation == "Portrait" then
										f_drawQuickSpr(p2randomPortrait, 320, 20, 1, 0.5)
									elseif data.charPresentation == "Mixed" then
										f_drawQuickSpr(p2randomPortrait, 290, 20, 0.5, 0.5)
									end
								elseif data.randomPortrait == "Roulette" then
									if data.charPresentation == "Portrait" then
										drawPortrait(t_randomChars[math.random(#t_randomChars)], 320, 20, -1, 0.5)
									elseif data.charPresentation == "Mixed" then
										drawPortrait(t_randomChars[math.random(#t_randomChars)], 290, 20, -0.5, 0.5)
									end
								end
							end
							if p2memberPreview == 2 then
								if data.randomPortrait == "Simple" or data.randomPortrait == "Fixed" then
									f_drawQuickSpr(p2randomPortrait, 320, 90, 0.5, 0.5)
								elseif data.randomPortrait == "Roulette" then
									drawPortrait(t_randomChars[math.random(#t_randomChars)], 320, 90, -0.5, 0.5)
								end
							end
							if p2memberPreview == 3 then
								if data.randomPortrait == "Simple" or data.randomPortrait == "Fixed" then
									f_drawQuickSpr(p2randomPortrait, 260, 90, 0.5, 0.5)
								elseif data.randomPortrait == "Roulette" then
									drawPortrait(t_randomChars[math.random(#t_randomChars)], 260, 90, -0.5, 0.5)
								end
							end
						elseif p2numChars == 4 then
							if p2memberPreview == 1 then
								if data.randomPortrait == "Simple" or data.randomPortrait == "Fixed" then
									f_drawQuickSpr(p2randomPortrait, 320, 20, 0.5, 0.5)
								elseif data.randomPortrait == "Roulette" then
									drawPortrait(t_randomChars[math.random(#t_randomChars)], 320, 20, -0.5, 0.5)
								end
							end
							if p2memberPreview == 2 then
								if data.randomPortrait == "Simple" or data.randomPortrait == "Fixed" then
									f_drawQuickSpr(p2randomPortrait, 260, 20, 0.5, 0.5)
								elseif data.randomPortrait == "Roulette" then
									drawPortrait(t_randomChars[math.random(#t_randomChars)], 260, 20, -0.5, 0.5)
								end
							end
							if p2memberPreview == 3 then
								if data.randomPortrait == "Simple" or data.randomPortrait == "Fixed" then
									f_drawQuickSpr(p2randomPortrait, 320, 90, 0.5, 0.5)
								elseif data.randomPortrait == "Roulette" then
									drawPortrait(t_randomChars[math.random(#t_randomChars)], 320, 90, -0.5, 0.5)
								end
							end
							if p2memberPreview == 4 then
								if data.randomPortrait == "Simple" or data.randomPortrait == "Fixed" then
									f_drawQuickSpr(p2randomPortrait, 260, 90, 0.5, 0.5)
								elseif data.randomPortrait == "Roulette" then
									drawPortrait(t_randomChars[math.random(#t_randomChars)], 260, 90, -0.5, 0.5)
								end
							end
						--[[
						--else
							if data.randomPortrait == "Simple" or data.randomPortrait == "Fixed" then
								f_drawQuickSpr(p2randomPortrait, 195, 36, 0.5, 0.5)
							elseif data.randomPortrait == "Roulette" then
								drawPortrait(t_randomChars[math.random(#t_randomChars)], 195, 36, -0.5, 0.5)
							end
						]]
						end
					end
					if data.charPresentation == "Sprite" or data.charPresentation == "Mixed" then
						if data.charPresentation == "Sprite" then
							if data.coop then
								if data.randomPortrait == "Simple" or data.randomPortrait == "Fixed" then
									f_drawQuickSpr(p2randomSprite, 110, 75)
								elseif data.randomPortrait == "Roulette" then
									f_drawCharAnim(t_selChars[math.random(#t_randomChars)], 'p1AnimStand', 114, 164, true) --p1AnimStand because sprite animation will see to right
								end
							else
								if data.randomPortrait == "Simple" or data.randomPortrait == "Fixed" then
									f_drawQuickSpr(p2randomSprite, 260 - 28*#t_selected, 75)
								elseif data.randomPortrait == "Roulette" then
									f_drawCharAnim(t_selChars[math.random(#t_randomChars)], 'p2AnimStand', 280 - 28*#t_selected, 164, true)
								end
							end
						elseif data.charPresentation == "Mixed" then
							if data.randomPortrait == "Roulette" then
								if p2numChars == 1 then
									f_drawCharAnim(t_selChars[math.random(#t_randomChars)], 'p2AnimStand', 290, 158, true)
								elseif p2numChars == 2 then
									if data.coop then
										f_drawCharAnim(t_selChars[math.random(#t_randomChars)], 'p1AnimStand', 90, 158, true, 0.5, 0.5)
									else
										if p2memberPreview == 1 then f_drawCharAnim(t_selChars[math.random(#t_randomChars)], 'p2AnimStand', 230, 90, true, 0.5, 0.5) end
										if p2memberPreview == 2 then f_drawCharAnim(t_selChars[math.random(#t_randomChars)], 'p2AnimStand', 230, 158, true, 0.5, 0.5) end
									end
								elseif p2numChars == 3 then
									if p2memberPreview == 1 then f_drawCharAnim(t_selChars[math.random(#t_randomChars)], 'p2AnimStand', 280, 89, true, 0.5, 0.5) end
									if p2memberPreview == 2 then f_drawCharAnim(t_selChars[math.random(#t_randomChars)], 'p2AnimStand', 310, 158, true, 0.5, 0.5) end
									if p2memberPreview == 3 then f_drawCharAnim(t_selChars[math.random(#t_randomChars)], 'p2AnimStand', 250, 158, true, 0.5, 0.5) end
								elseif p2numChars == 4 then
									if p2memberPreview == 1 then f_drawCharAnim(t_selChars[math.random(#t_randomChars)], 'p2AnimStand', 310, 89, true, 0.5, 0.5) end
									if p2memberPreview == 2 then f_drawCharAnim(t_selChars[math.random(#t_randomChars)], 'p2AnimStand', 250, 89, true, 0.5, 0.5) end
									if p2memberPreview == 3 then f_drawCharAnim(t_selChars[math.random(#t_randomChars)], 'p2AnimStand', 310, 158, true, 0.5, 0.5) end
									if p2memberPreview == 4 then f_drawCharAnim(t_selChars[math.random(#t_randomChars)], 'p2AnimStand', 250, 158, true, 0.5, 0.5) end
								--else
									--f_drawCharAnim(t_selChars[math.random(#t_randomChars)], 'p2AnimStand', 132, 105, true, 0.5, 0.5)
								end
							end
						end
					end
				else
					if data.charPresentation == "Portrait" or data.charPresentation == "Mixed" then
						if p2Portrait then --To avoid issues when draw Portrait after continue/service screen
							--drawPortrait(p2Portrait, 320 - 60*(#t_selected-1), 20, -1, 1)
							if p2numChars == 1 then
								drawPortrait(p2Portrait, 320, 20, -1, 1)
							elseif p2numChars == 2 then
								if data.coop then
									if data.charPresentation == "Portrait" then
										drawPortrait(p2Portrait, 0, 90, 1, 0.5)
									elseif data.charPresentation == "Mixed" then
										drawPortrait(p2Portrait, 0, 90, 0.5, 0.5)
									end
								else
									if p2memberPreview == 1 then
										if data.charPresentation == "Portrait" then
											drawPortrait(p2Portrait, 320, 20, -1, 0.5)
										elseif data.charPresentation == "Mixed" then
											drawPortrait(p2Portrait, 320, 20, -0.5, 0.5)
										end
									end
									if p2memberPreview == 2 then
										if data.charPresentation == "Portrait" then
											drawPortrait(p2Portrait, 320, 90, -1, 0.5)
										elseif data.charPresentation == "Mixed" then
											drawPortrait(p2Portrait, 320, 90, -0.5, 0.5)
										end
									end
								end
							elseif p2numChars == 3 then
								if p2memberPreview == 1 then
									if data.charPresentation == "Portrait" then
										drawPortrait(p2Portrait, 320, 20, -1, 0.5)
									elseif data.charPresentation == "Mixed" then
										drawPortrait(p2Portrait, 290, 20, -0.5, 0.5)
									end
								end
								if p2memberPreview == 2 then drawPortrait(p2Portrait, 320, 90, -0.5, 0.5) end
								if p2memberPreview == 3 then drawPortrait(p2Portrait, 260, 90, -0.5, 0.5) end
							elseif p2numChars == 4 then
								if p2memberPreview == 1 then drawPortrait(p2Portrait, 320, 20, -0.5, 0.5) end
								if p2memberPreview == 2 then drawPortrait(p2Portrait, 260, 20, -0.5, 0.5) end
								if p2memberPreview == 3 then drawPortrait(p2Portrait, 320, 90, -0.5, 0.5) end
								if p2memberPreview == 4 then drawPortrait(p2Portrait, 260, 90, -0.5, 0.5) end
							--else
								--drawPortrait(p2Portrait, 195, 36, -0.5, 0.5)
							end
						end
					end
					if data.charPresentation == "Sprite" or data.charPresentation == "Mixed" then
						if data.charPresentation == "Sprite" then
							if data.coop then
								f_drawCharAnim(t_selChars[p2Cell+1], 'p1AnimStand', 114, 164, true)
							else
								f_drawCharAnim(t_selChars[p2Cell+1], 'p2AnimStand', 280 - 28*#t_selected, 164, true)
							end
						elseif data.charPresentation == "Mixed" then
							if p2numChars == 1 then
								f_drawCharAnim(t_selChars[p2Cell+1], 'p2AnimStand', 290, 158, true, 1, 1)
							elseif p2numChars == 2 then
								if data.coop then
									f_drawCharAnim(t_selChars[p2Cell+1], 'p1AnimStand', 90, 158, true, 0.5, 0.5)
								else
									if p2memberPreview == 1 then f_drawCharAnim(t_selChars[p2Cell+1], 'p2AnimStand', 230, 90, true, 0.5, 0.5) end
									if p2memberPreview == 2 then f_drawCharAnim(t_selChars[p2Cell+1], 'p2AnimStand', 230, 158, true, 0.5, 0.5) end
								end
							elseif p2numChars == 3 then
								if p2memberPreview == 1 then f_drawCharAnim(t_selChars[p2Cell+1], 'p2AnimStand', 280, 89, true, 0.5, 0.5) end
								if p2memberPreview == 2 then f_drawCharAnim(t_selChars[p2Cell+1], 'p2AnimStand', 310, 158, true, 0.5, 0.5) end
								if p2memberPreview == 3 then f_drawCharAnim(t_selChars[p2Cell+1], 'p2AnimStand', 250, 158, true, 0.5, 0.5) end
							elseif p2numChars == 4 then
								if p2memberPreview == 1 then f_drawCharAnim(t_selChars[p2Cell+1], 'p2AnimStand', 310, 89, true, 0.5, 0.5) end
								if p2memberPreview == 2 then f_drawCharAnim(t_selChars[p2Cell+1], 'p2AnimStand', 250, 89, true, 0.5, 0.5) end
								if p2memberPreview == 3 then f_drawCharAnim(t_selChars[p2Cell+1], 'p2AnimStand', 310, 158, true, 0.5, 0.5) end
								if p2memberPreview == 4 then f_drawCharAnim(t_selChars[p2Cell+1], 'p2AnimStand', 250, 158, true, 0.5, 0.5) end
							--else
								--f_drawCharAnim(t_selChars[p2Cell+1], 'p2AnimStand', 132, 105, true, 0.5, 0.5)
							end
						end
					end
					if t_unlockLua.chars[t_selChars[p2Cell+1].char] ~= nil and not onlinegame then
						if data.charPresentation == "Portrait" or data.charPresentation == "Mixed" then
							if p2numChars == 1 then
								f_drawQuickSpr(p2portraitLockWindowBG, 320, 20, 120, 140, 256, 102)
								f_drawQuickSpr(p2portraitLock, 295.5, 50, 0.20, 0.20)
							elseif p2numChars == 2 then
								if data.coop then
									f_drawQuickSpr(p1portraitLockWindowBG, 0, 90, 120, 70, 256, 102)
									f_drawQuickSpr(p1portraitLock, 42, 106, 0.10, 0.10)
								else
									if p2memberPreview == 1 then
										f_drawQuickSpr(p2portraitLockWindowBG, 320, 20, 120, 70, 256, 102)
										f_drawQuickSpr(p2portraitLock, 278, 36, 0.10, 0.10)
									elseif p2memberPreview == 2 then
										f_drawQuickSpr(p2portraitLockWindowBG, 320, 90, 120, 70, 256, 102)
										f_drawQuickSpr(p2portraitLock, 278, 106, 0.10, 0.10)
									end
								end
							elseif p2numChars == 3 then
								if p2memberPreview == 1 then
									f_drawQuickSpr(p2portraitLockWindowBG, 320, 20, 120, 70, 256, 102)
									f_drawQuickSpr(p2portraitLock, 278, 36, 0.10, 0.10)
								elseif p2memberPreview == 2 then
									f_drawQuickSpr(p2portraitLockWindowBG, 320, 90, 60, 70, 256, 102)
									f_drawQuickSpr(p2portraitLock, 308, 106, 0.10, 0.10)
								elseif p2memberPreview == 3 then
									f_drawQuickSpr(p2portraitLockWindowBG, 260, 90, 60, 70, 256, 102)
									f_drawQuickSpr(p2portraitLock, 248, 106, 0.10, 0.10)
								end
							elseif p2numChars == 4 then
								if p2memberPreview == 1 then
									f_drawQuickSpr(p2portraitLockWindowBG, 320, 20, 60, 70, 256, 102)
									f_drawQuickSpr(p2portraitLock, 308, 36, 0.10, 0.10)
								elseif p2memberPreview == 2 then
									f_drawQuickSpr(p2portraitLockWindowBG, 260, 20, 60, 70, 256, 102)
									f_drawQuickSpr(p2portraitLock, 248, 36, 0.10, 0.10)
								elseif p2memberPreview == 3 then
									f_drawQuickSpr(p2portraitLockWindowBG, 320, 90, 60, 70, 256, 102)
									f_drawQuickSpr(p2portraitLock, 308, 106, 0.10, 0.10)
								elseif p2memberPreview == 4 then
									f_drawQuickSpr(p2portraitLockWindowBG, 260, 90, 60, 70, 256, 102)
									f_drawQuickSpr(p2portraitLock, 248, 106, 0.10, 0.10)
								end
							end
						elseif data.charPresentation == "Sprite" then
							if data.coop then
								f_drawQuickSpr(p1portraitLock, 110, 75, 0.15, 0.15)
							else
								f_drawQuickSpr(p2portraitLock, 300 - 28*#t_selected, 75, 0.15, 0.15)
							end
						end
					end
				end
			end
			for j=#t_selected, 1, -1 do
				if not exclusiveStageMenu then
					if data.charPresentation == "Portrait" or data.charPresentation == "Mixed" then
						--drawPortrait(t_selected[j].cel, 320 - 60*(j-1), 20, -1, 1)
						if p2numChars == 1 then
							if data.randomPortrait == "Fixed" and p2member1Random == true then
								f_drawQuickSpr(p2randomPortrait, 320, 20)
							else
								drawPortrait(t_selected[1].cel, 320, 20, -1, 1)
							end
						elseif p2numChars == 2 then
							if j == 2 then
								if data.randomPortrait == "Fixed" and p2member2Random == true then
									if data.charPresentation == "Portrait" then
										f_drawQuickSpr(p2randomPortrait, 320, 90, 1, 0.5)
									elseif data.charPresentation == "Mixed" then
										f_drawQuickSpr(p2randomPortrait, 320, 90, 0.5, 0.5)
									end
								else
									if data.charPresentation == "Portrait" then
										drawPortrait(t_selected[2].cel, 320, 90, -1, 0.5)
									elseif data.charPresentation == "Mixed" then
										drawPortrait(t_selected[2].cel, 320, 90, -0.5, 0.5)
									end
								end
							end
							if data.randomPortrait == "Fixed" and p2member1Random == true then
								if data.charPresentation == "Portrait" then
									f_drawQuickSpr(p2randomPortrait, 320, 20, 1, 0.5)
								elseif data.charPresentation == "Mixed" then
									f_drawQuickSpr(p2randomPortrait, 320, 20, 0.5, 0.5)
								end
							else
								if data.charPresentation == "Portrait" then
									drawPortrait(t_selected[1].cel, 320, 20, -1, 0.5)
								elseif data.charPresentation == "Mixed" then
									drawPortrait(t_selected[1].cel, 320, 20, -0.5, 0.5)
								end
							end
						elseif p2numChars == 3 then
							if j == 3 then
								if data.randomPortrait == "Fixed" and p2member3Random == true then
									f_drawQuickSpr(p2randomPortrait, 260, 90, 0.5, 0.5)
								else
									drawPortrait(t_selected[3].cel, 260, 90, -0.5, 0.5)
								end
							end
							if j == 2 then
								if data.randomPortrait == "Fixed" and p2member2Random == true then
									f_drawQuickSpr(p2randomPortrait, 320, 90, 0.5, 0.5)
								else
									drawPortrait(t_selected[2].cel, 320, 90, -0.5, 0.5)
								end
							end
							if data.randomPortrait == "Fixed" and p2member1Random == true then
								if data.charPresentation == "Portrait" then
									f_drawQuickSpr(p2randomPortrait, 320, 20, 1, 0.5)
								elseif data.charPresentation == "Mixed" then
									f_drawQuickSpr(p2randomPortrait, 290, 20, 0.5, 0.5)
								end
							else
								if data.charPresentation == "Portrait" then
									drawPortrait(t_selected[1].cel, 320, 20, -1, 0.5)
								elseif data.charPresentation == "Mixed" then
									drawPortrait(t_selected[1].cel, 290, 20, -0.5, 0.5)
								end
							end
						elseif p2numChars == 4 then
							if j == 4 then
								if data.randomPortrait == "Fixed" and p2member4Random == true then
									f_drawQuickSpr(p2randomPortrait, 260, 90, 0.5, 0.5)
								else
									drawPortrait(t_selected[4].cel, 260, 90, -0.5, 0.5)
								end
							end
							if j == 3 then
								if data.randomPortrait == "Fixed" and p2member3Random == true then
									f_drawQuickSpr(p2randomPortrait, 320, 90, 0.5, 0.5)
								else
									drawPortrait(t_selected[3].cel, 320, 90, -0.5, 0.5)
								end
							end
							if j == 2 then
								if data.randomPortrait == "Fixed" and p2member2Random == true then
									f_drawQuickSpr(p2randomPortrait, 260, 20, 0.5, 0.5)
								else
									drawPortrait(t_selected[2].cel, 260, 20, -0.5, 0.5)
								end
							end
							if data.randomPortrait == "Fixed" and p2member1Random == true then
								f_drawQuickSpr(p2randomPortrait, 320, 20, 0.5, 0.5)
							else
								drawPortrait(t_selected[1].cel, 320, 20, -0.5, 0.5)
							end
						end
					end
					if data.charPresentation == "Sprite" or data.charPresentation == "Mixed" then
						if data.charPresentation == "Sprite" then
							if j == 4 then
								if data.randomPortrait == "Fixed" and p2member4Random == true then
									f_drawQuickSpr(p2randomSprite, 176, 75)
								else
									f_drawCharAnim(t_selChars[t_selected[4].cel+1], 'p2AnimWin', 196, 164, t_selected[4].up, 1, 1, alphaS)
								end
							end
							if j == 3 then
								if data.randomPortrait == "Fixed" and p2member3Random == true then
									f_drawQuickSpr(p2randomSprite, 204, 75)
								else
									f_drawCharAnim(t_selChars[t_selected[3].cel+1], 'p2AnimWin', 224, 164, t_selected[3].up, 1, 1, alphaS)
								end
							end
							if j == 2 then
								if data.randomPortrait == "Fixed" and p2member2Random == true then
									f_drawQuickSpr(p2randomSprite, 232, 75)
								else
									f_drawCharAnim(t_selChars[t_selected[2].cel+1], 'p2AnimWin', 252, 164, t_selected[2].up, 1, 1, alphaS)
								end
							end
							if data.randomPortrait == "Fixed" and p2member1Random == true then
								f_drawQuickSpr(p2randomSprite, 260, 75)
							else
								f_drawCharAnim(t_selChars[t_selected[1].cel+1], 'p2AnimWin', 280, 164, t_selected[1].up, 1, 1, alphaS)
							end
							--f_drawCharAnim(t_selChars[t_selected[j].cel+1], 'p2AnimWin', 280 - 28*(j-1), 164, t_selected[j].up, 1, 1, alphaS)
						elseif data.charPresentation == "Mixed" then
							if p2numChars == 1 then
								if data.randomPortrait == "Fixed" and p2member1Random == true then
									--You can put your own sprite for random select but as also we are using the portrait logic is not necessary
								else
									f_drawCharAnim(t_selChars[t_selected[1].cel+1], 'p2AnimWin', 290, 158, t_selected[1].up, 1, 1, alphaS)
								end
							elseif p2numChars == 2 then
								if j == 2 then
									if data.randomPortrait == "Fixed" and p2member2Random == true then
										
									else
										f_drawCharAnim(t_selChars[t_selected[2].cel+1], 'p2AnimWin', 230, 158, t_selected[2].up, 0.5, 0.5, alphaS)
									end
								end
								if data.randomPortrait == "Fixed" and p2member1Random == true then
									
								else
									f_drawCharAnim(t_selChars[t_selected[1].cel+1], 'p2AnimWin', 230, 90, t_selected[1].up, 0.5, 0.5, alphaS)
								end
							elseif p2numChars == 3 then
								if j == 3 then
									if data.randomPortrait == "Fixed" and p2member3Random == true then
										
									else
										f_drawCharAnim(t_selChars[t_selected[3].cel+1], 'p2AnimWin', 250, 158, t_selected[3].up, 0.5, 0.5, alphaS)
									end
								end
								if j == 2 then
									if data.randomPortrait == "Fixed" and p2member2Random == true then
										
									else
										f_drawCharAnim(t_selChars[t_selected[2].cel+1], 'p2AnimWin', 310, 158, t_selected[2].up, 0.5, 0.5, alphaS)
									end
								end
								if data.randomPortrait == "Fixed" and p2member1Random == true then
									
								else
									f_drawCharAnim(t_selChars[t_selected[1].cel+1], 'p2AnimWin', 280, 89, t_selected[1].up, 0.5, 0.5, alphaS)
								end
							elseif p2numChars == 4 then
								if j == 4 then
									if data.randomPortrait == "Fixed" and p2member4Random == true then
										
									else
										f_drawCharAnim(t_selChars[t_selected[4].cel+1], 'p2AnimWin', 250, 158, t_selected[4].up, 0.5, 0.5, alphaS)
									end
								end
								if j == 3 then
									if data.randomPortrait == "Fixed" and p2member3Random == true then
										
									else
										f_drawCharAnim(t_selChars[t_selected[3].cel+1], 'p2AnimWin', 310, 158, t_selected[3].up, 0.5, 0.5, alphaS)
									end
								end
								if j == 2 then
									if data.randomPortrait == "Fixed" and p2member2Random == true then
										
									else
										f_drawCharAnim(t_selChars[t_selected[2].cel+1], 'p2AnimWin', 250, 89, t_selected[2].up, 0.5, 0.5, alphaS)
									end
								end
								if data.randomPortrait == "Fixed" and p2member1Random == true then
									
								else
									f_drawCharAnim(t_selChars[t_selected[1].cel+1], 'p2AnimWin', 310, 89, t_selected[1].up, 0.5, 0.5, alphaS)
								end
							end
						end
					end
				end
			end
		end
		for j=#t_selected, 1, -1 do --Again to set priority over sprites
			if not exclusiveStageMenu then
				if data.charPresentation == "Portrait" or data.charPresentation == "Mixed" then
					if p2numChars == 1 then
						if data.randomPortrait == "Fixed" and p2member1Random == true then
							f_drawQuickText(txt_p2RandomMember1, jgFnt, 5, -1, "RANDOM SELECT 1", 310, 165, 0.8, 0.8)
						else
							f_drawSelectName(txt_p2Name, t_selected[1], 310, 165)
						end
					elseif p2numChars == 2 then
						if j == 2 then
							if data.charPresentation == "Portrait" then
								if data.randomPortrait == "Fixed" and p2member2Random == true then
									f_drawQuickText(txt_p2RandomMember2, jgFnt, 5, -1, "RANDOM SELECT 2", 318, 100, 0.8, 0.8)
								else
									f_drawSelectName(txt_p2Name, t_selected[2], 318, 100)
								end
							elseif data.charPresentation == "Mixed" then
								if data.randomPortrait == "Fixed" and p2member2Random == true then
									f_drawQuickText(txt_p2RandomMember2, jgFnt, 5, -1, "RANDOM SELECT 2", 254, 100, 0.5, 0.5)
								else
									f_drawSelectName(txt_p2Name, t_selected[2], 254, 100, 0.5, 0.5)
								end
							end
						end
						if data.charPresentation == "Portrait" then
							if data.randomPortrait == "Fixed" and p2member1Random == true then
								f_drawQuickText(txt_p2RandomMember1, jgFnt, 5, -1, "RANDOM SELECT 1", 318, 88, 0.8, 0.8)
							else
								f_drawSelectName(txt_p2Name, t_selected[1], 318, 88)
							end
						elseif data.charPresentation == "Mixed" then
							if data.randomPortrait == "Fixed" and p2member1Random == true then
								f_drawQuickText(txt_p2RandomMember1, jgFnt, 5, -1, "RANDOM SELECT 1", 254, 30, 0.5, 0.5)
							else
								f_drawSelectName(txt_p2Name, t_selected[1], 254, 30, 0.5, 0.5)
							end
						end
					elseif p2numChars == 3 then
						if j == 3 then
							if data.randomPortrait == "Fixed" and p2member3Random == true then
								f_drawQuickText(txt_p2RandomMember3, jgFnt, 5, -1, "RANDOM SELECT 3", 254, 100, 0.5, 0.5)
							else
								f_drawSelectName(txt_p2Name, t_selected[3], 254, 100, 0.5, 0.5)
							end
						end
						if j == 2 then
							if data.randomPortrait == "Fixed" and p2member2Random == true then
								f_drawQuickText(txt_p2RandomMember2, jgFnt, 5, -1, "RANDOM SELECT 2", 320, 100, 0.5, 0.5)
							else
								f_drawSelectName(txt_p2Name, t_selected[2], 320, 100, 0.5, 0.5)
							end
						end
						if data.charPresentation == "Portrait" then
							if data.randomPortrait == "Fixed" and p2member1Random == true then
								f_drawQuickText(txt_p2RandomMember1, jgFnt, 5, -1, "RANDOM SELECT 1", 318, 88, 0.8, 0.8)
							else
								f_drawSelectName(txt_p2Name, t_selected[1], 318, 88)
							end
						elseif data.charPresentation == "Mixed" then
							if data.randomPortrait == "Fixed" and p2member1Random == true then
								f_drawQuickText(txt_p2RandomMember1, jgFnt, 5, -1, "RANDOM SELECT 1", 290, 30, 0.5, 0.5)
							else
								f_drawSelectName(txt_p2Name, t_selected[1], 290, 30, 0.5, 0.5)
							end
						end
					elseif p2numChars == 4 then
						if j == 4 then
							if data.randomPortrait == "Fixed" and p2member4Random == true then
								f_drawQuickText(txt_p2RandomMember4, jgFnt, 5, -1, "RANDOM SELECT 4", 254, 100, 0.5, 0.5)
							else
								f_drawSelectName(txt_p2Name, t_selected[4], 254, 100, 0.5, 0.5)
							end
						end
						if j == 3 then
							if data.randomPortrait == "Fixed" and p2member3Random == true then
								f_drawQuickText(txt_p2RandomMember3, jgFnt, 5, -1, "RANDOM SELECT 3", 320, 100, 0.5, 0.5)
							else
								f_drawSelectName(txt_p2Name, t_selected[3], 320, 100, 0.5, 0.5)
							end
						end
						if j == 2 then
							if data.randomPortrait == "Fixed" and p2member2Random == true then
								f_drawQuickText(txt_p2RandomMember2, jgFnt, 5, -1, "RANDOM SELECT 2", 254, 30, 0.5, 0.5)
							else
								f_drawSelectName(txt_p2Name, t_selected[2], 254, 30, 0.5, 0.5)
							end
						end
						if data.randomPortrait == "Fixed" and p2member1Random == true then
							f_drawQuickText(txt_p2RandomMember1, jgFnt, 5, -1, "RANDOM SELECT 1", 320, 30, 0.5, 0.5)
						else
							f_drawSelectName(txt_p2Name, t_selected[1], 320, 30, 0.5, 0.5)
						end
					end
				elseif data.charPresentation == "Sprite" then
					if j == 4 then
						if data.randomPortrait == "Fixed" and p2member4Random == true then
							f_drawQuickText(txt_p2RandomMember4, jgFnt, 5, -1, "RANDOM SELECT 4", 308, 166, 0.8, 0.8)
						else
							f_drawSelectName(txt_p2Name, t_selected[4], 308, 166)
						end
					end
					if j == 3 then
						if data.randomPortrait == "Fixed" and p2member3Random == true then
							f_drawQuickText(txt_p2RandomMember3, jgFnt, 5, -1, "RANDOM SELECT 3", 312, 160, 0.8, 0.8)
						else
							f_drawSelectName(txt_p2Name, t_selected[3], 312, 160)
						end
					end
					if j == 2 then
						if data.randomPortrait == "Fixed" and p2member2Random == true then
							f_drawQuickText(txt_p2RandomMember2, jgFnt, 5, -1, "RANDOM SELECT 2", 316, 154, 0.8, 0.8)
						else
							f_drawSelectName(txt_p2Name, t_selected[2], 316, 154)
						end
					end
					if data.randomPortrait == "Fixed" and p2member1Random == true then
						f_drawQuickText(txt_p2RandomMember1, jgFnt, 5, -1, "RANDOM SELECT 1", 320, 148, 0.8, 0.8)
					else
						f_drawSelectName(txt_p2Name, t_selected[1], 320, 148)
					end
				end
				if data.charInfo == "Author" then
					if t_selChars[p2Cell+1].author ~= nil or getCharName(p2Cell) == "Random" then
						if data.charPresentation == "Portrait" or data.charPresentation == "Mixed" then
							if p2numChars == 1 then
								if data.randomPortrait == "Fixed" and p2member1Random == true then
									--Keep random author as: ???
								else
									textImgSetText(txt_p2Author, txt_authorText..t_selected[1].author)
								end
								textImgDraw(txt_p2Author)
							elseif p2numChars == 2 then
								if j == 2 then
									if data.randomPortrait == "Fixed" and p2member2Random == true then
									--
									else
										textImgSetText(txt_p2Author, txt_authorText..t_selected[2].author)
										
									end
									textImgScalePosDraw(txt_p2Author, 320, 165, 0.65, 0.65)
								end
								if j == 1 then
									if data.randomPortrait == "Fixed" and p2member1Random == true then
									--
									else
										textImgSetText(txt_p2Author, txt_authorText..t_selected[1].author)
										
									end
									textImgScalePosDraw(txt_p2Author, 320, 20, 0.65, 0.65)
								end
							elseif p2numChars == 3 then
								if j == 3 then
									if data.randomPortrait == "Fixed" and p2member3Random == true then
									--
									else
										textImgSetText(txt_p2Author, txt_authorText..t_selected[3].author)
										
									end
									textImgScalePosDraw(txt_p2Author, 260, 95, 0.5, 0.5)
								end
								if j == 2 then
									if data.randomPortrait == "Fixed" and p2member2Random == true then
									--
									else
										textImgSetText(txt_p2Author, txt_authorText..t_selected[2].author)
										
									end
									textImgScalePosDraw(txt_p2Author, 320, 165, 0.5, 0.5)
								end
								if j == 1 then
									if data.randomPortrait == "Fixed" and p2member1Random == true then
									--
									else
										textImgSetText(txt_p2Author, txt_authorText..t_selected[1].author)
									end
									textImgScalePosDraw(txt_p2Author, 320, 25, 0.5, 0.5)
								end
							elseif p2numChars == 4 then
								if j == 4 then
									if data.randomPortrait == "Fixed" and p2member4Random == true then
									--
									else
										textImgSetText(txt_p2Author, txt_authorText..t_selected[4].author)
										
									end
									textImgScalePosDraw(txt_p2Author, 260, 95, 0.5, 0.5)
								end
								if j == 3 then
									if data.randomPortrait == "Fixed" and p2member3Random == true then
									--
									else
										textImgSetText(txt_p2Author, txt_authorText..t_selected[3].author)
										
									end
									textImgScalePosDraw(txt_p2Author, 320, 165, 0.5, 0.5)
								end
								if j == 2 then
									if data.randomPortrait == "Fixed" and p2member2Random == true then
									--
									else
										textImgSetText(txt_p2Author, txt_authorText..t_selected[2].author)
										
									end
									textImgScalePosDraw(txt_p2Author, 260, 89, 0.5, 0.5)
								end
								if j == 1 then
									if data.randomPortrait == "Fixed" and p2member1Random == true then
									--
									else
										textImgSetText(txt_p2Author, txt_authorText..t_selected[1].author)
										
									end
									textImgScalePosDraw(txt_p2Author, 320, 25, 0.5, 0.5)
								end
							end
						elseif data.charPresentation == "Sprite" then
							if data.randomPortrait == "Fixed" and p2member1Random == true then
							--
							else
								textImgSetText(txt_p2Author, txt_authorText..t_selected[j].author)
							end
							textImgPosDraw(txt_p2Author, 320, 20+10*(j-1), 0.65, 0.65)
						end
					end
				end
			end
		end
		if p2coopReady then --Draw Player 2 Selected Assets for Co-Op Mode
			--Portrait
			if data.charPresentation == "Portrait" or data.charPresentation == "Mixed" then
				if data.randomPortrait == "Fixed" and p2coopRandom == true then
					if data.charPresentation == "Portrait" then
						f_drawQuickSpr(p1randomPortrait, 0, 90, 1, 0.5)
					elseif data.charPresentation == "Mixed" then
						f_drawQuickSpr(p1randomPortrait, 0, 90, 0.5, 0.5)
					end
				else
					if data.charPresentation == "Portrait" then
						drawPortrait(data.t_p1selected[2].cel, 0, 90, 1, 0.5)
					elseif data.charPresentation == "Mixed" then
						drawPortrait(data.t_p1selected[2].cel, 0, 90, 0.5, 0.5)
					end
				end
			end
			--Animated Sprite
			if data.charPresentation == "Sprite" or data.charPresentation == "Mixed" then
				if data.charPresentation == "Sprite" then
					if data.randomPortrait == "Fixed" and p2coopRandom == true then
						f_drawQuickSpr(p1randomSprite, 48, 75)
					else
						f_drawCharAnim(t_selChars[data.t_p1selected[2].cel+1], 'p1AnimWin', 68, 164, data.t_p1selected[2].up, 1, 1, alphaS)
					end
				elseif data.charPresentation == "Mixed" then
					if data.randomPortrait == "Fixed" and p2coopRandom == true then
						--
					else
						f_drawCharAnim(t_selChars[data.t_p1selected[2].cel+1], 'p1AnimWin', 90, 158, data.t_p1selected[2].up, 0.5, 0.5, alphaS)
					end
				end
			end
			--Name
			if data.charPresentation == "Portrait" then
				if data.randomPortrait == "Fixed" and p2coopRandom == true then
					f_drawQuickText(txt_p2RandomMember2, jgFnt, 5, -1, "RANDOM SELECT 2", 116, 100, 0.8, 0.8)
				else
					f_drawSelectName(txt_p2Name, data.t_p1selected[2], 116, 100)
				end	
			elseif data.charPresentation == "Mixed" then
				if data.randomPortrait == "Fixed" and p2coopRandom == true then
					f_drawQuickText(txt_p2RandomMember2, jgFnt, 5, 1, "RANDOM SELECT 2", 66, 100, 0.5, 0.5)
				else
					f_drawSelectName(txt_p2Name, data.t_p1selected[2], 66, 100, 0.5, 0.5)
				end
			end
			if data.charPresentation == "Portrait" or data.charPresentation == "Mixed" then
				--Author
				if data.randomPortrait == "Fixed" and p2coopRandom == true then
				--
				else
					textImgSetText(txt_p1Author, txt_authorText..data.t_p1selected[2].author)
				end
				textImgScalePosDraw(txt_p1Author, 0, 165, 0.65, 0.65)
			elseif data.charPresentation == "Sprite" then
				if data.randomPortrait == "Fixed" and p2coopRandom == true then
					--
				else
					textImgSetText(txt_p1Author, txt_authorText..data.t_p1selected[j].author)
				end
				textImgScalePosDraw(txt_p1Author, 0, 30, 0.65, 0.65)
			end
		end
		if not p2SelEnd then
			local tmpCelX = p2SelX
			local tmpCelY = p2SelY
			if backScreen == false and not p2CharEnd then
				if commandGetState(p2Cmd, 'u') or (commandGetState(p2Cmd, 'holdu') and bufSel2u >= 30) then
					local foundCel = false
					while true do
						if foundCel then
							break
						end
						p2SelY, p2FaceOffset, p2OffsetRow = f_findCelYSub(p2SelY, p2FaceOffset, p2OffsetRow)
						if getCharName(p2SelX+selectColumns*p2SelY) ~= '' then
							foundCel = true
						else
							for i=0, tmpCelX do
								p2SelX = f_findCelXSub(p2SelX, false)
								if getCharName(p2SelX+selectColumns*p2SelY) ~= '' then
									foundCel = true
									break
								end
							end
							if not foundCel then
								p2SelX = tmpCelX
								for i=1, selectColumns-tmpCelX do
									p2SelX = f_findCelXAdd(p2SelX, false)
									if getCharName(p2SelX+selectColumns*p2SelY) ~= '' then
										foundCel = true
										break
									end
								end
								if not foundCel then
									p2SelX = tmpCelX
								end
							end
						end
					end
					if tmpCelY ~= p2SelY or tmpCelX ~= p2SelX then
						sndPlay(sndSys, 100, 0)
					end
				elseif commandGetState(p2Cmd, 'd') or (commandGetState(p2Cmd, 'holdd') and bufSel2d >= 30) then
					local foundCel = false
					while true do
						if foundCel then
							break
						end
						p2SelY, p2FaceOffset, p2OffsetRow = f_findCelYAdd(p2SelY, p2FaceOffset, p2OffsetRow)
						if getCharName(p2SelX+selectColumns*p2SelY) ~= '' then
							foundCel = true
						else
							for i=1, selectColumns-tmpCelX do
								p2SelX = f_findCelXAdd(p2SelX, false)
								if getCharName(p2SelX+selectColumns*p2SelY) ~= '' then
									foundCel = true
									break
								end
							end
							if not foundCel then
								p2SelX = tmpCelX
								for i=0, tmpCelX do
									p2SelX = f_findCelXSub(p2SelX, false)
									if getCharName(p2SelX+selectColumns*p2SelY) ~= '' then
										foundCel = true
										break
									end
								end
								if not foundCel then
									p2SelX = tmpCelX
								end
							end
						end
					end
					if tmpCelY ~= p2SelY or tmpCelX ~= p2SelX then
						sndPlay(sndSys, 100, 0)
					end
				elseif commandGetState(p2Cmd, 'l') or (commandGetState(p2Cmd, 'holdl') and bufSel2l >= 30) then
					while true do
						p2SelX = f_findCelXSub(p2SelX, wrappingX)
						if getCharName(p2SelX+selectColumns*p2SelY) ~= '' then break end
					end
					if tmpCelX ~= p2SelX then
						sndPlay(sndSys, 100, 0)
					end
				elseif commandGetState(p2Cmd, 'r') or (commandGetState(p2Cmd, 'holdr') and bufSel2r >= 30) then
					while true do
						p2SelX = f_findCelXAdd(p2SelX, wrappingX)
						if getCharName(p2SelX+selectColumns*p2SelY) ~= '' then break end
					end
					if tmpCelX ~= p2SelX then
						sndPlay(sndSys, 100, 0)
					end
				end
				if commandGetState(p2Cmd, 'holdu') then
					bufSel2d = 0
					bufSel2u = bufSel2u + 1
				elseif commandGetState(p2Cmd, 'holdd') then
					bufSel2u = 0
					bufSel2d = bufSel2d + 1
				elseif commandGetState(p2Cmd, 'holdr') then
					bufSel2l = 0
					bufSel2r = bufSel2r + 1
				elseif commandGetState(p2Cmd, 'holdl') then
					bufSel2r = 0
					bufSel2l = bufSel2l + 1
				else
					bufSel2u = 0
					bufSel2d = 0
					bufSel2r = 0
					bufSel2l = 0
				end
			end
			p2Cell = p2SelX + selectColumns*p2SelY
			p2Portrait = p2Cell
			--Draw Hidden Rows Cursors
			--[[
			if offsetRows >= 1 and not data.p2Faces then
				animDraw(arrowsUSR)
				animUpdate(arrowsUSR)
				animDraw(arrowsDSR)
				animUpdate(arrowsDSR)
			elseif offsetRows >= 1 and data.p2Faces then
				animDraw(arrowsUMR2)
				animUpdate(arrowsUMR2)
				animDraw(arrowsDMR2)
				animUpdate(arrowsDMR2)
			end
			]]
			if data.charInfo == "Author" then
				if t_selChars[p2Cell+1].author ~= nil or getCharName(p2Cell) == "Random" then
					if t_selChars[p2Cell+1].author ~= nil then
						textImgSetText(txt_p2Author, txt_authorText..t_selChars[p2Cell+1].author)
					else
						textImgSetText(txt_p2Author, txt_authorText.."???")
					end
					if data.coop then
						textImgSetAlign(txt_p2Author, 1)
						if data.charPresentation == "Sprite" then
							textImgScalePosDraw(txt_p2Author, 0, 30, 0.65, 0.65)
						else
							textImgScalePosDraw(txt_p2Author, 0, 165, 0.65, 0.65)
						end
					else
						textImgSetAlign(txt_p2Author, -1)
						textImgScalePosDraw(txt_p2Author, 320, 20, 0.65, 0.65)
						--textImgDraw(txt_p2Author)
					end
				end
			end
			textImgSetBank(txt_p2Name, 0)
			textImgSetText(txt_p2Name, f_getName(p2Cell))
			if data.charPresentation == "Portrait" or data.charPresentation == "Mixed" then
				if p2numChars == 1 then
					textImgScalePosDraw(txt_p2Name, 310, 165, 0.8, 0.8)
				elseif p2numChars == 2 then
					if data.coop then
						if data.charPresentation == "Portrait" then
							textImgScalePosDraw(txt_p2Name, 116, 100, 0.8, 0.8)
						elseif data.charPresentation == "Mixed" then
							textImgScalePosDraw(txt_p2Name, 116, 100, 0.5, 0.5)
						end
					else
						if p2memberPreview == 1 then
							if data.charPresentation == "Portrait" then
								textImgScalePosDraw(txt_p2Name, 318, 88, 0.8, 0.8)
							elseif data.charPresentation == "Mixed" then
								textImgScalePosDraw(txt_p2Name, 254, 30, 0.5, 0.5)
							end
						end
						if p2memberPreview == 2 then
							if data.charPresentation == "Portrait" then
								textImgScalePosDraw(txt_p2Name, 318, 100, 0.8, 0.8)
							elseif data.charPresentation == "Mixed" then
								textImgScalePosDraw(txt_p2Name, 254, 100, 0.5, 0.5)
							end
						end
					end
				elseif p2numChars == 3 then
					if p2memberPreview == 1 then
						if data.charPresentation == "Portrait" then
							textImgScalePosDraw(txt_p2Name, 318, 88, 0.8, 0.8)
						elseif data.charPresentation == "Mixed" then
							textImgScalePosDraw(txt_p2Name, 290, 30, 0.5, 0.5)
						end
					end
					if p2memberPreview == 2 then textImgScalePosDraw(txt_p2Name, 320, 100, 0.5, 0.5) end
					if p2memberPreview == 3 then textImgScalePosDraw(txt_p2Name, 254, 100, 0.5, 0.5) end
				elseif p2numChars == 4 then
					if p2memberPreview == 1 then textImgScalePosDraw(txt_p2Name, 320, 30, 0.5, 0.5) end
					if p2memberPreview == 2 then textImgScalePosDraw(txt_p2Name, 254, 30, 0.5, 0.5) end
					if p2memberPreview == 3 then textImgScalePosDraw(txt_p2Name, 320, 100, 0.5, 0.5) end
					if p2memberPreview == 4 then textImgScalePosDraw(txt_p2Name, 254, 100, 0.5, 0.5) end
				end
			elseif data.charPresentation == "Sprite" then
				if data.coop then
					textImgPosDraw(txt_p2Name, 150, 156)
				else
					if p2memberPreview == 1 then
						textImgPosDraw(txt_p2Name, 320, 148)
					elseif p2memberPreview == 2 then
						textImgPosDraw(txt_p2Name, 316, 154)
					elseif p2memberPreview == 3 then
						textImgPosDraw(txt_p2Name, 312, 160)
					elseif p2memberPreview == 4 then
						textImgPosDraw(txt_p2Name, 308, 166)
					end
				end
			end
		--Back to Team Menu Logic
			if (data.p1In == 2 and data.p2In == 2) then --Player 1 in player 2 (right) side
				if commandGetState(p2Cmd, 'e') then
					if serviceBack == true then
						f_p2sideReset()
						p2TeamEnd = true
						p2BG = true
						p2memberPreview = 1
					elseif p2SelBack == true then
						sndPlay(sndSys, 100, 2)
						f_p2sideReset()
					end
				end
			else
				if commandGetState(p1Cmd, 'e') and p2SelBack == true and not data.coop then
					sndPlay(sndSys, 100, 2)
					f_p2sideReset()
				end
			end
			if btnPalNo(p2Cmd) > 0 then
				if t_unlockLua.chars[t_selChars[p2Cell+1].char] == nil or onlinegame then
					f_p2Selection()
				elseif t_unlockLua.chars[t_selChars[p2Cell+1].char] ~= nil and not onlinegame then
					sndPlay(sndSys, 100, 5)
				end
			elseif selectTimer == 0 then
				if t_unlockLua.chars[t_selChars[p2Cell+1].char] ~= nil and not onlinegame then
					p2Cell = t_randomChars[math.random(#t_randomChars)]
				end
				f_p2Selection()
			end
			if p2HandicapEnd and p2PalEnd and p2CharEnd then
				local cel = p2Cell
				if getCharName(cel) == "Random" then
					randomP2Rematch = true
					cel = t_randomChars[math.random(#t_randomChars)]
					if data.coop then p2coopRandom = true end
					if p2memberPreview == 1 then p2member1Random = true	end
					if p2memberPreview == 2 then p2member2Random = true	end
					if p2memberPreview == 3 then p2member3Random = true	end
					if p2memberPreview == 4 then p2member4Random = true	end
				else
					f_p2charAnnouncer()
				end
				if p2numChars > 1 and not data.coop then
					if p2memberPreview == 1 then p2memberPreview = 2
					elseif p2memberPreview == 2 then p2memberPreview = 3
					elseif p2memberPreview == 3 then p2memberPreview = 4
					elseif p2memberPreview == 4 then p2memberPreview = 1
					end
				end
				local updateAnim = true
				if data.coop then
					for i=1, #data.t_p1selected do
						if data.t_p1selected[i].cel == p2Cell then 
							updateAnim = false
						end
					end
					data.t_p1selected[2] = {['cel'] = cel, ['name'] = t_selChars[cel+1].name, ['displayname'] = t_selChars[cel+1].displayname, ['path'] = t_selChars[cel+1].char, ['pal'] = p2PalSel, ['handicap'] = p2HandicapSel, ['up'] = updateAnim, ['author'] = t_selChars[cel+1].author}
					p2coopReady = true
					p2SelEnd = true
				else
					for i=1, #data.t_p2selected do
						if data.t_p2selected[i].cel == p2Cell then 
							updateAnim = false
						end
					end
					data.t_p2selected[#data.t_p2selected+1] = {['cel'] = cel, ['name'] = t_selChars[cel+1].name, ['displayname'] = t_selChars[cel+1].displayname, ['path'] = t_selChars[cel+1].char, ['pal'] = p2PalSel, ['handicap'] = p2HandicapSel, ['up'] = updateAnim, ['author'] = t_selChars[cel+1].author}
					if #data.t_p2selected == p2numChars then
						--
						if data.p1In == 2 and matchNo == 0 then
							p1TeamEnd = false
							p1SelEnd = false
							--commandBufReset(p1Cmd)
						end
						--
						p2SelEnd = true
					else
						p2HandicapEnd = false
						p2PalEnd = false
						p2CharEnd = false
					end
				end
				if data.debugLog then
					f_printTable(data.t_p2selected, "save/debug/data.t_p2selected.txt")
					f_printTable(t_selected, "save/debug/t_selected.txt")
				end
			end
		end
	end
end

function f_p2Selection()
	sndPlay(sndSys, 100, 1)
	if data.palType == "Classic" then
		p2PalSel = btnPalNo(p2Cmd)
		if selectTimer == 0 then p2PalSel = 1 end --Avoid freeze when Character Select timer is over and there is not are a palette selected
		p2PalEnd = true
	else
		if getCharName(p2Cell) == "Random" then
			p2PalSel = math.random(1,12) --Set Random Palette for random select
			p2PalEnd = true
		end
	end
	if data.gameMode ~= "versus" or data.ftcontrol > 0 then
		p2HandicapSel = 1 --Set Normal Handicap as Default
		p2HandicapEnd = true
	end
	p2CharEnd = true
	cmdInput()
end

--;===========================================================
--; PLAYER 2 PALETTE SELECT
--;===========================================================
function f_p2SelectPal()
	if (commandGetState(p2Cmd, 'r') or commandGetState(p2Cmd, 'd') or (commandGetState(p2Cmd, 'holdd') and bufPal2d >= 30) or (commandGetState(p2Cmd, 'holdr') and bufPal2r >= 30)) and p2PalSel <= 11 then
		sndPlay(sndSys, 100, 0)
		p2PalSel = p2PalSel + 1
	elseif (commandGetState(p2Cmd, 'l') or commandGetState(p2Cmd, 'u') or (commandGetState(p2Cmd, 'holdu') and bufPal2u >= 30) or (commandGetState(p2Cmd, 'holdl') and bufPal2l >= 30)) and p2PalSel > 1 then
		sndPlay(sndSys, 100, 0)
		p2PalSel = p2PalSel - 1
	end
	if commandGetState(p2Cmd, 'holdu') then
		bufPal2d = 0
		bufPal2u = bufPal2u + 1
	elseif commandGetState(p2Cmd, 'holdd') then
		bufPal2u = 0
		bufPal2d = bufPal2d + 1
	elseif commandGetState(p2Cmd, 'holdr') then
		bufPal2l = 0
		bufPal2r = bufPal2r + 1
	elseif commandGetState(p2Cmd, 'holdl') then
		bufPal2r = 0
		bufPal2l = bufPal2l + 1
	else
		bufPal2u = 0
		bufPal2d = 0
		bufPal2r = 0
		bufPal2l = 0
	end
	animPosDraw(palSelBG, palSelBGP2posX, palSelBGP2posY)
	textImgDraw(txt_p2Pal)
	textImgSetText(txt_p2PalNo, p2PalSel.."/12")
	textImgDraw(txt_p2PalNo)
	if p2PalSel > 1 then
		animPosDraw(palSelArrowLeft, palSelArrowLP2posX, palSelArrowLP2posY)
	end
	if p2PalSel <= 11 then
		animPosDraw(palSelArrowRight, palSelArrowRP2posX, palSelArrowRP2posY)
	end
	if btnPalNo(p2Cmd) > 0 or selectTimer == 0 then
		sndPlay(sndSys, 100, 1)
		p2PalEnd = true
		cmdInput()
	elseif commandGetState(p2Cmd, 'e') then
		sndPlay(sndSys, 100, 2)
		p2CharEnd = false
		cmdInput()
	end
end

--;===========================================================
--; PLAYER 2 HANDICAP SELECT
--;===========================================================
function f_p2SelectHandicap()
	local maxItems = 3
	if commandGetState(p2Cmd, 'u') or (commandGetState(p2Cmd, 'holdu') and bufHand2u >= 30) then
		sndPlay(sndSys, 100, 0)
		p2HandicapSel = p2HandicapSel - 1
	elseif commandGetState(p2Cmd, 'd') or (commandGetState(p2Cmd, 'holdd') and bufHand2d >= 30) then
		sndPlay(sndSys, 100, 0)
		p2HandicapSel = p2HandicapSel + 1
	end
	if p2HandicapSel < 1 then
		p2HandicapSel = #t_handicapSelect2
		if #t_handicapSelect2 > maxItems then
			p2HandicapCursorPosY = maxItems
		else
			p2HandicapCursorPosY = #t_handicapSelect2
		end
	elseif p2HandicapSel > #t_handicapSelect2 then
		p2HandicapSel = 1
		p2HandicapCursorPosY = 1
	elseif (commandGetState(p2Cmd, 'u') or (commandGetState(p2Cmd, 'holdu') and bufHand2u >= 30)) and p2HandicapCursorPosY > 1 then
		p2HandicapCursorPosY = p2HandicapCursorPosY - 1
	elseif (commandGetState(p2Cmd, 'd') or (commandGetState(p2Cmd, 'holdd') and bufHand2d >= 30)) and p2HandicapCursorPosY < maxItems then
		p2HandicapCursorPosY = p2HandicapCursorPosY + 1
	end
	if p2HandicapCursorPosY == maxItems then
		p2HandicapMoveTxt = (p2HandicapSel - maxItems) * 13
	elseif p2HandicapCursorPosY == 1 then
		p2HandicapMoveTxt = (p2HandicapSel - 1) * 13
	end
	if #t_handicapSelect2 <= maxItems then
		maxP2Handicap = #t_handicapSelect2
	elseif p2HandicapSel - p2HandicapCursorPosY > 0 then
		maxP2Handicap = p2HandicapSel + maxItems - p2HandicapCursorPosY
	else
		maxP2Handicap = maxItems
	end
	if commandGetState(p2Cmd, 'holdu') then
		bufHand2d = 0
		bufHand2u = bufHand2u + 1
	elseif commandGetState(p2Cmd, 'holdd') then
		bufHand2u = 0
		bufHand2d = bufHand2d + 1
	elseif commandGetState(p2Cmd, 'holdr') then
		bufHand2l = 0
		bufHand2r = bufHand2r + 1
	elseif commandGetState(p2Cmd, 'holdl') then
		bufHand2r = 0
		bufHand2l = bufHand2l + 1
	else
		bufHand2u = 0
		bufHand2d = 0
		bufHand2r = 0
		bufHand2l = 0
	end
	animPosDraw(handicapWindowBG, handicapSelBGP2posX, handicapSelBGP2posY)
	textImgDraw(txt_handicapP2)
	for i=1, maxP2Handicap do
		if i > p2HandicapSel - p2HandicapCursorPosY then
			if i == p2HandicapSel then
				p2Handbank = 5
			else
				p2Handbank = 0
			end
			if t_handicapSelect2[i].id ~= nil then
				textImgDraw(f_updateTextImg(t_handicapSelect2[i].id, jgFnt, p2Handbank, 0, t_handicapSelect2[i].text, 244, 168+i*13-p2HandicapMoveTxt, 0.95, 0.95))
			end
		end
	end
	animSetWindow(cursorBox, 172, 158+p2HandicapCursorPosY*13, 145, 13)
	f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
	animDraw(f_animVelocity(cursorBox, -1, -1))
	if maxP2Handicap > maxItems then
		animPosDraw(handicapSelArrowUp, handicapSelArrowUP2posX, handicapSelArrowUP2posY)
	end
	if #t_handicapSelect2 > maxItems and maxP2Handicap < #t_handicapSelect2 then
		animPosDraw(handicapSelArrowDown, handicapSelArrowDP2posX, handicapSelArrowDP2posY)
	end
	if btnPalNo(p2Cmd) > 0 or selectTimer == 0 then
		sndPlay(sndSys, 100, 1)
		p2HandicapEnd = true
		cmdInput()
	elseif commandGetState(p2Cmd, 'e') then
		sndPlay(sndSys, 100, 2)
		p2PalEnd = false
		cmdInput()
	end
end

--;===========================================================
--; STAGE SELECT MENU
--;===========================================================
function f_selectStage()
	if data.debugLog then f_printTable(data.t_p1selected, "save/debug/data.t_p1selected.txt") end
	if data.stageMenu then --If Stage Select is Enabled
		stageMenuActive = true --To Delete content from previous menu
		if data.rosterAdvanced == true then
			f_loadCharResources() --Because in selectAdvanced for some side, there's not a character loaded
		else --selectSimple game modes
		--Logic For Auto Characters Song
			p1charSong = ""
			if t_selChars[data.t_p1selected[1].cel+1].music ~= nil then
				p1charSong = math.random(1,#t_selChars[data.t_p1selected[1].cel+1].music) --if there are more than 1 song assigned for that character, pick 1 of them via randomizer
				p1charSong = t_selChars[data.t_p1selected[1].cel+1].music[p1charSong].bgmusic --data.t_p1selected[1] means that data (music) will taken from 1st char member selected in any team mode, but if you set data.t_p1selected[2] will get data from the 2nd member of a team mode.
				p1song = true
			else --If there no music assigned for left side character
				p1song = false
			end
			p2charSong = ""
			if t_selChars[data.t_p2selected[1].cel+1].music ~= nil then
				p2charSong = math.random(1,#t_selChars[data.t_p2selected[1].cel+1].music)
				p2charSong = t_selChars[data.t_p2selected[1].cel+1].music[p2charSong].bgmusic
				p2song = true
			else --If there no music assigned for right side character
				p2song = false
			end
		--Logic For Auto Characters Stage
			if t_selChars[data.t_p1selected[1].cel+1].stage ~= nil then
				p1charStage = math.random(1,#t_selChars[data.t_p1selected[1].cel+1].stage) --if there are more than 1 stage assigned for that character, pick 1 of them via randomizer
				p1charStage = t_selChars[data.t_p1selected[1].cel+1].stage[p1charStage] --data.t_p1selected[1] means that data (stage) will taken from 1st char member selected in any team mode, but if you set data.t_p1selected[2] will get data from the 2nd member of a team mode.
				p1stage = true
			else --If there no stage assigned for left side character
				p1stage = false
			end
			if t_selChars[data.t_p2selected[1].cel+1].stage ~= nil then
				p2charStage = math.random(1,#t_selChars[data.t_p2selected[1].cel+1].stage)
				p2charStage = t_selChars[data.t_p2selected[1].cel+1].stage[p2charStage]
				p2stage = true
			else
				--If there no stage assigned for right side character
				p2stage = false
			end
		end
	--Set screen Assets
		if data.stageType == "Classic" then
			--Info Text
			textImgSetPos(txt_selStage, 160, 239)
			
			textImgSetPos(txt_selectMusic, 158, 170.5)
			textImgSetScale(txt_selectMusic, 0.5, 0.5)
			
			textImgSetPos(txt_stageAuthor, 206.5, 186)
			textImgSetScale(txt_stageAuthor, 0.5, 0.5)
			textImgSetAlign(txt_stageAuthor, 1)
			textImgSetBank(txt_stageAuthor, 0)
			
			textImgSetPos(txt_stageLocation, 159, 227)
			textImgSetScale(txt_stageLocation, 0.5, 0.5)
			textImgSetBank(txt_stageLocation, 0)
			
			textImgSetPos(txt_stageDayTime, 112, 186)
			textImgSetScale(txt_stageDayTime, 0.5, 0.5)
			textImgSetAlign(txt_stageDayTime, -1)
			textImgSetBank(txt_stageDayTime, 0)
		elseif data.stageType == "Modern" then
			exclusiveStageMenu = true
			--Info Text
			textImgSetPos(txt_selStage, 160, 205)
			
			textImgSetPos(txt_selectMusic, 158, 60)
			textImgSetScale(txt_selectMusic, 1, 1)
			
			textImgSetPos(txt_stageAuthor, 159, 235)
			textImgSetScale(txt_stageAuthor, 1, 1)
			textImgSetAlign(txt_stageAuthor, 0)
			textImgSetBank(txt_stageAuthor, 0)
			
			textImgSetPos(txt_stageLocation, 159, 220)
			textImgSetScale(txt_stageLocation, 1, 1)
			textImgSetBank(txt_stageLocation, 0)
			
			textImgSetPos(txt_stageDayTime, 159, 190)
			textImgSetScale(txt_stageDayTime, 1, 1)
			textImgSetAlign(txt_stageDayTime, 0)
			textImgSetBank(txt_stageDayTime, 0)
			--Draw Stage Select Title BG
			animDraw(f_animVelocity(selectSTBG2a, -1, 0))
			animDraw(f_animVelocity(selectSTBG2b, -3, 0))
			animDraw(f_animVelocity(selectSTBG2c, -6, 0))
			--Draw Stage Name BG
			animDraw(f_animVelocity(selectSBG2a, 1, 0))
			animDraw(f_animVelocity(selectSBG2b, 3, 0))
			animDraw(f_animVelocity(selectSBG2c, 6, 0))
			--Draw Stage Title Text
			textImgDraw(txt_stageSelect)
		end
		--if stageAnnouncer == false then
			if backScreen == false and stageAnnouncer == false then
				if commandGetState(p1Cmd, 's') or commandGetState(p2Cmd, 's') then
					if stageSelect == true then
						--sndPlay(sndSys, 100, 0)
						--TO-DO: Alternative Stage Code Like Ikemen Go Chars Slots
					end
					if songSelect == true then --Song Preview
						if stageList == 0 then
						--Do Nothing because Song Preview for Random Stage will get an Error because it can't detect which Stage will be Selected (can be resolved by adding a Song selection Menu Apart from the stage selection, it will work when a Stage was selected)
						else 
							f_musicPreview()
						end
					end
				elseif commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u') then
					sndPlay(sndSys, 100, 0)
					if bufStagel then bufStagel = 0 end
					if bufStager then bufStager = 0 end
					--Allow Stage Select
					if stageSelect then stageSelect = false
					else stageSelect = true
					end
					--Allow Song Select
					if songSelect then songSelect = false
					else songSelect = true
					end
				elseif commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd') then
					sndPlay(sndSys, 100, 0)
					if bufStagel then bufStagel = 0 end
					if bufStager then bufStager = 0 end
					--Allow Stage Select
					if stageSelect then stageSelect = false
					else stageSelect = true
					end
					--Allow Song Select
					if songSelect then songSelect = false
					else songSelect = true
					end
				elseif (commandGetState(p1Cmd, 'r') or commandGetState(p2Cmd, 'r')) or ((commandGetState(p1Cmd, 'holdr') or commandGetState(p2Cmd, 'holdr')) and bufStager >= 30) then
					sndPlay(sndSys, 100, 0)
					if stageSelect == true then
					--Auto Right Side Stage Logic
						if stageList == 0 and not p1autoSlot then
							if p2stage == true and not p2autoSlot then --Go to Auto Stage
								p2autoSlot = true
								--stageList = 0
							elseif not p2stage then --Skip Player 2 Stage if is not assigned (Go to next stage)
								stageList = stageList + 1
							elseif p2stage == true and p2autoSlot == true then --Go to first stage loaded
								p2autoSlot = false
								stageList = stageList + 1
							end
						elseif stageList ~= 0 then --Normal scrolling between stages loaded
							if not p1autoSlot and not p2autoSlot then
								stageList = stageList + 1
							end
						end
					--Auto Left Side Stage Logic
						if stageList == data.includestage + 1 then
							if p1stage == true and not p1autoSlot then --Go to Auto Stage
								p1autoSlot = true
								stageList = 0
							elseif not p1stage then --Skip Player 1 Stage if is not assigned (Go to random select)
								--p1autoSlot = false
								stageList = 0
							end
						elseif stageList == 0 and p1autoSlot == true then --Go to random select
							p1autoSlot = false
							stageList = 0
						end
					end
					if songSelect == true then
						musicList = musicList + 1
						if musicList == #t_selMusic-1 and not p1song then musicList = musicList + 1 end --Skip Player 1 Song if is not assigned
						if musicList == 1 and not p2song then musicList = musicList + 1 end --Skip Player 2 Song if is not assigned
						if musicList > #t_selMusic-1 then musicList = 0 end
					end
				elseif (commandGetState(p1Cmd, 'l') or commandGetState(p2Cmd, 'l')) or ((commandGetState(p1Cmd, 'holdl') or commandGetState(p2Cmd, 'holdl')) and bufStagel >= 30) then
					sndPlay(sndSys, 100, 0)
					if stageSelect == true then
					--Auto Left Side Stage Logic
						if stageList == 0 and not p2autoSlot then
							if p1stage == true and not p1autoSlot then --Go to Auto Stage
								p1autoSlot = true
								stageList = 0
							elseif not p1stage then --Skip Player 1 Stage if is not assigned (Go to lastest stage loaded)
								stageList = data.includestage
							elseif p1stage == true and p1autoSlot == true then --Go to lastest stage loaded
								p1autoSlot = false
								stageList = data.includestage
							end
						elseif stageList ~= 0 then --Normal scrolling between stages loaded
							if not p1autoSlot and not p2autoSlot then
								stageList = stageList - 1
							end
						end
						--Auto Right Side Stage Logic
						if stageList == 0 and p2autoSlot == true then --Go to random select
							p2autoSlot = false
							stageList = 0
						elseif stageList == 0 and not p1autoSlot then
							if p2stage == true and not p2autoSlot then --Go to Auto Stage
								p2autoSlot = true
								stageList = 0
							elseif not p2stage then --Skip Player 2 Stage if is not assigned (Go to random select)
								stageList = 0
							end
						end
					end
					if songSelect == true then
						musicList = musicList - 1
						if musicList < 0 then musicList = #t_selMusic-1 end
						if musicList == #t_selMusic-1 and not p1song then musicList = musicList - 1 end
						if musicList == 1 and not p2song then musicList = musicList - 1 end
					end
				end
			end
		--end
		if commandGetState(p1Cmd, 'holdr') or commandGetState(p2Cmd, 'holdr') then
			bufStagel = 0
			bufStager = bufStager + 1
		elseif commandGetState(p1Cmd, 'holdl') or commandGetState(p2Cmd, 'holdl') then
			bufStager = 0
			bufStagel = bufStagel + 1
		else
			bufStager = 0
			bufStagel = 0
		end
		if data.stageType == "Classic" then
			animUpdate(selStage)
			animDraw(selStage)
		elseif data.stageType == "Modern" then
			animUpdate(selStageM) --Because is an animation need this
			animDraw(selStageM)
		end
	--Stage Data
		if stageList == 0 then
			if p1autoSlot == true then
			--[[Draw Auto Stage Preview
				if data.stageType == "Classic" then
					animUpdate(stagep1)
					animDraw(stagep1)
				elseif data.stageType == "Modern" then
					animUpdate(stagep1M)
					animDraw(stagep1M)
				end
			]]
			--Set Auto Stage Name
				textImgSetText(txt_selStage, "STAGE: AUTO [LEFT SIDE]")
			elseif p2autoSlot == true then
				--[[
				if data.stageType == "Classic" then
					animUpdate(stagep2)
					animDraw(stagep2)
				elseif data.stageType == "Modern" then
					animUpdate(stagep2M)
					animDraw(stagep2M)
				end
				]]
				textImgSetText(txt_selStage, "STAGE: AUTO [RIGHT SIDE]")
			else --random select
				if data.randomStagePortrait == "Roulette" then
					textImgSetText(txt_selStage, "STAGE " .. math.random(1, data.includestage) .. ": " .. t_selStages[math.random(1, data.includestage)].name)
					if data.stageType == "Classic" then
						drawStagePortrait(math.random(1, data.includestage), 114.5, 172, 0.0705, 0.0699)
					elseif data.stageType == "Modern" then
						drawStagePortrait(math.random(1, data.includestage), 64.600, 74.8, 0.149, 0.148)
					end
				elseif data.randomStagePortrait == "Simple" or data.randomStagePortrait == "Fixed" then
					if data.stageType == "Classic" then
						--animUpdate(stage0)
						animDraw(stage0)
					elseif data.stageType == "Modern" then
						--animUpdate(stage0M)
						animDraw(stage0M)
					end
					textImgSetText(txt_selStage, "STAGE: RANDOM SELECT")
				end
			end
		else --Stages Added in select.def
		--Draw Stage Preview (Resolution Recommended for images: 1280x720)
			if data.stageType == "Classic" then
				drawStagePortrait(stageList-1, 114.5, 172, 0.0705, 0.0699)
				if t_unlockLua.stages[t_selStages[stageList].stage] ~= nil and not onlinegame then --Draw Lock stuff
					animDraw(stageLockWindowBG)
					animDraw(stageLock)
				end
			elseif data.stageType == "Modern" then
				drawStagePortrait(stageList-1, 64.600, 74.8, 0.149, 0.148)
				if t_unlockLua.stages[t_selStages[stageList].stage] ~= nil and not onlinegame then
					animDraw(stageMLockWindowBG)
					animDraw(stageMLock)
				end
			end
		--Set Stage Name
			textImgSetText(txt_selStage, "STAGE " .. stageList .. ": " .. t_selStages[stageList].name)
		end
	--BGM Data
		if musicList == #t_selMusic-2 then --Mute
			musicNo = ""
		elseif musicList == #t_selMusic-1 then --Auto Left Side
			musicNo = ""
		elseif musicList == 0 then --Auto Stage
			musicNo = ""
		elseif musicList == 1 then --Auto Right Side
			musicNo = ""
		elseif musicList == 2 then --Random
			musicNo = ""
		else --Loaded Folder Songs
			musicNo = " " .. musicList-2 .. ""
		end
	--Set BGM Name
		textImgSetText(txt_selectMusic, "BGM" .. musicNo .. ": " .. t_selMusic[musicList+1].bgmname)
	--Draw Info Text
		if stageSelect == true then --Draw Stage Cursor Text
			textImgSetBank(txt_selStage, 5)
			textImgSetBank(txt_selectMusic, 0)
			textImgDraw(txt_selStage)
			textImgDraw(txt_selectMusic)
		elseif songSelect == true then --Draw BGM Cursor Text
			textImgSetBank(txt_selStage, 0)
			textImgSetBank(txt_selectMusic, 5)
			textImgDraw(txt_selStage)
			textImgDraw(txt_selectMusic)
		end
	--Set Author Text
		if data.stageInfo == "Author" or data.stageInfo == "All" then
			if stageList == 0 then
				if p1autoSlot == true then --For Auto - Left Side Player Stage
					if t_selStages[p1charStage].author ~= nil and t_selStages[p1charStage].author ~= "" then textImgSetText(txt_stageAuthor, txt_authorStageText..t_selStages[p1charStage].author) end
				elseif p2autoSlot == true then --For Auto - Right Side Player Stage
					if t_selStages[p2charStage].author ~= nil and t_selStages[p2charStage].author ~= "" then textImgSetText(txt_stageAuthor, txt_authorStageText..t_selStages[p2charStage].author) end
				else --For Random Select
					--if data.randomStagePortrait == "Roulette" then
						--if t_selStages[math.random(1, data.includestage)].author ~= nil and t_selStages[math.random(1, data.includestage)].author ~= "" then
							--textImgSetText(txt_stageAuthor, txt_authorStageText..t_selStages[math.random(1, data.includestage)].author)
						--end
					--elseif data.randomStagePortrait == "Simple" or data.randomStagePortrait == "Fixed" then
						textImgSetText(txt_stageAuthor, txt_authorStageText.."???")
					--end
				end
			else --For loaded stages
				if t_selStages[stageList].author ~= nil and t_selStages[stageList].author ~= "" then
					textImgSetText(txt_stageAuthor, txt_authorStageText..t_selStages[stageList].author)
				else
					textImgSetText(txt_stageAuthor, txt_authorStageText.."???")
				end
			end
			if stageAnnouncer == false then textImgDraw(txt_stageAuthor) end --Draw Info Text
		end
	--Set Location Text
		if data.stageInfo == "Location" or data.stageInfo == "All" then
			if stageList == 0 then
				if p1autoSlot == true then
					if t_selStages[p1charStage].location ~= nil and t_selStages[p1charStage].location ~= "" then textImgSetText(txt_stageLocation, txt_locationStageText..t_selStages[p1charStage].location) end
				elseif p2autoSlot == true then
					if t_selStages[p2charStage].location ~= nil and t_selStages[p2charStage].location ~= "" then textImgSetText(txt_stageLocation, txt_locationStageText..t_selStages[p2charStage].location) end
				else
					--if data.randomStagePortrait == "Roulette" then
						--if t_selStages[math.random(1, data.includestage)].location ~= nil and t_selStages[math.random(1, data.includestage)].location ~= "" then
							--textImgSetText(txt_stageLocation, txt_locationStageText..t_selStages[math.random(1, data.includestage)].location)
						--end
					--elseif data.randomStagePortrait == "Simple" or data.randomStagePortrait == "Fixed" then
						textImgSetText(txt_stageLocation, txt_locationStageText.."???")
					--end
				end
			else
				if t_selStages[stageList].location ~= nil and t_selStages[stageList].location ~= "" then
					textImgSetText(txt_stageLocation, txt_locationStageText..t_selStages[stageList].location)
				else
					textImgSetText(txt_stageLocation, txt_locationStageText.."???")
				end
			end
			if stageAnnouncer == false then textImgDraw(txt_stageLocation) end
		end
	--Set Time Text
		if data.stageInfo == "Time" or data.stageInfo == "All" then
			if stageList == 0 then
				if p1autoSlot == true then
					if t_selStages[p1charStage].daytime ~= nil and t_selStages[p1charStage].daytime ~= "" then textImgSetText(txt_stageDayTime, txt_daytimeStageText..t_selStages[p1charStage].daytime) end
				elseif p2autoSlot == true then
					if t_selStages[p2charStage].daytime ~= nil and t_selStages[p2charStage].daytime ~= "" then textImgSetText(txt_stageDayTime, txt_daytimeStageText..t_selStages[p2charStage].daytime) end
				else
					--if data.randomStagePortrait == "Roulette" then
						--if t_selStages[math.random(1, data.includestage)].daytime ~= nil and t_selStages[math.random(1, data.includestage)].daytime ~= "" then
							--textImgSetText(txt_stageDayTime, txt_daytimeStageText..t_selStages[math.random(1, data.includestage)].daytime)
						--end
					--elseif data.randomStagePortrait == "Simple" or data.randomStagePortrait == "Fixed" then
						textImgSetText(txt_stageDayTime, txt_daytimeStageText.."???")
					--end
				end
			else
				if t_selStages[stageList].daytime ~= nil and t_selStages[stageList].daytime ~= "" then
					textImgSetText(txt_stageDayTime, txt_daytimeStageText..t_selStages[stageList].daytime)
				else
					textImgSetText(txt_stageDayTime, txt_daytimeStageText.."???")
				end
			end
			if stageAnnouncer == false then textImgDraw(txt_stageDayTime) end
		end
		--Stage Select Timer
		if data.gameMode == "arcade" or data.gameMode == "tower" or data.ftcontrol > 0 or data.attractMode == true then
			if data.stageType == "Classic" then textImgSetPos(txt_stageTime, 160, 70)
			elseif data.stageType == "Modern" then textImgSetPos(txt_stageTime, 160, 105)
			end
			stageTimeNumber = stageTimer/gameTick
			nodecimalStageTime = string.format("%.0f",stageTimeNumber)
			textImgSetText(txt_stageTime, nodecimalStageTime)
			if stageTimer > 0 then
				if not backScreen then stageTimer = stageTimer - 0.5 end--Activate Stage Select Timer
				textImgDraw(txt_stageTime)
			else --when stageTimer <= 0
				
			end
		end
		--When you select the stage
		if (btnPalNo(p1Cmd) > 0 or btnPalNo(p2Cmd) > 0 or stageTimer == 0) and stageAnnouncer == false then
			if stageList == 0 then --For random or character sides stages
				stageChosen = true
			else --For visible stages
				if t_unlockLua.stages[t_selStages[stageList].stage] == nil or onlinegame then --This stage is unlocked
					stageChosen = true
				elseif t_unlockLua.stages[t_selStages[stageList].stage] ~= nil and not onlinegame then --stage locked
					if stageTimer == 0 then --Select Random Stage to prevent issues when time to select is over
						stageList = 0
						stageChosen = true
					else
						stageChosen = false
						sndPlay(sndSys, 100, 5)
					end
				end
			end
		--After to verifications, this is the true selection
			if stageChosen then
				stageSelect = false
				songSelect = false
				stageAnnouncer = true
				sndPlay(sndSys, 100, 1)
				f_stageAnnouncer()
				f_loadStage()
			end
		end
		--create a timer to hear full announcer voice
		if announcerTimer > 55 then
			if data.coop == true then --To avoid issues in Stage Select with Arcade Co-Op
				p2Cell = nil
				p2Portrait = nil
				data.t_p2selected = {}
				p2PalEnd = false
				p2SelEnd = false
			end
			stageEnd = true
			cmdInput()
			--announcerTimer = 0 --Restart Stage Announcer Timer
		end
	--When stage has been selected/announcer is active:
		if stageAnnouncer == true then
			--Apply Color
			textImgSetBank(txt_selectMusic, 2)
			textImgSetBank(txt_selStage, 2)
			textImgSetBank(txt_stageAuthor, 2)
			textImgSetBank(txt_stageLocation, 2)
			textImgSetBank(txt_stageDayTime, 2)
			if stageList == 0 then --For random select
				if data.randomStagePortrait == "Simple" or data.randomStagePortrait == "Roulette" then
					textImgSetText(txt_selStage, "STAGE " .. stageNo .. ": " .. t_selStages[stageNo].name) --Load Selected Stage Name
					if t_selStages[stageNo].author ~= nil and t_selStages[stageNo].author ~= "" then textImgSetText(txt_stageAuthor, txt_authorStageText..t_selStages[stageNo].author) end --Load Selected Stage Author IF is assigned
					if t_selStages[stageNo].location ~= nil and t_selStages[stageNo].location ~= "" then textImgSetText(txt_stageLocation, txt_locationStageText..t_selStages[stageNo].location) end --Load Selected Stage Location IF is assigned
					if t_selStages[stageNo].daytime ~= nil and t_selStages[stageNo].daytime ~= "" then textImgSetText(txt_stageDayTime, txt_daytimeStageText..t_selStages[stageNo].daytime) end --Load Selected Stage Day Time IF is assigned
					if data.stageType == "Classic" then
						drawStagePortrait(stageNo-1, 114.5, 172, 0.0705, 0.0699) --Load Selected Stage Portrait
					elseif data.stageType == "Modern" then
						drawStagePortrait(stageNo-1, 64.600, 74.8, 0.149, 0.148)
					end
				end
			end
			--Re-Draw Selected Stuff
			textImgDraw(txt_selectMusic)
			textImgDraw(txt_selStage)
			if data.stageInfo == "Author" or data.stageInfo == "All" then textImgDraw(txt_stageAuthor) end
			if data.stageInfo == "Location" or data.stageInfo == "All" then textImgDraw(txt_stageLocation) end
			if data.stageInfo == "Time" or data.stageInfo == "All" then textImgDraw(txt_stageDayTime) end
		end
	else --If Stage Select is Disabled
		if data.stage == nil then --Assign Auto Stage via Select.def
			if (data.p1In == 2 and data.p2In == 2) then --Player 1 in player 2 (right) side
				if t_selChars[data.t_p1selected[1].cel+1].stage ~= nil then
					stageNo = math.random(1,#t_selChars[data.t_p1selected[1].cel+1].stage)
					stageNo = t_selChars[data.t_p1selected[1].cel+1].stage[stageNo]
				else
					stageNo = math.random(1, data.includestage)
				end
			else
				if t_selChars[data.t_p2selected[1].cel+1].stage ~= nil then
					stageNo = math.random(1,#t_selChars[data.t_p2selected[1].cel+1].stage)
					stageNo = t_selChars[data.t_p2selected[1].cel+1].stage[stageNo]
				else
					stageNo = math.random(1, data.includestage)
				end
			end
		else --if data.stage ~= nil then Assign Custom Stage Loaded in select.def via lua script, with data.stage
			data.stage = data.stage:lower() --Convert to lower case to avoid issues
			local stageID = t_stageDef[data.stage] --Get stage number from table t_stageDef
			t_stageSelected = {['cel'] = stageID, ['name'] = t_selStages[stageID].name, ['path'] = t_selStages[stageID].stage, ['author'] = t_selStages[stageID].author, ['location'] = t_selStages[stageID].location, ['daytime'] = t_selStages[stageID].daytime} --get stage info
			if data.debugLog then f_printTable(t_stageSelected, "save/debug/t_stageSelected.txt") end
			--stagePortrait = t_stageSelected.cel
			stageNo = t_stageSelected.cel
		end
		setStage(stageNo)
		selectStage(stageNo)
		stageEnd = true
	end
end

function f_loadCharResources()
	if (data.p1In == 2 and data.p2In == 2) then --Player 1 in player 2 (right) side
	--Logic For Characters Song
		p1song = false
		p2charSong = ""
		if t_selChars[data.t_p2selected[1].cel+1].music ~= nil then
			p2charSong = math.random(1,#t_selChars[data.t_p2selected[1].cel+1].music)
			p2charSong = t_selChars[data.t_p2selected[1].cel+1].music[p2charSong].bgmusic
			p2song = true
		else --If there no music assigned for right side character
			p2song = false
		end
	--Logic For Characters Stages
		p1stage = false
		if t_selChars[data.t_p2selected[1].cel+1].stage ~= nil then
			p2charStage = math.random(1,#t_selChars[data.t_p2selected[1].cel+1].stage)
			p2charStage = t_selChars[data.t_p2selected[1].cel+1].stage[p2charStage]
			p2stage = true
		else
			--If there no stage assigned for right side character
			p2stage = false
		end
	else
		p2song = false
		p1charSong = ""
		if t_selChars[data.t_p1selected[1].cel+1].music ~= nil then
			p1charSong = math.random(1,#t_selChars[data.t_p1selected[1].cel+1].music)
			p1charSong = t_selChars[data.t_p1selected[1].cel+1].music[p1charSong].bgmusic
			p1song = true
		else --If there no music assigned for left side character
			p1song = false
		end
		p2stage = false
		if t_selChars[data.t_p1selected[1].cel+1].stage ~= nil then
			p1charStage = math.random(1,#t_selChars[data.t_p1selected[1].cel+1].stage)
			p1charStage = t_selChars[data.t_p1selected[1].cel+1].stage[p1charStage]
			p1stage = true
		else --If there no stage assigned for left side character
			p1stage = false
		end
	end
end

function f_assignMusic()
	if data.bgm == nil then --Assign Stage Song via stage.def or select.def
		track = ""
		if data.stageMenu then
			if t_selStages[stageNo].music ~= nil then
				track = math.random(1,#t_selStages[stageNo].music)
				track = t_selStages[stageNo].music[track].bgmusic
			end
		else
			if (data.p1In == 2 and data.p2In == 2) then --Player 1 in player 2 (right) side
				if t_selChars[data.t_p1selected[1].cel+1].music ~= nil then
					track = math.random(1,#t_selChars[data.t_p1selected[1].cel+1].music)
					track = t_selChars[data.t_p1selected[1].cel+1].music[track].bgmusic
				elseif t_selStages[stageNo].music ~= nil then
					track = math.random(1,#t_selStages[stageNo].music)
					track = t_selStages[stageNo].music[track].bgmusic
				end
			else
				if t_selChars[data.t_p2selected[1].cel+1].music ~= nil then
					track = math.random(1,#t_selChars[data.t_p2selected[1].cel+1].music)
					track = t_selChars[data.t_p2selected[1].cel+1].music[track].bgmusic
				elseif t_selStages[stageNo].music ~= nil then
					track = math.random(1,#t_selStages[stageNo].music)
					track = t_selStages[stageNo].music[track].bgmusic
				end
			end
			stageEnd = true
		end
	else --Assign Custom Stage Song via lua script, with data.bgm
		track = data.bgm
		stageEnd = true
	end
	if musicList == #t_selMusic-2 then --Mute Song
		playBGM(bgmNothing)
	elseif musicList == #t_selMusic-1 then --Player 1 Song
		playBGM(p1charSong)
	elseif musicList == 0 then --Auto Stage Song
		playBGM(track)
	elseif musicList == 1 then --Player 2 Song
		playBGM(p2charSong)
	elseif musicList == 2 then --Random Song
		playBGM(t_selMusic[math.random(3, #t_selMusic)].bgmfile)
	else --Sound Folder Song
		playBGM(t_selMusic[musicList+1].bgmfile)
	end
end

function f_musicPreview()
	song = ""
	if t_selStages[stageList].music ~= nil then
		song = math.random(1,#t_selStages[stageList].music)
		song = t_selStages[stageList].music[song].bgmusic
	end
	if musicList == #t_selMusic-2 then --playBGM(bgmNothing)
	elseif musicList == #t_selMusic-1 and p1song then playBGM(p1charSong)
	elseif musicList == 0 then playBGM(song)
	elseif musicList == 1 and p2song then playBGM(p2charSong)
	elseif musicList == 2 then --None because Random Preview Will be different of selected
	else
		playBGM(t_selMusic[musicList+1].bgmfile)
	end
end

function f_stageAnnouncer()
	if getStageName(stageList):gsub('^["%s]*(.-)["%s]*$', '%1') == "Training Room" then sndPlay(sndAnncr, 0,0) --Stage Announcer Voice Example
	elseif getStageName(stageList):gsub('^["%s]*(.-)["%s]*$', '%1') == "Training Room 2" then sndPlay(sndAnncr, 0,0)
	--elseif getStageName(stageList):gsub('^["%s]*(.-)["%s]*$', '%1') == "Your Stage Name" then sndPlay(sndAnncr, 0,1)
	end
end

function f_loadStage()
	if stageList == 0 then
		if p1autoSlot == true then stageNo = p1charStage --Auto - Left Side Player Stage
		elseif p2autoSlot == true then stageNo = p2charStage --Auto - Right Side Player Stage
		else --Random Stage
			if randomStageRematch and data.randomStageRematch == "Fixed" then
				--stageNo = stageNo --Reload Previous Random Stage Selected
			else
				stageNo = math.random(1, data.includestage) --Load a New Random Stage
				randomStageRematch = true
			end
		end
	else stageNo = stageList --Stages Loaded via select.def
	end
	setStage(stageNo)
	selectStage(stageNo)
end

function f_loadSong() --Can be replaced by f_assignMusic() ?
	if musicList == #t_selMusic-1 then playBGM(p1charSong) --Player 1 Song
	elseif musicList == 0 then f_assignMusic() --Auto Stage Song
	elseif musicList == 1 then playBGM(p2charSong) --Player 2 Song
	elseif musicList == 2 then --Random Song
		playBGM(t_selMusic[math.random(3, #t_selMusic)].bgmfile)
	end
end

--;===========================================================
--; ORDER SELECT
--;===========================================================
function f_orderSelect()
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	local i = 0
--Order Select OFF
	if not data.orderSelect then
		while true do
			if i == 0 then
				--f_selectChar(1, data.t_p1selected)
				--f_selectChar(2, data.t_p2selected)
			elseif i == 10 then
				cmdInput()
				break
			end
			i = i + 1
			cmdInput()
			refresh()
		end
--Order Select OFF when playing in CO-OP Mode
	elseif data.coop == true then
		while true do
			if i == 0 then
				--f_selectChar(1, data.t_p1selected)
				--f_selectChar(2, data.t_p2selected)
			elseif i == 10 then
				cmdInput()
				break
			end
			i = i + 1
			cmdInput()
			refresh()
		end
--Order Select OFF when P1 and P2 playing in Single Team Mode
	elseif p1teamMode == 0 and p2teamMode == 0 then
		while true do
			if i == 0 then
				--f_selectChar(1, data.t_p1selected)
				--f_selectChar(2, data.t_p2selected)
			elseif i == 10 then
				cmdInput()
				break
			end
			i = i + 1
			cmdInput()
			refresh()
		end
--Order Select ON
	else
		local bufOrderu = 0
		local bufOrderd = 0
		local bufOrderr = 0
		local bufOrderl = 0
		local bufOrder2u = 0
		local bufOrder2d = 0
		local bufOrder2r = 0
		local bufOrder2l = 0
		local p1Confirmed = false
		local p2Confirmed = false
		local p1Row = 1
		local p2Row = 1
		local t_tmp = {}
		local sndNumber = -1
		local sndTime = 0
		local hintTime = 0
		local seconds = data.orderTime
		local orderTime = seconds*gameTick --Set time for Order Select
		local p1Anim = "p1AnimStand"
		local p2Anim = "p2AnimStand"
		local charDataL = nil
		local charDataR = nil
		local scaleDataL = nil
		local scaleDataR = nil
		local xPortScaleL, yPortScaleL = nil
		local xPortScaleR, yPortScaleR = nil
		textImgSetBank(txt_p1State, 0) --Reset Text Color
		textImgSetBank(txt_p2State, 0)
	--Set Order Select Music
		if data.rosterAdvanced and matchNo >= lastMatch then
			playBGM(bgmSelectOrderFinal)
		else	
			playBGM(bgmSelectOrder)
		end
		--f_getOrderHint() --Load First Hint
		f_resetVersusLogo()
	--Set order time
		if data.p1In == 1 and data.p2In == 2 and (#data.t_p1selected > 1 or #data.t_p2selected > 1) or data.coop == true then
			--orderTime = math.max(#data.t_p1selected, #data.t_p2selected) * 60 --Order Time is setting by the amount of characters selected
		elseif #data.t_p1selected > 1 or data.coop == true then
			--orderTime = #data.t_p1selected * 60 --Order Time is setting by the amount of characters selected
		else
			--f_selectChar(1, data.t_p1selected)
			p1Confirmed = true
			--f_selectChar(2, data.t_p2selected)
			--p2Confirmed = true --Activate to don't order CPU characters in team modes
		end
		--Portraits Scale Logic
		for j=#data.t_p1selected, 1, -1 do
			charDataL = t_selChars[data.t_p1selected[j].cel+1]
			if charDataL.orderSprScale ~= nil then
				scaleDataL = charDataL.orderSprScale
			else
				scaleDataL = "1.0,1.0"
			end
			xPortScaleL, yPortScaleL = scaleDataL:match('^([^,]-)%s*,%s*(.-)$')
		end
		for j=#data.t_p2selected, 1, -1 do
			charDataR = t_selChars[data.t_p2selected[j].cel+1]
			if charDataR.orderSprScale ~= nil then
				scaleDataR = charDataR.orderSprScale
			else
				scaleDataR = "1.0,1.0"
			end
			xPortScaleR, yPortScaleR = scaleDataR:match('^([^,]-)%s*,%s*(.-)$')
		end
		cmdInput()
		while true do
			orderTimeNumber = orderTime/gameTick
			nodecimalOrderTime = string.format("%.0f",orderTimeNumber)
			textImgSetText(txt_orderTime, nodecimalOrderTime)
		--Draw Order Select Last Match Backgrounds
			if data.rosterAdvanced and matchNo >= lastMatch then
				animDraw(f_animVelocity(selectHardBG0, -1, -1)) --Draw Red BG for Final Battle
		--Draw Order Select Normal Matchs Backgrounds
			else
				--Draw Black BG only for Tower/Abyss Mode
				if data.gameMode == "tower" or data.gameMode == "abyss" then
					animDraw(f_animVelocity(selectTowerBG0, -1, -1))
				--Draw Red BG for Special Modes
				elseif data.gameMode == "bossrush" or data.gameMode == "singleboss" or data.rosterMode == "suddendeath" or data.gameMode == "intermission" then
					animDraw(f_animVelocity(selectHardBG0, -1, -1))
				--Draw Blue BG for Normal Modes
				else
					animDraw(f_animVelocity(commonBG0, -1, -1))
				end
			end
		--Draw Window Portraits
			animDraw(f_animVelocity(orderWindowL, -2, 0))
			animDraw(f_animVelocity(orderWindowR, 2, 0))
		--Set Order Status Assets
			if not p1Confirmed then
				--textImgSetBank(txt_p1State, 3) --Set Blue Color
				textImgSetText(txt_p1State, txt_waitingOrder) --Set Text
			else
				textImgSetBank(txt_p1State, 5)
				textImgSetText(txt_p1State, txt_orderFinished)
				p1Anim = "p1AnimWin" --Change Anim when Order Select is complete
			end
			if not p2Confirmed then
				--textImgSetBank(txt_p2State, 1) --Set Red Color
				textImgSetText(txt_p2State, txt_waitingOrder)
			else
				textImgSetBank(txt_p2State, 5)
				textImgSetText(txt_p2State, txt_orderFinished)
				p2Anim = "p2AnimWin"
			end
		--Draw Order Status Text
			textImgDraw(txt_p1State)
			textImgDraw(txt_p2State)
		--Both Sides are Ready
			if p1Confirmed == true and p2Confirmed == true then
				orderTime = 0
				animSetWindow(cursorBox, 20, 9, 120, 16)
				f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
				animDraw(f_animVelocity(cursorBox, -1, -1))
			end
			i = i + 1
			if sndTime > 0 then
				sndTime = sndTime - 1
			end
			sndNumber = -1
			--Adjust characters order if timer is > 0
			if orderTime > 0 then
				orderTime = orderTime - 0.5 --Activate Order Select Timer
				textImgDraw(txt_orderTime)
				
			else --when orderTime <= 0
				
			end
		--if Player 1 has not confirmed the order yet
			if not p1Confirmed and data.p1In ~= 2 then
				if btnPalNo(p1Cmd) > 0 then
					if not p1Confirmed then
						sndNumber = 1
						--f_selectChar(1, data.t_p1selected)
						p1Confirmed = true
						commandBufReset(p1Cmd)
					end
					if data.p2In ~= 2 and p2numChars == 1 then --Necessary for Single Boss Mode
						if not p2Confirmed then
							--f_selectChar(2, data.t_p2selected)
							p2Confirmed = true
						end
					end
				elseif commandGetState(p1Cmd, 'u') or (commandGetState(p1Cmd, 'holdu') and bufOrderu >= 30) then
					if #data.t_p1selected > 1 then
						sndNumber = 0
						p1Row = p1Row - 1
						if p1Row == 0 then p1Row = #data.t_p1selected end
					end
				elseif commandGetState(p1Cmd, 'd') or (commandGetState(p1Cmd, 'holdd') and bufOrderd >= 30) then
					if #data.t_p1selected > 1 then
						sndNumber = 0
						p1Row = p1Row + 1
						if p1Row > #data.t_p1selected then p1Row = 1 end
					end
				elseif commandGetState(p1Cmd, 'l') or (commandGetState(p1Cmd, 'holdl') and bufOrderl >= 30) then
					if p1Row-1 > 0 then
						sndNumber = 0
						p1Row = p1Row - 1
						t_tmp = {}
						t_tmp[p1Row] = data.t_p1selected[p1Row+1]
						for i=1, #data.t_p1selected do
							for j=1, #data.t_p1selected do
								if t_tmp[j] == nil and i ~= p1Row+1 then
									t_tmp[j] = data.t_p1selected[i]
									break
								end
							end
						end
						data.t_p1selected = t_tmp
					end
				elseif commandGetState(p1Cmd, 'r') or (commandGetState(p1Cmd, 'holdr') and bufOrderr >= 30) then
					if p1Row+1 <= #data.t_p1selected then
						sndNumber = 0
						p1Row = p1Row + 1
						t_tmp = {}
						t_tmp[p1Row] = data.t_p1selected[p1Row-1]
						for i=1, #data.t_p1selected do
							for j=1, #data.t_p1selected do
								if t_tmp[j] == nil and i ~= p1Row-1 then
									t_tmp[j] = data.t_p1selected[i]
									break
								end
							end
						end
						data.t_p1selected = t_tmp
					end
				end
				animSetWindow(cursorBox, 0,152+p1Row*14, 140,14.5)
				f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
				animDraw(f_animVelocity(cursorBox, -1, -1))
			end
		--if Player 1 has not confirmed the order yet and IS controlled by IA (CPU VS P1)
			if not p1Confirmed and data.p1In == 2 and p2Confirmed == true then
				if btnPalNo(p1Cmd) > 0 then
					if not p1Confirmed then
						sndNumber = 1
						--f_selectChar(1, data.t_p1selected)
						p1Confirmed = true
						commandBufReset(p1Cmd)
					end
					if data.p2In ~= 2 and p2numChars == 1 then --Necessary for Single Boss Mode
						if not p2Confirmed then
							--f_selectChar(2, data.t_p2selected)
							p2Confirmed = true
						end
					end
				elseif commandGetState(p1Cmd, 'u') or (commandGetState(p1Cmd, 'holdu') and bufOrderu >= 30) then
					if #data.t_p1selected > 1 then
						sndNumber = 0
						p1Row = p1Row - 1
						if p1Row == 0 then p1Row = #data.t_p1selected end
					end
				elseif commandGetState(p1Cmd, 'd') or (commandGetState(p1Cmd, 'holdd') and bufOrderd >= 30) then
					if #data.t_p1selected > 1 then
						sndNumber = 0
						p1Row = p1Row + 1
						if p1Row > #data.t_p1selected then p1Row = 1 end
					end
				elseif commandGetState(p1Cmd, 'l') or (commandGetState(p1Cmd, 'holdl') and bufOrderl >= 30) then
					if p1Row-1 > 0 then
						sndNumber = 0
						p1Row = p1Row - 1
						t_tmp = {}
						t_tmp[p1Row] = data.t_p1selected[p1Row+1]
						for i=1, #data.t_p1selected do
							for j=1, #data.t_p1selected do
								if t_tmp[j] == nil and i ~= p1Row+1 then
									t_tmp[j] = data.t_p1selected[i]
									break
								end
							end
						end
						data.t_p1selected = t_tmp
					end
				elseif commandGetState(p1Cmd, 'r') or (commandGetState(p1Cmd, 'holdr') and bufOrderr >= 30) then
					if p1Row+1 <= #data.t_p1selected then
						sndNumber = 0
						p1Row = p1Row + 1
						t_tmp = {}
						t_tmp[p1Row] = data.t_p1selected[p1Row-1]
						for i=1, #data.t_p1selected do
							for j=1, #data.t_p1selected do
								if t_tmp[j] == nil and i ~= p1Row-1 then
									t_tmp[j] = data.t_p1selected[i]
									break
								end
							end
						end
						data.t_p1selected = t_tmp
					end
				end
				animSetWindow(cursorBox, 0,152+p1Row*14, 140,14.5)
				f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
				animDraw(f_animVelocity(cursorBox, -1, -1))
			end
		--if Player2 has not confirmed the order yet and IS controlled by IA (P1 VS CPU)
			if not p2Confirmed and data.p2In == 1 and p1Confirmed == true then
				if btnPalNo(p1Cmd) > 0 then
					if not p2Confirmed then
						sndNumber = 1
						--f_selectChar(2, data.t_p2selected)
						p2Confirmed = true
					end
				elseif commandGetState(p1Cmd, 'u') or (commandGetState(p1Cmd, 'holdu') and bufOrderu >= 30) then
					if #data.t_p2selected > 1 then
						sndNumber = 0
						p2Row = p2Row - 1
						if p2Row == 0 then p2Row = #data.t_p2selected end
					end
				elseif commandGetState(p1Cmd, 'd') or (commandGetState(p1Cmd, 'holdd') and bufOrderd >= 30) then
					if #data.t_p2selected > 1 then
						sndNumber = 0
						p2Row = p2Row + 1
						if p2Row > #data.t_p2selected then p2Row = 1 end
					end
				elseif commandGetState(p1Cmd, 'l') or (commandGetState(p1Cmd, 'holdl') and bufOrderl >= 30) then
					if p2Row+1 <= #data.t_p2selected then
						sndNumber = 0
						p2Row = p2Row + 1
						t_tmp = {}
						t_tmp[p2Row] = data.t_p2selected[p2Row-1]
						for i=1, #data.t_p2selected do
							for j=1, #data.t_p2selected do
								if t_tmp[j] == nil and i ~= p2Row-1 then
									t_tmp[j] = data.t_p2selected[i]
									break
								end
							end
						end
						data.t_p2selected = t_tmp
					end
				elseif commandGetState(p1Cmd, 'r') or (commandGetState(p1Cmd, 'holdr') and bufOrderr >= 30) then
					if p2Row-1 > 0 then
						sndNumber = 0
						p2Row = p2Row - 1
						t_tmp = {}
						t_tmp[p2Row] = data.t_p2selected[p2Row+1]
						for i=1, #data.t_p2selected do
							for j=1, #data.t_p2selected do
								if t_tmp[j] == nil and i ~= p2Row+1 then
									t_tmp[j] = data.t_p2selected[i]
									break
								end
							end
						end
						data.t_p2selected = t_tmp
					end
				end
				animSetWindow(cursorBox, 180,152+p2Row*14, 140,14.5)
				f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
				animDraw(f_animVelocity(cursorBox, -1, -1))
			end
		--if Player2 has not confirmed the order yet and is not controlled by Player 1 (P1 VS P2)
			if not p2Confirmed and data.p2In ~= 1 then
				if btnPalNo(p2Cmd) > 0 then
					if not p2Confirmed then
						sndNumber = 1
						--f_selectChar(2, data.t_p2selected)
						p2Confirmed = true
					end
				elseif commandGetState(p2Cmd, 'u') or (commandGetState(p2Cmd, 'holdu') and bufOrder2u >= 30) then
					if #data.t_p2selected > 1 then
						sndNumber = 0
						p2Row = p2Row - 1
						if p2Row == 0 then p2Row = #data.t_p2selected end
					end
				elseif commandGetState(p2Cmd, 'd') or (commandGetState(p2Cmd, 'holdd') and bufOrder2d >= 30) then
					if #data.t_p2selected > 1 then
						sndNumber = 0
						p2Row = p2Row + 1
						if p2Row > #data.t_p2selected then p2Row = 1 end
					end
				elseif commandGetState(p2Cmd, 'l') or (commandGetState(p2Cmd, 'holdl') and bufOrder2l >= 30) then
					if p2Row+1 <= #data.t_p2selected then
						sndNumber = 0
						p2Row = p2Row + 1
						t_tmp = {}
						t_tmp[p2Row] = data.t_p2selected[p2Row-1]
						for i=1, #data.t_p2selected do
							for j=1, #data.t_p2selected do
								if t_tmp[j] == nil and i ~= p2Row-1 then
									t_tmp[j] = data.t_p2selected[i]
									break
								end
							end
						end
						data.t_p2selected = t_tmp
					end
				elseif commandGetState(p2Cmd, 'r') or (commandGetState(p2Cmd, 'holdr') and bufOrder2r >= 30) then
					if p2Row-1 > 0 then
						sndNumber = 0
						p2Row = p2Row - 1
						t_tmp = {}
						t_tmp[p2Row] = data.t_p2selected[p2Row+1]
						for i=1, #data.t_p2selected do
							for j=1, #data.t_p2selected do
								if t_tmp[j] == nil and i ~= p2Row+1 then
									t_tmp[j] = data.t_p2selected[i]
									break
								end
							end
						end
						data.t_p2selected = t_tmp
					end
				end
				animSetWindow(cursorBox, 180,152+p2Row*14, 140,14.5)
				f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
				animDraw(f_animVelocity(cursorBox, -1, -1))
			end
		--sndPlay separated to not play more than 1 sound at once
			if sndNumber ~= -1 then
				sndPlay(sndSys, 100, sndNumber)
				sndTime = 30
			end
		--Order Time Over
			if orderTime == 0 then
				if not p1Confirmed then
					--f_selectChar(1, data.t_p1selected)
					p1Confirmed = true
				end
				if not p2Confirmed then
					--f_selectChar(2, data.t_p2selected)
					p2Confirmed = true
				end
				if btnPalNo(p1Cmd) > 0 or btnPalNo(p2Cmd) > 0 then
					if i < 120 then i = 120 end
				end
				data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
				break
			end
		--Draw Character Portraits
			if data.charPresentation == "Portrait" or data.charPresentation == "Mixed" then
				for j=#data.t_p1selected, 1, -1 do
					drawOrderPortrait(data.t_p1selected[j].cel, 124 - (2*j-1) * 17.9, 25, xPortScaleL, yPortScaleL)
				end
				for j=#data.t_p2selected, 1, -1 do
					drawOrderPortrait(data.t_p2selected[j].cel, 195 + (2*j-1) * 17.9, 25, -xPortScaleR, yPortScaleR)
				end
			end
		--Draw Character Sprite Animations
			if data.charPresentation == "Sprite" or data.charPresentation == "Mixed" then
			--Left Side
				for j=#data.t_p1selected, 1, -1 do
					f_drawCharAnim(t_selChars[data.t_p1selected[j].cel+1], p1Anim, 139 - (2*j-1) * 18, 163, data.t_p1selected[j].up)
				end
			--Right Side
				for j=#data.t_p2selected, 1, -1 do
					f_drawCharAnim(t_selChars[data.t_p2selected[j].cel+1], p2Anim, 180 + (2*j-1) * 18, 163, data.t_p2selected[j].up)
				end
			end
		--Draw Names
			f_drawNameList(txt_p1NameOrder, 5, data.t_p1selected, 78, 175, 0, 14, p1Row, 0)
			f_drawNameList(txt_p2NameOrder, 5, data.t_p2selected, 241, 175, 0, 14, p2Row, 0)
		--Draw Order Number Assets
			--Left Side
			for n=#data.t_p1selected, 1, -1 do
				animPosDraw(p1OrderCursor, 1, 153+14*n) --Draw Order Icon
				textImgSetText(txt_p1OrderNo, n) --Set Order Number Text
				textImgPosDraw(txt_p1OrderNo, 9, 161+14*n) --Draw Order Number Text
			end
			--Right Side
			for n=#data.t_p2selected, 1, -1 do
				animPosDraw(p2OrderCursor, 305, 153+14*n)
				textImgSetText(txt_p2OrderNo, n)
				textImgPosDraw(txt_p2OrderNo, 310, 161+14*n)
			end
		--Draw Title
			textImgDraw(txt_orderSelect)
		--Draw Assets
			animUpdate(vsLogo)
			animDraw(vsLogo)
			--[[
			animDraw(footerBG)
			if hintTime > 150 then --Time to load a new random hint
				f_getOrderHint() --Update Hint
				hintTime = 0 --Restart timer for a new random hint
			end
			textImgDraw(txt_hints) --Draw Hints
			]]
			drawOrderInputHints()
			animDraw(data.fadeTitle)
			animUpdate(data.fadeTitle)
			hintTime = hintTime + 1 --Start timer for randoms hints
			if commandGetState(p1Cmd, 'holdu') then
				bufOrderd = 0
				bufOrderu = bufOrderu + 1
			elseif commandGetState(p1Cmd, 'holdd') then
				bufOrderu = 0
				bufOrderd = bufOrderd + 1
			elseif commandGetState(p1Cmd, 'holdr') then
				bufOrderl = 0
				bufOrderr = bufOrderr + 1
			elseif commandGetState(p1Cmd, 'holdl') then
				bufOrderr = 0
				bufOrderl = bufOrderl + 1
			elseif commandGetState(p2Cmd, 'holdu') then
				bufOrder2d = 0
				bufOrder2u = bufOrder2u + 1
			elseif commandGetState(p2Cmd, 'holdd') then
				bufOrder2u = 0
				bufOrder2d = bufOrder2d + 1
			elseif commandGetState(p2Cmd, 'holdr') then
				bufOrder2l = 0
				bufOrder2r = bufOrder2r + 1
			elseif commandGetState(p2Cmd, 'holdl') then
				bufOrder2r = 0
				bufOrder2l = bufOrder2l + 1
			else
				bufOrderu = 0
				bufOrderd = 0
				bufOrderr = 0
				bufOrderl = 0
				bufOrder2u = 0
				bufOrder2d = 0
				bufOrder2r = 0
				bufOrder2l = 0
			end
			cmdInput()
			refresh()
		end
	end
end

function f_getOrderHint()
	textImgSetText(txt_hints, t_orderHints[math.random(1, #t_orderHints)].text) 
end

--;===========================================================
--; VERSUS SCREEN
--;===========================================================
function f_selectVersus()
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	local i = 0
	if data.gameMode == "abyss" then f_setAbyssStats() end --Assign Abyss Stats
	if not data.versusScreen then
		while true do
			if i == 0 then
				--f_selectChar(1, data.t_p1selected)
				--f_selectChar(2, data.t_p2selected)
			elseif i == 30 then
				cmdInput()
				break
			end
			i = i + 1
			cmdInput()
			refresh()
		end
	else
		local colorToName = 1
		local screenTime = 0
		local hintTime = 0
		local timeLimit = 150
	--Set Versus Screen Music
		if data.gameMode == "bossrush" or data.gameMode == "singleboss" or data.rosterMode == "suddendeath" or (data.rosterAdvanced and matchNo >= lastMatch) then
			playBGM(bgmVSFinal)
		elseif data.gameMode == "intermission" then
			playBGM(bgmVSSpecial)
			timeLimit = 350
		else
			playBGM(bgmVS)
		end
		f_getVSHint() --Load First Hint
		f_resetVersusLogo()
		--Portraits Scale Logic
		local charDataL = t_selChars[data.t_p1selected[1].cel+1]
		local charDataR = t_selChars[data.t_p2selected[1].cel+1]
		if charDataL.vsSprScale ~= nil then
			scaleDataL = charDataL.vsSprScale
		else
			scaleDataL = "1.0,1.0"
		end
		if charDataR.vsSprScale ~= nil then
			scaleDataR = charDataR.vsSprScale
		else
			scaleDataR = "1.0,1.0"
		end
		local xPortScaleL, yPortScaleL = scaleDataL:match('^([^,]-)%s*,%s*(.-)$')
		local xPortScaleR, yPortScaleR = scaleDataR:match('^([^,]-)%s*,%s*(.-)$')
		cmdInput()
		while true do
		--Actions
			if screenTime == timeLimit then --or (btnPalNo(p1Cmd) > 0 or btnPalNo(p2Cmd) > 0) then --Disable temporarily to prevent desync in online mode
				commandBufReset(p1Cmd)
				commandBufReset(p2Cmd)
				break
			end
		--Draw Versus Screen Last Match Backgrounds
			if data.rosterAdvanced and matchNo >= lastMatch then
				animDraw(f_animVelocity(selectHardBG0, -1, -1)) --Draw Red BG for Final Battle
		--Draw Versus Screen Normal Matchs Backgrounds
			else
				--Draw Black BG only for Tower/Abyss Mode
				if data.gameMode == "tower" or data.gameMode == "abyss" then
					animDraw(f_animVelocity(selectTowerBG0, -1, -1))
				--Draw Red BG for Special Modes
				elseif data.gameMode == "bossrush" or data.gameMode == "singleboss" or data.rosterMode == "suddendeath" or data.gameMode == "intermission" then
					animDraw(f_animVelocity(selectHardBG0, -1, -1))
				--Draw Blue BG for Normal Modes
				else
					animDraw(f_animVelocity(commonBG0, -1, -1))
				end
			end
		--Draw Window Portraits
			animDraw(f_animVelocity(vsWindowL, -2, 0))
			animDraw(f_animVelocity(vsWindowR, 2, 0))
		--Draw Character Portraits
			if data.charPresentation == "Portrait" or data.charPresentation == "Mixed" then
				drawPortrait(data.t_p1selected[1].cel, 20, 30, xPortScaleL, yPortScaleL)
				drawPortrait(data.t_p2selected[1].cel, 300, 30, -xPortScaleR, yPortScaleR)
				--You can use drawVSPortrait instead of drawPortrait to draw exclusive Portraits in this screen.
			end
		--Draw Character Sprite Animations
			if data.charPresentation == "Sprite" then
				for j=#data.t_p1selected, 1, -1 do
					f_drawCharAnim(t_selChars[data.t_p1selected[j].cel+1], 'p1AnimWin', 139 - (2*j-1) * 18, 168, data.t_p1selected[j].up)
				end
				for j=#data.t_p2selected, 1, -1 do
					f_drawCharAnim(t_selChars[data.t_p2selected[j].cel+1], 'p2AnimWin', 180 + (2*j-1) * 18, 168, data.t_p2selected[j].up)
				end
			end
		--Draw Match Info
			if data.gameMode == "arcade" or data.gameMode == "tower" or data.gameMode == "tourney" or data.gameMode == "abyss" then
				textImgDraw(txt_matchNo)
			elseif data.gameMode == "versus" or data.gameMode == "survival" or data.gameMode == "vskumite" or data.gameMode == "allroster" or data.gameMode == "intermission" then
				textImgDraw(txt_gameNo)
			elseif data.gameMode == "bossrush" then
				textImgDraw(txt_bossNo)
			elseif data.gameMode == "bonusrush" then
				textImgDraw(txt_bonusNo)
			end
		--Draw Names
			f_drawNameList(txt_p1NameVS, 5, data.t_p1selected, 78, 180, 0, 14, colorToName, 0)
			f_drawNameList(txt_p2NameVS, 5, data.t_p2selected, 241, 180, 0, 14, colorToName, 0)
		--Draw Assets
			animUpdate(vsLogo)
			animDraw(vsLogo)
			animDraw(footerBG)
			if hintTime > 150 then --Time to load a new random hint
				f_getVSHint() --Update Hint
				hintTime = 0 --Restart timer for a new random hint
			end
			textImgDraw(txt_hints) --Draw Hints
			--[[
			if data.debugMode and data.gameMode == "abyss" then
				f_drawQuickText(txt_mtcno, font2, 0, 1, "MATCH: "..matchNo, 100, 60)
				f_drawQuickText(txt_abmtcno, font2, 0, 1, "NEXT ABYSS BOSS MATCH: "..abyssBossMatch, 100, 90)
				f_drawQuickText(txt_absmtcno, font2, 0, 1, "NEXT ABYSS SPECIAL BOSS MATCH: "..getAbyssDepthBossSpecial(), 100, 120)
			end
			]]
			animDraw(data.fadeTitle)
			animUpdate(data.fadeTitle)
			hintTime = hintTime + 1 --Start Timer for Randoms Hints
			screenTime = screenTime + 1 --Start Timer for Versus Screen
			cmdInput()
			refresh()
		end
	end
end

function f_getVSHint()
	textImgSetText(txt_hints, t_vsHints[math.random(1, #t_vsHints)].text) --Get Random Hint from t_vsHints Table
end

function f_setAbyssStats()
	local statsPlus = 0
	setAbyssBossFight(0)
--Prepare Normal Boss Battle
	if matchNo > abyssBossMatch then abyssBossMatch = abyssBossMatch+abyssBossMatchNo end
--[[Each time that this screen start, abyssBossMatch will increase abyssBossMatchNo ONLY if matchNo(depth) > abyssBossMatch
	
	Examples:
		abyssBossMatchNo = 20 --loaded from screenpack.lua
		
		matchNo = 19
		abyssBossMatch = 0+20
		
		matchNo = 21
		abyssBossMatch = 20+20 = 40
		
		matchNo = 41
		abyssBossMatch = 40+20 = 60
	]]
	if matchNo == abyssBossMatch then
		statsPlus = abyssBossStatsIncrease --When enter in a normal boss match set specific cpu stats (loaded from screenpack.lua)
		abyssBossMatch = abyssBossMatch+abyssBossMatchNo --Also increase abyssBossMatch counter to the next boss to avoid boss challenger loop when enter in the match
		setAbyssBossFight(1) --This match is an Abyss Boss Fight
	end
	setAbyssDepthBoss(abyssBossMatch) --Save NORMAL boss depthNo in ssz to manage as ".com.abyssDepthBoss" via fighting.ssz, match.cns, etc
	abyssDat.nosave.nextboss = abyssBossMatch
--Prepare Special Boss Battle
	if t_abyssSel[abyssSel].specialboss ~= nil then
		if t_abyssSel[abyssSel].specialboss[abyssSpecialBossCnt] ~= nil then
			if matchNo == t_abyssSel[abyssSel].specialboss[abyssSpecialBossCnt].depth then
				statsPlus = t_abyssSel[abyssSel].specialboss[abyssSpecialBossCnt].stats --Set specific cpu stats for a SPECIAL boss
				abyssSpecialBossCnt = abyssSpecialBossCnt + 1 --Increase special abyss boss count for next special fight
				setAbyssBossFight(1) --This match is an Abyss Boss Fight
			end
			if t_abyssSel[abyssSel].specialboss[abyssSpecialBossCnt] == nil then
				setAbyssDepthBossSpecial(0) --No more special boss left
			else
				setAbyssDepthBossSpecial(t_abyssSel[abyssSel].specialboss[abyssSpecialBossCnt].depth) --Save SPECIAL boss depthNo in ssz to manage as ".com.abyssDepthBossSpecial" via fighting.ssz, match.cns, etc
			end
			abyssDat.nosave.nextspecialboss = getAbyssDepthBossSpecial()
		end
	end
--Store Abyss Stats for each player	
	if (data.p1In == 2 and data.p2In == 2) then --Player 1 in player 2 (right) side
		--TODO
	else
		for p=1, #data.t_p1selected do
			data.t_p1selected[p]['life'] = getAbyssLife()
			data.t_p1selected[p]['power'] = getAbyssPower()
			data.t_p1selected[p]['attack'] = getAbyssAttack()
			data.t_p1selected[p]['defence'] = getAbyssDefence()
		end
		for p=1, #data.t_p2selected do
			data.t_p2selected[p]['life'] = t_abyssSel[abyssSel].cpustats+statsPlus
			data.t_p2selected[p]['power'] = t_abyssSel[abyssSel].cpustats+statsPlus
			data.t_p2selected[p]['attack'] = t_abyssSel[abyssSel].cpustats+statsPlus
			data.t_p2selected[p]['defence'] = t_abyssSel[abyssSel].cpustats+statsPlus
			--
			data.t_p2selected[p]['sp1'] = "" --TODO
			data.t_p2selected[p]['sp2'] = ""
			data.t_p2selected[p]['sp3'] = ""
		end
	end
	abyssDat.nosave.life = getAbyssLife()
	abyssDat.nosave.power = getAbyssPower()
	abyssDat.nosave.attack = getAbyssAttack()
	abyssDat.nosave.defence = getAbyssDefence()
	abyssDat.nosave.reward = getAbyssReward()
	abyssDat.nosave.depth = getAbyssDepth()
	f_saveStats()
end

--;===========================================================
--; LOADING MATCH SCREEN
--;===========================================================
function f_loading()
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	if data.t_p1selected ~= nil and data.t_p2selected ~= nil then
		for i=1, #data.t_p1selected do --To set real Player Value to set handicaps and player(data.t_p1selected[i].pn) stuff in debug.lua
			local playerID = 1
			if i == 2 then playerID = 3
			elseif i == 3 then playerID = 5
			elseif i == 4 then playerID = 7
			end
			data.t_p1selected[i]['pn'] = playerID
		end
		f_selectChar(1, data.t_p1selected)
		for i=1, #data.t_p2selected do
			local playerID = 2
			if i == 2 then playerID = 4
			elseif i == 3 then playerID = 6
			elseif i == 4 then playerID = 8
			end
			data.t_p2selected[i]['pn'] = playerID
		end
		f_selectChar(2, data.t_p2selected)
	end
	local t = 0
	while true do
		if t == 30 then
			cmdInput()
			break
		end
		t = t + 1
		textImgSetText(txt_loading, "LOADING MATCH...")
		textImgDraw(txt_loading)
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		cmdInput()
		refresh()
	end
end

--;===========================================================
--; VICTORY SCREEN
--;===========================================================
function f_selectWin()
	local bufRematchu = 0
	local bufRematchd = 0
	local bufRematchr = 0
	local bufRematchl = 0
	local bufRematch2u = 0
	local bufRematch2d = 0
	local bufRematch2r = 0
	local bufRematch2l = 0
	local menuReady = false
	local timeToSkip = 650
	local winnerTeam = nil
	local winnerSide = nil
	local charData = nil
	local scaleData = nil
	local xPortScale, yPortScale = nil
	p1Cursor = 1
	p2Cursor = 1
	p1Ready = false
	p2Ready = false
	f_resetHandicaps()
	f_modeplayTime() --Store Favorite Game Mode (Addressed to Simple Character Select)
	if data.winscreen == "Fixed" or not data.victoryscreen then
		playBGM(bgmNothing)
	else --Classic/Modern Victory Screen
		playBGM(bgmVictory)
	end
	local txt = ""
	local i = 0
--Winner Logic
	if winner == 1 then
		p1Wins = p1Wins + 1
		winnerTeam = p1numChars
		winnerSide = data.t_p1selected
		if (data.p1In == 2 and data.p2In == 2) then --Player 1 in player 2 (right) side
			--Player 1 is not in this side so..:
			f_defeats() --Store Player Losses
			--f_loseCoins()
		else
			f_winCoins() --Add Coins Rewards by win
			f_victories() --Store Player Victories
		end
		if data.winscreen == "Fixed" or not data.victoryscreen then --Permanent Victory Quotes when Left Side Wins
			txt = "READY FOR THE NEXT BATTLE?"
		else --Victory Quotes from Left Side char
			txt = f_winParse(t_selChars[data.t_p1selected[1].cel+1], t_selChars[data.t_p2selected[1].cel+1], data.t_p2selected[1].pal, #data.t_p2selected)
		end
	else--if winner == 2 then
		p2Wins = p2Wins + 1
		winnerTeam = p2numChars
		winnerSide = data.t_p2selected
		if (data.p1In == 2 and data.p2In == 2) then --Player 1 in player 2 (right) side
			--Player 2 is not in this side so..:
			f_winCoins()
			f_victories()
		else
			f_defeats()
			--f_loseCoins()
		end
		if data.winscreen == "Fixed" or not data.victoryscreen then --Permanent Victory Quotes when Right Side Wins
			txt = "READY FOR THE NEXT BATTLE?"
		else --Victory Quotes from Right Side char
			txt = f_winParse(t_selChars[data.t_p2selected[1].cel+1], t_selChars[data.t_p1selected[1].cel+1], data.t_p1selected[1].pal, #data.t_p1selected)
		end
	end
	if txt == "" or txt == nil then txt = "I am the winner!" end --In case that f_winParse returns "nothing"
--Online Ranked Match Control
	if onlinegame == true and data.gameMode == "versus" then
		f_ftcontrol()
	end
	--Portraits Scale Logic
	for j=#winnerSide, 1, -1 do
		charData = t_selChars[winnerSide[j].cel+1]
		if charData.winSprScale ~= nil then
			scaleData = charData.winSprScale
		else
			scaleData = "1.0,1.0"
		end
		xPortScale, yPortScale = scaleData:match('^([^,]-)%s*,%s*(.-)$')
	end
	cmdInput()
	while true do
		if data.victoryscreen then --Only shows if data.victoryscreen == true
		--Draw Winner Screen Last Match Backgrounds
			if data.rosterAdvanced and matchNo >= lastMatch then
				animDraw(f_animVelocity(selectHardBG0, -1, -1)) --Draw Red BG for Final Battle
		--Draw Winner Screen Normal Matchs Backgrounds
			else
				--Draw Black BG only for Tower/Abyss Mode
				if data.gameMode == "tower" or data.gameMode == "abyss" then
					animDraw(f_animVelocity(selectTowerBG0, -1, -1))
				--Draw Red BG for Special Modes
				elseif data.gameMode == "bossrush" or data.gameMode == "singleboss" or data.rosterMode == "suddendeath" or data.gameMode == "intermission" then
					animDraw(f_animVelocity(selectHardBG0, -1, -1))
				--Draw Blue BG for Normal Modes
				else
					animDraw(f_animVelocity(commonBG0, -1, -1))
				end
			end
		--Draw Permanent Victory Quote Message
			if data.winscreen == "Fixed" then
				f_textRender(txt_winquoteFix, txt, i, 20, 175, 15, 2, 59)
			else --Classic/Modern Victory Screen
				if data.winscreen == "Modern" then
					animDraw(f_animVelocity(wincharBG, 0, 1.5))
					--Draw Portraits
					if data.charPresentation == "Portrait" or data.charPresentation == "Mixed" then
						if winnerTeam == 1 then
							drawWinPortrait(winnerSide[1].cel, 99, 0, xPortScale, yPortScale) --Your char portrait appears in modern win screen
						elseif winnerTeam == 2 then	--Your 2nd char portrait appears in modern win screen
							drawWinPortrait(winnerSide[2].cel, 150, 0, xPortScale, yPortScale)
							drawWinPortrait(winnerSide[1].cel, 45, 0, xPortScale, yPortScale)
						elseif winnerTeam == 3 then	--Your 3rd char portrait appears in modern win screen	
							drawWinPortrait(winnerSide[3].cel, 0, 0, xPortScale, yPortScale)
							drawWinPortrait(winnerSide[2].cel, 205, 0, xPortScale, yPortScale)
							drawWinPortrait(winnerSide[1].cel, 99, 0, xPortScale, yPortScale)
						elseif winnerTeam == 4 then	--Your 4th char portrait appears in modern win screen
							drawWinPortrait(winnerSide[4].cel, 205, 0, xPortScale, yPortScale)
							drawWinPortrait(winnerSide[3].cel, 0, 0, xPortScale, yPortScale)
							drawWinPortrait(winnerSide[2].cel, 150, 0, xPortScale, yPortScale)
							drawWinPortrait(winnerSide[1].cel, 45, 0, xPortScale, yPortScale)
						end
					--Draw Char Animations
					elseif data.charPresentation == "Sprite" then
						for j=#data.t_p1selected, 1, -1 do
							f_drawCharAnim(t_selChars[data.t_p1selected[j].cel+1], 'p1AnimWin', 178 - (2*j-1) * 18, 137.5, data.t_p1selected[j].up)
						end
					end
				elseif data.winscreen == "Classic" then
					if winner == 2 then
						--Draw Portraits
						if data.charPresentation == "Portrait" or data.charPresentation == "Mixed" then
							drawLoserPortrait(data.t_p1selected[1].cel, 32, 5, 1, 1)
						--Draw Char Animations
						elseif data.charPresentation == "Sprite" then
							for j=#data.t_p1selected, 1, -1 do
								f_drawCharAnim(t_selChars[data.t_p1selected[j].cel+1], 'p1AnimDizzy', 139 - (2*j-1) * 18, 143, data.t_p1selected[j].up)
							end
						end
					end
					animDraw(f_animVelocity(wincharBGC1, -2, 0))
					if winner == 1 then
						if data.charPresentation == "Portrait" or data.charPresentation == "Mixed" then
							drawWinPortrait(data.t_p1selected[1].cel, 32, 5, 1, 1)
							drawLoserPortrait(data.t_p2selected[1].cel, 289, 5, -1, 1)
						elseif data.charPresentation == "Sprite" then
							for j=#data.t_p1selected, 1, -1 do
								f_drawCharAnim(t_selChars[data.t_p1selected[j].cel+1], 'p1AnimWin', 149 - (2*j-1) * 18, 143, data.t_p1selected[j].up)
							end
							for j=#data.t_p2selected, 1, -1 do
								f_drawCharAnim(t_selChars[data.t_p2selected[j].cel+1], 'p2AnimDizzy', 180 + (2*j-1) * 18, 143, data.t_p2selected[j].up)
							end
						end
					end
					animDraw(f_animVelocity(wincharBGC2, 2, 0))
					if winner == 2 then
						if data.charPresentation == "Portrait" or data.charPresentation == "Mixed" then
							drawWinPortrait(data.t_p2selected[1].cel, 289, 5, -1, 1)
						elseif data.charPresentation == "Sprite" then
							for j=#data.t_p2selected, 1, -1 do
								f_drawCharAnim(t_selChars[data.t_p2selected[j].cel+1], 'p2AnimWin', 170 + (2*j-1) * 18, 143, data.t_p2selected[j].up)
							end
						end
					end
				end
			--Draw Winner Message
				animDraw(f_animVelocity(quoteBG, 2, 0))
				f_textRender(txt_winquote, txt, i, 20, 175, 15, 2, 59)
			--Draw Character Name
				textImgSetText(txt_winnername, f_getName(winnerSide[1].cel))
				textImgDraw(txt_winnername)
			end
		end
	--REMATCH OPTION
		if data.victoryscreen then --If victory screen is enable
			if data.gameMode == "versus" then --Show Rematch Menu for these modes
				if not menuReady then
					if i == timeToSkip or (btnPalNo(p1Cmd) > 0 or btnPalNo(p2Cmd) > 0) then
						cmdInput()
						menuReady = true
					end
				elseif menuReady then
					f_rematch()
				end
				if rematchEnd then
					data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
					commandBufReset(p1Cmd, 1)
					commandBufReset(p2Cmd, 2)
					break
				end
			else --Don't Show Rematch Menu
				if i == timeToSkip or (btnPalNo(p1Cmd) > 0 or btnPalNo(p2Cmd) > 0) then
					cmdInput()
					data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
					if data.orderSelect == true and data.gameMode == "arcade" then f_selectMusic()
					elseif data.gameMode == "tower" then playBGM(bgmTower)
					elseif data.gameMode == "abyss" then playBGM(bgmAbyss)
					elseif data.gameMode == "singleboss" then playBGM(bgmSelectBoss)
					end
					commandBufReset(p1Cmd, 1)
					commandBufReset(p2Cmd, 2)
					break
				end
			end
		else--If victory screen is disable
			if data.gameMode == "versus" then
				f_rematch()
			else --Don't Show Rematch Menu
				rematchEnd = true
			end
			if rematchEnd then
				data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
				if data.orderSelect == true and data.gameMode == "arcade" then f_selectMusic()
				elseif data.gameMode == "tower" then playBGM(bgmTower)
				elseif data.gameMode == "abyss" then playBGM(bgmAbyss)
				elseif data.gameMode == "singleboss" then playBGM(bgmSelectBoss)
				end
				commandBufReset(p1Cmd, 1)
				commandBufReset(p2Cmd, 2)
				break
			end
		end
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		i = i + 1
		cmdInput()
		refresh()
	end
end

function f_winParse(winner, looser, pal)
	local quote = -1
	local logVar = winner.name .. '\n'
	if winner.quotes ~= nil then
		if #winner.trigger == 0 then
			logVar = logVar .. '0 triggers found\n'
			local i = 0
			for k,v in pairs(winner.quotes) do
				i = i + 1
			end
			if i ~= 0 then
				logVar = logVar .. 'quote = random value from all ' .. i .. ' available quotes\n'
				quote = math.random(1,i)
				i = 0
				for k,v in pairs(winner.quotes) do
					i = i + 1
					if i == quote then
						quote = k
					end
				end
			else
				logVar = logVar .. '0 quotes found\n'
			end
		else
			for i=1, #winner.trigger do
				local value = 0
				local trigger = false
				local condition = false
				local triggerall = true
				local triggerCnt = 0
				logVar = logVar .. 'condition: ' .. i .. '\n'
				for k,v in pairs(winner.trigger[i]) do
					if k == 'value' then
						logVar = logVar .. ' value\n  before: ' .. v .. '\n'
						v = v:gsub('%s*', '')
						if tonumber(v) then
							value = tonumber(v)
						else
							v = v:gsub('ifelse%s*%([^,]+,[^,]+,(.+)', '(%1') --always return else value
							v = v:gsub('var%s*%(%s*[0-9]+%s*%)%s*[><=!]+', '0*')
							v = v:gsub('var%s*%(%s*[0-9]+%s*%)', '0')
							v = v:gsub('ceil%s*%(', 'math.ceil(')
							v = v:gsub('random', 'math.random(0,999)')
							v = v:gsub('%%', '*1/1000*')
							f = assert(loadstring('return ' .. v))
							value = f()
							if tonumber(value) then
								value = tonumber(value)
								value = math.floor(value)
							else
								value = -1
							end
						end
						logVar = logVar .. '  after: ' .. v .. '\n  result: ' .. value .. '\n'
					else --trigger
						local skip = false
						if k == 'all' then
							logVar = logVar .. ' triggerall' .. '\n  before: ' .. v .. '\n'
							if v:match('numenemy') then
								skip = false --Added condition for numenemy to always be true (WHY THE FUCK WOULD THERE BE NO ENEMY TO READ WINQUOTES OFF OF!!!!)
								--logVar = logVar .. '  after: skipped\n'
							elseif v:match('numpartner') then
								skip = true
								logVar = logVar .. '  after: skipped\n'
							elseif v:match('numhelper') then
								skip = true
								logVar = logVar .. '  after: skipped\n'
							elseif v:match('ishelper') then
								skip = true
								logVar = logVar .. '  after: skipped\n'
							elseif v:match('numtarget') then
								skip = true
								logVar = logVar .. '  after: skipped\n'
							elseif v:match('playeridexist') then
								skip = true
								logVar = logVar .. '  after: skipped\n'
							end
						else
							logVar = logVar .. ' trigger' .. '\n  before: ' .. v .. '\n'
							triggerCnt = triggerCnt + 1
						end
						if not skip then
							if v:match('numexplod') then
								trigger = false
								logVar = logVar .. '  after: false\n  result: false\n'
							elseif v:match('helper%s*%([^,]+,') then
								trigger = false
								logVar = logVar .. '  after: false\n  result: false\n'
							elseif v:match('s?e?l?f?animexist%s*%([^%)]+%)') then
								trigger = false
								logVar = logVar .. '  after: false\n  result: false\n'
							else
								v = v:gsub('^%s*1%s*$', 'true')
								v = v:gsub('!%s*time', 'true')
								v = v:gsub('enemyn?e?a?r?%s*,', '')
								v = v:gsub('ifelse%s*%([^,]+,[^,]+,(.+)', '(%1')
								v = v:gsub('var%s*%(%s*[0-9]+%s*%)%s*(=?)', '0%1%1')
								v = v:gsub('life%s*=', '1000 ==')
								v = v:gsub('life%s*%s*([<>!])', '1000 %1')
								v = v:gsub('winperfect', 'false')
								v = v:gsub('wintime', 'false')
								v = v:gsub('winko', 'false')
								v = v:gsub('ceil%s*%(', 'math.ceil(')
								v = v:gsub('!=', '~=')
								v = v:gsub('!', ' not ')
								v = v:gsub('||', ' or ')
								v = v:gsub('&&', ' and ')
								v = v:gsub('authorname%s*=', '"' .. looser.author .. '"==')
								v = v:gsub('name%s*=', '"' .. looser.name .. '"==')
								v = v:gsub('palno%s*=%s*%[%s*([0-9]+)%s*,%s*([0-9]+)%s*%]', '(' .. pal .. '>=%1 and ' .. pal .. '<=%2)')
								v = v:gsub('palno%s*~=%s*%[%s*([0-9]+)%s*,%s*([0-9]+)%s*%]', '(' .. pal .. '<%1 or ' .. pal .. '>%2)') --Added this case
								v = v:gsub('numenemy', 'true') --ALWAYS assume there was an enemy...
								v = v:gsub('palno%s*=', pal .. '==')
								v = v:gsub('random', 'math.random(0,999)')
								v = v:gsub('%%', '*1/1000*')
								f = assert(loadstring('if ' .. v .. ' then return true else return false end'))
								trigger = f()
								logVar = logVar .. '  after: ' .. v .. '\n  result: ' .. tostring(trigger) .. '\n'
							end
							--triggerall == false
							if k == 'all' and not trigger then
								triggerall = false
							--triggerX == true
							elseif k ~= 'all' and trigger then
								condition = true
							end
						end
					end
				end
				if triggerall and (condition or triggerCnt == 0) then
					quote = value
				end
			end
		end
		quote = tostring(quote) --quotes table keys are strings
		if winner.quotes[quote] ~= nil then
			f_printVar(logVar .. '\nquote: ' .. quote .. '\nexists: yes', 'save/debug/quotes.log')
			return winner.quotes[quote]
		else
			f_printVar(logVar .. '\nquote: ' .. quote .. '\nexists: no', 'save/debug/quotes.log')
			return ''
		end
	else
		f_printVar(logVar .. '0 triggers found\n0 quotes found\n\nquote: -1\nexists: no', 'save/debug/quotes.log')
		return ''
	end
end

--;===========================================================
--; END RANKED MATCH SCREEN
--;===========================================================
function f_ftcontrol()
	if (p1Wins == data.ftcontrol) or (p2Wins == data.ftcontrol) then
		--os.exit()--Fightcade System
		cmdInput()
		while true do
			--Draw BG
			animDraw(f_animVelocity(commonBG0, -1, -1))
			--Draw Menu BG
			animDraw(rankWindowBG)
			animUpdate(rankWindowBG)
			--Draw Info Text
			f_textRender(txt_rankText, txt_rankMsg, 0, 160, 125, 10, 0, 25)
			--Draw Esc Text
			textImgDraw(txt_rankESC)
			--Draw Cursor
			animSetWindow(cursorBox, 87,141, 144,13)
			f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
			animDraw(f_animVelocity(cursorBox, -1, -1))
			--Draw Info Title Text
			textImgDraw(txt_rankInfo)
			--Actions
			if esc() then
				sndPlay(sndSys, 100, 2)
				break
			end
			animDraw(data.fadeTitle)
			animUpdate(data.fadeTitle)
			cmdInput()
			refresh()
		end
	end
end

--;===========================================================
--; REMATCH MENU
--;===========================================================
function f_rematch()
	if not p1Ready then
		--Player 1 Cursor
		if commandGetState(p1Cmd, 'u') or (commandGetState(p1Cmd, 'holdu') and bufRematchu >= 30) then
			sndPlay(sndSys, 100, 0)
			p1Cursor = p1Cursor - 1
		elseif commandGetState(p1Cmd, 'd') or (commandGetState(p1Cmd, 'holdd') and bufRematchd >= 30) then
			sndPlay(sndSys, 100, 0)
			p1Cursor = p1Cursor + 1
		end
		if p1Cursor < 1 then
			p1Cursor = #t_battleOption
		elseif p1Cursor > #t_battleOption then
			p1Cursor = 1
		end
	end
	--Draw BG only when Winscreen is off
	if not data.victoryscreen then animDraw(f_animVelocity(commonBG0, -1, -1)) end
	if data.p2In == 1 or (data.p1In == 2 and data.p2In == 2) then --VS CPU
		--Draw Menu BG
		animDraw(rematchCPUWindowBG)
		animUpdate(rematchCPUWindowBG)
		--Draw Title
		textImgDraw(txt_rematchCPU)
	else
		animDraw(rematchWindowBG)
		animUpdate(rematchWindowBG)
		textImgDraw(txt_rematch)
	end
	--Set Color and Text Position
	for i=1, #t_battleOption do
		if data.p2In == 1 or (data.p1In == 2 and data.p2In == 2) then --VS CPU
			t_battleOption[i].id = createTextImg(jgFnt, 0, 0, t_battleOption[i].text, 159.1, 89.5+i*13,0.95,0.95)
		else
			t_battleOption[i].id = createTextImg(jgFnt, 0, 0, t_battleOption[i].text, 76, 89.5+i*13,0.95,0.95)
		end
		if i == p1Cursor + 0 then
			textImgSetBank(t_battleOption[i].id, 5)
		else
			textImgSetBank(t_battleOption[i].id, 0)
		end
		textImgDraw(t_battleOption[i].id)
	end
	if not p1Ready then
	--Draw Cursor
		if data.p2In == 1 or (data.p1In == 2 and data.p2In == 2) then --VS CPU
			animSetWindow(cursorBox, 87.1, 79.5+p1Cursor*13, 145, 13)
		else
			animSetWindow(cursorBox, 4, 79.5+p1Cursor*13, 145, 13)
		end
		f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
		animDraw(f_animVelocity(cursorBox, -1, -1))
	end
	--Player 2 Mirror Assets
	if data.p2In == 2 and data.p1In ~= 2 then
		if not p2Ready then
			if commandGetState(p2Cmd, 'u') or (commandGetState(p2Cmd, 'holdu') and bufRematch2u >= 30) then
				sndPlay(sndSys, 100, 0)
				p2Cursor = p2Cursor - 1
			elseif commandGetState(p2Cmd, 'd') or (commandGetState(p2Cmd, 'holdd') and bufRematch2d >= 30) then
				sndPlay(sndSys, 100, 0)
				p2Cursor = p2Cursor + 1
			end
			if p2Cursor < 1 then
				p2Cursor = #t_battleOption2
			elseif p2Cursor > #t_battleOption2 then
				p2Cursor = 1
			end
		end
		animDraw(rematch2WindowBG)
		animUpdate(rematch2WindowBG)
		textImgDraw(txt_rematch2)
		for i=1, #t_battleOption2 do
			t_battleOption2[i].id = createTextImg(jgFnt, 0, 0, t_battleOption2[i].text, 244, 89.5+i*13,0.9,0.9)
			if i == p2Cursor + 0 then
				textImgSetBank(t_battleOption2[i].id, 5)
			else
				textImgSetBank(t_battleOption2[i].id, 0)
			end
			textImgDraw(t_battleOption2[i].id)
		end
		if not p2Ready then
			animSetWindow(cursorBox, 172, 79.5+p2Cursor*13, 145, 13)
			f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
			animDraw(f_animVelocity(cursorBox, -1, -1))
		end
	end
	--Rematch Option Timer
	if data.gameMode == "arcade" or data.gameMode == "tower" or data.ftcontrol > 0 or data.attractMode == true then
		rematchTimeNumber = rematchTimer/gameTick
		nodecimalRematchTime = string.format("%.0f",rematchTimeNumber)
		textImgSetText(txt_rematchTime, nodecimalRematchTime)
		if rematchTimer > 0 then
			rematchTimer = rematchTimer - 0.5 --Activate Rematch Timer
			textImgDraw(txt_rematchTime)
		else --when rematchTimer <= 0
			
		end
	end
	drawRematchInputHints() --Draw Input Hints Panel
	if commandGetState(p1Cmd, 'holdu') then
		bufRematchd = 0
		bufRematchu = bufRematchu + 1
	elseif commandGetState(p2Cmd, 'holdu') then
		bufRematch2d = 0
		bufRematch2u = bufRematch2u + 1
	elseif commandGetState(p1Cmd, 'holdd') then
		bufRematchu = 0
		bufRematchd = bufRematchd + 1
	elseif commandGetState(p2Cmd, 'holdd') then
		bufRematch2u = 0
		bufRematch2d = bufRematch2d + 1
	else
		bufRematchu = 0
		bufRematchd = 0
		bufRematch2u = 0
		bufRematch2d = 0
	end
	if not p1Ready then
		if btnPalNo(p1Cmd) > 0 or rematchTimer == 0 then
			if p1Cursor == 1 then
				sndPlay(sndSys, 100, 1)
				battleOption = 1 --Rematch
				p1Ready = true
			elseif p1Cursor == 2 then
				sndPlay(sndSys, 100, 1)
				battleOption = 2 --Back to Character Select
				p1Ready = true
				p2Ready = true
			elseif p1Cursor == 3 then
				sndPlay(sndSys, 100, 1)
				battleOption = 3 --Back to Stage Select
				p1Ready = true
				p2Ready = true
			elseif p1Cursor == 4 then
				sndPlay(sndSys, 100, 2)
				battleOption = 4 --Back to Main Menu
				p1Ready = true
				p2Ready = true
			end
			if data.p2In == 1 or (data.p1In == 2 and data.p2In == 2) then --Logic for CPU
				battleOption2 = battleOption
				p2Ready = true
			end
			cmdInput()
		end
	end
	if not p2Ready then
		if data.p2In == 2 and data.p1In ~= 2 then
			if btnPalNo(p2Cmd) > 0 or rematchTimer == 0 then
				if p2Cursor == 1 then
					sndPlay(sndSys, 100, 1)
					battleOption2 = 1
					p2Ready = true
				elseif p2Cursor == 2 then
					sndPlay(sndSys, 100, 1)
					battleOption2 = 2
					p1Ready = true
					p2Ready = true
				elseif p2Cursor == 3 then
					sndPlay(sndSys, 100, 1)
					battleOption2 = 3
					p1Ready = true
					p2Ready = true
				elseif p2Cursor == 4 then
					sndPlay(sndSys, 100, 2)
					battleOption2 = 4
					p1Ready = true
					p2Ready = true
				end
				cmdInput()
			end
		end
	end
	if p1Ready and p2Ready then rematchEnd = true end
	if onlinegame == true then
		if esc() then
			battleOption = 4
			rematchEnd = true
			f_exitOnline()
		end
	end
end

function f_randomRematch()
--Get new random chars for player 1 side
	if randomP1Rematch == true and data.randomCharRematch == "Variable" then
	--Your 1st char will be randomized for your rematch
		if p1numChars == 1 or p1numChars == 2 or p1numChars == 3 or p1numChars == 4 then
			data.t_p1selected[1].cel = t_randomChars[math.random(#t_randomChars)]
			data.t_p1selected[1].pal = math.random(1,12)
		end
	--Your 2nd char will be randomized for your rematch
		if p1numChars == 2 or p1numChars == 3 or p1numChars == 4 then
			data.t_p1selected[2].cel = t_randomChars[math.random(#t_randomChars)]
			data.t_p1selected[2].pal = math.random(1,12)
		end
	--Your 3rd char will be randomized for your rematch
		if p1numChars == 3 or p1numChars == 4 then
			data.t_p1selected[3].cel = t_randomChars[math.random(#t_randomChars)]
			data.t_p1selected[3].pal = math.random(1,12)
		end
	--Your 4th char will be randomized for your rematch
		if p1numChars == 4 then
			data.t_p1selected[4].cel = t_randomChars[math.random(#t_randomChars)]
			data.t_p1selected[4].pal = math.random(1,12)
		end
	end
--Get new random chars for player 2 side
	if randomP2Rematch == true and data.randomCharRematch == "Variable" then
		if p2numChars == 1 or p2numChars == 2 or p2numChars == 3 or p2numChars == 4 then
			data.t_p2selected[1].cel = t_randomChars[math.random(#t_randomChars)]
			data.t_p2selected[1].pal = math.random(1,12)
		end
		if p2numChars == 2 or p2numChars == 3 or p2numChars == 4 then
			data.t_p2selected[2].cel = t_randomChars[math.random(#t_randomChars)]
			data.t_p2selected[2].pal = math.random(1,12)
		end
		if p2numChars == 3 or p2numChars == 4 then
			data.t_p2selected[3].cel = t_randomChars[math.random(#t_randomChars)]
			data.t_p2selected[3].pal = math.random(1,12)
		end
		if p2numChars == 4 then
			data.t_p2selected[4].cel = t_randomChars[math.random(#t_randomChars)]
			data.t_p2selected[4].pal = math.random(1,12)
		end
	end
end

--;===========================================================
--; HERE COMES A NEW CHALLENGER SCREEN
--;===========================================================
function f_selectChallenger()
	if data.gameMode ~= "abyss" then
		if data.quickCont == true and data.rosterAdvanced == true then return end
		data.rosterMode = "challenger"
	end
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	playBGM(bgmNothing)
	sndPlay(sndSys, 200, 1) --Here comes a new Challenger!
	local i = 0
	cmdInput()
	while true do
		if i == 150 then
			data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
			cmdInput()
			break
		end
	--Draw Last Match Backgrounds
		if data.rosterAdvanced and matchNo >= lastMatch then
			animDraw(f_animVelocity(selectHardBG0, -1, -1)) --Draw Red BG for Final Battle
	--Draw Normal Matchs Backgrounds
		else
		--Draw Black BG only for Tower/Abyss Mode
			if data.gameMode == "tower" or data.gameMode == "abyss" then
				animDraw(f_animVelocity(selectTowerBG0, -1, -1))
		--Draw Red BG for Special Modes
			elseif data.gameMode == "bossrush" or data.gameMode == "singleboss" or data.rosterMode == "suddendeath" or data.gameMode == "intermission" then
				animDraw(f_animVelocity(selectHardBG0, -1, -1))
		--Draw Blue BG for Normal Modes
			else
				animDraw(f_animVelocity(commonBG0, -1, -1))
			end
		end
		animDraw(f_animVelocity(challengerWindow, 0, 1.5))
		animDraw(challengerText)
		animUpdate(challengerText)
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		i = i + 1
		cmdInput()
		refresh()
	end
end

--VS CHALLENGER (use your character selected for arcade mode to defeat a human challenger the winner keep playing the arcade)
function f_challengerVS()
	f_default()
	setGameMode('vs')
	data.gameMode = "challenger"
	data.rosterMode = "versus"
	data.stageMenu = true
	--data.p2Faces = true
	textImgSetText(txt_mainSelect, "CHALLENGER MODE")
--ARCADE PLAYER IS IN LEFT SIDE - NEW CHALLENGER COMES FROM RIGHT SIDE
	if keepLSide then
		data.p1TeamMenu = {mode = p1RestoreTeamMode, chars = p1RestoreCharsNo}
		data.p2TeamMenu = {mode = p1RestoreTeamMode, chars = p1RestoreCharsNo} --Set Challenger Team Mode at same arcade player conditions
		data.p1SelectMenu = false --Character Data will be loaded in f_p1SelectMenu() following this p1SelectMenu condition
		if P2overP1 then
			setHomeTeam(2)
			remapInput(1, 2)
			remapInput(2, 1)
			setPlayerSide('p1right')
		else
			setHomeTeam(1)
		end
--ARCADE PLAYER IS IN RIGHT SIDE - NEW CHALLENGER COMES FROM LEFT SIDE
	elseif keepRSide then
		data.p1TeamMenu = {mode = p2RestoreTeamMode, chars = p2RestoreCharsNo}
		data.p2TeamMenu = {mode = p2RestoreTeamMode, chars = p2RestoreCharsNo}
		data.p2SelectMenu = false
		if not P2overP1 then
			setHomeTeam(2)
			remapInput(1, 2)
			remapInput(2, 1)
			setPlayerSide('p1right')
		else
			setHomeTeam(1)
		end
	end
	data.p2In = 2
end

--;===========================================================
--; SERVICE MENU
--;===========================================================
function f_service()
	local cursorPosY = 1
	local moveTxt = 0
	local serviceMenu = 1
	local bufu = 0
	local bufd = 0
	local bufr = 0
	local bufl = 0
	local maxItems = 12
	serviceBack = false
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	playBGM(bgmService)
	f_resetListArrowsPos()
	cmdInput()
	while true do
		if commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u') or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30) then
			devService = false
			noService = false
			sndPlay(sndSys, 100, 0)
			serviceMenu = serviceMenu - 1
		elseif commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd') or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30) then
			devService = false
			noService = false
			sndPlay(sndSys, 100, 0)
			serviceMenu = serviceMenu + 1
		end
		if (btnPalNo(p1Cmd) > 0 or btnPalNo(p2Cmd) > 0) or serviceTimer == 0 then
		--DIFFICULTY -1 BUT ALWAYS NEEDS TO BE > 1
			if serviceMenu == 1 then
				sndPlay(sndSys, 100, 1)
				if data.difficulty == 1 then
					data.difficulty = 1
				else
					data.difficulty = data.difficulty - 1
					--tmpDifficulty = data.difficulty - 1
					--setCom(2, tmpDifficulty)
				end
				if onlinegame then
					script.options.f_netsaveCfg()
				else
					script.options.f_saveCfg()
				end
				serviceBack = true
		--FULL POWER
			elseif serviceMenu == 2 then
				sndPlay(sndSys, 100, 1)
				setService("max power")
				serviceBack = true
		--LOW CPU LIFE
			elseif serviceMenu == 3 then
				sndPlay(sndSys, 100, 1)
				setService("low cpu life")
				serviceBack = true
		--CHANGE PLAYER TEAM MODE
			elseif serviceMenu == 4 then
				if data.coop == true then
					noService = true
				elseif data.quickCont == true then
					noService = true
				else
					sndPlay(sndSys, 100, 1)
					serviceTeam = true
					break
				end
		--PLAYER DEFENCE X2
			elseif serviceMenu == 5 then
				sndPlay(sndSys, 100, 1)
				setService("defence x2")
				serviceBack = true
		--[[
		--???
			elseif serviceMenu == 6 then
				devService = true
				sndPlay(sndSys, 100, 1)
				setService("?")
		]]
		--NOT SERVICE
			else
				sndPlay(sndSys, 100, 1)
				serviceBack = true
			end
		end
		if serviceTimer == 0 and noService then --Based in KOF games, set no service when time over...
			setService("")
			serviceBack = true
		end
		if serviceBack then
			commandBufReset(p1Cmd, 1)
			commandBufReset(p2Cmd, 2)
			break
		end
	--Cursor position calculation
		if serviceMenu < 1 then
			serviceMenu = #t_service
			if #t_service > maxItems then
				cursorPosY = maxItems
			else
				cursorPosY = #t_service
			end
		elseif serviceMenu > #t_service then
			serviceMenu = 1
			cursorPosY = 1
		elseif ((commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u')) or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30)) and cursorPosY > 1 then
			cursorPosY = cursorPosY - 1
		elseif ((commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd')) or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30)) and cursorPosY < maxItems then
			cursorPosY = cursorPosY + 1
		end
		if cursorPosY == maxItems then
			moveTxt = (serviceMenu - maxItems) * 15
		elseif cursorPosY == 1 then
			moveTxt = (serviceMenu - 1) * 15
		end	
		if #t_service <= maxItems then
			maxService = #t_service
		elseif serviceMenu - cursorPosY > 0 then
			maxService = serviceMenu + maxItems - cursorPosY
		else
			maxService = maxItems
		end		
	--Draw Character Select Last Match Backgrounds
		if data.rosterAdvanced and matchNo >= lastMatch then
			animDraw(f_animVelocity(selectHardBG0, -1, -1)) --Draw Red BG for Final Battle
	--Draw Character Select Normal Matchs Backgrounds
		else
		--Draw Black BG only for Tower Mode
			if data.gameMode == "tower" then
				animDraw(f_animVelocity(selectTowerBG0, -1, -1))
		--Draw Red BG for Special Modes
			elseif data.gameMode == "bossrush" or data.gameMode == "singleboss" or data.rosterMode == "suddendeath" or data.gameMode == "intermission" then
				animDraw(f_animVelocity(selectHardBG0, -1, -1))
		--Draw Blue BG for Normal Modes
			else
				animDraw(f_animVelocity(commonBG0, -1, -1))
			end
		end
	--Draw Transparent Table BG		
		animSetScale(commonTBG, 240, maxService*15)
		animSetWindow(commonTBG, 80,20, 160,180)
		animDraw(commonTBG)
	--Draw Title Menu
		textImgDraw(txt_service)
	--Draw Cursor
		animSetWindow(cursorBox, 80,5+cursorPosY*15, 160,15)
		f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
		animDraw(f_animVelocity(cursorBox, -1, -1))
	--Draw Service Info
		if noService == true then
			if data.coop == true then
				for i=1, #t_lockedService do
					textImgDraw(t_lockedService[i].id)
				end
			else
				for i=1, #t_noService do
					textImgDraw(t_noService[i].id)
				end
			end
		end
		if devService == true then
			for i=1, #t_devService do
				textImgDraw(t_devService[i].id)
			end
		end
	--Draw Text for Table
		for i=1, maxService do	
			if i > serviceMenu - cursorPosY then
				t_service[i].id = createTextImg(font2, 0, 0, t_service[i].text, 158.5, 15+i*15-moveTxt)
				textImgDraw(t_service[i].id)
			end
		end
	--Service Option Timer
		serviceTimeNumber = serviceTimer/gameTick
		nodecimalServiceTime = string.format("%.0f",serviceTimeNumber)
		textImgSetText(txt_serviceTime, nodecimalServiceTime)
		if serviceTimer > 0 then
			serviceTimer = serviceTimer - 0.5 --Activate Service Timer
			textImgDraw(txt_serviceTime)
		else --when serviceTimer <= 0
			
		end
	--Draw Up Animated Cursor
		if maxService > maxItems then
			animDraw(menuArrowUp)
			animUpdate(menuArrowUp)
		end
	--Draw Down Animated Cursor
		if #t_service > maxItems and maxService < #t_service then
			animDraw(menuArrowDown)
			animUpdate(menuArrowDown)
		end
		drawServiceInputHints() --Draw Input Hints Panel
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		if commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu') then
			bufd = 0
			bufu = bufu + 1
		elseif commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd') then
			bufu = 0
			bufd = bufd + 1
		else
			bufu = 0
			bufd = 0
		end
		cmdInput()
		refresh()
	end
end

--;===========================================================
--; RESULTS SCREEN
--;===========================================================
function f_result(state)
	--if state == "win" then
	--elseif state == "lost" then
	--end
	if data.gameMode == "tower" then rosterSize = #t_selTower[destinySelect].kombats
	elseif data.gameMode == "abyss" then
		rosterSize = t_abyssSel[abyssSel].depth
	--Save Max Abyss Depth
		if getAbyssDepth() > stats.modes.abyss.maxdepth then
			stats.modes.abyss.maxdepth = getAbyssDepth()
			f_saveStats()
		end
	elseif data.gameMode == "endless" then rosterSize = 1
	else rosterSize = #t_roster
	end
	local victoriesPercent = (winCnt/rosterSize)*100
	local charPortr = nil
	local charTable = nil
	local scaleData = nil
	if data.gameMode == "survival" or data.gameMode == "abyss" or data.gameMode == "endless" or data.gameMode == "allroster" or data.gameMode == "vskumite" then
	--Common Data
		playBGM(bgmResults)
		data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
		if (data.p1In == 2 and data.p2In == 2) then --Player 1 in player 2 (right) side
			textImgSetText(txt_resultName, f_getName(data.t_p2selected[1].cel))
			charPortr = data.t_p2selected[1].cel
			charTable = data.t_p2selected
			if p2teamMode > 0 then
				textImgSetText(txt_resultTeam, "TEAM")
			elseif p1teamMode == 0 then
				textImgSetText(txt_resultTeam, "")
			end
		else
			textImgSetText(txt_resultName, f_getName(data.t_p1selected[1].cel))
			charPortr = data.t_p1selected[1].cel
			charTable = data.t_p1selected
			if p1teamMode > 0 then
				textImgSetText(txt_resultTeam, "TEAM")
			elseif p1teamMode == 0 then
				textImgSetText(txt_resultTeam, "")
			end
		end
		if data.gameMode == "survival" then
			textImgSetAlign(txt_resultTeam, -1)
			textImgSetPos(txt_resultTeam, 318, 48)
			textImgSetAlign(txt_resultName, -1)
			textImgSetPos(txt_resultName, 318, 60)
			textImgSetText(txt_resultNo, winCnt.." WINS")
			textImgSetText(txt_resultTitle, "SURVIVAL RESULTS")
		elseif data.gameMode == "abyss" then
			textImgSetAlign(txt_resultTeam, 1)
			textImgSetPos(txt_resultTeam, 2, 50)
			textImgSetAlign(txt_resultName, 1)
			textImgSetPos(txt_resultName, 2, 65)
			textImgSetText(txt_resultTitle, "ABYSS RESULTS")
		else--if data.gameMode == "endless" or data.gameMode == "allroster" or data.gameMode == "vskumite" then
			textImgSetAlign(txt_resultTeam, 1)
			textImgSetPos(txt_resultTeam, 2, 50)
			textImgSetAlign(txt_resultName, 1)
			textImgSetPos(txt_resultName, 2, 65)
			textImgSetText(txt_resultWins, winCnt.." WINS")
			textImgSetText(txt_resultLoses, looseCnt.." LOSES")
			if data.gameMode == "endless" then textImgSetText(txt_resultTitle, "ENDLESS RESULTS")
			elseif data.rosterMode == "suddendeath" then textImgSetText(txt_resultTitle, "SUDDEN DEATH RESULTS")
			elseif data.rosterMode == "timerush" then textImgSetText(txt_resultTitle, "TIME RUSH RESULTS")
			elseif data.rosterMode == "vskumite" then textImgSetText(txt_resultTitle, getKumiteData().." RESULTS")
			--elseif data.rosterMode == "timeattack" then textImgSetText(txt_resultTitle, "TIME ATTACK RESULTS")
			--elseif data.rosterMode == "scoreattack" then textImgSetText(txt_resultTitle, "SCORE ATTACK RESULTS")
			else textImgSetText(txt_resultTitle, "RESULTS")
			end
		end
	else --Boss/Bonus Rush Exit
		return
	end
--Portraits Scale Logic
	local charData = t_selChars[charPortr+1]
	if charData.resultSprScale ~= nil then
		scaleData = charData.resultSprScale
	else
		scaleData = "1.0,1.0"
	end
	local xPortScale, yPortScale = scaleData:match('^([^,]-)%s*,%s*(.-)$')
	cmdInput()
	while true do
		if btnPalNo(p1Cmd) > 0 or btnPalNo(p2Cmd) > 0 then
			cmdInput()
			break
		end
		if data.gameMode == "survival" then
		--Draw Character Portrait
			if data.charPresentation == "Portrait" or data.charPresentation == "Mixed" then
				drawResultPortrait(charPortr, 320, 80, -xPortScale, yPortScale)
		--Draw Character Sprite Animations
			elseif data.charPresentation == "Sprite" then
				for j=#charTable, 1, -1 do
					f_drawCharAnim(t_selChars[charTable[j].cel+1], 'p2AnimWin', 180 + (2*j-1) * 18, 206.5, charTable[j].up)
				end
			end
			animDraw(resultBG) --Draw BG
			textImgDraw(txt_resultNo)
			textImgDraw(txt_resultRank)
		--Show Ranks According Some Percentage Rates
			if victoriesPercent < 35 then --0% -- 34%
				animDraw(rankF)
			elseif victoriesPercent >= 35 and victoriesPercent < 40 then --35% -- 39%
				animDraw(rankDM)
			elseif victoriesPercent >= 40 and victoriesPercent < 45 then --40% -- 44%
				animDraw(rankD)
			elseif victoriesPercent >= 45 and victoriesPercent < 50 then --45% -- 49%
				animDraw(rankDP)
			elseif victoriesPercent >= 50 and victoriesPercent < 55 then --50% -- 54%
				animDraw(rankC)
			elseif victoriesPercent >= 55 and victoriesPercent < 60 then --55% -- 59%
				animDraw(rankCP)
			elseif victoriesPercent >= 60 and victoriesPercent < 65 then --60% -- 64%
				animDraw(rankB)
			elseif victoriesPercent >= 65 and victoriesPercent < 70 then --65% -- 69%
				animDraw(rankBP)
			elseif victoriesPercent >= 70 and victoriesPercent < 75 then --70% -- 74%
				animDraw(rankA)
			elseif victoriesPercent >= 75 and victoriesPercent < 80 then --75% -- 79
				animDraw(rankAP)
			elseif victoriesPercent >= 80 and victoriesPercent < 85 then --80% -- 84%
				animDraw(rankS)
			elseif victoriesPercent >= 85 and victoriesPercent < 90 then --85% -- 89%
				animDraw(rankSP)
			elseif victoriesPercent >= 90 and victoriesPercent < 95 then --90% -- 94%
				animDraw(rankXS)
			elseif victoriesPercent >= 95 then --95% -- 100%
				animDraw(rankGDLK)
			end
		else
		--Draw Character Portrait
			if data.charPresentation == "Portrait" or data.charPresentation == "Mixed" then
				drawResultPortrait(charPortr, 0, 80, xPortScale, yPortScale)
		--Draw Character Sprite Animations
			elseif data.charPresentation == "Sprite" then
				for j=#charTable, 1, -1 do
					f_drawCharAnim(t_selChars[charTable[j].cel+1], 'p1AnimWin', 139 - (2*j-1) * 18, 206.5, charTable[j].up)
				end
			end
			animDraw(resultBG) --Draw BG
			textImgDraw(txt_resultWins)
			textImgDraw(txt_resultLoses)
		end
		if data.gameMode == "abyss" then
			f_drawAbyssResults()
		end
		--textImgDraw(txt_resultTime)
		--textImgDraw(txt_resultScore)
		textImgDraw(txt_resultTitle)
		textImgDraw(txt_resultName)
		textImgDraw(txt_resultTeam)
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		cmdInput()
		refresh()
	end
end

--;===========================================================
--; CONTINUE SCREEN
--;===========================================================
function f_continue()
	setService("")
	serviceTeam = false
	sndPlay(sndCont, 1, 1)
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	playBGM(bgmContinue)
	f_contTimerReset()
	f_gameOverReset()
	data.continue = 0
	local tablePos = ''
	local tablePos2 = ''
	local tablePos3 = ''
	local tablePos4 = ''
	local anim = false
	local anim2 = false
	local anim3 = false
	local anim4 = false
	local animLength = 0
	local animLength2 = 0
	local animLength3 = 0
	local animLength4 = 0
	local i = 0
	if (data.p1In == 2 and data.p2In == 2) then --Player 1 in player 2 (right) side
		if p2numChars == 1 or p2numChars == 2 or p2numChars == 3 or p2numChars == 4 then
			tablePos = t_selChars[data.t_p2selected[1].cel+1] --Your 1st char appear in continue screen
		end
		if p2numChars == 2 or p2numChars == 3 or p2numChars == 4 then
			tablePos2 = t_selChars[data.t_p2selected[2].cel+1] --Your 2nd char appears in continue screen
		end
		if p2numChars == 3 or p2numChars == 4 then
			tablePos3 = t_selChars[data.t_p2selected[3].cel+1] --Your 3rd char appears in continue screen
		end
		if p2numChars == 4 then
			tablePos4 = t_selChars[data.t_p2selected[4].cel+1] --Your 4th char appears in continue screen
		end
	else
		if p1numChars == 1 or p1numChars == 2 or p1numChars == 3 or p1numChars == 4 then
			tablePos = t_selChars[data.t_p1selected[1].cel+1]
		end
		if p1numChars == 2 or p1numChars == 3 or p1numChars == 4 then
			tablePos2 = t_selChars[data.t_p1selected[2].cel+1]
		end
		if p1numChars == 3 or p1numChars == 4 then
			tablePos3 = t_selChars[data.t_p1selected[3].cel+1]
		end
		if p1numChars == 4 then
			tablePos4 = t_selChars[data.t_p1selected[4].cel+1]	
		end
	end
	if tablePos.sffData ~= nil and tablePos.dizzy ~= nil then
		anim = f_animFromTable(tablePos['dizzy'], tablePos.sffData, 80, 180, tablePos.xscale, tablePos.yscale, 0, 1)
	end
	if tablePos2.sffData ~= nil and tablePos2.dizzy ~= nil then
		anim2 = f_animFromTable(tablePos2['dizzy'], tablePos2.sffData, 60, 180, tablePos2.xscale, tablePos2.yscale, 0, 1)
	end
	if tablePos3.sffData ~= nil and tablePos3.dizzy ~= nil then
		anim3 = f_animFromTable(tablePos3['dizzy'], tablePos3.sffData, 40, 180, tablePos3.xscale, tablePos3.yscale, 0, 1)
	end
	if tablePos4.sffData ~= nil and tablePos4.dizzy ~= nil then
		anim4 = f_animFromTable(tablePos4['dizzy'], tablePos4.sffData, 100, 180, tablePos4.xscale, tablePos4.yscale, 0, 1)
	end
	if data.attractMode == true then
		textImgSetText(txt_coins, "CREDITS: "..stats.attractCoins)
	--else
		--textImgSetText(txt_coins, "COINS: "..stats.coins)
	end
	textImgSetText(txt_cont, "TIMES CONTINUED: "..stats.continueCount)
	cmdInput()
	while true do
		animDraw(contBG0)
		i = i + 1
		--if commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then
			--cmdInput()
			--data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
			--playBGM(bgmTitle)
			--break
		if data.continue == 0 then --waiting for player's decision
			if anim4 then
				animDraw(anim4)
				animUpdate(anim4)
			end
			if anim3 then
				animDraw(anim3)
				animUpdate(anim3)
			end	
			if anim2 then
				animDraw(anim2)
				animUpdate(anim2)
			end
			if anim then
				animDraw(anim)
				animUpdate(anim)
				animDraw(contBG1)
				animDraw(contBG2)
			end
			if commandGetState(p1Cmd, 'w') or commandGetState(p2Cmd, 'w') then
				if tablePos.sffData ~= nil and tablePos.win ~= nil then
					anim, animLength = f_animFromTable(tablePos['win'], tablePos.sffData, 80, 180, tablePos.xscale, tablePos.yscale, 0, 1)
				else
					animLength = 0
				end
				if tablePos2.sffData ~= nil and tablePos2.win ~= nil then
					anim2, animLength2 = f_animFromTable(tablePos2['win'], tablePos2.sffData, 60, 180, tablePos2.xscale, tablePos2.yscale, 0, 1)
				else
					animLength2 = 0
				end
				if tablePos3.sffData ~= nil and tablePos3.win ~= nil then
					anim3, animLength3 = f_animFromTable(tablePos3['win'], tablePos3.sffData, 40, 180, tablePos3.xscale, tablePos3.yscale, 0, 1)
				else
					animLength3 = 0
				end
				if tablePos4.sffData ~= nil and tablePos4.win ~= nil then
					anim4, animLength4 = f_animFromTable(tablePos4['win'], tablePos4.sffData, 100, 180, tablePos4.xscale, tablePos4.yscale, 0, 1)
				else
					animLength4 = 0
				end
				if not onlinegame then
					if data.attractMode then
						if stats.attractCoins < 1 then
							stats.attractCoins = 0
						elseif stats.attractCoins >= 1 then
							stats.attractCoins = stats.attractCoins - 1
						end
						f_saveStats()
					--else
						--if stats.coins < 1 then
							--stats.coins = 0
						--elseif stats.coins >= 1 then
							--stats.coins = stats.coins - 1 --Lose 1 Coin by be defeated :c
						--end
						--f_saveStats()
					end
				else
					--Free Online Arcade to Avoid Desync
				end
				stats.continueCount = stats.continueCount + 1 --Times Continue
				--f_saveStats()
				if data.attractMode == true then
					textImgSetText(txt_coins, "CREDITS: "..stats.attractCoins)
				--else
					--textImgSetText(txt_coins, "COINS: "..stats.coins)
				end
				textImgSetText(txt_cont, "TIMES CONTINUED: "..stats.continueCount)
				fadeContinue = f_fadeAnim(30, 'fadeout', 'black', sprFade)
				data.continue = 1
			elseif i > 1366 then --Continue = NO
				data.continue = 2
				f_gameOver()
				data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
				break
			end
			animDraw(contTimer)
			if (btnPalNo(p1Cmd) > 0 or btnPalNo(p2Cmd) > 0) and i >= 71 then
				local cnt = 0
				if i < 135 then
					cnt = 135
				elseif i <= 262 then
					cnt = 262
				elseif i < 389 then
					cnt = 389
				elseif i < 516 then
					cnt = 516
				elseif i < 643 then
					cnt = 643
				elseif i < 770 then
					cnt = 770
				elseif i < 897 then
					cnt = 897
				elseif i < 1024 then
					cnt = 1024
				elseif i < 1151 then
					cnt = 1151
				elseif i < 1278 then
					cnt = 1278
				end
				while i < cnt do
					i = i + 1
					animUpdate(contTimer)
				end
			else
				animUpdate(contTimer)
			end
			if i == 135 then
				sndPlay(sndCont, 0, 9)
			elseif i == 262 then
				sndPlay(sndCont, 0, 8)
			elseif i == 389 then
				sndPlay(sndCont, 0, 7)
			elseif i == 516 then
				sndPlay(sndCont, 0, 6)
			elseif i == 643 then
				sndPlay(sndCont, 0, 5)
			elseif i == 770 then
				sndPlay(sndCont, 0, 4)
			elseif i == 897 then
				sndPlay(sndCont, 0, 3)
			elseif i == 1024 then
				sndPlay(sndCont, 0, 2)
			elseif i == 1151 then
				sndPlay(sndCont, 0, 1)
			elseif i == 1278 then
				sndPlay(sndCont, 0, 0)
			end
			drawContinueInputHints()
		elseif data.continue == 1 then --Continue = YES
			if animLength4+30 > 0 then
					animLength4 = animLength4 - 1
					if anim4 then
						animDraw(anim4)
						if animLength4 > 0 then
							animUpdate(anim4)
						end
					end	
				--if animLength4 < 0 then
					--animDraw(fadeContinue)
					--animUpdate(fadeContinue)
				--end
				if animLength3+30 > 0 then
					animLength3 = animLength3 - 1
					if anim3 then
						animDraw(anim3)
						if animLength3 > 0 then
							animUpdate(anim3)
						end
					end
				end	
				--if animLength3 < 0 then
					--animDraw(fadeContinue)
					--animUpdate(fadeContinue)
				--end
				if animLength2+30 > 0 then
					animLength2 = animLength2 - 1
					if anim2 then
						animDraw(anim2)
						if animLength2 > 0 then
							animUpdate(anim2)
						end
					end
				end	
				--if animLength2 < 0 then
					--animDraw(fadeContinue)
					--animUpdate(fadeContinue)
				--end
				if animLength+30 > 0 then
					animLength = animLength - 1
					if anim then
						animDraw(anim)
						if animLength > 0 then
							animUpdate(anim)
						end
					end
					animDraw(contBG1)
					animDraw(contBG2)
				end
				if animLength < 0 then
					animDraw(fadeContinue)
					animUpdate(fadeContinue)
				end
			else
				--service screen
				if data.serviceScreen then
					f_service()
				end
				if not serviceTeam then --Draw Portrait BG when select a service different of Change Team
					if (data.p1In == 2 and data.p2In == 2) then --Player 1 in player 2 (right) side
						p2BG = true
						p2memberPreview = 1
					else
						p1BG = true
						p1memberPreview = 1
					end
					if data.coop then
						--p2BG = true
						--p2memberPreview = 1
						p2coopReady = false
						p2coopRandom = false
					end
				end
				--challenger screen
				if data.challengerScreen then
					f_selectChallenger()
					f_challengerMusic()
				else
					f_selectMusic() --play original char select song instead of challenger song
				end
				break
			end
		end
		if i >= 71 then --show when count starts counting down
			if not onlinegame then
				textImgDraw(txt_coins) --Show Coins Count
			else
				--Don't Show Coins Count
			end
			textImgDraw(txt_cont) --Always Show Times Continue Count
		end
		if data.debugMode then f_drawQuickText(txt_winreveal, font2, 0, 1, "WINNER: "..winner, 80, 60) end
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		cmdInput()
		refresh()
	end
end

--;===========================================================
--; GAME OVER SCREEN
--;===========================================================
function f_gameOver()
	playBGM(bgmGameOver)
	sndPlay(sndCont, 1, 0)
	f_gameOverReset()
	local tablePos = ''
	local tablePos2 = ''
	local tablePos3 = ''
	local tablePos4 = ''
	local anim = false
	local anim2 = false
	local anim3 = false
	local anim4 = false
	local animLength = 0
	local animLength2 = 0
	local animLength3 = 0
	local animLength4 = 0
	local i = 0
	if (data.p1In == 2 and data.p2In == 2) then --Player 1 in player 2 (right) side
		if p2numChars == 1 or p2numChars == 2 or p2numChars == 3 or p2numChars == 4 then
			tablePos = t_selChars[data.t_p2selected[1].cel+1]
		end
		if p2numChars == 2 or p2numChars == 3 or p2numChars == 4 then
			tablePos2 = t_selChars[data.t_p2selected[2].cel+1]
		end
		if p2numChars == 3 or p2numChars == 4 then
			tablePos3 = t_selChars[data.t_p2selected[3].cel+1]
		end
		if p2numChars == 4 then
			tablePos4 = t_selChars[data.t_p2selected[4].cel+1]	
		end
	else
		if p1numChars == 1 or p1numChars == 2 or p1numChars == 3 or p1numChars == 4 then
			tablePos = t_selChars[data.t_p1selected[1].cel+1]
		end
		if p1numChars == 2 or p1numChars == 3 or p1numChars == 4 then
			tablePos2 = t_selChars[data.t_p1selected[2].cel+1]
		end
		if p1numChars == 3 or p1numChars == 4 then
			tablePos3 = t_selChars[data.t_p1selected[3].cel+1]
		end
		if p1numChars == 4 then
			tablePos4 = t_selChars[data.t_p1selected[4].cel+1]	
		end
	end
	if tablePos.sffData ~= nil then
		if tablePos.cheese ~= nil then
			anim, animLength = f_animFromTable(tablePos['cheese'], tablePos.sffData, 80, 180, tablePos.xscale, tablePos.yscale, 0, 1)
		elseif tablePos.lieDown ~= nil then
			anim, animLength = f_animFromTable(tablePos['lieDown'], tablePos.sffData, 80, 180, tablePos.xscale, tablePos.yscale, 0, 1)
		end
	end
	if tablePos2.sffData ~= nil then
		if tablePos2.cheese ~= nil then
			anim2, animLength2 = f_animFromTable(tablePos2['cheese'], tablePos2.sffData, 60, 180, tablePos2.xscale, tablePos2.yscale, 0, 1)
		elseif tablePos2.lieDown ~= nil then
			anim2, animLength2 = f_animFromTable(tablePos2['lieDown'], tablePos2.sffData, 60, 180, tablePos2.xscale, tablePos2.yscale, 0, 1)
		end
	end
	if tablePos3.sffData ~= nil then
		if tablePos3.cheese ~= nil then
			anim3, animLength3 = f_animFromTable(tablePos3['cheese'], tablePos3.sffData, 40, 180, tablePos3.xscale, tablePos3.yscale, 0, 1)
		elseif tablePos3.lieDown ~= nil then
			anim3, animLength3 = f_animFromTable(tablePos3['lieDown'], tablePos3.sffData, 40, 180, tablePos3.xscale, tablePos3.yscale, 0, 1)
		end
	end
	if tablePos4.sffData ~= nil then
		if tablePos4.cheese ~= nil then
			anim4, animLength4 = f_animFromTable(tablePos4['cheese'], tablePos4.sffData, 100, 180, tablePos4.xscale, tablePos4.yscale, 0, 1)
		elseif tablePos4.lieDown ~= nil then
			anim4, animLength4 = f_animFromTable(tablePos4['lieDown'], tablePos4.sffData, 100, 180, tablePos4.xscale, tablePos4.yscale, 0, 1)
		end
	end
	cmdInput()
	while true do
		animDraw(contBG0)
		i = i + 1
		if btnPalNo(p1Cmd) > 0 or btnPalNo(p2Cmd) > 0 then
			cmdInput()
			playBGM(bgmTitle)
			break
		else
			if anim4 then
				animDraw(anim4)
				animLength4 = animLength4 - 1
				if animLength4 > 0 then
					animUpdate(anim4)
				end
			end
			if anim3 then
				animDraw(anim3)
				animLength3 = animLength3 - 1
				if animLength3 > 0 then
					animUpdate(anim3)
				end
			end
			if anim2 then
				animDraw(anim2)
				animLength2 = animLength2 - 1
				if animLength2 > 0 then
					animUpdate(anim2)
				end
			end
			if anim then
				animDraw(anim)
				animLength = animLength - 1
				if animLength > 0 then
					animUpdate(anim)
				end
				animDraw(contBG1)
				animDraw(contBG2)
			end
			if i <= 226+60 then
				animDraw(gameOver)
				animUpdate(gameOver)
				if i == 190 then --music is shorter than animation and we don't want looping here
					playBGM("")
				elseif i == 226 then --create fading animation
					fadeGameOver = f_fadeAnim(60, 'fadeout', 'black', sprFade)
				elseif i > 226 then --start fading the screen
					animDraw(fadeGameOver)
					animUpdate(fadeGameOver)
				end
			else
				cmdInput()
				break
			end
		end
		cmdInput()
		refresh()
	end
end

--;===================================================================================================
--; SIMPLE MODES (VERSUS, TRAINING, RANDOM, MISSIONS, EVENTS, SINGLE BONUS/BOSSES LIST)
--;===================================================================================================
function f_selectSimple()
if validCells() then
	f_unlock(false)
	f_updateUnlocks()
	f_backReset()
	f_selectInit()
	cmdInput()
	while true do
		data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
		if data.rosterMode == "challenger" then f_challengerMusic()
		elseif data.gameMode == "singleboss" then playBGM(bgmSelectBoss)
		elseif data.rosterMode == "event" then --playBGM("")
		elseif data.gameMode == "quick match" then --playBGM("")
		elseif data.gameMode == "intermission" then --playBGM("")
		elseif data.gameMode == "demo" then --playBGM("")
		else f_selectMusic()
		end
		if winner < 1 then
			f_selectReset()
		else
			selectStart()
			commandBufReset(p1Cmd)
			commandBufReset(p2Cmd)
		end
		while not selScreenEnd do
			if not onlinegame then
				if commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then f_exitSelect() end
			else
				if esc() then f_exitOnline() end
			end
			f_selectScreen()
		--Return to Main Menu
			assert(loadfile(saveTempPath))()
			if back == true or data.tempBack == true then
				f_resetMenuAssets()
				return
			end
		end
		if winner > 0 then
			--Victory Screen
			if (data.p1In == 2 and data.p2In == 2) then --Player 1 in player 2 (right) side
				if t_selChars[data.t_p1selected[1].cel+1].victoryscreen == nil or t_selChars[data.t_p1selected[1].cel+1].victoryscreen == 1 then
					f_selectWin()
				end
			else
				if t_selChars[data.t_p2selected[1].cel+1].victoryscreen == nil or t_selChars[data.t_p2selected[1].cel+1].victoryscreen == 1 then
					f_selectWin()
				end
			end
			if data.gameMode == "versus" then
				--BACK TO MAIN MENU
				if battleOption == 4 or battleOption2 == 4 then
					f_favoriteChar() --Store Favorite Character (WIP)
					f_favoriteStage() --Store Favorite Stage (WIP)
					if data.attractMode == true then playBGM(bgmTitle) else	f_menuMusic() end
					f_resetMenuArrowsPos()
					f_resetMenuInputs()
					break
				--BACK TO STAGE SELECT
				elseif battleOption == 3 or battleOption2 == 3 then
					f_selectMusic()
					f_randomRematch()
					f_stageSelectReset()
					--selectStart()
					selScreenEnd = false
					stageEnd = false
					charSelect = true
					rematchEnd = false
					battleOption = 0
					battleOption2 = 0
					--backScreen = false
					--back = false
					while not selScreenEnd do
						if onlinegame == true then
							if esc() then f_exitOnline() end
						end
						f_selectScreen()
						if back == true then
							f_resetMenuAssets()
							return
						end
					end
				--BACK TO CHARACTER SELECT
				elseif battleOption == 2 or battleOption2 == 2 then
					if data.challengerScreen then
						f_selectChallenger()
						f_challengerMusic()
					else
						f_selectMusic() --play original char select song instead of challenger song
					end
					f_selectReset()
					while not selScreenEnd do
						if not onlinegame then
							if commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then f_exitSelect() end
						else
							if esc() then f_exitOnline() end
						end
						f_selectScreen()
						if back == true then
							f_resetMenuAssets()
							return
						end
					end
				--REMATCH
				elseif battleOption == 1 and battleOption2 == 1 then
					rematchEnd = false
					battleOption = 0 --Reset Rematch Battle Option
					battleOption2 = 0
					f_randomRematch()
					f_loadStage()
					f_loadSong()
				end
			--For Challenger Route in Arcade Mode
			elseif data.gameMode == "challenger" then
				return
			--For Missions, Events, Quick Match or intermission Modes
			elseif data.gameMode == "demo" or data.gameMode == "quick match" or data.gameMode == "intermission" or data.rosterMode == "mission" or data.rosterMode == "event" then
				if data.gameMode == "demo" then
					--Don't playBGM
				else
					if data.attractMode == true then playBGM(bgmTitle) else	f_menuMusic() end
				end
				f_resetMenuInputs()
				return
			--For Single Boss/Bonus
			else
				f_selectReset()
				while not selScreenEnd do
					if commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then f_exitSelect() end
					f_selectScreen()
					if back == true then
						f_resetMenuAssets()
						return
					end
				end
			end
		end
		f_aiLevel()
		assert(loadfile(saveTrainingPath))()
		if data.gameMode == "training" then
			if data.dummyMode == 1 then
				setCom(2, data.AIlevel)
			else
				setCom(2, 0) --Not computer is controlling P2 side, only the human for training dummy
				if data.dummyMode == 3 then remapInput(2, 1) end --Mirror Controls 
			end
		end
		f_matchInfo()
		f_orderSelect()
		--Versus Screen
		if (data.p1In == 2 and data.p2In == 2) then --Player 1 in player 2 (right) side
			if t_selChars[data.t_p1selected[1].cel+1].vsscreen == nil or t_selChars[data.t_p1selected[1].cel+1].vsscreen == 1 then
				f_selectVersus()
			end
		else
			if t_selChars[data.t_p2selected[1].cel+1].vsscreen == nil or t_selChars[data.t_p2selected[1].cel+1].vsscreen == 1 then
				f_selectVersus()
			end
		end
		sndStop()
		f_loading()
		f_setZoom()
		matchTime = os.clock()
		f_assignMusic()
		winner = game() --Get into the fight
		matchTime = os.clock() - matchTime
		clearTime = clearTime + matchTime
		selectTimer = selectSeconds*gameTick
		stageTimer = stageSeconds*gameTick
		rematchTimer = rematchSeconds*gameTick
		serviceTimer = serviceSeconds*gameTick
		if data.rosterMode == "training" then f_modeplayTime() end --Store Training Time
		f_favoriteChar() --Store Favorite Character (WIP)
		f_favoriteStage() --Store Favorite Stage (WIP)
		f_unlock(false)
		f_updateUnlocks()
		playBGM("")
		f_resetP2CoopInput()
		cmdInput()
		refresh()
	end
else
	cmdInput()
	f_invalidCells()
	return --back to main menu
end

end

--;===================================================================
--; COMMON SIDE ACTIONS
--;===================================================================
function f_arcadeEnd()
	f_missionStatus() --Because for some reason, mission 2 not save data in his script..
	if data.rosterMode == "arcade" then
		stats.modes.arcade.clear = stats.modes.arcade.clear + 1 --Progress
		if getPlayerSide() == "p1right" then --Player 1 in Right Side
			unlockTarget = data.t_p2selected
		else --Player 1 in Left Side
			unlockTarget = data.t_p1selected
		end
		if unlockTarget[1].displayname == "Suave Dude" then	stats.unlocks.chars.reika = true end --Character Unlock
		f_saveStats()
		unlockTarget = "" --Reset Var
	elseif data.rosterMode == "tower" then
		stats.modes.tower.clear = stats.modes.tower.clear + 1
		f_saveStats()
	end
	--Intermissions Access
	if data.rosterMode == "arcade" and t_intermissionChars ~= nil and (p1teamMode == 0 and p2teamMode == 0) then --TODO enable intermissions in co-op mode
		data.intermission = true
	end
	f_playCredits()
	f_storyboard("data/screenpack/gameover.def")
	f_mainOpening()
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	if data.attractMode == true then playBGM(bgmTitle) else	f_menuMusic() end
	f_resetMenuArrowsPos()
	f_resetMenuInputs()
end

function f_noContinue()
	--f_mainOpening()
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	if data.attractMode == true then playBGM(bgmTitle) else	f_menuMusic() end
	f_resetMenuInputs()
end

function f_advancedEnd()
	if data.rosterMode == "survival" then
		stats.modes.survival.clear = stats.modes.survival.clear + 1
	elseif data.rosterMode == "boss" then
		stats.modes.bossrush.clear = stats.modes.bossrush.clear + 1
	end
	if data.gameMode == "abyss" then stats.coins = stats.coins + getAbyssReward() end --Get abyss reward when end it
	f_saveStats()
	f_storyboard("data/screenpack/gameover.def")
	exitAbyss = true
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	if data.attractMode == true then playBGM(bgmTitle) else	f_menuMusic() end
	f_resetMenuArrowsPos()
	f_resetMenuInputs()
end

function f_winAdvanced()
	f_records() --Save Stats
	f_result('win')
end

function f_loseAdvanced()
	f_records() --Save Stats
	f_result('lost')
	f_gameOver()
	--f_mainOpening()
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	if data.attractMode == true then playBGM(bgmTitle) else	f_menuMusic() end
	exitAbyss = true
	f_resetMenuArrowsPos()
	f_resetMenuInputs()
end

function f_editLeftSide()
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	if serviceTeam == true then p1TeamEnd = false end
	data.t_p1selected = {}
	p1Portrait = nil
	p1CharEnd = false
	p1PalEnd = false
	p1SelEnd = false
	if data.coop then
		p2CharEnd = false
		p2PalEnd = false
		p2SelEnd = false
	end
end

function f_editRightSide()
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	if serviceTeam == true then p2TeamEnd = false end
	data.t_p2selected = {}
	p2Portrait = nil
	p2CharEnd = false
	p2PalEnd = false
	p2SelEnd = false
	if data.coop then
		p1CharEnd = false
		p1PalEnd = false
		p1SelEnd = false
	end
end

function f_1stStageSel()
	--Load first stage selected for all next matches
	if data.stageMenu == true then
		f_loadStage()
		f_loadSong()
	end
end

function f_nextMatch()
	matchNo = matchNo + 1
	f_1stStageSel()
end

--;===========================================================================================================================
--; ADVANCED MODES (ARCADE, TOWER, SURVIVAL/ABYSS, BOSS/BONUS/TIME RUSH, SUDDEN DEATH, TIME/SCORE ATTACK, VS X KUMITE, ENDLESS)
--;===========================================================================================================================
function f_selectAdvance()
if validCells() then
	f_unlock(false)
	f_updateUnlocks()
	data.rosterAdvanced = true
	f_backReset()
	f_selectInit()
	f_selectReset()
	if not data.stageMenu then stageEnd = true end
	cmdInput()
	while true do
		if data.gameMode == "bossrush" or data.rosterMode == "suddendeath" then playBGM(bgmSelectBoss)
		elseif data.rosterMode == "challenger" then f_challengerMusic()
		elseif data.gameMode == "tower" then playBGM(bgmTower)
		elseif data.gameMode == "abyss" then --playBGM(bgmAbyss)
		else f_selectMusic()
		end
		data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
		selectStart()
		while not selScreenEnd do
			if not onlinegame then
				if commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then f_exitSelect2() end
			else
				if esc() then f_exitOnline() end
			end
			f_selectScreen()
			assert(loadfile(saveTempPath))()
			if back == true or data.tempBack == true then
				f_resetMenuAssets()
				return
			end
		end
	--FIRST MATCH
		if matchNo == 0 then
		--Arcade Intro
			if data.arcadeIntro == true then
				if (data.p1In == 2 and data.p2In == 2) then --Player 1 in player 2 (right) side
					storyBoardSide = t_selChars[data.t_p2selected[1].cel+1]
				else
					storyBoardSide = t_selChars[data.t_p1selected[1].cel+1]
				end
				local tPos = storyBoardSide
				if tPos.intro ~= nil and io.open(tPos.intro or '','r') ~= nil then
					f_storyboard(tPos.intro)
				elseif tPos.intro2 ~= nil and io.open(tPos.intro2 or '','r') ~= nil then
					playVideo(tPos.intro2)
				end
			end
			if data.gameMode == "tower" then
				f_selectDestiny() --Tower Select (Choose Your Destiny Screen)
				if data.tempBack == true then
					f_exitToMainMenu()
					return
				end
				lastMatch = #t_selTower[destinySelect].kombats --get roster selected in tower mode
			elseif data.gameMode == "abyss" then
				f_abyssMenu() --Go to that Abyss Menu that contains the item shop
				if data.tempBack == true then
					f_exitToMainMenu()
					return
				end
				f_makeRoster()
				lastMatch = t_abyssSel[abyssSel].depth --get roster selected in abyss depth select
			else
			--generate roster for other modes (arcade, survival, etc)
				f_makeRoster()
				if data.gameMode ~= "endless" then --because for endless we gonna make this infinite
					if (data.p1In == 2 and data.p2In == 2) then --Player 1 in player 2 (right) side
						lastMatch = #t_roster / p1numChars
					else
						lastMatch = #t_roster / p2numChars
					end
				end
			end
			matchNo = 1
			if data.gameMode ~= "endless" then f_aiRamp() end --generate AI ramping table
	--Player exit the match via ESC in Endless or All Roster modes (BOTH SIDES)
		elseif winner == -1 and (data.gameMode == "endless" or data.gameMode == "allroster" or data.gameMode == "vskumite") then
			if data.gameMode ~= "endless" then looseCnt = looseCnt + 1 end --because in endless a give up not counts as a loose
			assert(loadfile(saveTempPath))()
			if data.tempBack == true then
				f_exitToMainMenu()
				return
			end
			f_records() --Save Stats
			f_result('lost')
			data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade) --reset title screen fading
			if data.attractMode == true then playBGM(bgmTitle) else	f_menuMusic() end
			f_resetMenuInputs()
			return
	--Endless or All Roster modes (BOTH SIDES)
		elseif data.gameMode == "endless" or data.gameMode == "allroster" or data.gameMode == "vskumite" then
			if (data.p1In == 2 and data.p2In == 2) then --Player 1 in player 2 (right) side
				if winner == 2 then
					winCnt = winCnt + 1
				else
					looseCnt = looseCnt + 1
				end
			else
				if winner == 1 then
					winCnt = winCnt + 1
				else --only true in Endless or All Roster modes
					looseCnt = looseCnt + 1
				end
			end
		--No More Matches Left
			if matchNo >= lastMatch then
				f_winAdvanced()
				f_storyboard("data/screenpack/gameover.def")
				data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
				if data.attractMode == true then playBGM(bgmTitle) else	f_menuMusic() end
				f_resetMenuInputs()
				return
		--Next Match Available
			else
				f_nextMatch()
			end
	--LEFT SIDE ACTIONS
		elseif winner == 1 then
			--Player 1 (IN RIGHT SIDE):
			if (data.p1In == 2 and data.p2In == 2) then --Player 1 in player 2 (right) side
			--Lose in Survival, Boss/Bonus Rush or don't have coins to continue in (Arcade with Attract Mode)
				if data.gameMode == "survival" or data.gameMode == "abyss" or data.gameMode == "bossrush" or data.gameMode == "bonusrush" or (data.attractMode == true and stats.attractCoins == 0) then --if stats.coins == 0 or data.gameMode == "survival" or data.gameMode == "bossrush" or data.gameMode == "bonusrush" or (data.attractMode == true and stats.attractCoins == 0) then
					looseCnt = looseCnt + 1
				--Victory screen
					if data.gameMode == "arcade" or data.gameMode == "tower" then
						if winner >= 1 and (t_selChars[data.t_p1selected[1].cel+1].victoryscreen == nil or t_selChars[data.t_p1selected[1].cel+1].victoryscreen == 1) then
							f_selectWin()
						end
					end
					assert(loadfile(saveTempPath))()
					if data.tempBack == true then
						f_exitToMainMenu()
						return
					end
					f_loseAdvanced()
					return
				--Lose BUT can Continue (Arcade)
				else
					looseCnt = looseCnt + 1
					assert(loadfile(saveTempPath))()
					if data.tempBack == true then
						f_exitToMainMenu()
						return
					end
					f_records()
				--Victory Screen
					if winner >= 1 and (t_selChars[data.t_p1selected[1].cel+1].victoryscreen == nil or t_selChars[data.t_p1selected[1].cel+1].victoryscreen == 1) then
						f_selectWin()
					end
				--Continue Screen
					f_continue()
					if data.continue == 2 then --Continue = NO
						f_noContinue()
						return
					end
				--Quick Arcade Continue option disable (Character can be Changed after Continue/Services)
					if not data.quickCont then
						f_editRightSide()
						f_rosterReset()
						selScreenEnd = false
						while not selScreenEnd do
							if commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then f_exitSelect3() end
							f_selectScreen()
							if back == true then
								f_resetMenuAssets()
								return
							end
						end
				--Exit
					elseif commandGetState(p1Cmd, 'e') then
						data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
						sndPlay(sndSys, 100, 2)
						if data.attractMode == true then playBGM(bgmTitle) else	f_menuMusic() end
						f_resetMenuInputs()
						return
					end
					f_1stStageSel()
				end
		--Player 1 (IN LEFT SIDE):
			else
			--Wins in (Arcade, Survival, Boss/Bonus Rush)
				if winner == 1 then
					winCnt = winCnt + 1
				else
					looseCnt = looseCnt + 1
				end
			--Victory Screen
				if data.gameMode == "arcade" or data.gameMode == "tower" then
					if t_selChars[data.t_p2selected[1].cel+1].victoryscreen == nil or t_selChars[data.t_p2selected[1].cel+1].victoryscreen == 1 then
						f_selectWin()
					end
				end
			--No More Matches Left
				if matchNo >= lastMatch then
				--Arcade Ending
					if data.arcadeEnding == true then
						local tPos = t_selChars[data.t_p1selected[1].cel+1]
						if tPos.ending ~= nil and io.open(tPos.ending or '','r') ~= nil then
							f_storyboard(tPos.ending)
						elseif tPos.ending2 ~= nil and io.open(tPos.ending2 or '','r') ~= nil then
							playVideo(tPos.ending2)
						end
					end
					f_winAdvanced()
					if data.gameMode == "arcade" or data.gameMode == "tower" then
						f_arcadeEnd()
						return
					else
						f_advancedEnd()
						return
					end
			--Next Match Available
				else
					f_nextMatch()
				end
			end
	--RIGHT SIDE
		elseif winner == 2 then
		--Player 1 (IN RIGHT SIDE):
			if (data.p1In == 2 and data.p2In == 2) then --Player 1 in player 2 (right) side
			--Wins in (Arcade, Survival, Boss/Bonus Rush)
				if winner == 2 then
					winCnt = winCnt + 1
				else
					looseCnt = looseCnt + 1
				end
			--Victory Screen
				if data.gameMode == "arcade" or data.gameMode == "tower" then
					if t_selChars[data.t_p1selected[1].cel+1].victoryscreen == nil or t_selChars[data.t_p1selected[1].cel+1].victoryscreen == 1 then
						f_selectWin()
					end
				end
			--No More Matches Left
				if matchNo >= lastMatch then
				--Arcade Ending
					if data.arcadeEnding == true then
						local tPos = t_selChars[data.t_p2selected[1].cel+1]
						if tPos.ending ~= nil and io.open(tPos.ending or '','r') ~= nil then
							f_storyboard(tPos.ending)
						elseif tPos.ending2 ~= nil and io.open(tPos.ending2 or '','r') ~= nil then
							playVideo(tPos.ending2)
						end
					end
					f_winAdvanced()
					if data.gameMode == "arcade" or data.gameMode == "tower" then
						f_arcadeEnd()
						return
					else
						f_advancedEnd()
						return
					end
			--Next Match Available
				else
					f_nextMatch()
				end
		--Player 1 (IN LEFT SIDE):
			else
			--Lose in Survival, Boss/Bonus Rush or don't have coins to continue in (Arcade with Attract Mode)
				if data.gameMode == "survival" or data.gameMode == "abyss" or data.gameMode == "bossrush" or data.gameMode == "bonusrush" or (data.attractMode == true and stats.attractCoins == 0) then --if stats.coins == 0 or data.gameMode == "survival" or data.gameMode == "bossrush" or data.gameMode == "bonusrush" or (data.attractMode == true and stats.attractCoins == 0) then
					looseCnt = looseCnt + 1
				--Victory Screen
					if data.gameMode == "arcade" or data.gameMode == "tower" then
						if winner >= 1 and (t_selChars[data.t_p2selected[1].cel+1].victoryscreen == nil or t_selChars[data.t_p2selected[1].cel+1].victoryscreen == 1) then
							f_selectWin()
						end
					end
					assert(loadfile(saveTempPath))()
					if data.tempBack == true then
						f_exitToMainMenu()
						return
					end
					f_loseAdvanced()
					return
			--Lose BUT can Continue (Arcade)
				else
					looseCnt = looseCnt + 1
					assert(loadfile(saveTempPath))()
					if data.tempBack == true then
						f_exitToMainMenu()
						return
					end
					f_records() --Save Stats
				--Victory Screen
					if winner >= 1 and (t_selChars[data.t_p2selected[1].cel+1].victoryscreen == nil or t_selChars[data.t_p2selected[1].cel+1].victoryscreen == 1) then
						f_selectWin()
					end
				--Continue Screen
					f_continue()
					if data.continue == 2 then --Continue = NO
						f_noContinue()
						return
					end
				--Quick Arcade Continue option disable (Character can be Changed after Continue/Services)
					if not data.quickCont then
						f_editLeftSide()
						f_rosterReset()
						selScreenEnd = false
						while not selScreenEnd do
							if commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then f_exitSelect3() end
							f_selectScreen()
							if back == true then
								f_resetMenuAssets()
								return
							end
						end
				--Exit
					elseif commandGetState(p1Cmd, 'e') then
						data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
						sndPlay(sndSys, 100, 2)
						if data.attractMode == true then playBGM(bgmTitle) else	f_menuMusic() end
						f_resetMenuInputs()
						return
					end
					f_1stStageSel()
				end
			end
	--BOTH SIDES - NO WINNER (player exit the match via ESC in Arcade, Survival, Boss/Bonus Rush)
		else --if winner == -1
			assert(loadfile(saveTempPath))()
			if onlinegame and winner == -1 then
				f_exitToMainMenu()
				return
			end
		--Lose Screen for: Survival, Boss/Bonus Rush when GIVE UP option is selected in Pause Menu
			if data.gameMode == "survival" or data.gameMode == "bossrush" or data.gameMode == "bonusrush" or (data.attractMode == true and stats.attractCoins == 0) then --if stats.coins == 0 or data.gameMode == "survival" or data.gameMode == "bossrush" or data.gameMode == "bonusrush" or (data.attractMode == true and stats.attractCoins == 0) then
				looseCnt = looseCnt + 1
				if data.gameMode == "arcade" or data.gameMode == "tower" then --Attract Arcade
					if (data.p1In == 2 and data.p2In == 2) then --Player 1 in player 2 (right) side
						if winner >= 1 and (t_selChars[data.t_p1selected[1].cel+1].victoryscreen == nil or t_selChars[data.t_p1selected[1].cel+1].victoryscreen == 1) then
							f_selectWin()
						end
					else
						if winner >= 1 and (t_selChars[data.t_p2selected[1].cel+1].victoryscreen == nil or t_selChars[data.t_p2selected[1].cel+1].victoryscreen == 1) then
							f_selectWin()
						end
					end
				end
				assert(loadfile(saveTempPath))()
				if data.tempBack == true then
					f_exitToMainMenu()
					return
				end
				f_loseAdvanced()
				return
		--Abyss Boss Challenger
			elseif data.gameMode == "abyss" and data.challengerAbyss then
			--Don't Exit, just prepare stuff
				matchNo = getAbyssDepth()
				f_selectChallenger()
				data.challengerAbyss = false
				f_saveTemp()
		--Continue Screen for Arcade when GIVE UP option is selected in Pause Menu
			else
				assert(loadfile(saveTempPath))()
			--Here comes a New Challenger Route
				if data.challengerMode then
					data.challengerMode = false
					f_saveTemp()
				--Backup Arcade Data
					t_p1selectedTemp = data.t_p1selected --Get a copy of loaded chars to restore arcade after challenger battle
					t_p2selectedTemp = data.t_p2selected
					p1RestoreTeamMode = p1teamMode --Get a copy of team mode selected
					p2RestoreTeamMode = p2teamMode
					p1RestoreCharsNo = p1numChars --Get a copy of amount of chars selected
					p2RestoreCharsNo = p2numChars
					restoreMatchNo = matchNo --Get a copy of matchNo where arcade was cut
					if data.debugLog then f_printTable(t_p1selectedTemp, "save/debug/t_p1selectedTemp.txt") end
					if data.debugLog then f_printTable(t_p2selectedTemp, "save/debug/t_p2selectedTemp.txt") end
				--Load Side Player Data
					if getPlayerSide() == "p1left" or getPlayerSide() == "p2left" then
						keepLSide = true
					elseif getPlayerSide() == "p1right" or getPlayerSide() == "p2right" then
						keepRSide = true
					end
				--Go to VS Challenger Mode
					f_challengerVS() --Load Select Config
					backtomenu = false
					f_selectSimple() --Start Char Select
				--Read Winner results from f_selectSimple()
					if getPlayerSide() == "p1right" then --Player 1 in Right Side
						if winner == 1 then --Player 2 in Left Side Wins
							challengerEnd = true
							matchSetting = "humanvscpu"
							P2overP1 = true
						elseif winner == 2 then --Player 1 in Right Side Wins
							challengerEnd = true
							matchSetting = "cpuvshuman"
							P2overP1 = false
						else --No winner (maybe you use pause menu to exit) but what will happen if you come from a draw game?
							backtomenu = true
						end
					else --Player 1 in Left Side
						if winner == 1 then --Player 1 in Left Side Wins
							challengerEnd = true
							matchSetting = "humanvscpu"
							P2overP1 = false
						elseif winner == 2 then --Player 2 in Right Side Wins
							challengerEnd = true
							matchSetting = "cpuvshuman"
							P2overP1 = true
						else --No winner (maybe you use pause menu to exit) but what will happen if you come from a draw game?
							backtomenu = true
						end
					end
				--Restore Arcade Data when f_selectSimple() end
					if challengerEnd then
						if data.gameMode == "arcade" then
							arcadeCfg()
							textImgSetText(txt_mainSelect, "ARCADE")
						elseif data.gameMode == "tower" then
							towerCfg()
							textImgSetText(txt_mainSelect, "TOWER")
						end
						if matchSetting == "humanvscpu" then --is a copy frmo function arcadeHumanvsCPU()
							if P2overP1 then
								remapInput(1, 2)
								setPlayerSide('p2left')
							else
								setPlayerSide('p1left')
							end
							data.p2In = 1
							data.p2SelectMenu = false
						elseif matchSetting == "cpuvshuman" then --is a copy from function arcadeCPUvsHuman()
							remapInput(1, 2)
							if not P2overP1 then
								remapInput(2, 1)
								setPlayerSide('p1right')
							else
								setPlayerSide('p2right')
							end
							data.p1In = 2
							data.p2In = 2
							data.p1SelectMenu = false
						end
						p1teamMode = p1RestoreTeamMode --Restore team mode
						p2teamMode = p2RestoreTeamMode
						p1numChars = p1RestoreCharsNo --Restore chars amount
						p2numChars = p2RestoreCharsNo
						matchNo = restoreMatchNo --Restore matchNo
						challengerEnd = false
						matchSetting = ""
					end
			--Normal Give Up Route
				else
					looseCnt = looseCnt + 1
					if data.tempBack == true then
						f_exitToMainMenu()
						return
					end
					f_records()
					if (data.p1In == 2 and data.p2In == 2) then --Player 1 in player 2 (right) side
						if winner >= 1 and (t_selChars[data.t_p1selected[1].cel+1].victoryscreen == nil or t_selChars[data.t_p1selected[1].cel+1].victoryscreen == 1) then
							f_selectWin()
						end
					else
						if winner >= 1 and (t_selChars[data.t_p2selected[1].cel+1].victoryscreen == nil or t_selChars[data.t_p2selected[1].cel+1].victoryscreen == 1) then
							f_selectWin()
						end
					end
					f_continue()
					if data.continue == 2 then
						f_noContinue()
						return
					end
					if not data.quickCont then
						if (data.p1In == 2 and data.p2In == 2) then --Player 1 in player 2 (right) side
							f_editRightSide()
						else
							f_editLeftSide()
						end
						f_rosterReset()
						selScreenEnd = false
						while not selScreenEnd do
							if commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then f_exitSelect3() end
							f_selectScreen()
							if back == true then
								f_resetMenuAssets()
								return
							end
						end
					elseif commandGetState(p1Cmd, 'e') then
						data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
						sndPlay(sndSys, 100, 2)
						if data.attractMode == true then playBGM(bgmTitle) else	f_menuMusic() end
						f_resetMenuInputs()
						return
					end
					if data.stageMenu == true then
						f_loadStage()
						f_loadSong()
					end
				end
			--If you exit in char select from challenger mode then back to main menu
				if back == true or backtomenu == true then
					f_resetMenuAssets()
					return
				end
			end
		end
	--Assign enemy team for AI in Player 1 (LEFT SIDE)
		if (data.p1In == 2 and data.p2In == 2) then --Player 1 in player 2 (right) side
			data.t_p1selected = {}
			shuffle = true --was local function
			for i=1, p1numChars do
				if i == 1 and data.gameMode == "arcade" and t_selChars[data.t_p2selected[1].cel+1][matchNo] ~= nil then --Force Arcade Path Fight according to match number: 1, 2, (...)
					p1Cell = t_charAdd[t_selChars[data.t_p2selected[1].cel+1][matchNo]]
					shuffle = false
				else
					if data.gameMode == "tower" then
						p1Cell = t_selTower[destinySelect].kombats[matchNo]
					elseif data.gameMode == "endless" or data.gameMode == "abyss" then
						p1Cell = t_roster[math.random(#t_roster)] --get random character
					--Fight against boss character predefined at some depth/MatchNo
						if data.gameMode == "abyss" and t_abyssSel[abyssSel].specialboss ~= nil then
							for i=1, #t_abyssSel[abyssSel].specialboss do
								if matchNo == t_abyssSel[abyssSel].specialboss[i].depth then --should replace matchNo with getAbyssDepth()?
									local bossChar = nil
									local bossStage = nil
									local bossSong = nil
								--Pick Specific Char
									if t_abyssSel[abyssSel].specialboss[i].char ~= nil then
										bossChar = t_abyssSel[abyssSel].specialboss[i].char:lower()
								--Pick Random Char
									else
										bossChar = t_selChars[t_roster[math.random(#t_roster)]+1].char:lower()
									end
									p1Cell = t_charAdd[bossChar]
								--Set Custom Stage
									if t_abyssSel[abyssSel].specialboss[i].stage ~= nil then
										data.stage = t_abyssSel[abyssSel].specialboss[i].stage
									end
								--Set Custom BGM
									if t_abyssSel[abyssSel].specialboss[i].music ~= nil then
										data.bgm = t_abyssSel[abyssSel].specialboss[i].music
									end
								end
							end
						end
					else
						p1Cell = t_roster[matchNo*p1numChars-i+1]
					end
				end
			--Set AI Palette
				if data.gameMode == "abyss" then
					if matchNo == abyssBossMatch then
						p1Pal = 1 --Normal Boss Specific Palette
					else
						p1Pal = math.random(2,12) --Normal Enemy Random Palette
					end
				--Special Boss character predefined Palette
					if t_abyssSel[abyssSel].specialboss ~= nil then
						for i=1, #t_abyssSel[abyssSel].specialboss do
							if matchNo == t_abyssSel[abyssSel].specialboss[i].depth then
								p1Pal = t_abyssSel[abyssSel].specialboss[i].pal
							end
						end
					end
				else
					if data.aipal == "Default" then
						p1Pal = 1
					elseif data.aipal == "Random" then
						p1Pal = math.random(1,12)
					end
				end
				local updateAnim = true
				for j=1, #data.t_p1selected do
					if data.t_p1selected[j].cel == p1Cell then 
						updateAnim = false
					end
				end
				data.t_p1selected[#data.t_p1selected+1] = {['cel'] = p1Cell, ['name'] = t_selChars[p1Cell+1].name, ['displayname'] = t_selChars[p1Cell+1].displayname, ['path'] = t_selChars[p1Cell+1].char, ['pal'] = p1Pal, ['handicap'] = p1HandicapSel, ['up'] = updateAnim, ['rand'] = false}
				if shuffle then
					f_shuffleTable(data.t_p1selected)
				end
			end
		--Team conversion to Single match
			restoreTeam = false
			teamMode = p1teamMode --was local function
			numChars = p1numChars --was local function
			if p1numChars > 1 then
				for i=1, #data.t_p1selected do
					if (data.gameMode == "tower" and data.coop) or (data.coop and data.coopenemy == "Single") or (t_selChars[data.t_p1selected[i].cel+1].single ~= nil and t_selChars[data.t_p1selected[i].cel+1].single == 1) or (t_selChars[data.t_p1selected[i].cel+1].bonus ~= nil and t_selChars[data.t_p1selected[i].cel+1].bonus == 1) then
						p1teamMode = 0
						p1numChars = 1
						setTeamMode(1, 0, 2) --OR (1, 0, 1) ?
						p1Cell = t_charAdd[t_selChars[data.t_p1selected[i].cel+1].char]
						data.t_p1selected = {}
						data.t_p1selected[1] = {['cel'] = p1Cell, ['name'] = t_selChars[p1Cell+1].name, ['displayname'] = t_selChars[p1Cell+1].displayname, ['path'] = t_selChars[p1Cell+1].char, ['pal'] = p1Pal, ['handicap'] = p1HandicapSel, ['up'] = true, ['rand'] = false}
						restoreTeam = true
						break
					end
				end
			end
	--Assign enemy team for AI in Player 2 (RIGHT SIDE)
		else
			data.t_p2selected = {}
			shuffle = true --was local function
			for i=1, p2numChars do
				if i == 1 and data.gameMode == "arcade" and t_selChars[data.t_p1selected[1].cel+1][matchNo] ~= nil then
					p2Cell = t_charAdd[t_selChars[data.t_p1selected[1].cel+1][matchNo]]
					shuffle = false
				else
					if data.gameMode == "tower" then
						p2Cell = t_selTower[destinySelect].kombats[matchNo]
					elseif data.gameMode == "endless" or data.gameMode == "abyss" then
						p2Cell = t_roster[#t_roster] --Last char will be used because it will be removed below so that when the t_roster table is empty, f_makeRoster() will happen to renew. This logic will ensure that chars are not repeated until the entire roster is defeated.
					--Fight against boss character predefined at some depth/MatchNo
						if data.gameMode == "abyss" and t_abyssSel[abyssSel].specialboss ~= nil then
							for i=1, #t_abyssSel[abyssSel].specialboss do
								if matchNo == t_abyssSel[abyssSel].specialboss[i].depth then --should replace matchNo with getAbyssDepth()?
									local bossChar = nil
									local bossStage = nil
									local bossSong = nil
								--Pick Specific Char
									if t_abyssSel[abyssSel].specialboss[i].char ~= nil then
										bossChar = t_abyssSel[abyssSel].specialboss[i].char:lower()
								--Pick Random Char
									else
										bossChar = t_selChars[t_roster[#t_roster]+1].char:lower()
									end
									p2Cell = t_charAdd[bossChar]
								--Set Custom Stage
									if t_abyssSel[abyssSel].specialboss[i].stage ~= nil then
										data.stage = t_abyssSel[abyssSel].specialboss[i].stage
									end
								--Set Custom BGM
									if t_abyssSel[abyssSel].specialboss[i].music ~= nil then
										data.bgm = t_abyssSel[abyssSel].specialboss[i].music
									end
								end
							end
						end
					else
						p2Cell = t_roster[matchNo*p2numChars-i+1]
					end
				end
			--Set AI Palette
				if data.gameMode == "abyss" then
					if matchNo == abyssBossMatch then
						p2Pal = 1 --Normal Boss Specific Palette
					else
						p2Pal = math.random(2,12) --Normal Enemy Random Palette
					end
				--Special Boss character predefined Palette
					if t_abyssSel[abyssSel].specialboss ~= nil then
						for i=1, #t_abyssSel[abyssSel].specialboss do
							if matchNo == t_abyssSel[abyssSel].specialboss[i].depth then
								p2Pal = t_abyssSel[abyssSel].specialboss[i].pal
							end
						end
					end
				else
					if data.aipal == "Default" then
						p2Pal = 1
					elseif data.aipal == "Random" then
						p2Pal = math.random(1,12)
					end
				end
				local updateAnim = true
				for j=1, #data.t_p2selected do
					if data.t_p2selected[j].cel == p2Cell then 
						updateAnim = false
					end
				end
				data.t_p2selected[#data.t_p2selected+1] = {['cel'] = p2Cell, ['name'] = t_selChars[p2Cell+1].name, ['displayname'] = t_selChars[p2Cell+1].displayname, ['path'] = t_selChars[p2Cell+1].char, ['pal'] = p2Pal, ['handicap'] = p2HandicapSel, ['up'] = updateAnim, ['rand'] = false}
				if shuffle then
					f_shuffleTable(data.t_p2selected)
				end
			end
		--Team conversion to Single match
			restoreTeam = false
			teamMode = p2teamMode
			numChars = p2numChars --was local function
			if p2numChars > 1 then
				for i=1, #data.t_p2selected do
					if (data.gameMode == "tower" and data.coop) or (data.coop and data.coopenemy == "Single") or (t_selChars[data.t_p2selected[i].cel+1].single ~= nil and t_selChars[data.t_p2selected[i].cel+1].single == 1) or (t_selChars[data.t_p2selected[i].cel+1].bonus ~= nil and t_selChars[data.t_p2selected[i].cel+1].bonus == 1) then
						p2teamMode = 0
						p2numChars = 1
						setTeamMode(2, 0, 1)
						p2Cell = t_charAdd[t_selChars[data.t_p2selected[i].cel+1].char]
						data.t_p2selected = {}
						data.t_p2selected[1] = {['cel'] = p2Cell, ['name'] = t_selChars[p2Cell+1].name, ['displayname'] = t_selChars[p2Cell+1].displayname, ['path'] = t_selChars[p2Cell+1].char, ['pal'] = p2Pal, ['handicap'] = p2HandicapSel, ['up'] = true, ['rand'] = false}
						restoreTeam = true
						break
					end
				end
			end
		end
		setMatchNo(matchNo)
		f_aiLevel()
		if not data.stageMenu then f_selectStage() end --Load specific stage and music for roster characters
		if data.gameMode == "tower" and #t_selTower[destinySelect].kombats > 1 then f_battlePlan() end --Show Battle Plan Screen for tower mode with more than 1 floor.
		if data.gameMode == "abyss" then
			setMatchNo(getAbyssDepth())
			setAbyssReward(getAbyssReward()+(getAbyssDepth()-1)*5)
			if getAbyssDepth() == 1 then f_abyssMap() end
			if data.tempBack == true then
				f_exitToMainMenu()
				return
			end
		end
		f_matchInfo()
		f_orderSelect()
	--Versus Screen
		if (data.p1In == 2 and data.p2In == 2) then --Player 1 in player 2 (right) side
			if t_selChars[data.t_p1selected[1].cel+1].vsscreen == nil or t_selChars[data.t_p1selected[1].cel+1].vsscreen == 1 then
				f_selectVersus()
			end
		else
			if t_selChars[data.t_p2selected[1].cel+1].vsscreen == nil or t_selChars[data.t_p2selected[1].cel+1].vsscreen == 1 then
				f_selectVersus()
			end
		end
		if data.gameMode == "arcade" or data.gameMode == "tower" then
			f_setRoundTime() --Set Round Time for specific characters
			f_setRounds() --Set Rounds to Win for specific characters
		elseif data.gameMode == "abyss" or data.gameMode == "endless" then
			--Remove the last char loaded for the CPU side from t_roster and make a check so that when t_roster is empty, use f_makeRoster() again
			table.remove(t_roster, #t_roster)
			if data.debugLog then f_printTable(t_roster, "save/debug/t_roster.txt") end
			if #t_roster == 0 or t_roster == nil then f_makeRoster() end
		end
		f_setZoom()
	--inputs
		if data.coop then
			remapInput(3,2) --P2 controls assigned to P3 character
			--remapInput(2,3) --P3 controls assigned to P2 character
		end
		sndStop()
		f_loading()
		matchTime = os.clock()
		f_assignMusic()
		winner = game() --Get into the fight
		playBGM("")
		matchTime = os.clock() - matchTime
		clearTime = clearTime + matchTime
		selectTimer = selectSeconds*gameTick
		stageTimer = stageSeconds*gameTick
		rematchTimer = rematchSeconds*gameTick
		serviceTimer = serviceSeconds*gameTick
		destinyTimer = destinySeconds*gameTick
		f_modeplayTime() --Store Favorite Game Mode
		f_favoriteChar() --Store Favorite Character (WIP)
		f_records() --save record progress
		f_unlock(false)
		f_updateUnlocks()
		if (data.p1In == 2 and data.p2In == 2) then --Player 1 in player 2 (right) side
		--restore P1 Team settings if needed
			if restoreTeam then
				p1teamMode = teamMode
				p1numChars = numChars
				setTeamMode(1, p1teamMode, p1numChars)
			end
		else
		--restore P2 Team settings if needed
			if restoreTeam then
				p2teamMode = teamMode
				p2numChars = numChars
				setTeamMode(2, p2teamMode, p2numChars)
			end
		end
		f_resetP2CoopInput()
		cmdInput()
		refresh()
	end
else
	cmdInput()
	f_invalidCells()
	return --back to main menu
end

end

--;=================================================================================================
--; TOWER DESTINY SELECT
--;=================================================================================================
function f_selectDestiny()
	waitingTowerSel = true
	destinySelect = 1
	local cursorPosX = 1
	local moveTower = 0
	local bufu = 0
	local bufd = 0
	local bufr = 0
	local bufl = 0
	local selection = 0
	local startCount = false
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	if data.arcadeIntro then playBGM(bgmTower) end
	if t_selTower.data.snd ~= nil then --Choose your Destiny SFX
		twSfx = sndNew(t_selTower.data.snd) --Load snd File
		if t_selTower.data.sfxannouncer ~= nil then
			local data = t_selTower.data.sfxannouncer
			local sfxGroup, sfxIndex = data:match('^([^,]-)%s*,%s*(.-)$')
			sndPlay(twSfx, sfxGroup, sfxIndex)
		end
	end
	f_resetTowerArrowsPos()
	f_backReset()
	cmdInput()
	while true do
		--Actions
		if esc() and onlinegame then data.tempBack = true end --Exit during online mode
		if selection == 0 and not backScreen then
			if esc() or commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then
				sndPlay(sndSys, 100, 2)
				backScreen = true
			end
			if commandGetState(p1Cmd, 'l') or commandGetState(p2Cmd, 'l') or ((commandGetState(p1Cmd, 'holdl') or commandGetState(p2Cmd, 'holdl')) and bufl >= 30) then
				sndPlay(sndSys, 100, 0)
				destinySelect = destinySelect - 1
			elseif commandGetState(p1Cmd, 'r') or commandGetState(p2Cmd, 'r') or ((commandGetState(p1Cmd, 'holdr') or commandGetState(p2Cmd, 'holdr')) and bufr >= 30) then
				sndPlay(sndSys, 100, 0)
				destinySelect = destinySelect + 1
			elseif (btnPalNo(p1Cmd) > 0 or btnPalNo(p2Cmd) > 0) or destinyTimer == 0 then
				sndStop()
				sndPlay(sndSys, 100, 1)
				if t_selTower.data.snd ~= nil then f_playTWsfx() end
				startCount = true
			end
			--Cursor position calculation
			if destinySelect < 1 then
				destinySelect = #t_selTower
				if #t_selTower > 3 then
					cursorPosX = 3
				else
					cursorPosX = #t_selTower
				end
			elseif destinySelect > #t_selTower then
				destinySelect = 1
				cursorPosX = 1
			elseif ((commandGetState(p1Cmd, 'l') or commandGetState(p2Cmd, 'l')) or ((commandGetState(p1Cmd, 'holdl') or commandGetState(p2Cmd, 'holdl')) and bufl >= 30)) and cursorPosX > 1 then
				cursorPosX = cursorPosX - 1
			elseif ((commandGetState(p1Cmd, 'r') or commandGetState(p2Cmd, 'r')) or ((commandGetState(p1Cmd, 'holdr') or commandGetState(p2Cmd, 'holdr')) and bufr >= 30)) and cursorPosX < 3 then
				cursorPosX = cursorPosX + 1
			end
			if cursorPosX == 3 then
				moveTower = (destinySelect - 3) * 105 --Set how many space will move diffcult text
			elseif cursorPosX == 1 then
				moveTower = (destinySelect - 1) * 105
			end
			if #t_selTower <= 3 then
				maxDestiny = #t_selTower
			elseif destinySelect - cursorPosX > 0 then
				maxDestiny = destinySelect + 3 - cursorPosX
			else
				maxDestiny = 3
			end
		elseif selection > 100 then --End Destiny Select
			commandBufReset(p1Cmd)
			commandBufReset(p2Cmd)
			startCount = false
			break
		end
		if data.tempBack then break end --back to main menu
		if startCount then selection = selection + 1 end --Start End Destiny Select count
	--Draw BG
		animDraw(f_animVelocity(selectTowerBG0, -1, -1))
		--animDraw(destinyBG)
	--Set Towers Scroll Logic
		for i=1, maxDestiny do
			if i > destinySelect - cursorPosX then
			--Draw Towers Assets
				for length=#t_selTower[i].kombats, 1, -1 do
					animPosDraw(towerSlot, -85+100*i-moveTower, 250-32*length) --Draw Towers BG According to his size via kombats sub-table
					--Draw Stage Portraits
					if t_selChars[t_selTower[i].kombats[length]+1].stage ~= nil then
						towerStage = math.random(1,#t_selChars[t_selTower[i].kombats[length]+1].stage)
						towerStage = t_selChars[t_selTower[i].kombats[length]+1].stage[1]-1 -- -1 to get the correct stage
						drawStagePortrait(towerStage, -83+100*i-moveTower, 253-32*length, 0.056, 0.035)
					else
						animPosDraw(towerStgPreview, -83+100*i-moveTower, 253-32*length)
					end
					drawPortrait(t_selTower[i].kombats[length], -83+100*i-moveTower, 253-32*length, 0.18, 0.18) --Draw Chars Preview Portraits
				end
				if i == destinySelect then
				--Draw Cursor Icon
					animPosDraw(destinyCursor, -72+i*105-moveTower, 194)
				--Draw Difficulty Text for Tower Table
					if t_selTower[i].ID ~= nil then
						textImgDraw(f_updateTextImg(t_selTower[i].ID, font31, 0, 0, t_selTower[i].displayname:upper(), -52+i*105-moveTower, 219,0.85,0.85))
					end
				end
			end
		end
	--Draw Title
		textImgDraw(txt_towerSelect)
	--Draw Left Animated Cursor
		if maxDestiny > 3 then
			animDraw(menuArrowLeft)
			animUpdate(menuArrowLeft)
		end
	--Draw Right Animated Cursor
		if #t_selTower > 3 and maxDestiny < #t_selTower then
			animDraw(menuArrowRight)
			animUpdate(menuArrowRight)
		end
	--Destiny Select Timer
		destinyTimeNumber = destinyTimer/gameTick
		nodecimalDestinyTime = string.format("%.0f",destinyTimeNumber)
		textImgSetText(txt_destinyTime, nodecimalDestinyTime)
		if destinyTimer > 0 then
			if not backScreen and not startCount then destinyTimer = destinyTimer - 0.5 end--Activate Tower Select Timer
			textImgDraw(txt_destinyTime)
		else --when destinyTimer <= 0
			
		end
		if data.debugMode then f_drawQuickText(txt_selectionTime, font3, 0, 0, selection, 163.5, 168) end --For Debug Purposes
		if backScreen then f_backMenu() else drawTowerInputHints() end --Open Back Menu Question
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		if commandGetState(p1Cmd, 'holdr') or commandGetState(p2Cmd, 'holdr') then
			bufl = 0
			bufr = bufr + 1
		elseif commandGetState(p1Cmd, 'holdl') or commandGetState(p2Cmd, 'holdl') then
			bufr = 0
			bufl = bufl + 1
		else
			bufr = 0
			bufl = 0
		end
		cmdInput()
		refresh()
	end
end

function f_playTWsfx()
	if t_selTower[destinySelect].sfxplay ~= nil then
		local data = t_selTower[destinySelect].sfxplay
		local sfxGroup, sfxIndex = data:match('^([^,]-)%s*,%s*(.-)$')
		sndPlay(twSfx, sfxGroup, sfxIndex)
	end
end

function f_setTowerStage() --Unfinished
	if not data.stageMenu then
		if t_selChars[t_selTower[i].kombats[length]+1].stage ~= nil then
			data.stage = math.random(1,#t_selChars[t_selTower[i].kombats[length]+1].stage) --if there are more than 1 stage assigned for that character, pick 1 of them via randomizer
			data.stage = t_selChars[t_selTower[i].kombats[length]+1].stage[data.stage]
		end
	end
end

--;=================================================================================================
--; TOWER BATTLE PLAN
--;=================================================================================================
function f_battlePlan()
	sndStop()
	local sideSwitch = false
	if (data.p1In == 2 and data.p2In == 2) then --Player 1 in player 2 (right) side
		sideSwitch = true
	else --player 1 in left side
		sideSwitch = false
	end
	startKombat = false
	towerPlanTimer = 0
	towerPlanTimeLimit = 100
	battlePreviewTimer = 0
	local loopSfx = 0
	local scroll = 0
	local scrollDown = 0
	local scrollUp = 0
	local HumanslotPosX = 87
	local CPUslotPosX = 170
	if sideSwitch then
		HumanslotPosX = 233
		CPUslotPosX = 4
	end
	local CPUslotPosY = 170
	local CPUslotSpacingY = 85
	local CPUslotPosYInit = CPUslotPosY --get initial first battle pos
	if matchNo == 1 then
		CPUslotPosY = CPUslotPosY+(CPUslotSpacingY*#t_selTower[destinySelect].kombats)-CPUslotSpacingY --Portraits Y pos starts in the top of the tower
	else
		playBGM(bgmTower)
		CPUslotPosY = CPUslotPosY+(CPUslotSpacingY*matchNo)-CPUslotSpacingY*2 --Portraits Y pos starts in the lastest battle
	end
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	cmdInput()
	while true do
		if esc() and onlinegame then --Exit during online mode
			data.tempBack = true
			break
		end
		if startKombat then break end --Go to next Screen
		if matchNo == 1 then --Battle Plan Presentation
			if towerPlanTimer < towerPlanTimeLimit then --Intro Time
				towerPlanTimer = towerPlanTimer + 1
			else --when introTime is over. Start Down Scroll
				if CPUslotPosY > CPUslotPosYInit then
					if loopSfx > 45 then --reset sfx loop (time is in ticks)
						loopSfx = 0
					end
					if loopSfx == 0 then sndPlay(twSfx, 1, 0) end --Play Scroll Down Sfx
					loopSfx = loopSfx + 1
					--Scroll Logic
					CPUslotPosY = CPUslotPosY - 2
					if (btnPalNo(p1Cmd) > 0 or btnPalNo(p2Cmd) > 0) then --Skip Battle Plan Preview
						sndStop()
						CPUslotPosY = CPUslotPosYInit+1 -- +1 because position correct below logic
					end
				else --when down scroll finish
					if battlePreviewTimer == 0 then CPUslotPosY = CPUslotPosY+1 end --Position Correct
					f_battlePreview()
				end
			end
		else --Battle Plan Prosecution
			scroll = scrollUp
			if towerPlanTimer < towerPlanTimeLimit then --Intro Time
				towerPlanTimer = towerPlanTimer + 1
			else
				if scrollUp < CPUslotSpacingY then --when introTime is over. Start Up Scroll
					if scroll == 0 then sndPlay(twSfx, 1, 1) end --Play Scroll Up Sfx
					scrollUp = scrollUp + 0.8
					if (btnPalNo(p1Cmd) > 0 or btnPalNo(p2Cmd) > 0) then --Skip Battle Plan Preview
						sndStop()
						scrollUp = CPUslotSpacingY-1 -- -1 because position correct below logic
					end
				else
					if battlePreviewTimer == 0 then scrollUp = scrollUp-1 end --Position Correct
					f_battlePreview()
				end
			end
		end
		--Draw BG
		animDraw(f_animVelocity(selectTowerBG0, 0, 1.5))
		--animDraw(destinyFinalBG)
		--Draw Towers Assets
		for length=#t_selTower[destinySelect].kombats, 1, -1 do
			--Draw Tower Slots According to his size
			animPosDraw(battleSlot, CPUslotPosX, CPUslotPosY-CPUslotSpacingY*length+scroll)
			--Draw Stage Portraits
			if t_selChars[t_selTower[destinySelect].kombats[length]+1].stage ~= nil then
				battleStage = math.random(1,#t_selChars[t_selTower[destinySelect].kombats[length]+1].stage)
				battleStage = t_selChars[t_selTower[destinySelect].kombats[length]+1].stage[1]-1 -- -1 to get the correct stage
				drawStagePortrait(battleStage, CPUslotPosX+3.8, CPUslotPosY+7-CPUslotSpacingY*length+scroll, 0.1077, 0.093)
			else
				animPosDraw(battleStgPreview, CPUslotPosX+3.8, CPUslotPosY+6.97-CPUslotSpacingY*length+scroll)
			end
			--Draw CPU Portraits
			local PortraitXpos = 61.5
			local PortraitXscale = -0.48
			if sideSwitch then
				PortraitXpos = 84
				PortraitXscale = 0.48
			end
			if data.charPresentation == "Portrait" or data.charPresentation == "Mixed" then
				drawPortrait(t_selTower[destinySelect].kombats[length], CPUslotPosX+PortraitXpos, CPUslotPosY+7-CPUslotSpacingY*length+scroll, PortraitXscale, 0.48)
			end
			--Draw CPU Animations
			if data.charPresentation == "Sprite" or data.charPresentation == "Mixed" then
				local animPos = 30
				local cpuAnimType = 'p2AnimStand'
				if sideSwitch then
					cpuAnimType = 'p1AnimStand'
					if data.charPresentation == "Sprite" then animPos = 115 end
				end
				if data.charPresentation == "Mixed" then
					if not sideSwitch then animPos = 90 end
				end
				f_drawCharAnim(t_selChars[t_selTower[destinySelect].kombats[length]+1], cpuAnimType, CPUslotPosX+animPos, CPUslotPosY+73-CPUslotSpacingY*length+scroll, true, 0.60, 0.60)
			end
			--Draw CPU Names
			if sideSwitch then
				f_drawQuickText(cpuNamebtp, font14, 0, -1, t_selChars[t_selTower[destinySelect].kombats[length]+1].displayname, CPUslotPosX+141, CPUslotPosY+73-CPUslotSpacingY*length+scroll, 0.75, 0.75)
			else
				f_drawQuickText(cpuNamebtp, font14, 0, 1, t_selChars[t_selTower[destinySelect].kombats[length]+1].displayname, CPUslotPosX+4, CPUslotPosY+73-CPUslotSpacingY*length+scroll, 0.75, 0.75)
			end
		end
		--Draw Player Portrait
		local battleSlotPosX = 3
		if sideSwitch then battleSlotPosX = 170 end
		animPosDraw(battleSlot, battleSlotPosX, CPUslotPosYInit-CPUslotSpacingY) --Slot BG
		if data.charPresentation == "Portrait" or data.charPresentation == "Mixed" then
			local charPScaleX = 0.48
			local charPaddPosX = 22
			local charPSpacingPosX = 22
			if sideSwitch then --Right Side
				charPaddPosX = -23.5
				if p2numChars == 4 then
					charPScaleX = 0.30
					charPaddPosX = -40
					charPSpacingPosX = 17
				end
				for j=#data.t_p2selected, 1, -1 do
					drawPortrait(data.t_p2selected[j].cel, HumanslotPosX+charPaddPosX+(2*j-1)*charPSpacingPosX, CPUslotPosYInit-CPUslotSpacingY+7, -charPScaleX, 0.48)
				end
			else --Left Side
				if p1numChars == 4 then --Modify Some Portrait Params
					charPScaleX = 0.30
					charPaddPosX = 38
					charPSpacingPosX = 17
				end
				for j=#data.t_p1selected, 1, -1 do
					drawPortrait(data.t_p1selected[j].cel, HumanslotPosX+charPaddPosX-(2*j-1)*charPSpacingPosX, CPUslotPosYInit-CPUslotSpacingY+7, charPScaleX, 0.48)
				end
			end
		end
		--Draw Player Animations
		if data.charPresentation == "Sprite" or data.charPresentation == "Mixed" then
			local charAnimScaleX = 0.60
			local charAnimScaleY = 0.60
			local charAnimPosX = 139
			if sideSwitch then --Right Side
				if data.charPresentation == "Mixed" and p2numChars == 1 then
					charAnimPosX = 235
				else
					charAnimPosX = 182
				end
				for j=#data.t_p2selected, 1, -1 do
					f_drawCharAnim(t_selChars[data.t_p2selected[j].cel+1], 'p2AnimStand', charAnimPosX+(2*j-1)*18, 158, data.t_p2selected[j].up, charAnimScaleX, charAnimScaleY)
				end
			else --Left Side
				if data.charPresentation == "Mixed" and p1numChars == 1 then
					charAnimPosX = 85
				end
				for j=#data.t_p1selected, 1, -1 do
					f_drawCharAnim(t_selChars[data.t_p1selected[j].cel+1], 'p1AnimStand', charAnimPosX-(2*j-1)*18, 158, data.t_p1selected[j].up, charAnimScaleX, charAnimScaleY)
				end
			end
		end
		--Draw Player Name
		local pNameScaleX = 0.75
		local pNameScaleY = 0.75
		if sideSwitch then
			f_drawQuickText(playerNamebtp, font14, 0, 1, data.t_p2selected[1].displayname, HumanslotPosX-57, CPUslotPosYInit-CPUslotSpacingY+73, pNameScaleX, pNameScaleY)
			if p2numChars > 1 then f_drawQuickText(teamNamebtp, font14, 0, 1, "TEAM", HumanslotPosX-57, CPUslotPosYInit-CPUslotSpacingY+63, pNameScaleX, pNameScaleY) end
		else
			f_drawQuickText(playerNamebtp, font14, 0, -1, data.t_p1selected[1].displayname, HumanslotPosX+57, CPUslotPosYInit-CPUslotSpacingY+73, pNameScaleX, pNameScaleY)
			if p1numChars > 1 then f_drawQuickText(teamNamebtp, font14, 0, -1, "TEAM", HumanslotPosX+57, CPUslotPosYInit-CPUslotSpacingY+63, pNameScaleX, pNameScaleY) end
		end
		animDraw(vsPreview)
		--Draw Screen Info
		f_drawQuickText(txt_towerPlan, jgFnt, 0, 0, "BATTLE PLAN", 159, CPUslotPosY-65-CPUslotSpacingY*#t_selTower[destinySelect].kombats+scroll)
		if sideSwitch then
			f_drawQuickText(txt_towerDifficult, jgFnt, 0, -1, "DIFFICULTY: "..t_selTower[destinySelect].displayname:upper(), 315, 82, 0.7, 0.7)
		else
			f_drawQuickText(txt_towerDifficult, jgFnt, 0, 1, "DIFFICULTY: "..t_selTower[destinySelect].displayname:upper(), 5, 82, 0.7, 0.7)
		end
		f_drawQuickText(txt_towerMode, jgFnt, 0, 0, "TOWER MODE", 159, CPUslotPosY+150-CPUslotSpacingY*1+scroll)
		if data.debugMode then
			f_drawQuickText(towerTest, font14, 0, 1, CPUslotPosY, 50, 50) --Test Y Pos
		end
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		cmdInput()
		refresh()
	end
end

function f_battlePreview()
	if battlePreviewTimer == 0 then sndPlay(twSfx, 1, 2) end --Play Stop Sfx
	battlePreviewTimer = battlePreviewTimer + 1 --Time to show VS preview
	if battlePreviewTimer == 250 or (btnPalNo(p1Cmd) > 0 or btnPalNo(p2Cmd) > 0) then
		commandBufReset(p1Cmd)
		commandBufReset(p2Cmd)
		sndStop()
		startKombat = true
	end
end

--;===========================================================
--; TOURNAMENT SETTINGS MENU
--;===========================================================
function f_tourneyCfg()
	cmdInput()
	local cursorPosY = 1
	local moveTxt = 0
	local tourneyCfg = 1
	local bufu = 0
	local bufd = 0
	local bufr = 0
	local bufl = 0
	local maxItems = 7
	local teamName = nil
	exitTourney = false
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	playBGM(bgmTourney)
	f_resetListArrowsPos()
	animSetPos(menuArrowDown, 228, 126)
	while true do
		if esc() or commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') or exitTourney then
			sndPlay(sndSys, 100, 2)
			data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
			f_menuMusic()
			f_resetMenuArrowsPos()
			break
		elseif commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u') or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30) then
			sndPlay(sndSys, 100, 0)
			tourneyCfg = tourneyCfg - 1
			if bufl then bufl = 0 end
			if bufr then bufr = 0 end
		elseif commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd') or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30) then
			sndPlay(sndSys, 100, 0)
			tourneyCfg = tourneyCfg + 1
			if bufl then bufl = 0 end
			if bufr then bufr = 0 end
		--Participants/Entries
		elseif tourneyCfg == 1 then
			if commandGetState(p1Cmd, 'r') or (commandGetState(p1Cmd, 'holdr') and bufr >= 30) then
				if commandGetState(p1Cmd, 'r') and data.tourneySize < 16 then sndPlay(sndSys, 100, 0) end
				if data.tourneySize < 16 then
					data.tourneySize = data.tourneySize + data.tourneySize
				end
				modified = 1
			elseif commandGetState(p1Cmd, 'l') or (commandGetState(p1Cmd, 'holdl') and bufl >= 30) then
				if commandGetState(p1Cmd, 'l') and data.tourneySize > 4 then sndPlay(sndSys, 100, 0) end
				if data.tourneySize > 4 then
					data.tourneySize = data.tourneySize - (data.tourneySize/2)
				end
				modified = 1
			end
			if commandGetState(p1Cmd, 'holdr') then
				bufl = 0
				bufr = bufr + 1
			elseif commandGetState(p1Cmd, 'holdl') then
				bufr = 0
				bufl = bufl + 1
			else
				bufr = 0
				bufl = 0
			end
		--[[Format
		elseif tourneyCfg == 2 and (commandGetState(p1Cmd, 'r') or commandGetState(p1Cmd, 'l') or btnPalNo(p1Cmd) > 0) then
			sndPlay(sndSys, 100, 0)
			if data.tourneyType == "Single Elimination" then
				data.tourneyType = "Double Elimination"
				modified = 1
			elseif data.tourneyType == "Double Elimination" then
				data.tourneyType = "Single Elimination"
				modified = 1
			end
		]]
		--[[Team Mode
		elseif tourneyCfg == 3 then
			if commandGetState(p1Cmd, 'r') or (commandGetState(p1Cmd, 'holdr') and bufr >= 30) then
				if commandGetState(p1Cmd, 'r') and data.tourneyTeam < 2 then sndPlay(sndSys, 100, 0) end
				if data.tourneyTeam < 2 then
					data.tourneyTeam = data.tourneyTeam + 1
				end
				modified = 1
			elseif commandGetState(p1Cmd, 'l') or (commandGetState(p1Cmd, 'holdl') and bufl >= 30) then
				if commandGetState(p1Cmd, 'l') and data.tourneyTeam > 0 then sndPlay(sndSys, 100, 0) end
				if data.tourneyTeam > 0 then
					data.tourneyTeam = data.tourneyTeam - 1
				end
				modified = 1
			end
			if commandGetState(p1Cmd, 'holdr') then
				bufl = 0
				bufr = bufr + 1
			elseif commandGetState(p1Cmd, 'holdl') then
				bufr = 0
				bufl = bufl + 1
			else
				bufr = 0
				bufl = 0
			end
		]]
		--Allow Character Select
		elseif tourneyCfg == 2 and (commandGetState(p1Cmd, 'r') or commandGetState(p1Cmd, 'l') or btnPalNo(p1Cmd) > 0) then
			sndPlay(sndSys, 100, 0)
			if data.tourneyCharSel then
				data.tourneyCharSel = false
				modified = 1
			else
				data.tourneyCharSel = true
				modified = 1
			end
		--Allow Stage Select
		elseif tourneyCfg == 3 and (commandGetState(p1Cmd, 'r') or commandGetState(p1Cmd, 'l') or btnPalNo(p1Cmd) > 0) then
			sndPlay(sndSys, 100, 0)
			if data.tourneyStgSel then
				data.tourneyStgSel = false
				modified = 1
			else
				data.tourneyStgSel = true
				modified = 1
			end
		--Round Time
		elseif tourneyCfg == 4 then
			if commandGetState(p1Cmd, 'r') or (commandGetState(p1Cmd, 'holdr') and bufr >= 30) then
				if data.tourneyRoundTime < 1000 then
					data.tourneyRoundTime = data.tourneyRoundTime + 1
				else
					data.tourneyRoundTime = -1
				end
				if commandGetState(p1Cmd, 'r') then sndPlay(sndSys, 100, 0) end
				modified = 1
			elseif commandGetState(p1Cmd, 'l') or (commandGetState(p1Cmd, 'holdl') and bufl >= 30) then
				if data.tourneyRoundTime > -1 then
					data.tourneyRoundTime = data.tourneyRoundTime - 1
				else
					data.tourneyRoundTime = 1000
				end
				if commandGetState(p1Cmd, 'l') then sndPlay(sndSys, 100, 0) end
				modified = 1
			end
			if commandGetState(p1Cmd, 'holdr') then
				bufl = 0
				bufr = bufr + 1
			elseif commandGetState(p1Cmd, 'holdl') then
				bufr = 0
				bufl = bufl + 1
			else
				bufr = 0
				bufl = 0
			end
		--Rounds to Win
		elseif tourneyCfg == 5 then
			if commandGetState(p1Cmd, 'r') or (commandGetState(p1Cmd, 'holdr') and bufr >= 30) then
				if commandGetState(p1Cmd, 'r') and data.tourneyRoundsNum < 5 then sndPlay(sndSys, 100, 0) end
				if data.tourneyRoundsNum < 5 then
					data.tourneyRoundsNum = data.tourneyRoundsNum + 1
				end
				modified = 1
			elseif commandGetState(p1Cmd, 'l') or (commandGetState(p1Cmd, 'holdl') and bufl >= 30) then
				if commandGetState(p1Cmd, 'l') and data.tourneyRoundsNum > 1 then sndPlay(sndSys, 100, 0) end
				if data.tourneyRoundsNum > 1 then
					data.tourneyRoundsNum = data.tourneyRoundsNum - 1
				end
				modified = 1
			end
			if commandGetState(p1Cmd, 'holdr') then
				bufl = 0
				bufr = bufr + 1
			elseif commandGetState(p1Cmd, 'holdl') then
				bufr = 0
				bufl = bufl + 1
			else
				bufr = 0
				bufl = 0
			end
		--Matchs to Win (First To)
		elseif tourneyCfg == 6 then
			if commandGetState(p1Cmd, 'r') or (commandGetState(p1Cmd, 'holdr') and bufr >= 30) then
				if commandGetState(p1Cmd, 'r') and data.tourneyMatchsNum < 5 then sndPlay(sndSys, 100, 0) end
				if data.tourneyMatchsNum < 5 then
					data.tourneyMatchsNum = data.tourneyMatchsNum + 1
				end
				modified = 1
			elseif commandGetState(p1Cmd, 'l') or (commandGetState(p1Cmd, 'holdl') and bufl >= 30) then
				if commandGetState(p1Cmd, 'l') and data.tourneyMatchsNum > 1 then sndPlay(sndSys, 100, 0) end
				if data.tourneyMatchsNum > 1 then
					data.tourneyMatchsNum = data.tourneyMatchsNum - 1
				end
				modified = 1
			end
			if commandGetState(p1Cmd, 'holdr') then
				bufl = 0
				bufr = bufr + 1
			elseif commandGetState(p1Cmd, 'holdl') then
				bufr = 0
				bufl = bufl + 1
			else
				bufr = 0
				bufl = 0
			end
		--CREATE TOURNAMENT
		elseif tourneyCfg == #t_tourneyCfg and (btnPalNo(p1Cmd) > 0 or btnPalNo(p2Cmd) > 0) then
			sndPlay(sndSys, 100, 1)
			f_saveTourney()
			f_addTourneySlots()
			f_tourneyMenu()
		end
		if tourneyCfg < 1 then
			tourneyCfg = #t_tourneyCfg
			if #t_tourneyCfg > maxItems then
				cursorPosY = maxItems
			else
				cursorPosY = #t_tourneyCfg
			end
		elseif tourneyCfg > #t_tourneyCfg then
			tourneyCfg = 1
			cursorPosY = 1
		elseif ((commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u')) or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30)) and cursorPosY > 1 then
			cursorPosY = cursorPosY - 1
		elseif ((commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd')) or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30)) and cursorPosY < maxItems then
			cursorPosY = cursorPosY + 1
		end
		if cursorPosY == maxItems then
			moveTxt = (tourneyCfg - maxItems) * 15
		elseif cursorPosY == 1 then
			moveTxt = (tourneyCfg - 1) * 15
		end	
		if #t_tourneyCfg <= maxItems then
			maxtourneyCfg = #t_tourneyCfg
		elseif tourneyCfg - cursorPosY > 0 then
			maxtourneyCfg = tourneyCfg + maxItems - cursorPosY
		else
			maxtourneyCfg = maxItems
		end
		--Draw BG
		animDraw(f_animVelocity(commonBG0, -1, -1))
		--Draw Tourney BG Grids
		if data.tourneySize == 4 then
			animSetScale(tourney4, 0.359, 0.341)
			animPosDraw(tourney4, 100, 130)
		elseif data.tourneySize == 8 then
			animSetScale(tourney8, 0.359, 0.341)
			animPosDraw(tourney8, 100, 130)
		elseif data.tourneySize == 16 then
			animSetScale(tourney16, 0.359, 0.341)
			animPosDraw(tourney16, 100, 130)
		end
		--Draw Settings BG
		animSetScale(commonTBG, 240, maxtourneyCfg*15)
		animSetWindow(commonTBG, 80,20, 160,105)
		animDraw(commonTBG)
		--Draw Title
		textImgDraw(txt_tourneyCfg)
		--Draw Cursor
		animSetWindow(cursorBox, 80,5+cursorPosY*15, 160,15)
		f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
		animDraw(f_animVelocity(cursorBox, -1, -1))
		--Set Settings Text
		t_tourneyCfg[1].varText = data.tourneySize
		--[[t_tourneyCfg[2].varText = data.tourneyType
		if data.tourneyTeam == 0 then teamName = "Single"
		elseif data.tourneyTeam == 1 then teamName = "Simul"
		elseif data.tourneyTeam == 2 then teamName = "Turns"
		else teamName = "Unknown"
		end
		t_tourneyCfg[3].varText = teamName
		]]
		if data.tourneyCharSel then t_tourneyCfg[2].varText = "Every Match" else t_tourneyCfg[2].varText = "Fixed" end
		if data.tourneyStgSel then t_tourneyCfg[3].varText = "Every FT" else t_tourneyCfg[3].varText = "First FT" end
		t_tourneyCfg[4].varText = data.tourneyRoundTime
		t_tourneyCfg[5].varText = data.tourneyRoundsNum
		t_tourneyCfg[6].varText = "FT"..data.tourneyMatchsNum
		--t_tourneyCfg[10].varText = data.tourney3rdPlace
		--Draw Settings Text
		for i=1, maxtourneyCfg do
			if i > tourneyCfg - cursorPosY then
				if t_tourneyCfg[i].varID ~= nil then
					textImgDraw(f_updateTextImg(t_tourneyCfg[i].varID, font2, 0, 1, t_tourneyCfg[i].text, 85, 15+i*15-moveTxt))
					textImgDraw(f_updateTextImg(t_tourneyCfg[i].varID, font2, 0, -1, t_tourneyCfg[i].varText, 235, 15+i*15-moveTxt))
				end
			end
		end
		if maxtourneyCfg > maxItems then
			animDraw(menuArrowUp)
			animUpdate(menuArrowUp)
		end
		if #t_tourneyCfg > maxItems and maxtourneyCfg < #t_tourneyCfg then
			animDraw(menuArrowDown)
			animUpdate(menuArrowDown)
		end
		drawTourneyInputHints()
		if commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu') then
			bufd = 0
			bufu = bufu + 1
		elseif commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd') then
			bufu = 0
			bufd = bufd + 1
		else
			bufu = 0
			bufd = 0
		end
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		cmdInput()
		refresh()
	end
end

--;===========================================================
--; TOURNAMENT MODE MENU (participate in customizable tournaments)
--;===========================================================
function f_tourneyMenu()
	cmdInput()
	local cursorPosY = 0
	local moveSlotY = 0
	local moveSlotX = 0
	local bufu = 0
	local bufd = 0
	local bufr = 0
	local bufl = 0
	local maxItems = 12
--Iteration Position Logic
	local slotWidth = 29 --Sprite Width
	local slotHeight = 29 --Sprite Height
	local iconWidth = 25
	local iconHeight = 25
	local ctrlWidth = 20
	local ctrlHeight = 7
	--
	local updateStartPosX = 49 --When tourneySize is more small how much the values ​​change from the originals
	local updateSpacingX = 97.5
	local updateStartPosY = 16
	local updateSpacingY = 29.95
	local changeX = 2 --When tourneySize is more small how much will the values ​​of the axis change?
	local changeY = 2.92
--Positions for 16 Participants
	--Originals values
		slotStartPosX = 0.3
		slotSpacingX = 261
		slotStartPosY = 0
		slotSpacingY = 1.2
		--
		iconStartPosX = 2.3
		iconSpacingX = 265.2
		iconStartPosY = 1.3
		iconSpacingY = 5.3
		--
		ctrlStartPosX = 2
		ctrlSpacingX = 270
		ctrlStartPosY = 20
		ctrlSpacingY = 23.2
--Positions for 8 Participants
	if data.tourneySize == 8 then
		slotStartPosX = slotStartPosX + updateStartPosX
		slotSpacingX = slotSpacingX - updateSpacingX
		slotStartPosY = slotStartPosY + updateStartPosY
		slotSpacingY = slotSpacingY + updateSpacingY
		--
		iconStartPosX = iconStartPosX + updateStartPosX
		iconSpacingX = iconSpacingX - updateSpacingX
		iconStartPosY = iconStartPosY + updateStartPosY
		iconSpacingY = iconSpacingY + updateSpacingY
		--
		ctrlStartPosX = ctrlStartPosX + updateStartPosX
		ctrlSpacingX = ctrlSpacingX - updateSpacingX
		ctrlStartPosY = ctrlStartPosY + updateStartPosY
		ctrlSpacingY = ctrlSpacingY + updateSpacingY
--Positions for 4 Participants
	elseif data.tourneySize == 4 then
		slotStartPosX = slotStartPosX + (updateStartPosX*changeX)
		slotSpacingX = slotSpacingX - (updateSpacingX*changeX)
		slotStartPosY = slotStartPosY + (updateStartPosY*changeY)
		slotSpacingY = slotSpacingY + (updateSpacingY*changeY)
		--
		iconStartPosX = iconStartPosX + (updateStartPosX*changeX)
		iconSpacingX = iconSpacingX - (updateSpacingX*changeX)
		iconStartPosY = iconStartPosY + (updateStartPosY*changeY)
		iconSpacingY = iconSpacingY + (updateSpacingY*changeY)
		--
		ctrlStartPosX = ctrlStartPosX + (updateStartPosX*changeX)
		ctrlSpacingX = ctrlSpacingX - (updateSpacingX*changeX)
		ctrlStartPosY = ctrlStartPosY + (updateStartPosY*changeY)
		ctrlSpacingY = ctrlSpacingY + (updateSpacingY*changeY)
	end
	--
	local hideMenu = false
	if data.tourneyType == "Single Elimination" then textImgSetText(txt_tourneyType, txt_tourneyType1)
	elseif data.tourneyType == "Double Elimination" then textImgSetText(txt_tourneyType, txt_tourneyType2)
	end
	f_confirmReset()
	tourneyBack = false
	tourneyRow = 1
	tourneyGroup = 1 --1=A, 2=B
	tourneyFightNo = 1 --Tournament Matchs Counter
	tourneyRoundNo = 1 --Tournament Matchs Round State (Initial, Quarterfinals, Semifinals, Final)
	tourneyNextRound = false --Prepare table data for next round
	tourneyCharSel = false --Allow Player 2 Char Select when is active for Every Match
	startTourney = false --Controls when tourney has been started
	endTourney = false --Controls when tourney enter in the last match
	confirmRandomSel = false --Controls when random select occurs
	while true do
		if exitTourney then break end --Back to Main Menu
	--Prepare Final Match
		if (tourneyRoundNo == 4 and data.tourneySize == 16) or (tourneyRoundNo == 3 and data.tourneySize == 8) or (tourneyRoundNo == 2 and data.tourneySize == 4) then endTourney = true end
		if not startTourney then
		--BACK TO TOURNEY SETTINGS
			if esc() or commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then
				sndPlay(sndSys, 100, 2)
				break
		--START TOURNAMENT
			elseif commandGetState(p1Cmd, 's') or commandGetState(p2Cmd, 's') then
				sndPlay(sndSys, 100, 1)
				f_tourneySelRandomPlayer()
				if not confirmRandomSel then
					startTourney = true
					hideMenu = false
					tourneyGroupNo = 1 --Start tourney from Left Group
					tourneyParticipantNo = 0 --Player Slot ID
					tourneyNextRound = true
					if data.debugLog then f_printTable(t_tourneyMenu, "save/debug/t_tourneyMenu.txt") end
					f_tourneySelCfg()
				end
				confirmRandomSel = false
		--SLOT SELECT
			elseif commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u') or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30) then
				sndPlay(sndSys, 100, 0)
				tourneyRow = tourneyRow - 1
			elseif commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd') or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30) then
				sndPlay(sndSys, 100, 0)
				tourneyRow = tourneyRow + 1
		--GROUP SIDE SELECT
			elseif commandGetState(p1Cmd, 'l') or commandGetState(p2Cmd, 'l') or ((commandGetState(p1Cmd, 'holdl') or commandGetState(p2Cmd, 'holdl')) and bufl >= 30) then
				sndPlay(sndSys, 100, 0)
				if tourneyGroup == 1 then
					tourneyGroup = 2
				elseif tourneyGroup == 2 then
					tourneyGroup = 1
				end
				--tourneyGroup = tourneyGroup - 1
			elseif commandGetState(p1Cmd, 'r') or commandGetState(p2Cmd, 'r') or ((commandGetState(p1Cmd, 'holdr') or commandGetState(p2Cmd, 'holdr')) and bufr >= 30) then
				sndPlay(sndSys, 100, 0)
				if tourneyGroup == 1 then
					tourneyGroup = 2
				elseif tourneyGroup == 2 then
					tourneyGroup = 1
				end
				--tourneyGroup = tourneyGroup + 1
		--HIDE INPUT HINTS MENU
			elseif commandGetState(p1Cmd, 'y') or commandGetState(p2Cmd, 'y') then
				if not hideMenu then hideMenu = true else hideMenu = false end
		--SET CHARACTER CONTROL
			elseif commandGetState(p1Cmd, 'a') or commandGetState(p2Cmd, 'a') then
				local slotControl = t_tourneyMenu.Group[tourneyGroup].Round[1][tourneyRow].CharControl
				local slotLevel = t_tourneyMenu.Group[tourneyGroup].Round[1][tourneyRow].AIlevel
				local slotHuman = t_tourneyMenu.Group[tourneyGroup].Round[1][tourneyRow].Player
				if slotControl == "CPU" then
					if slotLevel < 8 then t_tourneyMenu.Group[tourneyGroup].Round[1][tourneyRow].AIlevel = slotLevel+1
					elseif slotLevel == 8 then
						t_tourneyMenu.Group[tourneyGroup].Round[1][tourneyRow].Player = 1
						t_tourneyMenu.Group[tourneyGroup].Round[1][tourneyRow].AIlevel = 0
						t_tourneyMenu.Group[tourneyGroup].Round[1][tourneyRow].CharControl = "HUMAN"
					end
				elseif slotControl == "HUMAN" then
					if slotHuman == 1 then t_tourneyMenu.Group[tourneyGroup].Round[1][tourneyRow].Player = 2
					elseif slotHuman == 2 then
						t_tourneyMenu.Group[tourneyGroup].Round[1][tourneyRow].Player = 0
						t_tourneyMenu.Group[tourneyGroup].Round[1][tourneyRow].AIlevel = 1
						t_tourneyMenu.Group[tourneyGroup].Round[1][tourneyRow].CharControl = "CPU"
					end
				end
		--EDIT CHARACTER SLOT
			elseif commandGetState(p1Cmd, 'w') or commandGetState(p2Cmd, 'w') then
				sndPlay(sndSys, 100, 1)
				startTourney = false
				f_tourneySelCfg()
				if data.debugLog then f_printTable(t_tourneyMenu, "save/debug/t_tourneyMenu.txt") end
			end
		--Cursor position calculation
			if tourneyRow < 1 then
				tourneyRow = #t_tourneyMenu.Group[tourneyGroup].Round[1]
				if #t_tourneyMenu.Group[tourneyGroup].Round[1] > maxItems then
					cursorPosY = maxItems
				else
					cursorPosY = #t_tourneyMenu.Group[tourneyGroup].Round[1]
				end
			elseif tourneyRow > #t_tourneyMenu.Group[tourneyGroup].Round[1] then
				tourneyRow = 1
				cursorPosY = 1
			elseif ((commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u')) or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30)) and cursorPosY > 1 then
				cursorPosY = cursorPosY - 1
			elseif ((commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd')) or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30)) and cursorPosY < maxItems then
				cursorPosY = cursorPosY + 1
			end
			if cursorPosY == maxItems then
				moveSlotY = (tourneyRow - maxItems) * 20
			elseif cursorPosY == 1 then
				moveSlotY = (tourneyRow - 1) * 20
			end
			if #t_tourneyMenu.Group[tourneyGroup].Round[1] <= maxItems then
				maxSlots = #t_tourneyMenu.Group[tourneyGroup].Round[1]
			elseif tourneyRow - cursorPosY > 0 then
				maxSlots = tourneyRow + maxItems - cursorPosY
			else
				maxSlots = maxItems
			end
		else --If tournament has been started
		--BACK TO TOURNEY SETTINGS
			if tourneyBack then
				startTourney = false
				tourneyBack = false
				break
			end
			if esc() or commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then
				sndPlay(sndSys, 100, 2)
				confirmScreen = true
		--HIDE INPUT HINTS MENU
			elseif commandGetState(p1Cmd, 'y') or commandGetState(p2Cmd, 'y') then
				if not hideMenu then hideMenu = true else hideMenu = false end
		--START NEXT MATCH
			elseif commandGetState(p1Cmd, 'w') or commandGetState(p2Cmd, 'w') then
				hideMenu = false
				if data.debugLog then f_printTable(t_tourneyMenu, "save/debug/t_tourneyMenu.txt") end
				f_tourneySelCfg()
			end
		end
	--Draw BG
		animDraw(f_animVelocity(commonBG0, -1, -1))
	--Draw Tourney BG Grids
		if data.tourneySize == 4 then
			animSetScale(tourney4, 1.059, 1.041)
			animPosDraw(tourney4, -10, -5)
		elseif data.tourneySize == 8 then
			animSetScale(tourney8, 1.059, 1.041)
			animPosDraw(tourney8, -10, -5)
		elseif data.tourneySize == 16 then
			animSetScale(tourney16, 1.059, 1.041)
			animPosDraw(tourney16, -10, -5)
		end
	--Draw Menu Titles
		textImgDraw(txt_tourneyType)
		f_setTourneyState()
		textImgSetText(txt_tourneyState, tourneyState)
		textImgDraw(txt_tourneyState)
		--[[
		if data.tourneyType == "Double Elimination" then
			textImgSetText(txt_tourneyBracket, txt_tourneyWinners)
			textImgDraw(txt_tourneyBracket)
		end
		]]
		textImgDraw(txt_tourneyTitle)
	--Draw Group A Assets
		for c=1, #t_tourneyMenu.Group[1].Round do
			for d=1, #t_tourneyMenu.Group[1].Round[c] do
			--Set AI Icon
				local ctrlIcon = nil
				local GroupAai = t_tourneyMenu.Group[1].Round[c][d].AIlevel
				if GroupAai == 1 then ctrlIcon = tourneyAI1
				elseif GroupAai == 2 then ctrlIcon = tourneyAI2
				elseif GroupAai == 3 then ctrlIcon = tourneyAI3
				elseif GroupAai == 4 then ctrlIcon = tourneyAI4
				elseif GroupAai == 5 then ctrlIcon = tourneyAI5
				elseif GroupAai == 6 then ctrlIcon = tourneyAI6
				elseif GroupAai == 7 then ctrlIcon = tourneyAI7
				elseif GroupAai == 8 then ctrlIcon = tourneyAI8
				end
			--Set Player Icon
				if t_tourneyMenu.Group[1].Round[c][d].Player == 1 then ctrlIcon = tourneyP1
				elseif t_tourneyMenu.Group[1].Round[c][d].Player == 2 then ctrlIcon = tourneyP2
				end
			--Draw Characters Icon
				local newStartPosX = 0
				local newSpacingX = 0
				local newStartPosY = 0
				local newSpacingY = 0
				local newChangeX = 0
				local newChangeY = 0
				local character = t_tourneyMenu.Group[1].Round[c][d].CharID
				if character == "randomselect" then
					--animSetScale(tourneyRandomIcon, 1.025,1.025)
					animPosDraw(tourneyRandomIcon, iconStartPosX+(1-1)*(iconWidth+iconSpacingX), iconStartPosY+(d-1)*(iconHeight+iconSpacingY))
				else --If a character is stored
					if data.tourneySize == 16 then --To draw assets for next rounds
						if c == 2 then --Quarterfinals
							newStartPosX = updateStartPosX
							newSpacingX = updateSpacingX
							newStartPosY = updateStartPosY
							newSpacingY = updateSpacingY
							newChangeX = 1
							newChangeY = 1
						elseif c == 3 then --Semifinals
							newStartPosX = updateStartPosX
							newSpacingX = updateSpacingX
							newStartPosY = updateStartPosY
							newSpacingY = updateSpacingY
							newChangeX = changeX
							newChangeY = changeY
						elseif c == 4 then --Final
							newStartPosX = updateStartPosX
							newSpacingX = updateSpacingX
							newStartPosY = updateStartPosY
							newSpacingY = updateSpacingY
							newChangeX = 2.97
							newChangeY = 5.3
						end
					elseif data.tourneySize == 8 then
						if c == 2 then --Semifinals
							newStartPosX = updateStartPosX
							newSpacingX = updateSpacingX
							newStartPosY = updateStartPosY
							newSpacingY = updateSpacingY
							newChangeX = 1
							newChangeY = 1.92
						elseif c == 3 then --Final
							newStartPosX = updateStartPosX
							newSpacingX = updateSpacingX
							newStartPosY = updateStartPosY
							newSpacingY = updateSpacingY
							newChangeX = 1.97
							newChangeY = 4.3
						end
					elseif data.tourneySize == 4 then
						if c == 2 then --Final
							newStartPosX = updateStartPosX
							newSpacingX = updateSpacingX
							newStartPosY = updateStartPosY
							newSpacingY = updateSpacingY
							newChangeX = 0.97
							newChangeY = 2.38
						end
					end
				--Draw Face
					drawTourneyPortrait(character-1, (iconStartPosX+(newStartPosX*newChangeX))+(1-1)*(iconWidth+(iconSpacingX-(newSpacingX*newChangeX))), (iconStartPosY+(newStartPosY*newChangeY))+(d-1)*(iconHeight+(iconSpacingY+(newSpacingY*newChangeY))))
				end
			--Draw Control Icon
				animPosDraw(ctrlIcon, (ctrlStartPosX+(newStartPosX*newChangeX))+(1-1)*(ctrlWidth+(ctrlSpacingX-(newSpacingX*newChangeX))), (ctrlStartPosY+(newStartPosY*newChangeY))+(d-1)*(ctrlHeight+(ctrlSpacingY+(newSpacingY*newChangeY))))
			end
		end
	--Draw Group B Assets
		for c=1, #t_tourneyMenu.Group[2].Round do
			for d=1, #t_tourneyMenu.Group[2].Round[c] do
			--Set AI Icon
				local ctrlIcon = nil
				local GroupBai = t_tourneyMenu.Group[2].Round[c][d].AIlevel
				if GroupBai == 1 then ctrlIcon = tourneyAI1
				elseif GroupBai == 2 then ctrlIcon = tourneyAI2
				elseif GroupBai == 3 then ctrlIcon = tourneyAI3
				elseif GroupBai == 4 then ctrlIcon = tourneyAI4
				elseif GroupBai == 5 then ctrlIcon = tourneyAI5
				elseif GroupBai == 6 then ctrlIcon = tourneyAI6
				elseif GroupBai == 7 then ctrlIcon = tourneyAI7
				elseif GroupBai == 8 then ctrlIcon = tourneyAI8
				end
			--Set Player Icon
				if t_tourneyMenu.Group[2].Round[c][d].Player == 1 then ctrlIcon = tourneyP1
				elseif t_tourneyMenu.Group[2].Round[c][d].Player == 2 then ctrlIcon = tourneyP2
				end
			--Draw Characters Icon
				local newStartPosX = 0
				local newSpacingX = 0
				local newStartPosY = 0
				local newSpacingY = 0
				local newChangeX = 0
				local newChangeY = 0
				local character = t_tourneyMenu.Group[2].Round[c][d].CharID
				if character == "randomselect" then
					animPosDraw(tourneyRandomIcon, iconStartPosX+(2-1)*(iconWidth+iconSpacingX), iconStartPosY+(d-1)*(iconHeight+iconSpacingY))
				else --If a character is stored
					if data.tourneySize == 16 then --To draw assets for next rounds
						if c == 2 then --Quarterfinals
							newStartPosX = updateStartPosX
							newSpacingX = updateSpacingX
							newStartPosY = updateStartPosY
							newSpacingY = updateSpacingY
							newChangeX = 1
							newChangeY = 1
						elseif c == 3 then --Semifinals
							newStartPosX = updateStartPosX
							newSpacingX = updateSpacingX
							newStartPosY = updateStartPosY
							newSpacingY = updateSpacingY
							newChangeX = changeX
							newChangeY = changeY
						elseif c == 4 then --Final
							newStartPosX = updateStartPosX
							newSpacingX = updateSpacingX
							newStartPosY = updateStartPosY
							newSpacingY = updateSpacingY
							newChangeX = 2.98
							newChangeY = 8.02
						end
					elseif data.tourneySize == 8 then
						if c == 2 then --Semifinals
							newStartPosX = updateStartPosX
							newSpacingX = updateSpacingX
							newStartPosY = updateStartPosY
							newSpacingY = updateSpacingY
							newChangeX = 1
							newChangeY = 1.92
						elseif c == 3 then --Final
							newStartPosX = updateStartPosX
							newSpacingX = updateSpacingX
							newStartPosY = updateStartPosY
							newSpacingY = updateSpacingY
							newChangeX = 1.98
							newChangeY = 7.02
						end
					elseif data.tourneySize == 4 then
						if c == 2 then --Final
							newStartPosX = updateStartPosX
							newSpacingX = updateSpacingX
							newStartPosY = updateStartPosY
							newSpacingY = updateSpacingY
							newChangeX = 0.98
							newChangeY = 5.1
						end
					end
				--Draw Face
					drawTourneyPortrait(character-1, (iconStartPosX+(newStartPosX*newChangeX))+(2-1)*(iconWidth+(iconSpacingX-(newSpacingX*newChangeX))), (iconStartPosY+(newStartPosY*newChangeY))+(d-1)*(iconHeight+(iconSpacingY+(newSpacingY*newChangeY))))
				end
			--Draw Control Icon
				animPosDraw(ctrlIcon, (ctrlStartPosX+(newStartPosX*newChangeX))+(2-1)*(ctrlWidth+(ctrlSpacingX-(newSpacingX*newChangeX))), (ctrlStartPosY+(newStartPosY*newChangeY))+(d-1)*(ctrlHeight+(ctrlSpacingY+(newSpacingY*newChangeY))))
			end
		end
	--Draw Slot Cursor
		if not startTourney then
			animPosDraw(tourneyP1Cursor, slotStartPosX+(tourneyGroup-1)*(slotWidth+slotSpacingX), slotStartPosY+(tourneyRow-1)*(slotHeight+slotSpacingY))
			if not hideMenu then drawTourneyInputHints2() end --Draw Input Hints
		else
			if confirmScreen then
				f_confirmMenu()
			else
				if not hideMenu then drawTourneyInputHints3() end
			end
		end
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
	--VERTICAL BUF KEY CONTROL
		if commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu') then
			bufd = 0
			bufu = bufu + 1
		elseif commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd') then
			bufu = 0
			bufd = bufd + 1
		else
			bufu = 0
			bufd = 0			
		end
	--LATERAL BUF KEY CONTROL
		if commandGetState(p1Cmd, 'holdr') or commandGetState(p2Cmd, 'holdr') then
			bufl = 0
			bufr = bufr + 1
		elseif commandGetState(p1Cmd, 'holdl') or commandGetState(p2Cmd, 'holdl') then
			bufr = 0
			bufl = bufl + 1
		else
			bufr = 0
			bufl = 0
		end
		cmdInput()
		refresh()
	end
end

function f_tourneySelRandomPlayer()
--Group A
	for i=1, #t_tourneyMenu.Group[1].Round[1] do
		local character = t_tourneyMenu.Group[1].Round[1][i].CharID
		if character == "randomselect" then --When starts the tournament (if some slots have not been set manually than AI level and character is chosen randomly).
			t_tourneyMenu.Group[1].Round[1][i].CharID = t_randomTourneyChars[math.random(#t_randomTourneyChars)]+1
			t_tourneyMenu.Group[1].Round[1][i].pal = math.random(1,12)
			confirmRandomSel = true
		end
	end
--Group B
	for i=1, #t_tourneyMenu.Group[2].Round[1] do
		local character = t_tourneyMenu.Group[2].Round[1][i].CharID
		if character == "randomselect" then
			t_tourneyMenu.Group[2].Round[1][i].CharID = t_randomTourneyChars[math.random(#t_randomTourneyChars)]+1
			t_tourneyMenu.Group[2].Round[1][i].pal = math.random(1,12)
			confirmRandomSel = true
		end
	end
	if data.debugLog then f_printTable(t_tourneyMenu, "save/debug/t_tourneyMenu.txt") end
end

--Load Common Settings for Tournament Battles
function f_tourneySelCfg()
	f_default()
	data.gameMode = "tourney"
	data.rosterMode = "tourney"
	data.stageMenu = true
	setRoundTime(data.tourneyRoundTime * 60)
	setRoundsToWin(data.tourneyRoundsNum)
	setFTNo(data.tourneyMatchsNum) --Set Matchs To Wins/FT
	textImgSetText(txt_mainSelect, tourneyState)
	data.p1TeamMenu = {mode = 0, chars = 1}
	data.p2TeamMenu = {mode = 0, chars = 1}
	data.p2In = 2
	data.p2SelectMenu = false
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	sndPlay(sndSys, 100, 1)
	f_selectTourney()
end

function f_tourneySelectReset()
	p1SelX = data.p1SelX --System.def: p1CursorStartcell for X
	p1SelY = data.p1SelY --System.def: p1CursorStartcell for Y
	p2SelX = data.p2SelX --System.def: p2CursorStartcell for X
	p2SelY = data.p2SelY --System.def: p2CursorStartcell for Y
	p1FaceOffset = 0
	p2FaceOffset = 0
	p1OffsetRow = 0
	p2OffsetRow = 0
	p1OffsetColumn = 0
	p2OffsetColumn = 0
	back = false
	--Quick Scrolling Vars
	bufTmu = 0
	bufTmd = 0
	bufTmr = 0
	bufTml = 0

	bufTm2u = 0
	bufTm2d = 0
	bufTm2r = 0
	bufTm2l = 0
	--
	bufSelu = 0
	bufSeld = 0
	bufSelr = 0
	bufSell = 0
	
	bufSel2u = 0
	bufSel2d = 0
	bufSel2r = 0
	bufSel2l = 0
	--
	bufPalu = 0
	bufPald = 0
	bufPalr = 0
	bufPall = 0
	
	bufPal2u = 0
	bufPal2d = 0
	bufPal2r = 0
	bufPal2l = 0
	--
	bufHandu = 0
	bufHandd = 0
	bufHandr = 0
	bufHandl = 0
	
	bufHand2u = 0
	bufHand2d = 0
	bufHand2r = 0
	bufHand2l = 0
	--
	bufStageu = 0
	bufStaged = 0
	bufStager = 0
	bufStagel = 0
	--Timers
	selectSeconds = data.selectTime
	stageSeconds = data.stageTime
	rematchSeconds = data.rematchTime
	serviceSeconds = data.serviceTime
	destinySeconds = data.destinyTime
	selectTimer = selectSeconds*gameTick --Set time for Character Select
	stageTimer = stageSeconds*gameTick --Set time for Stage Select
	rematchTimer = rematchSeconds*gameTick --Set time for Rematch Option
	serviceTimer = serviceSeconds*gameTick --Set time for Service Option
	destinyTimer = destinySeconds*gameTick --Set time for Tower/Destiny Select
	stageList = 0
	musicList = 0
	gameNo = 0
	winner = 0
	winCnt = 0
	looseCnt = 0
	clearTime = 0
	matchTime = 0
end

function f_tourneySelStage()
	f_stageSelectReset()
	stageEnd = false
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	while true do
		if matchNo == lastMatch then animDraw(f_animVelocity(selectHardBG0, -1, -1)) --Draw Red BG for Final Match
		else animDraw(f_animVelocity(commonBG0, -1, -1)) --Draw Blue BG for normal Matches
		end
		f_selectStage()
		if stageEnd then break end --Go to next screen
		--Activate Stage Announcer Timer
		if stageAnnouncer == true then
			announcerTimer = announcerTimer + 1
		end
		drawStageInputHints()
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		cmdInput()
		refresh()
	end
end

function f_tourneyControls()
	if p1Cell.Player == 2 then
		remapInput(1, 2) --P2 control Left Side
	end
	if p2Cell.Player == 1 then
		remapInput(2, 1) --P1 control Right Side
		setPlayerSide('p1right')
	end
	if p1Cell.AIlevel > 0 and p2Cell.AIlevel > 0 then setGameMode("tourneyAI") --this is a AI Battle
	else setGameMode("tourney") --at least there is a human controlling
	end
	setCom(1, p1Cell.AIlevel)
	setCom(2, p2Cell.AIlevel)
	--setTag(1, 0)
end

--;=================================================================================================
--; TOURNAMENT (CHARACTER SELECT/FIGHTS LAUNCHER)
--;=================================================================================================
function f_selectTourney()
if validCells() then
	f_unlock(false)
	f_updateUnlocks()
	f_backReset()
	f_selectInit()
	if tourneyNextRound then
		t_tourneyMenu.Group[tourneyGroupNo].Round[tourneyRoundNo+1] = {} --To Add New Round Table Row
		tourneyNextRound = false
	end
	cmdInput()
	while true do
		--f_selectMusic()
		if winner < 1 then
			f_selectReset()
		else
			selectStart()
			commandBufReset(p1Cmd)
			commandBufReset(p2Cmd)
		end
	--Tourney Screen Logic
		if not startTourney then --When tourney has not been started
			while not selScreenEnd do
				if not onlinegame then
					if commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then f_exitSelect() end
				else
					if esc() then f_exitOnline() end
				end
				f_selectScreen()
				--Back from Char Select
				if back == true then return end
			end
		--Save Character Selected Data (Single Team Mode)
			t_tourneyMenu.Group[tourneyGroup].Round[1][tourneyRow].CharID = data.t_p1selected[1].cel+1
			t_tourneyMenu.Group[tourneyGroup].Round[1][tourneyRow].up = data.t_p1selected[1].up
			t_tourneyMenu.Group[tourneyGroup].Round[1][tourneyRow].pal = data.t_p1selected[1].pal
			break --Back to Tournament Menu
		else --When tourney has been started
			matchNo = matchNo + 1 --Go to Next FT
			if p1Wins == data.tourneyMatchsNum or p2Wins == data.tourneyMatchsNum then --If one of participants have reached the FT rule setting
				if not endTourney then
					t_tourneyMenu.Group[tourneyGroupNo].Round[tourneyRoundNo+1][tourneyFightNo] = {} --To Add New Fighter Table Row
					local p1Data = t_tourneyMenu.Group[tourneyGroupNo].Round[tourneyRoundNo][tourneyParticipantNo+1]
					local p2Data = t_tourneyMenu.Group[tourneyGroupNo].Round[tourneyRoundNo][tourneyParticipantNo+2]
				--Save Left Side Winner Data
					if p1Wins == data.tourneyMatchsNum then
						t_tourneyMenu.Group[tourneyGroupNo].Round[tourneyRoundNo+1][tourneyFightNo]['CharID'] = p1Data.CharID
						t_tourneyMenu.Group[tourneyGroupNo].Round[tourneyRoundNo+1][tourneyFightNo]['up'] = p1Data.up
						t_tourneyMenu.Group[tourneyGroupNo].Round[tourneyRoundNo+1][tourneyFightNo]['pal'] = p1Data.pal
						t_tourneyMenu.Group[tourneyGroupNo].Round[tourneyRoundNo+1][tourneyFightNo]['CharControl'] = p1Data.CharControl
						t_tourneyMenu.Group[tourneyGroupNo].Round[tourneyRoundNo+1][tourneyFightNo]['AIlevel'] = p1Data.AIlevel
						t_tourneyMenu.Group[tourneyGroupNo].Round[tourneyRoundNo+1][tourneyFightNo]['Player'] = p1Data.Player
						t_tourneyMenu.Group[tourneyGroupNo].Round[tourneyRoundNo+1][tourneyFightNo]['Loser'] = p1Data.Loser
						t_tourneyMenu.Group[tourneyGroupNo].Round[tourneyRoundNo+1][tourneyFightNo]['Active'] = p1Data.Active
						p2Data.Loser = true
						if data.tourneyType == "Single Elimination" then p2Data.Active = false --The loser of each match will be immediately eliminated from the tournament
						--elseif data.tourneyType == "Double Elimination" then --A participant gets eliminated upon having lost two games or matches.
						end
				--Save Right Side Winner Data
					elseif p2Wins == data.tourneyMatchsNum then
						t_tourneyMenu.Group[tourneyGroupNo].Round[tourneyRoundNo+1][tourneyFightNo]['CharID'] = p2Data.CharID
						t_tourneyMenu.Group[tourneyGroupNo].Round[tourneyRoundNo+1][tourneyFightNo]['up'] = p2Data.up
						t_tourneyMenu.Group[tourneyGroupNo].Round[tourneyRoundNo+1][tourneyFightNo]['pal'] = p2Data.pal
						t_tourneyMenu.Group[tourneyGroupNo].Round[tourneyRoundNo+1][tourneyFightNo]['CharControl'] = p2Data.CharControl
						t_tourneyMenu.Group[tourneyGroupNo].Round[tourneyRoundNo+1][tourneyFightNo]['AIlevel'] = p2Data.AIlevel
						t_tourneyMenu.Group[tourneyGroupNo].Round[tourneyRoundNo+1][tourneyFightNo]['Player'] = p2Data.Player
						t_tourneyMenu.Group[tourneyGroupNo].Round[tourneyRoundNo+1][tourneyFightNo]['Loser'] = p2Data.Loser
						t_tourneyMenu.Group[tourneyGroupNo].Round[tourneyRoundNo+1][tourneyFightNo]['Active'] = p2Data.Active
						p1Data.Loser = true
						if data.tourneyType == "Single Elimination" then p1Data.Active = false end
					end
					tourneyFightNo = tourneyFightNo + 1
					tourneyParticipantNo = tourneyParticipantNo + 2 --Get participants for next Tourney Match
				--When fights from one group are done
					if tourneyParticipantNo >= #t_tourneyMenu.Group[tourneyGroupNo].Round[tourneyRoundNo] then
					--Reset for new group
						tourneyParticipantNo = 0
						tourneyFightNo = 1
						if tourneyGroupNo == 1 then
							tourneyGroupNo = 2
						elseif tourneyGroupNo == 2 then
							tourneyGroupNo = 1
							tourneyRoundNo = tourneyRoundNo + 1 --Reset for the new round
						end
						tourneyNextRound = true
					end
				else --After final match show tourney awards screen
					f_tourneyChampion()
				end
			--Back to Tourney Menu
				f_resetMenuInputs()
				if data.debugLog then f_printTable(t_tourneyMenu, "save/debug/t_tourneyMenu.txt") end
				break
			end
		--Show Character Select every Match
			if data.tourneyCharSel then
				if (p1Wins > 0 or p2Wins > 0) or tourneyRoundNo > 1 then
					tourneyCharSel = true
					data.p2Faces = true
					data.p2SelectMenu = true
					local p1Data = t_tourneyMenu.Group[tourneyGroupNo].Round[tourneyRoundNo][tourneyParticipantNo+1]
					local p2Data = t_tourneyMenu.Group[tourneyGroupNo].Round[tourneyRoundNo][tourneyParticipantNo+2]
					if endTourney then --Rewritte data to avoid issue with p2Data 
						p1Data = t_tourneyMenu.Group[1].Round[tourneyRoundNo][1] --Pick the only character left in Group A
						p2Data = t_tourneyMenu.Group[2].Round[tourneyRoundNo][1] --Pick the only character left in Group B
					end
					if p1Data.AIlevel == 0 and p2Data.AIlevel == 0 then --VS HUMAN (1P and 2P controls his sides in Character Select)
						data.p2In = 2
						if p1Data.Player == 2 then
							remapInput(1, 2) --P2 control Left Side
						end
						if p2Data.Player == 1 then
							remapInput(2, 1) --P1 control Right Side
							setPlayerSide('p1right')
						end
					else --VS CPU (1P or 2P controls both sides in Character Select)
						data.p2In = 1
						if p1Data.Player == 2 then
							--data.p1In = 2 --Test
							remapInput(1, 2) --P2 control Left Side
						end
						if p2Data.Player == 1 then
							data.p1In = 2
							data.p2In = 2
							remapInput(2, 1) --P1 control Right Side
							setPlayerSide('p1right')
						end
					end
					--f_tourneySelectReset() --(Unused) to restart cursor position
					f_selectReset()
					--selectStart()
					while not selScreenEnd do
						if not onlinegame then
							if commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then f_exitSelect() end
						else
							if esc() then f_exitOnline() end
						end
						f_selectScreen()
					--Back from Char Select
						if back == true then
							exitTourney = true
							break
						end
					end
					if exitTourney then
						if data.attractMode == true then playBGM(bgmTitle) else	f_menuMusic() end
						f_resetMenuInputs()
						break
					end
				--Save Character Selected Data (Single Team Mode)
					t_tourneyMenu.Group[tourneyGroupNo].Round[tourneyRoundNo][tourneyParticipantNo+1].CharID = data.t_p1selected[1].cel+1
					t_tourneyMenu.Group[tourneyGroupNo].Round[tourneyRoundNo][tourneyParticipantNo+1].up = data.t_p1selected[1].up
					t_tourneyMenu.Group[tourneyGroupNo].Round[tourneyRoundNo][tourneyParticipantNo+1].pal = data.t_p1selected[1].pal
					--t_tourneyMenu.Group[tourneyGroupNo].Round[tourneyRoundNo][tourneyParticipantNo+1].handicap = data.t_p1selected[1].handicap
				--Player 2 Data
					local player2Data = tourneyParticipantNo+2
					local player2Group = tourneyGroupNo
					if endTourney then --Rewritte data to avoid issue with p2Data (Picking the only character left in Group B)
						player2Data = 1
						player2Group = 2
					end
					t_tourneyMenu.Group[player2Group].Round[tourneyRoundNo][player2Data].CharID = data.t_p2selected[1].cel+1
					t_tourneyMenu.Group[player2Group].Round[tourneyRoundNo][player2Data].up = data.t_p2selected[1].up
					t_tourneyMenu.Group[player2Group].Round[tourneyRoundNo][player2Data].pal = data.t_p2selected[1].pal
					--t_tourneyMenu.Group[player2Group].Round[tourneyRoundNo][player2Data].handicap = data.t_p2selected[1].handicap
					if data.debugLog then f_printTable(t_tourneyMenu, "save/debug/t_tourneyMenu.txt") end
				end
			end
		--Assign Characters to the Match
			data.t_p1selected = {}
			data.t_p2selected = {}
			if not endTourney then
				p1Cell = t_tourneyMenu.Group[tourneyGroupNo].Round[tourneyRoundNo][tourneyParticipantNo+1]
				p2Cell = t_tourneyMenu.Group[tourneyGroupNo].Round[tourneyRoundNo][tourneyParticipantNo+2]
			else
				p1Cell = t_tourneyMenu.Group[1].Round[tourneyRoundNo][1] --Pick the only character left in Group A
				p2Cell = t_tourneyMenu.Group[2].Round[tourneyRoundNo][1] --Pick the only character left in Group B
			end
			data.t_p1selected[#data.t_p1selected+1] = {['cel'] = p1Cell.CharID-1, ['name'] = t_selChars[p1Cell.CharID].name, ['displayname'] = t_selChars[p1Cell.CharID].displayname, ['path'] = t_selChars[p1Cell.CharID].char, ['pal'] = p1Cell.pal, ['up'] = p1Cell.up, ['rand'] = false}
			data.t_p2selected[#data.t_p2selected+1] = {['cel'] = p2Cell.CharID-1, ['name'] = t_selChars[p2Cell.CharID].name, ['displayname'] = t_selChars[p2Cell.CharID].displayname, ['path'] = t_selChars[p2Cell.CharID].char, ['pal'] = p2Cell.pal, ['up'] = p2Cell.up, ['rand'] = false}
			setMatchNo(matchNo)
			f_tourneyControls()
			if data.tourneyStgSel or matchNo == 1 then --Show Stage Select every FT 1
				f_tourneySelStage()
			else --Load First Stage Selected
				--f_randomRematch()
				f_loadStage()
				f_loadSong()
			end
			f_matchInfo()
			f_orderSelect()
			f_selectVersus()
			sndStop()
			f_loading()
			f_setZoom()
			--inputs
			if data.coop then
				remapInput(3,2) --P2 controls assigned to P3 character
				--remapInput(2,3) --P3 controls assigned to P2 character
			end
			matchTime = os.clock()
			if data.songSelect then f_assignMusic() end
			setTourneyState(tourneyState)
			setP1matchWins(p1Wins)
			setP2matchWins(p2Wins)
			winner = game() --Get into the fight
			matchTime = os.clock() - matchTime
			clearTime = clearTime + matchTime
			selectTimer = selectSeconds*gameTick
			stageTimer = stageSeconds*gameTick
			rematchTimer = rematchSeconds*gameTick
			serviceTimer = serviceSeconds*gameTick
			--f_favoriteChar() --Store Favorite Character (WIP)
			--f_favoriteStage() --Store Favorite Stage (WIP)
			f_unlock(false)
			f_updateUnlocks()
			playBGM("")
		--Victory Screen
			commandBufReset(p1Cmd)
			commandBufReset(p2Cmd)
			data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
			if winner == 1 or winner == 2 then
				f_selectWin()
				if data.rosterMode == "tourney" then
					playBGM(bgmTourney)
				else
					if data.attractMode == true then playBGM(bgmTitle) else	f_menuMusic() end
				end
		--Back from Pause Menu (Give Up or Main Menu Options)
			elseif winner == -1 then
				assert(loadfile(saveTempPath))()
			--Back to Main Menu
				if data.tempBack == true then
					exitTourney = true
					if data.attractMode == true then playBGM(bgmTitle) else	f_menuMusic() end
					data.tempBack = false
					f_saveTemp()
					f_resetMenuInputs()
					break
			--Give Up
				else
				--P1 Give Up
					if data.p1Lose then
						winner = 2
				--P2 Give Up
					elseif data.p2Lose then
						winner = 1
				--CPU VS CPU Random Winner
					elseif data.AIskip then
						winner = math.random(1,2)
					end
					data.p1Lose = false
					data.p2Lose = false
					data.AIskip = false
					f_saveTemp()
					f_selectWin()
					if data.rosterMode == "tourney" then
						playBGM(bgmTourney)
					else
						if data.attractMode == true then playBGM(bgmTitle) else	f_menuMusic() end
					end
				end
			end
		end
		f_resetP2CoopInput()
		cmdInput()
		refresh()
	end
else
	cmdInput()
	f_invalidCells()
	return --back to main menu
end

end

--;===========================================================
--; TOURNAMENT CHAMPION SCREEN
--;===========================================================
function f_tourneyChampion()
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	playBGM(bgmTourneyChampion)
	local screenTime = 0
	local timeLimit = 150
	local xPortScale = 0.9
	local yPortScale = 0.9
	local winner1 = nil
	local winner2 = nil
	if p1Wins == data.tourneyMatchsNum then
		winner1 = data.t_p1selected
		winner2 = data.t_p2selected
	elseif p2Wins == data.tourneyMatchsNum then
		winner1 = data.t_p2selected
		winner2 = data.t_p1selected
	end
	textImgSetText(txt_tourneyPlace1, f_getName(winner1[1].cel))
	textImgSetText(txt_tourneyPlace2, f_getName(winner2[1].cel))
	if data.tourney3rdPlace then
		--textImgSetText(txt_tourneyPlace3, f_getName(1)) TODO
	end
	cmdInput()
	while true do
	--SKIP
		if btnPalNo(p1Cmd) > 0 or btnPalNo(p2Cmd) > 0 then
			exitTourney = true
			break
		end
		animDraw(f_animVelocity(commonBG0, -1, -1)) --Draw BG
	--Draw Character Portraits
		if data.charPresentation == "Portrait" or data.charPresentation == "Mixed" then
			if data.tourney3rdPlace then
				--drawWinPortrait(1, 207, 76, xPortScale, yPortScale) --Third Place
			end
			drawWinPortrait(winner2[1].cel, 6, 57, xPortScale, yPortScale) --Second Place
			drawWinPortrait(winner1[1].cel, 109.5, 32, xPortScale, yPortScale) --First Place
		end
	--Draw Character Sprite Animations
		if data.charPresentation == "Sprite" or data.charPresentation == "Mixed" then
		--First Place
			for j=#winner1, 1, -1 do
				f_drawCharAnim(t_selChars[winner1[j].cel+1], 'p1AnimWin', 179 - (2*j-1) * 18, 157, winner1[j].up)
			end
		--Second Place
			for j=#winner2, 1, -1 do
				f_drawCharAnim(t_selChars[winner2[j].cel+1], 'p1AnimWin', 78 - (2*j-1) * 18, 182, winner2[j].up)
			end
		--Third Place
			if data.tourney3rdPlace then
			--[[
				for j=#???, 1, -1 do
					f_drawCharAnim(1, 'p1AnimWin', 279 - (2*j-1) * 18, 201, true)
				end
			]]
			end
		end
		animDraw(tourneyAwards2)
		--Draw Titles
		textImgDraw(txt_tourneyChampionTitle)
		textImgDraw(txt_tourneyPlace1)
		textImgDraw(txt_tourneyPlace2)
		if data.tourney3rdPlace then textImgDraw(txt_tourneyPlace3) end
	    animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		cmdInput()
		refresh()
	end
end

--;===========================================================
--; ABYSS SELECT MENU (Defeat way of enemies, strengthening your character along the way)
--;===========================================================
function f_abyssSelect()
	cmdInput()
	local cursorPosX = 1
	local moveTxt = 0
	local bufu = 0
	local bufd = 0
	local bufr = 0
	local bufl = 0
	local maxItems = 3
	local continue = true --TODO
	local continueBox = false --TODO
	f_sideReset()
	init_abyssStats() --Reset Abyss Character Stats Data
	f_saveStats()
	abyssSel = 1
	exitAbyss = false
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	playBGM(bgmAbyss)
	f_resetAbyssArrowsPos()
	while true do
		if not sideScreen then
			if commandGetState(p1Cmd, 'l') or commandGetState(p2Cmd, 'l') or ((commandGetState(p1Cmd, 'holdl') or commandGetState(p2Cmd, 'holdl')) and bufl >= 30) then
				sndPlay(sndSys, 100, 0)
				abyssSel = abyssSel - 1
			elseif commandGetState(p1Cmd, 'r') or commandGetState(p2Cmd, 'r') or ((commandGetState(p1Cmd, 'holdr') or commandGetState(p2Cmd, 'holdr')) and bufr >= 30) then
				sndPlay(sndSys, 100, 0)
				abyssSel = abyssSel + 1
		--Abyss Level Select
			elseif (btnPalNo(p1Cmd) > 0 or btnPalNo(p2Cmd) > 0) then
				sndPlay(sndSys, 100, 1)
			--Continue Game
				if continueBox then
					--TODO
			--New Game
				else
					f_abyssBoot() --Open Side Select
				end
			end
			if esc() or commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') or exitAbyss then
				sndPlay(sndSys, 100, 2)
				data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
				f_menuMusic()
				f_resetMenuArrowsPos()
				break
			end
			if abyssSel < 1 then
				abyssSel = #t_abyssSel
				if #t_abyssSel > maxItems then
					cursorPosX = maxItems
				else
					cursorPosX = #t_abyssSel
				end
			elseif abyssSel > #t_abyssSel then
				abyssSel = 1
				cursorPosX = 1
			elseif ((commandGetState(p1Cmd, 'l') or commandGetState(p2Cmd, 'l')) or ((commandGetState(p1Cmd, 'holdl') or commandGetState(p2Cmd, 'holdl')) and bufl >= 30)) and cursorPosX > 1 then
				cursorPosX = cursorPosX - 1
			elseif ((commandGetState(p1Cmd, 'r') or commandGetState(p2Cmd, 'r')) or ((commandGetState(p1Cmd, 'holdr') or commandGetState(p2Cmd, 'holdr')) and bufr >= 30)) and cursorPosX < maxItems then
				cursorPosX = cursorPosX + 1
			end
			if cursorPosX == maxItems then
				moveTxt = (abyssSel - maxItems) * 104
			elseif cursorPosX == 1 then
				moveTxt = (abyssSel - 1) * 104
			end	
			if #t_abyssSel <= maxItems then
				maxabyssSel = #t_abyssSel
			elseif abyssSel - cursorPosX > 0 then
				maxabyssSel = abyssSel + maxItems - cursorPosX
			else
				maxabyssSel = maxItems
			end
		end
	--Draw BG
		animDraw(abyssBG)
		animDraw(f_animVelocity(abyssFog, -1, -1))
	--Draw Title
		textImgDraw(txt_abyssSel)
		animPosDraw(abyssSelInfoBG, -56, 185) --Draw Info Text BG
		f_textRender(txt_abyssLvInfo, t_abyssSel[abyssSel].info, 0, 159, 200, 10, 0, 100)
	--Draw Abyss Level Content Text
		for i=1, maxabyssSel do
			if i > abyssSel - cursorPosX then
				local txtDepth = ""
				if t_abyssSel[i].depth == -1 then txtDepth = "INFINITE" else txtDepth = t_abyssSel[i].depth end
				if t_abyssSel[i].id ~= nil then
					animPosDraw(abyssSelWindowBG, -94+i*104-moveTxt,50)
					textImgDraw(f_updateTextImg(t_abyssSel[i].id, font20, 4, 0, txtDepth, -50+i*104-moveTxt, 120))
					textImgSetPos(txt_abyssLv, -50+i*104-moveTxt, 75)
					textImgSetText(txt_abyssLv, "LEVEL "..i)
					textImgDraw(txt_abyssLv)
					textImgSetPos(txt_abyssDepth, -50+i*104-moveTxt, 105)
					textImgDraw(txt_abyssDepth)
				end
			end
		end
	--Draw Continue Box
		if continue then
			animPosDraw(abyssContBG, 106, 147)
			textImgDraw(txt_abyssContinue)
		end
	--Draw Cursor
		animSetWindow(cursorBox, -94+cursorPosX*104,54, 89.5,78)
		f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
		animDraw(f_animVelocity(cursorBox, -1, -1))
		if maxabyssSel > maxItems then
			animDraw(menuArrowLeft)
			animUpdate(menuArrowLeft)
		end
		if #t_abyssSel > maxItems and maxabyssSel < #t_abyssSel then
			animDraw(menuArrowRight)
			animUpdate(menuArrowRight)
		end
		if sideScreen then f_sideSelect() else drawAbyssInputHints() end
		if commandGetState(p1Cmd, 'holdl') or commandGetState(p2Cmd, 'holdl') then
			bufr = 0
			bufl = bufl + 1
		elseif commandGetState(p1Cmd, 'holdr') or commandGetState(p2Cmd, 'holdr') then
			bufl = 0
			bufr = bufr + 1
		else
			bufl = 0
			bufr = 0
		end
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		cmdInput()
		refresh()
	end
end

function f_abyssBoot()
	menuSelect = "abyss"
	sideScreen = true
end

--Load Common Settings for Abyss Modes
function abyssCfg()
	f_default()
	setRoundsToWin(1)
	setRoundTime(99*60)
	setGameMode('abyss')
	data.gameMode = "abyss"
	data.rosterMode = "abyss"
	data.victoryscreen = false
	data.stage = "stages/Mountainside Temple/Dark Corridor.def" --Abyss Initial Stage
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	sndPlay(sndSys, 100, 1)
end

--HUMAN VS CPU (fight against CPU controlled opponents from left side)
function abyssHumanvsCPU()
	if P2overP1 then
		remapInput(1, 2)
		setPlayerSide('p2left')
	else
		setPlayerSide('p1left')
	end
	data.p2TeamMenu = {mode = 0, chars = 1}
	data.p2In = 1
	data.p2SelectMenu = false
	textImgSetText(txt_mainSelect, "ABYSS MODE [MAX DEPTH "..stats.modes.abyss.maxdepth.."]")
	f_selectAdvance()
	P2overP1 = false
end

--CPU VS HUMAN (fight against CPU controlled opponents from right side)
function abyssCPUvsHuman()
	remapInput(1, 2)
	if not P2overP1 then
		remapInput(2, 1)
		setPlayerSide('p1right')
	else
		setPlayerSide('p2right')
	end
	data.p1TeamMenu = {mode = 0, chars = 1}
	data.p1In = 2
	data.p2In = 2
	data.p1SelectMenu = false
	textImgSetText(txt_mainSelect, "ABYSS MODE [MAX DEPTH "..stats.modes.abyss.maxdepth.."]")
	f_selectAdvance()
	P2overP1 = false
end

--P1&P2 VS CPU [CO-OP MODE] (team up with another player from left side against CPU controlled opponents)
function abyssP1P2vsCPU()
	data.p2In = 2
	data.p2Faces = true
	data.coop = true
	setPlayerSide('p1left')
	setGameMode('abysscoop')
	textImgSetText(txt_mainSelect, "ABYSS COOPERATIVE [MAX DEPTH "..stats.modes.abyss.maxdepth.."]")
	f_selectAdvance()
end

--CPU VS P1&P2 [CO-OP MODE] (team up with another player from right side against CPU controlled opponents)
function abyssCPUvsP1P2()
	f_comingSoon()
--[[
	setPlayerSide('p1right')
	data.p1In = 2
	data.p2In = 2
	data.p2Faces = true
	data.coop = true
	setGameMode('abysscoop')
	textImgSetText(txt_mainSelect, "ABYSS COOPERATIVE [MAX DEPTH "..stats.modes.abyss.maxdepth.."]")
	f_selectAdvance()
]]
end

--CPU MODE (watch CPU fight in abyss)
function abyssCPUvsCPU()
	data.p2TeamMenu = {mode = 0, chars = 1}
	data.p2In = 1
	data.p2SelectMenu = false
	data.aiFight = true
	setPlayerSide('p1left')
	setGameMode('abysscpu')
	data.rosterMode = "cpu"
	textImgSetText(txt_mainSelect, "WATCH ABYSS [MAX DEPTH "..stats.modes.abyss.maxdepth.."]")
	f_selectAdvance()
end

--;===========================================================
--; ABYSS MAIN MENU
--;===========================================================
function f_abyssMenu()
	cmdInput()
	local cursorPosY = 1
	local moveTxt = 0
	local abyssMenu = 1
	local bufu = 0
	local bufd = 0
	local bufr = 0
	local bufl = 0
	local maxItems = 10
	local shop = false
	local buyDone = false
	local t_menuBackup = t_abyssMenu
	local backupCurrency = stats.coins
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	f_resetAbyss2ArrowsPos()
	f_confirmReset()
--Store Player Data
	local playerDat = nil
	if (data.p1In == 2 and data.p2In == 2) then --Player 1 in player 2 (right) side
		playerDat = data.t_p2selected
	else
		playerDat = data.t_p1selected
	end
	abyssDat.nosave.name = playerDat[1].displayname
	abyssDat.nosave.cel = playerDat[1].cel
	f_saveStats()
--Check Shop Item Unlocks
	f_unlock(false)
	f_updateUnlocks()
	local itemName = nil
	local itemPrice = nil
	local itemInfo = nil
	f_abyssResetShop()
	while true do
		if not confirmScreen then
			if esc() or commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then
				sndPlay(sndSys, 100, 2)
				if not shop then
					confirmScreen = true
				else
					t_abyssMenu = t_menuBackup
					shop = false
				end
			elseif commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u') or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30) then
				sndPlay(sndSys, 100, 0)
				abyssMenu = abyssMenu - 1
			elseif commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd') or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30) then
				sndPlay(sndSys, 100, 0)
				abyssMenu = abyssMenu + 1
		--Actions
			elseif (btnPalNo(p1Cmd) > 0 or btnPalNo(p2Cmd) > 0) then
			--Abyss Option Select
				if not shop then
					sndPlay(sndSys, 100, 1)
					if abyssMenu == 1 then
						t_abyssMenu = t_abyssShop
						shop = true
					elseif abyssMenu == 2 then
						abyssDat.nosave.expense = backupCurrency - stats.coins --calculates the amount spent in the store to be displayed on the results screen
						f_saveStats()
						break --Start Abyss Mode
					end
			--Abyss Shop
				else
				--Shop Item is unlocked/has been found and player have enough currency to buy it
					if (t_unlockLua.abyss[t_abyssMenu[abyssMenu].text] == nil) and stats.coins >= t_abyssMenu[abyssMenu].price then
					--Shop Item is NOT sold out
						if not t_abyssMenu[abyssMenu].sold then
						--Attribute Assign
							if t_abyssMenu[abyssMenu].attack then
								buyDone = true
								setAbyssAttack(getAbyssAttack() + t_abyssMenu[abyssMenu].val)
							elseif t_abyssMenu[abyssMenu].defence then
								buyDone = true
								setAbyssDefence(getAbyssDefence() + t_abyssMenu[abyssMenu].val)
							elseif t_abyssMenu[abyssMenu].power then
								buyDone = true
								setAbyssPower(getAbyssPower() + t_abyssMenu[abyssMenu].val)
							elseif t_abyssMenu[abyssMenu].life then
								buyDone = true
								setAbyssLife(getAbyssLife() + t_abyssMenu[abyssMenu].val)
							elseif t_abyssMenu[abyssMenu].depth then
								buyDone = true
								setAbyssDepth(getAbyssDepth() + t_abyssMenu[abyssMenu].val)
						--Special Items Assign
							else
							--Special Items Slots are Full
								if abyssDat.nosave.sp3 ~= "" then
									sndPlay(sndSys, 100, 5)
							--At least there is 1 Special Items Slot free
								else
									if abyssDat.nosave.sp1 == "" then abyssDat.nosave.sp1 = t_abyssMenu[abyssMenu].text
									elseif abyssDat.nosave.sp2 == "" then abyssDat.nosave.sp2 = t_abyssMenu[abyssMenu].text
									elseif abyssDat.nosave.sp3 == "" then abyssDat.nosave.sp3 = t_abyssMenu[abyssMenu].text
									end
									buyDone = true
								end
							end
							if buyDone then
								sndPlay(sndSys, 200, 3)
								stats.coins = stats.coins - t_abyssMenu[abyssMenu].price
							--Save Data
								f_saveStats()
								t_abyssMenu[abyssMenu].sold = true --Item Sold out
								buyDone = false
							end
					--Shop Item is sold out
						else
							sndPlay(sndSys, 100, 5)
						end
				--Shop Item is locked/has not been discovered/is sold out or player NOT have enough currency to buy it
					else
						sndPlay(sndSys, 100, 5)
					end
				end
		--Refund
			elseif commandGetState(p1Cmd, 's') or commandGetState(p2Cmd, 's') then
				if shop and t_abyssMenu[abyssMenu].sold then
					sndPlay(sndSys, 100, 2)
					stats.coins = stats.coins + t_abyssMenu[abyssMenu].price
				--Attribute Refund
					if t_abyssMenu[abyssMenu].attack then
						setAbyssAttack(getAbyssAttack() - t_abyssMenu[abyssMenu].val)
					elseif t_abyssMenu[abyssMenu].defence then
						setAbyssDefence(getAbyssDefence() - t_abyssMenu[abyssMenu].val)
					elseif t_abyssMenu[abyssMenu].power then
						setAbyssPower(getAbyssPower() - t_abyssMenu[abyssMenu].val)
					elseif t_abyssMenu[abyssMenu].life then
						setAbyssLife(getAbyssLife() - t_abyssMenu[abyssMenu].val)
					elseif t_abyssMenu[abyssMenu].depth then
						setAbyssDepth(getAbyssDepth() - t_abyssMenu[abyssMenu].val)
				--Special Items Refund
					else
						if abyssDat.nosave.sp1 == t_abyssMenu[abyssMenu].text then
							abyssDat.nosave.sp1 = ""
						elseif abyssDat.nosave.sp2 == t_abyssMenu[abyssMenu].text then
							abyssDat.nosave.sp2 = ""
						elseif abyssDat.nosave.sp3 == t_abyssMenu[abyssMenu].text then
							abyssDat.nosave.sp3 = ""
						end
					end
					f_saveStats()
					t_abyssMenu[abyssMenu].sold = false --Item available again
				end
			end
			if exitAbyss then
				stats.coins = backupCurrency --Restore money only if not start a game
				data.tempBack = true --To exit to Main Menu from Abyss Menu
				break
			end
			if abyssMenu < 1 then
				abyssMenu = #t_abyssMenu
				if #t_abyssMenu > maxItems then
					cursorPosY = maxItems
				else
					cursorPosY = #t_abyssMenu
				end
			elseif abyssMenu > #t_abyssMenu then
				abyssMenu = 1
				cursorPosY = 1
			elseif ((commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u')) or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30)) and cursorPosY > 1 then
				cursorPosY = cursorPosY - 1
			elseif ((commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd')) or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30)) and cursorPosY < maxItems then
				cursorPosY = cursorPosY + 1
			end
			if cursorPosY == maxItems then
				moveTxt = (abyssMenu - maxItems) * 15
			elseif cursorPosY == 1 then
				moveTxt = (abyssMenu - 1) * 15
			end	
			if #t_abyssMenu <= maxItems then
				maxabyssMenu = #t_abyssMenu
			elseif abyssMenu - cursorPosY > 0 then
				maxabyssMenu = abyssMenu + maxItems - cursorPosY
			else
				maxabyssMenu = maxItems
			end
		end
	--Draw BG
		animDraw(abyssBG)
		animDraw(f_animVelocity(abyssFog, -1, -1))
	--Draw Title
		if shop then
			textImgSetText(txt_abyssMain, "ABYSS SHOP")
		else
			textImgSetText(txt_abyssMain, "ABYSS MENU")
		end
		textImgDraw(txt_abyssMain)
	--Draw Menu Options BG
		animSetScale(abyssTBG, 240, maxabyssMenu*15)
		animSetWindow(abyssTBG, 2,20, 165,155)
		animDraw(abyssTBG)
	--Draw Cursor
		if not confirmScreen then
			animSetWindow(cursorBox, 2,10+cursorPosY*15, 165,15)
			f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
			animDraw(f_animVelocity(cursorBox, -1, -1))
		end
	--Draw Menu Options Text
		for i=1, maxabyssMenu do
			if i > abyssMenu - cursorPosY then
				if t_abyssMenu[i].id ~= nil then
					if shop then --SHOP MENU
						if t_unlockLua.abyss[t_abyssMenu[i].text] == nil then --Item is unlocked/has been found
							if t_abyssMenu[i].sold then --Item is sold out
								itemName = txt_abyssShopItemSold
								itemPrice = ""
							else --Item is NOT sold out
								itemName = t_abyssMenu[i].text
								itemPrice = t_abyssMenu[i].price
							end
						else --Item is locked/has not been discovered
							itemName = txt_abyssShopItemLock
							itemPrice = ""
						end
						textImgDraw(f_updateTextImg(t_abyssMenu[i].id, font2, 0, -1, itemPrice, 163, 20+i*15-moveTxt))
					else --NORMAL MENU
						itemName = t_abyssMenu[i].text
					end
					textImgDraw(f_updateTextImg(t_abyssMenu[i].id, font2, 0, 1, itemName, 5, 20+i*15-moveTxt))
				end
			end
		end
	--Draw Info Text Stuff
		animPosDraw(abyssSelInfoBG, -56, 185)
		if t_unlockLua.abyss[t_abyssMenu[abyssMenu].text] == nil then --Item is unlocked/has been found
			if t_abyssMenu[abyssMenu].sold then --Item is sold out
				itemInfo = txt_abyssShopInfoSold
			else --Item is NOT sold out
				itemInfo = t_abyssMenu[abyssMenu].info
			end
		else --Item is locked/has not been discovered
			itemInfo = txt_abyssShopInfoLock
		end
		f_textRender(txt_abyssLvInfo, itemInfo, 0, 159, 196, 10, 0, 40)
		f_abyssProfile() --Draw Char Profile Box
		if maxabyssMenu > maxItems then
			animDraw(menuArrowUp)
			animUpdate(menuArrowUp)
		end
		if #t_abyssMenu > maxItems and maxabyssMenu < #t_abyssMenu then
			animDraw(menuArrowDown)
			animUpdate(menuArrowDown)
		end
		if confirmScreen then f_confirmMenu() else drawAbyssInputHints(shop, t_abyssMenu[abyssMenu].sold) end
		if commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu') then
			bufd = 0
			bufu = bufu + 1
		elseif commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd') then
			bufu = 0
			bufd = bufd + 1
		else
			bufu = 0
			bufd = 0
		end
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		cmdInput()
		refresh()
	end
end

--;===========================================================
--; ABYSS MAP MENU
--;===========================================================
function f_abyssMap()
	cmdInput()
	local abyssDepth = getAbyssDepth() --From script.ssz
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	f_confirmReset()
	while true do
		if not confirmScreen then
			if esc() or commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then
				sndPlay(sndSys, 100, 2)
				confirmScreen = true
		--Actions
			elseif (btnPalNo(p1Cmd) > 0 or btnPalNo(p2Cmd) > 0) then
				sndPlay(sndSys, 100, 1)
				break --Go to vs
			end
		end
		if exitAbyss then
			data.tempBack = true --To exit to Main Menu from Abyss Menu
			break
		end
	--Draw BG
		animDraw(abyssMapBG)
		animDraw(f_animVelocity(abyssFog, -1, -1))
	--Draw Depth Stuff
		animDraw(abyssMapDepthBG)
		textImgSetText(txt_abyssMapDepth, "DEPTH "..getAbyssDepth())
		textImgDraw(txt_abyssMapDepth)
	--Draw Depth Levels
		for i=2, 11 do
			local startNo = nil
			if getAbyssDepth() == 1 then startNo = 1
			else startNo = 0
			end
			textImgSetText(txt_abyssMapDepthLv, getAbyssDepth()-startNo + (i-1)*10)
			textImgSetPos(txt_abyssMapDepthLv, 42, 10+i*22)
			textImgDraw(txt_abyssMapDepthLv)
		end
	--Draw Reward Text Stuff
		animDraw(abyssMapRewardBG)
		textImgSetText(txt_abyssMapReward, "REWARD "..getAbyssReward())
		textImgDraw(txt_abyssMapReward)
	--Draw Char Profile Box
		f_abyssProfile(0,14)
		animDraw(abyssMapInputWindowBG)
		if confirmScreen then f_confirmMenu() else drawAbyssMapInputHints() end
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		cmdInput()
		refresh()
	end
end

--;===========================================================
--; RANDOMTEST MODE (watch CPU play to generate AI rank data)
--;===========================================================
--[[
Used to generate AI rank data
AutoLevel is a function that ranks characters based on his number of loses vs wins
AutoLevel is palette dependent so if a char has a 12th palette OP mode that mode can have more rank than his normal one
]]

--Ints variables
local tuyoiBorder = 0
local juuni = 12
local moudeta = {}
local rank = 0
local saikyou = false
local roster = {}
local debugText = ''
local numChars = 0
local nextChar = 1

function addMoudeta(rank)
	moudeta[#moudeta + 1] = rank
	local max = math.floor(numChars / (math.min(numChars / (juuni*10) + 3, juuni)*juuni))
	while #moudeta > max do
		table.remove(moudeta, 1)
	end
end

function randRank()
	local r = 0
	while true do
		r = math.random(1, tuyoiBorder + juuni - 2);
		local notbroken = true
		for i = 1, #moudeta do
			if math.abs(moudeta[i] - r) <= math.floor(juuni/3) then
				notbroken = false
				break
			end
		end
		if notbroken then
			break
		end
	end
	return r
end

function eachAllChars(f)
	for cel = 1, #t_randomChars do
		f(cel-1)
	end
end

function rakuBenry()
	local alf = "save/debug/autolevel.txt"
	local veljnz = {}
	local winct = {}
	local buf = '\239\187\191'
	local fp = io.open(alf, 'r')
	if fp then
		for line in fp:lines() do
			local tmp = strsplit(',', line)
			if #tmp >= 2 then
				for i = 1, 4 do
					if i == 4 then
						tmp[1] = string.sub(tmp[1], 4)
					else
						if string.byte(tmp[1], i) ~= string.byte(buf, i) then break end
					end
				end
				winct[tmp[1]] = map(tonumber, strsplit(' ', strtrim(tmp[2])))
			end
		end
		io.close(fp)
	end
	numChars = 0
	eachAllChars(function(cel)
		numChars = numChars + 1
	end)
	local tuyoninzu = math.floor(numChars / (juuni*10))
	if tuyoninzu < juuni - 1 then
		tuyoiBorder =  math.floor(numChars / (tuyoninzu + 1))
		tuyoninzu = juuni - 1
	else
		tuyoiBorder = math.floor(numChars / juuni)
	end
	local total = 0
	local zero ={}
	local tsuyoshi = {}
	local rand = {}
	local kai = {}
	local bimyou = {}
	local tuyocnt = 0
	local ran = randRank()
	eachAllChars(function(cel)
		if #veljnz < cel*12 then
			for i = #veljnz + 1, cel*12 do
				veljnz[i] = 0
			end
		end
		local wins = winct[getCharFileName(cel)]
		local tmp = 0
		for j = 1, 12 do
			if wins and j <= #wins then
				total = total + wins[j]
				veljnz[cel*12 + j] = wins[j]
				tmp = tmp + wins[j]
			else
				veljnz[cel*12 + j] = 0
			end
		end
		if tmp >= tuyoiBorder then tuyocnt = tuyocnt + 1 end
		if tmp >= tuyoiBorder - juuni then table.insert(tsuyoshi, cel) end
		if tmp >= 1 and tmp <= juuni then table.insert(bimyou, cel) end
		if tmp > ran-juuni and tmp <= ran then table.insert(rand, cel) end
		if tmp == 0 then table.insert(zero, cel) end
		if tmp < 0 then table.insert(kai, cel) end
	end)
	function charAdd(cList, numAdd)
	if numAdd <= 0 then return end
		for i = 1, numAdd do
			if #cList == 0 then break end
			local cidx = math.random(1, #cList)
			table.insert(roster, cList[cidx])
			table.remove(cList, cidx)
		end
	end
	roster = {}
	nextChar = 1
	debugText = ''
	local numZero = #zero
	if numZero > 0 then
		charAdd(zero, numZero)
		charAdd(kai, tuyoninzu - numZero)
		rank = 0
	elseif #bimyou >= math.max(tuyoninzu*20, math.floor((numChars*3)/20)) then
		charAdd(bimyou, #bimyou)
		rank = juuni
	else
		for n = 1, 3 do
			if #rand >= tuyoninzu then break end
			rand = {}
			ran = randRank()
			eachAllChars(function(cel)
				local tmp = 0
				for j = 1, 12 do
					tmp = tmp + veljnz[cel*12 + j]
				end
				if tmp > ran-juuni and tmp <= ran then table.insert(rand, cel) end
			end)
		end
		debugText = ran .. ' ' .. #rand
		if #rand >= tuyoninzu then
			charAdd(rand, #rand)
			rank = ran
			addMoudeta(rank)
		elseif tuyocnt >= tuyoninzu then
			charAdd(tsuyoshi, #tsuyoshi)
			rank = tuyoiBorder+juuni-1
		else
			addMoudeta(tuyoiBorder + (juuni-2) - math.floor(juuni/3))
			charAdd(kai, #kai)
			rank = -1
		end
	end
	if numZero == 0 then
		while total ~= 0 do
			local i = math.random(1, #veljnz)
			if total > 0 then
				veljnz[i] = veljnz[i] - 1
				total = total - 1
			else
				veljnz[i] = veljnz[i] + 1
				total = total + 1
			end
		end
	end
	eachAllChars(function(cel)
		buf = buf .. getCharFileName(cel) .. ','
		for j = 1, 12 do
			buf = buf .. ' ' .. veljnz[cel*12 + j]
		end
		buf = buf .. '\r\n'
	end)
	local alv = io.open(alf, 'wb')
	alv:write(buf)
	io.close(alv)
end

function randSel(pno, winner)
	if winner > 0 and (pno == winner) == not saikyou then return end
	local team
	if rank == 0 or rank == 12 or saikyou then
		team = 0
	elseif rank < 0 then
		team = math.random(0, 2)
	else
		team = math.random(0, 1)*2
	end
	setTeamMode(pno, team, math.random(1, 4))
	local tmp = 0
	while tmp < 2 do
		tmp = selectChar(pno, roster[nextChar], math.random(1, 12))
		nextChar = nextChar + 1
		if nextChar > #roster then nextChar = 1 end
	end
end

--Writes the ranked AI levels to a save file
--This file is not used by AutoLevel
function rosterTxt()
	local str = "Rank: " .. rank .. ' ' .. debugText
	for i = 1, #roster do
		str = str .. '\n' .. getCharFileName(roster[i])
	end
	dscr = io.open("save/debug/AI_Rank.txt", 'w')
	dscr:write(str)
	io.close(dscr)
end

--Sets AIs to level 8 (MAX level) and ints AutoLevel
function initRandom()
	for i = 1, 8 do
		setCom(i, 8)
	end
	setAutoLevel(true)
	rakuBenry()
	winner = 0
	wins = 0
	rosterTxt()
	nextChar = 1
	saikyou = rank == tuyoiBorder+juuni-1
end

function randomTest()
	initRandom()
	refresh()
	while not esc() do
		randSel(1, winner)
		randSel(2, winner)
		setMatchNo(1)
		selectStage(0)
		loadStart()
		local oldwinner = winner
		winner = game() --Get into the fight
		if winner < 0 or esc() then break end
		oldwins = wins
		wins = wins + 1
		if winner ~= oldwinner then
			wins = 1
			setHomeTeam(winner == 1 and 2 or 1)
		end
		setMatchNo(wins)
		if winner <= 0 or wins >= 20 or wins == oldwins then
			initRandom()
		end
		refresh()
	end
end

--;===========================================================
--; CREDITS SCREEN (play staff credits)
--;=========================================================== 
function f_playCredits()
	sndStop()
	if data.rosterMode ~= "story" then playBGM("sound/system/credits.mp3") end
	local scroll = 0
	local speed = 0
	local speed1 = 0.5
	local speed2 = 1.8
	local skip = false
	local txtFont = font7--font14
	local txtBank = 0
	local txtAline = 0 --[1]= Align text left | [0]= Center Text | [-1]= Align text right
	local txtSpacing = 12 --spacing between lines (rendering Y position increasement for each line)
	local txtScaleX = 1
	local txtScaleY = 1
	local txtAlphaS = 255
	local txtAlphaD = 0
	local creditsTable = f_extractText(txt_creditsBox) --This returns a table with all text in the same written order
	cmdInput()
	data.fadeTitle = f_fadeAnim(50, 'fadein', 'black', sprFade)
	while true do
		if scroll > 2480 or esc() then break end --Credits Duration
		--Actions
		if (btnPalNo(p1Cmd) > 0 or btnPalNo(p2Cmd) > 0) and not skip then --Skip Button
			skip = true
		elseif (btnPalNo(p1Cmd) > 0 or btnPalNo(p2Cmd) > 0) and skip then --Unskip Button
			skip = false
		end
		if not skip then speed = speed1 --Normal
		elseif skip then speed = speed2 --Faster
		end
		--Draw Text
		for i = 1, #creditsTable do
			textImgDraw(f_updateTextImg(textImgNew(), txtFont, txtBank, txtAline, creditsTable[i], 155, 260 + txtSpacing * (i - 1) - scroll, txtScaleX, txtScaleY, txtAlphaS, txtAlphaD))
		end
		if data.debugMode then
			f_drawQuickText(speedTest, font14, 0, 1, scroll, 50, 100) --Test Timer
		end
		scroll = scroll + speed
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		cmdInput()
		refresh()
	end
	--When End
	data.fadeTitle = f_fadeAnim(50, 'fadein', 'black', sprFade)
	if data.attractMode == true then
		playBGM(bgmTitle)
	elseif data.rosterMode == "story" then
		playBGM(bgmStory)
	elseif data.rosterMode == "arcade" or data.rosterMode == "tower" then
		--Nothing because game over screen comes...
	else
		f_menuMusic()
	end
	if data.intermission then
		f_getIntermission() --Load t_secretChallenger
		--Conditions to enter in secret fight
		if #t_secretChallenger ~= 0 and stats.continueCount == 0 and data.difficulty >= 4 then
			f_intermission()
			f_secretFight()
		end
	end
	f_default()
end

--;===========================================================
--; EXTERNAL LUA CODE
--;===========================================================
local t_luaExternalMods = {}
function f_loadExternalModules(path)
if path == nil or path == "" then return end
	for item in lfs.dir(path) do --For each item readed in path
		if item ~= "." and item ~= ".." and item ~= ".keep" then --exclude items
			local details = path.."/"..item --Get path and file name
			local attribute = lfs.attributes(details) --Get atributes from items readed
			assert(type(attribute) == "table")
			f_loadExternalModules(details)
			if attribute.mode == "file" then --If the item have "file" attribute
				if item:match('^.*(%.)[Ll][Uu][Aa]$') then
					row = #t_luaExternalMods+1
					t_luaExternalMods[row] = {}
					t_luaExternalMods[row]['folder'] = path
					t_luaExternalMods[row]['path'] = details
					t_luaExternalMods[row]['name'] = item:gsub('^(.*)[%.][Ll][Uu][Aa]$', '%1')
				end
			end
		end
	end
	if data.debugLog then f_printTable(t_luaExternalMods, 'save/debug/t_luaExternalMods.txt') end
end
for mods=1, #luaModules do
	f_loadExternalModules(luaModules[mods]) --Load External Modules
end
for _, v in ipairs(t_luaExternalMods) do
	--require(v.path:gsub('[/\\]+', '.'))
	assert(loadfile(v.path))()
end
--;===========================================================
--; INITIALIZE LOOPS
--;===========================================================
f_mainStart() --Start Menu