math.randomseed(os.time())
--;===========================================================
--; INITIAL ACTIONS
--;===========================================================
--Detect Operating System to configure/load specific vars and libraries
batOpen("tools", "os_version.bat")
local osDetect = io.open("tools/os_info.txt", "r")
local osType = ""
if osDetect then
	local file_content = osDetect:read("*a")
	osDetect:close()
	if file_content then
		osType = file_content:gsub("^%s*(.-)%s*$", "%1")
	else
		osType = "Error Reading OS Content"
	end
else
	osType = "Error: Check OS File Not Found"
end
setOS(osType)
os.remove("tools/os_info.txt")
local file = io.open('save/debug/osVer.log',"w+")
file:write(osType)
file:close()

--Load Common stuff (shared with pause.lua)
require("script.common")
--playVideo("videos/mk004.bik", 1)

--Debug/Match Stuff
loadDebugFont(fontDebug)
setDebugScript("script/match.lua")
loadLifebar(fightDef) --Assign Lifebar Screenpack

f_discordInit() --Send Discord Rich Presence
--;===========================================================
--; GLOBAL VARIABLES DEFINITION
--;===========================================================
--Default System Vars
onlinegame = false
soundTest = false
altBGM = false
data.tagmode = 1
menuSelect = ""
P2overP1 = false
secretTarget = ""
unlockTarget = ""
--Default Turns/Simul Count after starting
p1numTurns = 2
p2numTurns = 2
p1numSimul = 2
p2numSimul = 2
--Default Team Mode after starting (0=Single, 1=Simul, 2=Turns)
p1teamMode = 0
p2teamMode = 0

function f_resetArcadeStuff()
stats.continueCount = 0 --Restart Times Continue in Arcade
f_saveStats()
keepLSide = false
keepRSide = false
end
--;===========================================================
--; LOAD ADDITIONAL SCRIPTS
--;===========================================================
assert(loadfile("script/loader.lua"))()

--;===========================================================
--; GAME START
--;===========================================================
function f_mainStart()
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	f_infoReset() --Allow select options below if the Engine detects characters or stages
--First Check (Tables generated by Sections)
	if t_selChars == nil then --If the Engine not detect Characters
		charsInfo = true
		infoScreen = true
		f_exitMenu()
	elseif t_selStages == nil then --If the Engine not detect Stages
		stagesInfo = true
		infoScreen = true
		f_exitMenu()
	elseif t_selOptions == nil then --If the Engine not detect Arcade and Survival roster Config in [Options] section from select.def
		configInfo = true
		infoScreen = true
		f_exitMenu()
	end
--Second Check (Content store in tables)
	if #t_selChars == 0 then --[Characters] section detected but there's not characters added
		charsInfo = true
		infoScreen = true
		f_exitMenu()
	elseif #t_selStages == 0 then --[ExtraStages] section detected but there's not stages added
		stagesInfo = true
		infoScreen = true
		f_exitMenu()
--Everything is "OK"
	else
		f_resetTemp()
		f_soundtrack() --Load Soundtrack Tables from common.lua for use in menus
		f_generateUnlocks()
		f_unlock(false) --Check For Unlocked Content
		f_updateUnlocks() --Print Unlock Data (when Save Debug Logs is Enabled)
		if data.attractMode then f_discordUpdate({details = "Attract Mode"}) end
		f_mainLogos(data.attractMode)
		f_resetArcadeStuff()
		if data.attractMode then
			f_mainAttract()
		else
			f_mainTitle()
		end
	end
end

--;===========================================================
--; LOGOS SCREEN
--;===========================================================
function f_mainLogos()
	if not data.attractMode then f_discordUpdate({details = "Title Screen"}) end
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	f_storyboard(storyboardLogo)
	f_mainOpening()
end

function f_mainOpening()
	if altBGM then playBGM(bgmIntroJP) else playBGM(bgmIntro) end
	f_storyboard(storyboardIntro)
	if altBGM then altBGM = false else altBGM = true end --Alternate Storyboard Opening BGM Songs
end

--;===========================================================
--; TITLE SCREEN
--;===========================================================
function f_mainTitle()
	cmdInput()
	local i = 0
	local t = 0
	--f_resetFadeBGM()
	playBGM(bgmTitle)
	while true do
		if i == 500 then
			i = 0
			demoModeCfg()
			f_mainLogos()
			playBGM(bgmTitle)
		elseif btnPalNo(p1Cmd, true) > 0 or btnPalNo(p2Cmd, true) > 0 then
			sndPlay(sndSys, 100, 1) --Play SFX from .snd file
			i = 0
			if startEn then f_mainMenu() end
		elseif esc() or commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then
			i = 0
			sndPlay(sndSys, 100, 2)
			f_exitMenu()
		end
		drawBottomMenuSP()
		drawMiddleMenuSP()
		textImgDraw(txt_titleFt)
		textImgSetText(txt_titleFt, "WELCOME TO SUEHIRO I.K.E.M.E.N. ENGINE")
		f_sysTime()
		drawTitleInputHints()
		if t%60 < 30 then
			textImgDraw(txt_mainTitle)
		end
		t = t >= 60 and 0 or t + 1
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		i = i + 1
		cmdInput()
		refresh()
	end
end

--Load Common Settings for Demo Mode
function demoModeCfg()
	if not data.attractMode then f_discordUpdate({details = "Demo"}) end
	f_default()
	setGameMode('demo')
	data.gameMode = "demo"
	data.rosterMode = "cpu"
	data.aiFight = true
	data.versusScreen = false
	data.victoryscreen = false
	data.p1TeamMenu = {mode = 0, chars = 1}
	data.p2TeamMenu = {mode = 0, chars = 1}
	data.p1Char = {t_selChars[t_randomChars[math.random(#t_randomChars)]+1].char} --Pick Random Char
	data.p2Char = {t_selChars[t_randomChars[math.random(#t_randomChars)]+1].char} --Pick Random Char
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	f_selectSimple()
	f_resetTemp()
end

--;===========================================================
--; ATTRACT MENU
--;===========================================================
function f_mainAttract()
	cmdInput()
	playBGM(bgmTitle)
	while true do
	--START GAME
		if getCredits() > 0 and (commandGetState(p1Cmd, 's') or commandGetState(p2Cmd, 's') or attractTimer == 0) then
			--playVideo(videoHowToPlay)
			data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
			--sndPlay(sndSys, 100, 1)
			setCredits(getCredits() - 1)
			arcadeCfg()
		--[[
			data.p1TeamMenu = {mode = 0, chars = 1}
			data.p2TeamMenu = {mode = 0, chars = 1}
		]]
			if commandGetState(p1Cmd, 's') or attractTimer == 0 then arcadeHumanvsCPU() --Start P1 from Left Side
			elseif commandGetState(p2Cmd, 's') then P2overP1 = true arcadeCPUvsHuman() --Start P2 from Right Side
			end
			f_discordUpdate({details = "Attract Mode"})
			attractTimer = attractSeconds*gameTick
	--START DEMO MODE
		elseif attractDemoTimer == 350 then
			demoModeCfg()
			f_mainLogos()
			attractDemoTimer = 0
			attractTimer = attractSeconds*gameTick
			playBGM(bgmTitle)
		end
		animDraw(f_animVelocity(titleBG0, -2.15, 0))
		animDraw(titleBG1)
		animAddPos(titleBG2, -1, 0)
		animUpdate(titleBG2)
		animDraw(titleBG2)
		animDraw(titleBG3)
		animDraw(titleBG4)
		animDraw(titleBG5)
		animPosDraw(inputHintsBG, -56, 219)
		f_textRender(txt_attractCopyrightCfg, txt_attractCopyright, 0, 159, 228, 10, 0, 55)
		f_titleText()
		f_sysTime()
		f_attractCredits()
		attractTimeNumber = attractTimer/gameTick --Convert Ticks to Seconds
		nodecimalAttractTime = string.format("%.0f",attractTimeNumber) --Delete Decimals
		textImgSetText(txt_attractTimer, "TIME "..nodecimalAttractTime)
		if attractTimer > 0 and getCredits() > 0 then
			attractTimer = attractTimer - 0.5 --Activate Title Screen Timer
			textImgDraw(txt_attractTimer)
		else --when attractTimer <= 0
			attractDemoTimer = attractDemoTimer + 1
		end
		drawAttractStatus()
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		cmdInput()
		refresh()
	end
end

--;===========================================================
--; MAIN MENU
--;===========================================================
function f_mainMenu()
	f_discordMainMenu()
	cmdInput()
	local cursorPosY = 0
	local moveTxt = 0
	local mainMenu = 1
	local bufu = 0
	local bufd = 0
	local bufr = 0
	local bufl = 0
	closeText = 1
	f_menuMusic()
	f_infoReset()
	f_infoboxReset()
	--f_resetFadeBGM()
	f_resetMenuArrowsPos()
	while true do
		if not infoScreen and not infoboxScreen then
		--First Run Msg
			if stats.firstRun then
				infoScreen = true
			end
			if f1Key() then infoboxScreen = true end --Show Classic Mugen Info Screen
			if esc() or commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then
				f_discordUpdate({details = "Title Screen"})
				sndPlay(sndSys, 100, 2)
				playBGM(bgmTitle)
				return
			elseif commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u') or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30) then
				sndPlay(sndSys, 100, 0)
				mainMenu = mainMenu - 1
			elseif commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd') or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30) then
				sndPlay(sndSys, 100, 0)
				mainMenu = mainMenu + 1
			end
		--mode titles/cursor position calculation
			if mainMenu < 1 then
				mainMenu = #t_mainMenu
				if #t_mainMenu > 5 then
					cursorPosY = 5
				else
					cursorPosY = #t_mainMenu-1
				end
			elseif mainMenu > #t_mainMenu then
				mainMenu = 1
				cursorPosY = 0
			elseif ((commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u')) or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30)) and cursorPosY > 0 then
				cursorPosY = cursorPosY - 1
			elseif ((commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd')) or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30)) and cursorPosY < 5 then
				cursorPosY = cursorPosY + 1
			end
			if cursorPosY == 5 then
				moveTxt = (mainMenu - 6) * 13
			elseif cursorPosY == 0 then
				moveTxt = (mainMenu - 1) * 13
			end
			if #t_mainMenu <= 5 then
				maxMainMenu = #t_mainMenu
			elseif mainMenu - cursorPosY > 0 then
				maxMainMenu = mainMenu + 5 - cursorPosY
			else
				maxMainMenu = 5
			end
		--Enter Actions
			if btnPalNo(p1Cmd, true) > 0 or btnPalNo(p2Cmd, true) > 0 then
				sndPlay(sndSys, 100, 1)
				f_gotoFunction(t_mainMenu[mainMenu]) --Functions are called from t_mainMenu table
			end
		end
		drawBottomMenuSP()
		for i=1, #t_mainMenu do
			if i == mainMenu then
				bank = 5 --Text Color (0=Nothing, 1=Red, 2=Green, 3=Blue, 4=Nothing, 5=Yellow, 6=Pink, 7=Shadow, 8=Black, 9=Â¿?)
			else
				bank = 0
			end
			if not infoboxScreen then
				textImgDraw(f_updateTextImg(t_mainMenu[i].id, jgFnt, bank, 0, t_mainMenu[i].text, 159, 122+i*13-moveTxt)) --Text Position
			end
		end
		if not infoScreen and not infoboxScreen then
			animSetWindow(cursorBox, 0,125+cursorPosY*13, 316,13) --Position and Size of the selection cursor
			f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
			animDraw(f_animVelocity(cursorBox, -1, -1)) --Blink rate
		end
		drawMiddleMenuSP()
		f_sysTime()
		if not infoboxScreen then
			textImgDraw(txt_gameFt)
			textImgSetText(txt_gameFt, "MAIN MENU")
			textImgDraw(txt_version)
			textImgDraw(txt_f1)
			if maxMainMenu > 6 then
				animDraw(menuArrowUp)
				animUpdate(menuArrowUp)
			end
			if #t_mainMenu > 6 and maxMainMenu < #t_mainMenu then
				animDraw(menuArrowDown)
				animUpdate(menuArrowDown)
			end
		end
		if infoScreen then
			f_infoMenu()
		else
			drawMainMenuInputHints()
		end
		if infoboxScreen then f_infoboxMenu() end
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		if commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu') then
			bufd = 0
			bufu = bufu + 1
		elseif commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd') then
			bufu = 0
			bufd = bufd + 1
		else
			bufu = 0
			bufd = 0
		end
		cmdInput()
		refresh()
	end
end

--This main menu type does not have scroll limits to items amount
function f_mainMenu2()
	f_discordMainMenu()
	cmdInput()
	local cursorPosY = 3 --To mark central item
	local mainMenu = 1
	local bufu = 0
	local bufd = 0
	local bufr = 0
	local bufl = 0
	closeText = 1
	f_menuMusic()
	f_infoReset()
	f_infoboxReset()
	--f_resetFadeBGM()
	f_resetMenuArrowsPos()
	while true do
		if not infoScreen and not infoboxScreen then
		--First Run Msg
			if stats.firstRun then
				infoScreen = true
			end
			if f1Key() then infoboxScreen = true end --Show Classic Mugen Info Screen
			if esc() or commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then
				sndPlay(sndSys, 100, 2)
				playBGM(bgmTitle)
				return
			elseif commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u') or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30) then
				sndPlay(sndSys, 100, 0)
				mainMenu = mainMenu - 1
			elseif commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd') or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30) then
				sndPlay(sndSys, 100, 0)
				mainMenu = mainMenu + 1
			end
		--mode titles/cursor position calculation
			if mainMenu < 1 then
				mainMenu = #t_mainMenu
			elseif mainMenu > #t_mainMenu then
				mainMenu = 1
			end
		--Enter Actions
			if btnPalNo(p1Cmd, true) > 0 or btnPalNo(p2Cmd, true) > 0 then
				sndPlay(sndSys, 100, 1)
				f_gotoFunction(t_mainMenu[mainMenu]) --Functions are called from t_mainMenu table
			end
		end
		drawBottomMenuSP()
		if not infoboxScreen then
		--Draw Up to 6 items with unlimited scroll
			local font = jgFnt
			local bank = 0
			local align = 0
			drawMenuItem(t_mainMenu, mainMenu, -3, font, bank, align, 159, 136)
			drawMenuItem(t_mainMenu, mainMenu, -2, font, bank, align, 159, 149)
			drawMenuItem(t_mainMenu, mainMenu, -1, font, bank, align, 159, 161)
			drawMenuItem(t_mainMenu, mainMenu, 0, font, 5, align, 159, 174) --Central Item (cursor)
			--textImgDraw(f_updateTextImg(t_mainMenu[mainMenu].id, font, 5, align, t_mainMenu[mainMenu].text, 159, 174)) --Central Item (cursor)
			drawMenuItem(t_mainMenu, mainMenu, 1, font, bank, align, 159, 187)
			drawMenuItem(t_mainMenu, mainMenu, 2, font, bank, align, 159, 201)
		end
		if not infoScreen and not infoboxScreen then
			animSetWindow(cursorBox, 0,125+cursorPosY*13, 316,13) --Position and Size of the selection cursor
			f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
			animDraw(f_animVelocity(cursorBox, -1, -1)) --Blink rate
		end
		drawMiddleMenuSP()
		f_sysTime()
		if not infoboxScreen then
			textImgDraw(txt_gameFt)
			textImgSetText(txt_gameFt, "MAIN MENU")
			textImgDraw(txt_version)
			textImgDraw(txt_f1)
			animDraw(menuArrowUp)
			animUpdate(menuArrowUp)
			animDraw(menuArrowDown)
			animUpdate(menuArrowDown)
		end
		if infoScreen then
			f_infoMenu()
		else
			drawMainMenuInputHints()
		end
		if infoboxScreen then f_infoboxMenu() end
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		if commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu') then
			bufd = 0
			bufu = bufu + 1
		elseif commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd') then
			bufu = 0
			bufd = bufd + 1
		else
			bufu = 0
			bufd = 0
		end
		cmdInput()
		refresh()
	end
end

--;===========================================================
--; OPTIONS MENU (adjust game settings)
--;===========================================================
function f_optionsMenu()
	onlinegame = false --only for identify purposes
	assert(loadfile(saveCfgPath))()
	f_mainCfg() --start f_mainCfg() function from script/options.lua
end

--;===========================================================
--; ARCADE MENU (select arcade variants)
--;===========================================================
function f_arcadeMenu()
	cmdInput()
	local cursorPosY = 0
	local moveTxt = 0
	local arcadeMenu = 1
	local bufu = 0
	local bufd = 0
	local bufr = 0
	local bufl = 0
	f_infoReset()
	f_sideReset() --Reset Values to Show Side Select
	while true do
		if not infoScreen and not sideScreen then --Turn off controls over arcade menu if Side Select is active
			if esc() or commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then
				sndPlay(sndSys, 100, 2)
				break
			elseif commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u') or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30) then
				sndPlay(sndSys, 100, 0)
				arcadeMenu = arcadeMenu - 1
			elseif commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd') or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30) then
				sndPlay(sndSys, 100, 0)
				arcadeMenu = arcadeMenu + 1
			end
			if arcadeMenu < 1 then
				arcadeMenu = #t_arcadeMenu
				if #t_arcadeMenu > 5 then
					cursorPosY = 5
				else
					cursorPosY = #t_arcadeMenu-1
				end
			elseif arcadeMenu > #t_arcadeMenu then
				arcadeMenu = 1
				cursorPosY = 0
			elseif ((commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u')) or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30)) and cursorPosY > 0 then
				cursorPosY = cursorPosY - 1
			elseif ((commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd')) or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30)) and cursorPosY < 5 then
				cursorPosY = cursorPosY + 1
			end
			if cursorPosY == 5 then
				moveTxt = (arcadeMenu - 6) * 13
			elseif cursorPosY == 0 then
				moveTxt = (arcadeMenu - 1) * 13
			end
			if #t_arcadeMenu <= 5 then
				maxArcadeMenu = #t_arcadeMenu
			elseif arcadeMenu - cursorPosY > 0 then
				maxArcadeMenu = arcadeMenu + 5 - cursorPosY
			else
				maxArcadeMenu = 5
			end
		--Enter Actions
			if btnPalNo(p1Cmd, true) > 0 or btnPalNo(p2Cmd, true) > 0 then
				sndPlay(sndSys, 100, 1)
				f_gotoFunction(t_arcadeMenu[arcadeMenu])
			end
		end
		drawBottomMenuSP()
		for i=1, #t_arcadeMenu do
			if i == arcadeMenu then
				bank = 5
			else
				bank = 0
			end
			textImgDraw(f_updateTextImg(t_arcadeMenu[i].id, jgFnt, bank, 0, t_arcadeMenu[i].text, 159, 122+i*13-moveTxt))
		end
		if not infoScreen and not sideScreen then
			animSetWindow(cursorBox, 0,125+cursorPosY*13, 316,13)
			f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
			animDraw(f_animVelocity(cursorBox, -1, -1))
		end
		drawMiddleMenuSP()
		textImgDraw(txt_gameFt)		
		textImgSetText(txt_gameFt, "ARCADE MODES")
		textImgDraw(txt_version)
		f_sysTime()
		if maxArcadeMenu > 6 then
			animDraw(menuArrowUp)
			animUpdate(menuArrowUp)
		end
		if #t_arcadeMenu > 6 and maxArcadeMenu < #t_arcadeMenu then
			animDraw(menuArrowDown)
			animUpdate(menuArrowDown)
		end
		if not infoScreen and not sideScreen then drawMainMenuInputHints() end
		if sideScreen then f_sideSelect() end --Show Side Select
		if infoScreen then f_infoMenu() end
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		if commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu') then
			bufd = 0
			bufu = bufu + 1
		elseif commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd') then
			bufu = 0
			bufd = bufd + 1
		else
			bufu = 0
			bufd = 0
		end
		cmdInput()
		refresh()
	end
end

--;===========================================================
--; VERSUS MENU (face specific opponents)
--;===========================================================
function f_vsMenu()
	cmdInput()
	local cursorPosY = 0
	local moveTxt = 0
	local vsMenu = 1
	local bufu = 0
	local bufd = 0
	local bufr = 0
	local bufl = 0
	f_infoReset()
	f_sideReset()
	while true do
		if not infoScreen and not sideScreen then
			if esc() or commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then
				sndPlay(sndSys, 100, 2)
				break
			elseif commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u') or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30) then
				sndPlay(sndSys, 100, 0)
				vsMenu = vsMenu - 1
			elseif commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd') or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30) then
				sndPlay(sndSys, 100, 0)
				vsMenu = vsMenu + 1
			end
			if vsMenu < 1 then
				vsMenu = #t_vsMenu
				if #t_vsMenu > 5 then
					cursorPosY = 5
				else
					cursorPosY = #t_vsMenu-1
				end
			elseif vsMenu > #t_vsMenu then
				vsMenu = 1
				cursorPosY = 0
			elseif ((commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u')) or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30)) and cursorPosY > 0 then
				cursorPosY = cursorPosY - 1
			elseif ((commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd')) or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30)) and cursorPosY < 5 then
				cursorPosY = cursorPosY + 1
			end
			if cursorPosY == 5 then
				moveTxt = (vsMenu - 6) * 13
			elseif cursorPosY == 0 then
				moveTxt = (vsMenu - 1) * 13
			end
			if #t_vsMenu <= 5 then
				maxVSMenu = #t_vsMenu
			elseif vsMenu - cursorPosY > 0 then
				maxVSMenu = vsMenu + 5 - cursorPosY
			else
				maxVSMenu = 5
			end
		--Enter Actions
			if btnPalNo(p1Cmd, true) > 0 or btnPalNo(p2Cmd, true) > 0 then
				sndPlay(sndSys, 100, 1)
				f_gotoFunction(t_vsMenu[vsMenu])
			end
		end
		drawBottomMenuSP()
		for i=1, #t_vsMenu do
			if i == vsMenu then
				bank = 5
			else
				bank = 0
			end
			textImgDraw(f_updateTextImg(t_vsMenu[i].id, jgFnt, bank, 0, t_vsMenu[i].text, 159, 122+i*13-moveTxt))
		end
		if not infoScreen and not sideScreen then
			animSetWindow(cursorBox, 0,125+cursorPosY*13, 316,13)
			f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
			animDraw(f_animVelocity(cursorBox, -1, -1))
		end
		drawMiddleMenuSP()
		textImgDraw(txt_gameFt)
		textImgSetText(txt_gameFt, "VERSUS MODES")
		textImgDraw(txt_version)
		f_sysTime()
		if maxVSMenu > 6 then
			animDraw(menuArrowUp)
			animUpdate(menuArrowUp)
		end
		if #t_vsMenu > 6 and maxVSMenu < #t_vsMenu then
			animDraw(menuArrowDown)
			animUpdate(menuArrowDown)
		end
		if not infoScreen and not sideScreen then drawMainMenuInputHints() end
		if sideScreen then f_sideSelect() end
		if infoScreen then f_infoMenu() end
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		if commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu') then
			bufd = 0
			bufu = bufu + 1
		elseif commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd') then
			bufu = 0
			bufd = bufd + 1
		else
			bufu = 0
			bufd = 0
		end
		cmdInput()
		refresh()
	end
end

--;===========================================================
--; PRACTICE MENU (Learn the basics of 2D Fighting Games through customizable Game Modes designed to practice)
--;===========================================================
function f_practiceMenu()
	cmdInput()
	local cursorPosY = 0
	local moveTxt = 0
	local practiceMenu = 1
	local bufu = 0
	local bufd = 0
	local bufr = 0
	local bufl = 0
	f_infoReset()
	f_sideReset()
	while true do
		if not infoScreen and not sideScreen then
			if esc() or commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then
				sndPlay(sndSys, 100, 2)
				break
			elseif commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u') or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30) then
				sndPlay(sndSys, 100, 0)
				practiceMenu = practiceMenu - 1
			elseif commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd') or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30) then
				sndPlay(sndSys, 100, 0)
				practiceMenu = practiceMenu + 1
			end
			if practiceMenu < 1 then
				practiceMenu = #t_practiceMenu
				if #t_practiceMenu > 5 then
					cursorPosY = 5
				else
					cursorPosY = #t_practiceMenu-1
				end
			elseif practiceMenu > #t_practiceMenu then
				practiceMenu = 1
				cursorPosY = 0
			elseif ((commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u')) or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30)) and cursorPosY > 0 then
				cursorPosY = cursorPosY - 1
			elseif ((commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd')) or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30)) and cursorPosY < 5 then
				cursorPosY = cursorPosY + 1
			end
			if cursorPosY == 5 then
				moveTxt = (practiceMenu - 6) * 13
			elseif cursorPosY == 0 then
				moveTxt = (practiceMenu - 1) * 13
			end
			if #t_practiceMenu <= 5 then
				maxpracticeMenu = #t_practiceMenu
			elseif practiceMenu - cursorPosY > 0 then
				maxpracticeMenu = practiceMenu + 5 - cursorPosY
			else
				maxpracticeMenu = 5
			end
			if btnPalNo(p1Cmd, true) > 0 or btnPalNo(p2Cmd, true) > 0 then
				sndPlay(sndSys, 100, 1)
				f_gotoFunction(t_practiceMenu[practiceMenu])
			end
		end
		drawBottomMenuSP()
		for i=1, #t_practiceMenu do
			if i == practiceMenu then
				bank = 5
			else
				bank = 0
			end
			textImgDraw(f_updateTextImg(t_practiceMenu[i].id, jgFnt, bank, 0, t_practiceMenu[i].text, 159, 122+i*13-moveTxt))
		end
		if not infoScreen and not sideScreen then
			animSetWindow(cursorBox, 0,125+cursorPosY*13, 316,13)
			f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
			animDraw(f_animVelocity(cursorBox, -1, -1))
		end
		drawMiddleMenuSP()
		textImgDraw(txt_gameFt)
		textImgSetText(txt_gameFt, "PRACTICE MODES")
		textImgDraw(txt_version)
		f_sysTime()
		if maxpracticeMenu > 6 then
			animDraw(menuArrowUp)
			animUpdate(menuArrowUp)
		end
		if #t_practiceMenu > 6 and maxpracticeMenu < #t_practiceMenu then
			animDraw(menuArrowDown)
			animUpdate(menuArrowDown)
		end
		if not infoScreen and not sideScreen then drawMainMenuInputHints() end
		if sideScreen then f_sideSelect() end
		if infoScreen then f_infoMenu() end
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		if commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu') then
			bufd = 0
			bufu = bufu + 1
		elseif commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd') then
			bufu = 0
			bufd = bufd + 1
		else
			bufu = 0
			bufd = 0
		end
		cmdInput()
		refresh()
	end
end

--;===========================================================
--; TRAINING MODE (practice special attacks and combos with training dummy character(s) of your choice)
--;===========================================================
function f_training()
	f_discordUpdate({details = "Training"})
	f_default()
	setGameMode('practice')
	data.gameMode = "training"
	data.rosterMode = "training"
	setRoundTime(-1) --round time disabled
	data.versusScreen = false --versus screen disabled
	data.victoryscreen = false --victory screen disabled
	data.stageMenu = true
	data.p1TeamMenu = {mode = 0, chars = 1} --predefined P1 team mode as Single, 1 Character				
	data.p2TeamMenu = {mode = 0, chars = 1} --predefined P2 team mode as Single, 1 Character
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	--sndPlay(sndSys, 100, 1)
	if #t_trainingChar ~= 0 then --If a training char is detected in select.def with training=1 paramvalue
		data.p2In = 2
		data.p2Char = {t_selChars[t_trainingChar[math.random(#t_trainingChar)]+1].char} --pick a random training char from the table
	else --Training Char will be selected in char select if there is not training chars detected in select.def with training=1 paramvalue
		data.p2In = 1
		data.p2Faces = true
	end
	textImgSetText(txt_mainSelect, "TRAINING MODE")
	f_selectSimple()
	f_discordMainMenu()
end

--;===========================================================
--; CHALLENGES MENU (play advanced game modes)
--;===========================================================	
function f_challengeMenu()
	cmdInput()
	local cursorPosY = 0
	local moveTxt = 0
	local challengeMenu = 1
	local bufu = 0
	local bufd = 0
	local bufr = 0
	local bufl = 0
	f_infoReset()
	f_sideReset()
	while true do
		if not infoScreen and not sideScreen then
			if esc() or commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then
				sndPlay(sndSys, 100, 2)
				break
			elseif commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u') or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30) then
				sndPlay(sndSys, 100, 0)
				challengeMenu = challengeMenu - 1
			elseif commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd') or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30) then
				sndPlay(sndSys, 100, 0)
				challengeMenu = challengeMenu + 1
			end
			if challengeMenu < 1 then
				challengeMenu = #t_challengeMenu
				if #t_challengeMenu > 5 then
					cursorPosY = 5
				else
					cursorPosY = #t_challengeMenu-1
				end
			elseif challengeMenu > #t_challengeMenu then
				challengeMenu = 1
				cursorPosY = 0
			elseif ((commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u')) or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30)) and cursorPosY > 0 then
				cursorPosY = cursorPosY - 1
			elseif ((commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd')) or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30)) and cursorPosY < 5 then
				cursorPosY = cursorPosY + 1
			end
			if cursorPosY == 5 then
				moveTxt = (challengeMenu - 6) * 13
			elseif cursorPosY == 0 then
				moveTxt = (challengeMenu - 1) * 13
			end
			if #t_challengeMenu <= 5 then
				maxChallengeMenu = #t_challengeMenu
			elseif challengeMenu - cursorPosY > 0 then
				maxChallengeMenu = challengeMenu + 5 - cursorPosY
			else
				maxChallengeMenu = 5
			end
		--Enter Actions
			if btnPalNo(p1Cmd, true) > 0 or btnPalNo(p2Cmd, true) > 0 then
				sndPlay(sndSys, 100, 1)
				f_gotoFunction(t_challengeMenu[challengeMenu])
			end
		end
		drawBottomMenuSP()
		for i=1, #t_challengeMenu do
			if i == challengeMenu then
				bank = 1
			else
				bank = 0
			end
			textImgDraw(f_updateTextImg(t_challengeMenu[i].id, jgFnt, bank, 0, t_challengeMenu[i].text, 159, 122+i*13-moveTxt))
		end
		if not infoScreen and not sideScreen then
			animSetWindow(cursorBox, 0,125+cursorPosY*13, 316,13)
			f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
			animDraw(f_animVelocity(cursorBox, -1, -1))
		end
		drawMiddleMenuSP()
		textImgDraw(txt_gameFt)
		textImgSetText(txt_gameFt, "CHALLENGE MODES")
		textImgDraw(txt_version)
		f_sysTime()
		if maxChallengeMenu > 6 then
			animDraw(menuArrowUp)
			animUpdate(menuArrowUp)
		end
		if #t_challengeMenu > 6 and maxChallengeMenu < #t_challengeMenu then
			animDraw(menuArrowDown)
			animUpdate(menuArrowDown)
		end
		if not infoScreen and not sideScreen then drawMainMenuInputHints() end
		if sideScreen then f_sideSelect() end
		if infoScreen then f_infoMenu() end
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		if commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu') then
			bufd = 0
			bufu = bufu + 1
		elseif commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd') then
			bufu = 0
			bufd = bufd + 1
		else
			bufu = 0
			bufd = 0
		end
		cmdInput()
		refresh()
	end
end

--;===========================================================
--; EXTRAS MENU (play special game modes)
--;===========================================================	
function f_extrasMenu()
	if stats.modes.arcade.clear < 1 then
		f_secret()
		return
	end
	cmdInput()
	local cursorPosY = 0
	local moveTxt = 0
	local extrasMenu = 1
	local bufu = 0
	local bufd = 0
	local bufr = 0
	local bufl = 0
	f_sideReset()
	f_infoReset()
	while true do
		if not sideScreen and not infoScreen then
			if esc() or commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then
				sndPlay(sndSys, 100, 2)
				break
			elseif commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u') or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30) then
				sndPlay(sndSys, 100, 0)
				extrasMenu = extrasMenu - 1
			elseif commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd') or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30) then
				sndPlay(sndSys, 100, 0)
				extrasMenu = extrasMenu + 1
			end
			if extrasMenu < 1 then
				extrasMenu = #t_extrasMenu
				if #t_extrasMenu > 5 then
					cursorPosY = 5
				else
					cursorPosY = #t_extrasMenu-1
				end
			elseif extrasMenu > #t_extrasMenu then
				extrasMenu = 1
				cursorPosY = 0
			elseif ((commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u')) or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30)) and cursorPosY > 0 then
				cursorPosY = cursorPosY - 1
			elseif ((commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd')) or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30)) and cursorPosY < 5 then
				cursorPosY = cursorPosY + 1
			end
			if cursorPosY == 5 then
				moveTxt = (extrasMenu - 6) * 13
			elseif cursorPosY == 0 then
				moveTxt = (extrasMenu - 1) * 13
			end
			if #t_extrasMenu <= 5 then
				maxExtrasMenu = #t_extrasMenu
			elseif extrasMenu - cursorPosY > 0 then
				maxExtrasMenu = extrasMenu + 5 - cursorPosY
			else
				maxExtrasMenu = 5
			end
		--Enter Actions
			if btnPalNo(p1Cmd, true) > 0 or btnPalNo(p2Cmd, true) > 0 then
				sndPlay(sndSys, 100, 1)
				f_gotoFunction(t_extrasMenu[extrasMenu])
			end
		end
		drawBottomMenuSP()
		for i=1, #t_extrasMenu do
			if i == extrasMenu then
				bank = 2
			else
				bank = 0
			end
			textImgDraw(f_updateTextImg(t_extrasMenu[i].id, jgFnt, bank, 0, t_extrasMenu[i].text, 159, 122+i*13-moveTxt))
		end
		if not sideScreen and not infoScreen then
			animSetWindow(cursorBox, 0,125+cursorPosY*13, 316,13)
			f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
			animDraw(f_animVelocity(cursorBox, -1, -1))
		end
		drawMiddleMenuSP()
		textImgDraw(txt_gameFt)
		textImgSetText(txt_gameFt, "EXTRA MODES")
		textImgDraw(txt_version)
		f_sysTime()
		if maxExtrasMenu > 6 then
			animDraw(menuArrowUp)
			animUpdate(menuArrowUp)
		end
		if #t_extrasMenu > 6 and maxExtrasMenu < #t_extrasMenu then
			animDraw(menuArrowDown)
			animUpdate(menuArrowDown)
		end
		if not infoScreen and not sideScreen then drawMainMenuInputHints() end
		if sideScreen then f_sideSelect() end
		if infoScreen then f_infoMenu() end
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		if commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu') then
			bufd = 0
			bufu = bufu + 1
		elseif commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd') then
			bufu = 0
			bufd = bufd + 1
		else
			bufu = 0
			bufd = 0
		end
		cmdInput()
		refresh()
	end
end

--;===========================================================
--; WATCH MENU (watch replays, player profile, licenses and more)
--;===========================================================
function f_watchMenu()
	cmdInput()
	local cursorPosY = 0
	local moveTxt = 0
	local watchMenu = 1
	local bufu = 0
	local bufd = 0
	local bufr = 0
	local bufl = 0
	f_infoReset()
	while true do
		if not infoScreen then
			if esc() or commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then
				sndPlay(sndSys, 100, 2)
				break
			elseif commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u') or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30) then
				sndPlay(sndSys, 100, 0)
				watchMenu = watchMenu - 1
			elseif commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd') or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30) then
				sndPlay(sndSys, 100, 0)
				watchMenu = watchMenu + 1
			end
			if watchMenu < 1 then
				watchMenu = #t_watchMenu
				if #t_watchMenu > 5 then
					cursorPosY = 5
				else
					cursorPosY = #t_watchMenu-1
				end
			elseif watchMenu > #t_watchMenu then
				watchMenu = 1
				cursorPosY = 0
			elseif ((commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u')) or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30)) and cursorPosY > 0 then
				cursorPosY = cursorPosY - 1
			elseif ((commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd')) or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30)) and cursorPosY < 5 then
				cursorPosY = cursorPosY + 1
			end
			if cursorPosY == 5 then
				moveTxt = (watchMenu - 6) * 13
			elseif cursorPosY == 0 then
				moveTxt = (watchMenu - 1) * 13
			end
			if #t_watchMenu <= 5 then
				maxWatchMenu = #t_watchMenu
			elseif watchMenu - cursorPosY > 0 then
				maxWatchMenu = watchMenu + 5 - cursorPosY
			else
				maxWatchMenu = 5
			end
		--Enter Actions
			if btnPalNo(p1Cmd, true) > 0 or btnPalNo(p2Cmd, true) > 0 then
				sndPlay(sndSys, 100, 1)
				f_gotoFunction(t_watchMenu[watchMenu])
			end
		end
		drawBottomMenuSP()
		for i=1, #t_watchMenu do
			if i == watchMenu then
				bank = 5
			else
				bank = 0
			end
			textImgDraw(f_updateTextImg(t_watchMenu[i].id, jgFnt, bank, 0, t_watchMenu[i].text, 159, 122+i*13-moveTxt))
		end
		if not infoScreen then
			animSetWindow(cursorBox, 0,125+cursorPosY*13, 316,13)
			f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
			animDraw(f_animVelocity(cursorBox, -1, -1))
		end
		drawMiddleMenuSP()
		textImgDraw(txt_gameFt)
		textImgSetText(txt_gameFt, "WATCH CONTENT")
		textImgDraw(txt_version)
		f_sysTime()
		if maxWatchMenu > 6 then
			animDraw(menuArrowUp)
			animUpdate(menuArrowUp)
		end
		if #t_watchMenu > 6 and maxWatchMenu < #t_watchMenu then
			animDraw(menuArrowDown)
			animUpdate(menuArrowDown)
		end
		if infoScreen then f_infoMenu() else drawMainMenuInputHints() end
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		if commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu') then
			bufd = 0
			bufu = bufu + 1
		elseif commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd') then
			bufu = 0
			bufd = bufd + 1
		else
			bufu = 0
			bufd = 0
		end
		cmdInput()
		refresh()
	end
end

--;===========================================================
--; PROFILE MENU (display overall player data [RECORDS, LEADERBOARDS, ACHIEVEMENTS])
--;===========================================================
function f_profileMenu()
	cmdInput()
	local cursorPosY = 0
	local moveTxt = 0
	local profileMenu = 1
	local bufu = 0
	local bufd = 0
	local bufr = 0
	local bufl = 0
	f_infoReset()
	while true do
		if not infoScreen then
			if esc() or commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then
				sndPlay(sndSys, 100, 2)
				break
			elseif commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u') or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30) then
				sndPlay(sndSys, 100, 0)
				profileMenu = profileMenu - 1
			elseif commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd') or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30) then
				sndPlay(sndSys, 100, 0)
				profileMenu = profileMenu + 1
			end
			if profileMenu < 1 then
				profileMenu = #t_profileMenu
				if #t_profileMenu > 5 then
					cursorPosY = 5
				else
					cursorPosY = #t_profileMenu-1
				end
			elseif profileMenu > #t_profileMenu then
				profileMenu = 1
				cursorPosY = 0
			elseif ((commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u')) or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30)) and cursorPosY > 0 then
				cursorPosY = cursorPosY - 1
			elseif ((commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd')) or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30)) and cursorPosY < 5 then
				cursorPosY = cursorPosY + 1
			end
			if cursorPosY == 5 then
				moveTxt = (profileMenu - 6) * 13
			elseif cursorPosY == 0 then
				moveTxt = (profileMenu - 1) * 13
			end
			if #t_profileMenu <= 5 then
				maxprofileMenu = #t_profileMenu
			elseif profileMenu - cursorPosY > 0 then
				maxprofileMenu = profileMenu + 5 - cursorPosY
			else
				maxprofileMenu = 5
			end
			if btnPalNo(p1Cmd, true) > 0 or btnPalNo(p2Cmd, true) > 0 then
				sndPlay(sndSys, 100, 1)
				f_gotoFunction(t_profileMenu[profileMenu])
			end
		end
		drawBottomMenuSP()
		for i=1, #t_profileMenu do
			if i == profileMenu then
				bank = 5
			else
				bank = 0
			end
			textImgDraw(f_updateTextImg(t_profileMenu[i].id, jgFnt, bank, 0, t_profileMenu[i].text, 159, 122+i*13-moveTxt))
		end
		if not infoScreen then
			animSetWindow(cursorBox, 0,125+cursorPosY*13, 316,13)
			f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
			animDraw(f_animVelocity(cursorBox, -1, -1))
		end
		drawMiddleMenuSP()
		textImgDraw(txt_gameFt)
		textImgSetText(txt_gameFt, "PLAYER PROFILE")
		textImgDraw(txt_version)
		f_sysTime()
		if maxprofileMenu > 6 then
			animDraw(menuArrowUp)
			animUpdate(menuArrowUp)
		end
		if #t_profileMenu > 6 and maxprofileMenu < #t_profileMenu then
			animDraw(menuArrowDown)
			animUpdate(menuArrowDown)
		end
		if not infoScreen then drawMainMenuInputHints() end
		if infoScreen then f_infoMenu() end
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		if commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu') then
			bufd = 0
			bufu = bufu + 1
		elseif commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd') then
			bufu = 0
			bufd = bufd + 1
		else
			bufu = 0
			bufd = 0
		end
		cmdInput()
		refresh()
	end
end

--;===========================================================
--; CLASSIC ARCADE MODE (play a customizable arcade ladder)
--;===========================================================
function f_arcadeBoot()
	menuSelect = "arcade"
	sideScreen = true
end

--Load Common Settings for Classic Arcade Modes
function arcadeCfg()
	f_discordUpdate({details = "Arcade"})
	f_resetArcadeStuff()
	f_default() --Load f_default function defined in common.lua
	setGameMode('arcade')
	data.gameMode = "arcade" --mode recognized in select screen as arcade
	data.rosterMode = "arcade" --to record statistics
	data.serviceScreen = true --Enable Service Screen if you lose and continue
	data.arcadeTravel = true --Enable Arcade Travel Screen before order select
	data.arcadeIntro = true --Enable characters arcade intro before versus screen
	data.arcadeEnding = true --Enable characters arcade ending before credits screen
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	sndPlay(sndSys, 100, 1)
end

--HUMAN VS CPU (fight against CPU controlled opponents in a customizable arcade ladder from left side)
function arcadeHumanvsCPU()
	local modeName = "ARCADE"
	if data.attractMode then modeName = txt_attractSelectTitle end
	if P2overP1 then --Set player 2 controls config over player 1
		remapInput(1, 2) --P1 swap controls with p2 side
		setPlayerSide('p2left') --will be used to open challenger screen
	else
		setPlayerSide('p1left')
	end
	data.p2In = 1 --P1 controls P2 side of the select screen (but not the character only menus)
	data.p2SelectMenu = false --P2 character selection disabled
	textImgSetText(txt_mainSelect, modeName) --message displayed on top of select screen
	f_selectAdvance() --start f_selectAdvance() function
	P2overP1 = false --Reset Player 2 Control Swap Detection
	f_discordMainMenu()
end

--CPU VS HUMAN (fight against CPU controlled opponents in a customizable arcade ladder from right side)
function arcadeCPUvsHuman()
	local modeName = "ARCADE"
	if data.attractMode then modeName = txt_attractSelectTitle end
	remapInput(1, 2)
	if not P2overP1 then
		remapInput(2, 1) --P2 swap controls with p1 side
		setPlayerSide('p1right') --set Pause Controls if P1 is in Right Side
	else
		setPlayerSide('p2right')
	end
	data.p1In = 2
	data.p2In = 2
	data.p1SelectMenu = false --P1 character selection disabled
	textImgSetText(txt_mainSelect, modeName)
	f_selectAdvance()
	P2overP1 = false
	f_discordMainMenu()
end

--P1&P2 VS CPU [CO-OP MODE] (team up with another player from left side against CPU controlled opponents in a customizable arcade ladder)
function arcadeP1P2vsCPU()
	data.p2In = 2
	data.p2Faces = true
	data.coop = true --P2 fighting on P1 side enabled
	setPlayerSide('p1left')
	setGameMode('arcadecoop') --to avoid challenger screen
	textImgSetText(txt_mainSelect, "ARCADE COOPERATIVE")
	f_selectAdvance()
	f_discordMainMenu()
end

--CPU VS P1&P2 [CO-OP MODE] (team up with another player from right side against CPU controlled opponents in a customizable arcade ladder)
function arcadeCPUvsP1P2()
	f_comingSoon()
	--[[
	setPlayerSide('p1right')
	data.p1In = 2
	data.p2In = 2
	data.p2Faces = true
	data.coop = true
	setGameMode('arcadecoop')
	textImgSetText(txt_mainSelect, "ARCADE COOPERATIVE")
	f_selectAdvance()
	]]
end

--CPU MODE (watch CPU fight in a customizable arcade ladder)
function arcadeCPUvsCPU()
	data.p2In = 1
	data.p2SelectMenu = false
	data.aiFight = true --AI = data.difficulty for all characters enabled
	setPlayerSide('p1left')
	setGameMode('arcadecpu') --to avoid challenger screen
	data.rosterMode = "cpu" --to avoid record stats
	textImgSetText(txt_mainSelect, "WATCH ARCADE")
	f_selectAdvance()
	f_discordMainMenu()
end

--;===========================================================
--; TOWER ARCADE MODE (play through customizable arcade routes/ladders)
--;===========================================================
function f_towerBoot()
	if data.debugMode then f_loadTowers() end
	if #t_selTower ~= 0 then
		menuSelect = "tower"
		sideScreen = true
	else --If there are not towers loaded
		towerInfo = true
		infoScreen = true
	end
end

--Load Common Settings for Tower Modes
function towerCfg()
	f_discordUpdate({details = "Tower Arcade"})
	f_resetArcadeStuff()
	f_default()
	setGameMode('tower')
	data.gameMode = "tower"
	data.rosterMode = "tower"
	--data.arcadeIntro = true --Enable characters arcade intro before tower select
	data.arcadeEnding = true
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	sndPlay(sndSys, 100, 1)
end

--HUMAN VS CPU (fight against CPU controlled opponents in customizable tower ladders from left side)
function towerHumanvsCPU()
	if P2overP1 then
		remapInput(1, 2)
		setPlayerSide('p2left')
	else
		setPlayerSide('p1left')
	end
	data.p2TeamMenu = {mode = 0, chars = 1}
	data.p2In = 1
	data.p2SelectMenu = false
	textImgSetText(txt_mainSelect, "TOWER MODE")
	f_selectAdvance()
	P2overP1 = false
	f_discordMainMenu()
end

--CPU VS HUMAN (fight against CPU controlled opponents in customizable tower ladders from right side)
function towerCPUvsHuman()
	remapInput(1, 2)
	if not P2overP1 then
		remapInput(2, 1)
		setPlayerSide('p1right')
	else
		setPlayerSide('p2right')
	end
	data.p1TeamMenu = {mode = 0, chars = 1}
	data.p1In = 2
	data.p2In = 2
	data.p1SelectMenu = false
	textImgSetText(txt_mainSelect, "TOWER MODE")
	f_selectAdvance()
	P2overP1 = false
	f_discordMainMenu()
end

--P1&P2 VS CPU [CO-OP MODE] (team up with another player from left side against CPU controlled opponents in customizable tower ladders)
function towerP1P2vsCPU()
	data.p2In = 2
	data.p2Faces = true
	data.coop = true
	setPlayerSide('p1left')
	setGameMode('towercoop')
	textImgSetText(txt_mainSelect, "TOWER COOPERATIVE")
	f_selectAdvance()
	f_discordMainMenu()
end

--CPU VS P1&P2 [CO-OP MODE] (team up with another player from right side against CPU controlled opponents in customizable tower ladders)
function towerCPUvsP1P2()
	f_comingSoon()
	--[[
	setPlayerSide('p1right')
	data.p1In = 2
	data.p2In = 2
	data.p2Faces = true
	data.coop = true
	setGameMode('towercoop')
	textImgSetText(txt_mainSelect, "TOWER COOPERATIVE")
	f_selectAdvance()
	]]
end

--CPU MODE (watch CPU fight in customizable tower ladders)
function towerCPUvsCPU()
	data.p2TeamMenu = {mode = 0, chars = 1}
	data.p2In = 1
	data.p2SelectMenu = false
	data.aiFight = true
	setPlayerSide('p1left')
	setGameMode('towercpu')
	data.rosterMode = "cpu"
	textImgSetText(txt_mainSelect, "WATCH TOWER")
	f_selectAdvance()
	f_discordMainMenu()
end

--;===========================================================
--; QUICK/RANDOM MATCH MODE (play a random fight)
--;===========================================================
function f_quickvsBoot()
	menuSelect = "quick match"
	sideScreen = true
end

--Load Common Settings for Quick Match Modes
function randomModeCfg()
	f_discordUpdate({details = "Quick Match"})
	f_default()
	setGameMode('random')
	data.gameMode = "quick match"
	data.rosterMode = "versus"
	data.p1TeamMenu = {mode = 0, chars = 1}
	data.p2TeamMenu = {mode = 0, chars = 1}
	data.p1Char = {t_selChars[t_randomChars[math.random(#t_randomChars)]+1].char} --Pick Random Char
	data.p2Char = {t_selChars[t_randomChars[math.random(#t_randomChars)]+1].char} --Pick Random Char
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	sndPlay(sndSys, 100, 1)
end

--HUMAN VS CPU (defeat from left side a random CPU controlled opponent)
function randomHumanvsCPU()
	if P2overP1 then
		remapInput(1, 2)
	end
	data.p2In = 1
	f_selectSimple()
	P2overP1 = false
	f_discordMainMenu()
end

--CPU VS HUMAN (defeat from right side a random CPU controlled opponent of your choice)
function randomCPUvsHuman()
	remapInput(1, 2)
	if not P2overP1 then
		remapInput(2, 1)
	end
	setPlayerSide('p1right')
	data.p1In = 2
	data.p2In = 2
	f_selectSimple()
	P2overP1 = false
	f_discordMainMenu()
end

--HUMAN VS HUMAN (fight from left side to defeat a random human opponent)
function randomHumanvsHuman()
	if P2overP1 then
		setHomeTeam(2)
		remapInput(1, 2)
		remapInput(2, 1)
		setPlayerSide('p1right')
	else
		setHomeTeam(1)
	end
	data.p2In = 2
	f_selectSimple()
	P2overP1 = false
	f_discordMainMenu()
end

--CPU MATCH (watch random CPU controlled match)
function randomCPUvsCPU()
	data.aiFight = true
	data.rosterMode = "cpu"
	f_selectSimple()
	f_discordMainMenu()
end

--P1&P2 VS CPU (team up with another player from left side to defeat random CPU controlled opponents)
function randomP1P2vsCPU()
	--f_selectSimple()
	f_comingSoon()
end

--CPU VS P1&P2 (team up with another player from right side to defeat random CPU controlled opponents)
function randomCPUvsP1P2()
	--f_selectSimple()
	f_comingSoon()
end

--;===========================================================
--; FREE BATTLE MODE (play fights with your own rules)
--;===========================================================
function f_vsBoot()
	menuSelect = "free battle"
	sideScreen = true
end

--Load Common Settings for Free Battle Modes
function freeModeCfg()
	f_discordUpdate({details = "Free Versus"})
	f_default()
	setGameMode('vs')
	data.gameMode = "versus"
	data.rosterMode = "versus"
	data.stageMenu = true --stage selection enabled
	data.p2Faces = true --additional window with P2 select screen small portraits (faces) enabled
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	sndPlay(sndSys, 100, 1)
end

--HUMAN VS CPU (choose a fighter to defeat from left side a CPU controlled opponent of your choice)
function freeHumanvsCPU()
	if P2overP1 then
		remapInput(1, 2)
	end
	data.p2In = 1
	textImgSetText(txt_mainSelect, "FREE VERSUS")
	f_selectSimple()
	P2overP1 = false
	f_discordMainMenu()
end

--CPU VS HUMAN (choose a fighter to defeat from right side a CPU controlled opponent of your choice)
function freeCPUvsHuman()
	remapInput(1, 2)
	if not P2overP1 then
		remapInput(2, 1)
	end
	setPlayerSide('p1right')
	data.p1In = 2
	data.p2In = 2
	textImgSetText(txt_mainSelect, "FREE VERSUS")
	f_selectSimple()
	P2overP1 = false
	f_discordMainMenu()
end

--HUMAN VS HUMAN (choose a fighter from left side to defeat a human opponent)
function freeHumanvsHuman()
	if P2overP1 then
		setHomeTeam(2) --P2 side considered the home team
		remapInput(1, 2)
		remapInput(2, 1)
		setPlayerSide('p1right')
	else
		setHomeTeam(1) --P1 side considered the home team
	end
	data.p2In = 2 --P2 controls P2 side of the select screen
	textImgSetText(txt_mainSelect, "VERSUS MODE")
	f_selectSimple()
	P2overP1 = false
	f_discordMainMenu()
end

--CPU MATCH (watch CPU controlled match of your choice)
function freeCPUvsCPU()
	data.p2In = 1
	data.aiFight = true
	data.rosterMode = "cpu"
	textImgSetText(txt_mainSelect, "WATCH VERSUS")
	f_selectSimple()
	f_discordMainMenu()
end

--P1&P2 VS CPU (team up with another player from left side to defeat CPU controlled opponents of your choice)
function freeP1P2vsCPU()
	f_comingSoon()
	--[[
	setHomeTeam(1)
	data.p2In = 2
	data.stageMenu = false
	data.stage = "stages/training room.def"
	data.coop = true
	textImgSetText(txt_mainSelect, "FREE VERSUS COOPERATIVE")
	f_selectSimple()
	]]
end

--CPU VS P1&P2 (team up with another player from right side to defeat CPU controlled opponents of your choice)
function freeCPUvsP1P2()
	f_comingSoon()
end

--[[P1&P3 VS P2&P4 (team up with another player to defeat co-op team of human opponents)
function freeP1P3vsP2P4()
	setHomeTeam(1)
	data.p2In = 2
	data.coop = true
	textImgSetText(txt_mainSelect, "FREE VERSUS TEAM COOPERATIVE")
	f_selectSimple()
end
]]

--;===========================================================
--; SURVIVAL MENU (survive in a series of matches with special conditions)
--;===========================================================
function f_survivalMenu()
	cmdInput()
	local cursorPosY = 0
	local moveTxt = 0
	local survivalMenu = 1
	local bufu = 0
	local bufd = 0
	local bufr = 0
	local bufl = 0
	f_infoReset()
	f_sideReset()
	while true do
		if not infoScreen and not sideScreen then
			if esc() or commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then
				sndPlay(sndSys, 100, 2)
				break
			elseif commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u') or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30) then
				sndPlay(sndSys, 100, 0)
				survivalMenu = survivalMenu - 1
			elseif commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd') or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30) then
				sndPlay(sndSys, 100, 0)
				survivalMenu = survivalMenu + 1
			end
			if survivalMenu < 1 then
				survivalMenu = #t_survivalMenu
				if #t_survivalMenu > 5 then
					cursorPosY = 5
				else
					cursorPosY = #t_survivalMenu-1
				end
			elseif survivalMenu > #t_survivalMenu then
				survivalMenu = 1
				cursorPosY = 0
			elseif ((commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u')) or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30)) and cursorPosY > 0 then
				cursorPosY = cursorPosY - 1
			elseif ((commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd')) or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30)) and cursorPosY < 5 then
				cursorPosY = cursorPosY + 1
			end
			if cursorPosY == 5 then
				moveTxt = (survivalMenu - 6) * 13
			elseif cursorPosY == 0 then
				moveTxt = (survivalMenu - 1) * 13
			end
			if #t_survivalMenu <= 5 then
				maxsurvivalMenu = #t_survivalMenu
			elseif survivalMenu - cursorPosY > 0 then
				maxsurvivalMenu = survivalMenu + 5 - cursorPosY
			else
				maxsurvivalMenu = 5
			end
			if btnPalNo(p1Cmd, true) > 0 or btnPalNo(p2Cmd, true) > 0 then
				sndPlay(sndSys, 100, 1)
				f_gotoFunction(t_survivalMenu[survivalMenu])
			end
		end
		drawBottomMenuSP()
		for i=1, #t_survivalMenu do
			if i == survivalMenu then
				bank = 1
			else
				bank = 0
			end
			textImgDraw(f_updateTextImg(t_survivalMenu[i].id, jgFnt, bank, 0, t_survivalMenu[i].text, 159, 122+i*13-moveTxt))
		end
		if not infoScreen and not sideScreen then
			animSetWindow(cursorBox, 0,125+cursorPosY*13, 316,13)
			f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
			animDraw(f_animVelocity(cursorBox, -1, -1))
		end
		drawMiddleMenuSP()
		textImgDraw(txt_gameFt)
		textImgSetText(txt_gameFt, "SURVIVAL MODES")
		textImgDraw(txt_version)
		f_sysTime()
		if maxsurvivalMenu > 6 then
			animDraw(menuArrowUp)
			animUpdate(menuArrowUp)
		end
		if #t_survivalMenu > 6 and maxsurvivalMenu < #t_survivalMenu then
			animDraw(menuArrowDown)
			animUpdate(menuArrowDown)
		end
		if not infoScreen and not sideScreen then drawMainMenuInputHints() end
		if sideScreen then f_sideSelect() end
		if infoScreen then f_infoMenu() end
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		if commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu') then
			bufd = 0
			bufu = bufu + 1
		elseif commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd') then
			bufu = 0
			bufd = bufd + 1
		else
			bufu = 0
			bufd = 0
		end
		cmdInput()
		refresh()
	end
end

--;===========================================================
--; SURVIVAL MODE (defeat opponents with a single health meter)
--;===========================================================
function f_survivalBoot()
	menuSelect = "survival"
	sideScreen = true
end

--Load Common Settings for Survival Modes
function survivalCfg()
	f_discordUpdate({details = "Survival"})
	f_default()
	data.gameMode = "survival"
	data.rosterMode = "survival"
	data.stageMenu = true
	setRoundsToWin(1)
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	sndPlay(sndSys, 100, 1)
end

--HUMAN VS CPU (defeat as many opponents as you can with a single Health Meter from left side)
function survivalHumanvsCPU()
	if P2overP1 then
		remapInput(1, 2)
	end
	data.p2In = 1
	data.p2SelectMenu = false
	textImgSetText(txt_mainSelect, "SURVIVAL")
	f_selectAdvance()
	P2overP1 = false
	f_discordMainMenu()
end

--CPU VS HUMAN (defeat as many opponents as you can with a single Health Meter from right side)
function survivalCPUvsHuman()
	remapInput(1, 2)
	if not P2overP1 then
		remapInput(2, 1)
	end
	setPlayerSide('p1right')
	data.p1In = 2
	data.p2In = 2
	data.p1SelectMenu = false
	textImgSetText(txt_mainSelect, "SURVIVAL")
	f_selectAdvance()
	P2overP1 = false
	f_discordMainMenu()
end

--P1&P2 VS CPU [CO-OP MODE] (team up with another player from left side to defeat as many opponents as you can with a single Health Meter)
function survivalP1P2vsCPU()
	data.p2In = 2
	data.p2Faces = true
	data.coop = true
	textImgSetText(txt_mainSelect, "SURVIVAL COOPERATIVE")
	f_selectAdvance()
	f_discordMainMenu()
end

--CPU VS P1&P2 [CO-OP MODE] (team up with another player from right side to defeat as many opponents as you can with a single Health Meter)
function survivalCPUvsP1P2()
	f_comingSoon()
	--[[
	setPlayerSide('p1right')
	data.p1In = 2
	data.p2In = 2
	data.p2Faces = true
	data.coop = true
	textImgSetText(txt_mainSelect, "SURVIVAL COOPERATIVE")
	f_selectAdvance()
	]]
end

--CPU MODE (watch CPU defeat as many opponents as it can with a single Health Meter)
function survivalCPUvsCPU()
	data.p2In = 1
	data.p2SelectMenu = false
	data.aiFight = true
	data.rosterMode = "cpu"
	textImgSetText(txt_mainSelect, "WATCH SURVIVAL")
	f_selectAdvance()
	f_discordMainMenu()
end

--;===========================================================
--; BOSS RUSH MODE (defeat all bosses in a row)
--;===========================================================
function f_bossrushBoot()
	if #t_bossChars == 0 then
		bossInfo = true
		infoScreen = true
		return
	else
		menuSelect = "boss rush"
		sideScreen = true
	end
end

--Load Common Settings for Boss Rush Modes
function bossrushCfg()
	f_discordUpdate({details = "Boss Rush"})
	f_default()
	data.gameMode = "bossrush"
	data.rosterMode = "boss"
	--data.stageMenu = true
	setRoundsToWin(1)
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	sndPlay(sndSys, 100, 1)
end

--HUMAN VS CPU (defeat all bosses in a row from left side)
function bossrushHumanvsCPU()
	if P2overP1 then
		remapInput(1, 2)
	end
	data.p2In = 1
	data.p2SelectMenu = false
	textImgSetText(txt_mainSelect, "BOSS RUSH")					
	f_selectAdvance()
	P2overP1 = false
	f_discordMainMenu()
end

--CPU VS HUMAN (defeat all bosses in a row from right side)
function bossrushCPUvsHuman()
	remapInput(1, 2)
	if not P2overP1 then
		remapInput(2, 1)
	end
	setPlayerSide('p1right')
	data.p1In = 2
	data.p2In = 2
	data.p1SelectMenu = false
	textImgSetText(txt_mainSelect, "BOSS RUSH")					
	f_selectAdvance()
	P2overP1 = false
	f_discordMainMenu()
end

--P1&P2 VS CPU [CO-OP MODE] (team up with another player from left side to defeat all bosses in a row)
function bossrushP1P2vsCPU()
	data.p2In = 2
	data.p2Faces = true
	data.coop = true
	textImgSetText(txt_mainSelect, "BOSS RUSH COOPERATIVE")					
	f_selectAdvance()
	f_discordMainMenu()
end

--CPU VS P1&P2 [CO-OP MODE] (team up with another player from right side to defeat all bosses in a row)
function bossrushCPUvsP1P2()
	f_comingSoon()
	--[[
	setPlayerSide('p1right')
	data.p1In = 2
	data.p2In = 2
	data.p2Faces = true
	data.coop = true
	textImgSetText(txt_mainSelect, "BOSS RUSH COOPERATIVE")					
	f_selectAdvance()
	]]
end

--CPU MODE (watch CPU defeat all bosses in a row)
function bossrushCPUvsCPU()
	data.p2In = 1
	data.p2SelectMenu = false
	data.aiFight = true
	data.rosterMode = "cpu"
	textImgSetText(txt_mainSelect, "WATCH BOSS RUSH")
	f_selectAdvance()
	f_discordMainMenu()
end

--;===========================================================
--; SINGLE BOSS MENU (face a specific Boss Character)
--;===========================================================
function f_bossChars()
	if #t_bossChars == 0 then
		bossInfo = true
		infoScreen = true
		return
	end
	cmdInput()
	f_rushTables() --From loader.lua
	bossChars = 1 --Need to be public to be readed by above functions
	local cursorPosY = 0
	local moveTxt = 0
	local bufu = 0
	local bufd = 0
	local bufr = 0
	local bufl = 0
	f_sideReset()
	while true do
		if not sideScreen then
			if esc() or commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then
				sndPlay(sndSys, 100, 2)
				break
			elseif commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u') or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30) then
				sndPlay(sndSys, 100, 0)
				bossChars = bossChars - 1
			elseif commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd') or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30) then
				sndPlay(sndSys, 100, 0)
				bossChars = bossChars + 1
			end
			if bossChars < 1 then
				bossChars = #t_bossSingle
				if #t_bossSingle > 5 then
					cursorPosY = 5
				else
					cursorPosY = #t_bossSingle-1
				end
			elseif bossChars > #t_bossSingle then
				bossChars = 1
				cursorPosY = 0
			elseif ((commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u')) or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30)) and cursorPosY > 0 then
				cursorPosY = cursorPosY - 1
			elseif ((commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd')) or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30)) and cursorPosY < 5 then
				cursorPosY = cursorPosY + 1
			end
			if cursorPosY == 5 then
				moveTxt = (bossChars - 6) * 13
			elseif cursorPosY == 0 then
				moveTxt = (bossChars - 1) * 13
			end
			if #t_bossSingle <= 5 then
				maxBossChars = #t_bossSingle
			elseif bossChars - cursorPosY > 0 then
				maxBossChars = bossChars + 5 - cursorPosY
			else
				maxBossChars = 5
			end
			if btnPalNo(p1Cmd, true) > 0 or btnPalNo(p2Cmd, true) > 0 then
				sndPlay(sndSys, 100, 1)
				menuSelect = "boss"
				sideScreen = true
			end
		end
		drawBottomMenuSP()
		for i=1, #t_bossSingle do
			if i == bossChars then
				bank = 1
			else
				bank = 0
			end
			--Draw Boss Name
			textImgDraw(f_updateTextImg(t_bossSingle[i].id, jgFnt, bank, 0, t_bossSingle[i].text, 159, 122+i*13-moveTxt))
		end
		if not sideScreen then
			animSetWindow(cursorBox, 0,125+cursorPosY*13, 316,13)
			f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
			animDraw(f_animVelocity(cursorBox, -1, -1))
		end
		drawMiddleMenuSP()
		textImgDraw(txt_gameFt)
		textImgSetText(txt_gameFt, "BOSS SELECT")
		textImgDraw(txt_version)
		f_sysTime()
		if maxBossChars > 6 then
			animDraw(menuArrowUp)
			animUpdate(menuArrowUp)
		end
		if #t_bossSingle > 6 and maxBossChars < #t_bossSingle then
			animDraw(menuArrowDown)
			animUpdate(menuArrowDown)
		end
		if sideScreen then f_sideSelect() else drawMainMenuInputHints() end
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		if commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu') then
			bufd = 0
			bufu = bufu + 1
		elseif commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd') then
			bufu = 0
			bufd = bufd + 1
		else
			bufu = 0
			bufd = 0
		end
		cmdInput()
		refresh()
	end
end

--Load Common Settings for Single Boss Fight Modes
function bossCfg()
	local bossDat = t_selChars[t_bossChars[bossChars]+1].displayname
	f_discordUpdate({details = "Boss Assault: "..bossDat})
	f_default()
	data.gameMode = "singleboss"
	data.rosterMode = "boss"
	--data.stageMenu = true
	textImgSetText(txt_mainSelect, bossDat)
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	sndPlay(sndSys, 100, 1)
end

--HUMAN VS CPU (defeat selected boss character from left side)
function bossHumanvsCPU()
	if P2overP1 then
		remapInput(1, 2)
	end
	data.p2In = 1
	data.p2TeamMenu = {mode = 0, chars = 1}
	data.p2Char = {t_selChars[t_bossChars[bossChars]+1].char}
	f_selectSimple()
	P2overP1 = false
	f_discordMainMenu()
end

--CPU VS HUMAN (defeat selected boss character from right side)
function bossCPUvsHuman()
	remapInput(1, 2)
	if not P2overP1 then
		remapInput(2, 1)
	end
	setPlayerSide('p1right')
	data.p1In = 2
	data.p2In = 2
	data.p1SelectMenu = false
	data.p1TeamMenu = {mode = 0, chars = 1}
	data.p1Char = {t_selChars[t_bossChars[bossChars]+1].char}
	f_selectSimple()
	P2overP1 = false
	f_discordMainMenu()
end

--CPU MODE (watch CPU defeat selected boss character)
function bossCPUvsCPU()
	--data.p2SelectMenu = false
	data.aiFight = true
	data.rosterMode = "cpu"
	data.p2TeamMenu = {mode = 0, chars = 1}
	data.p2Char = {t_selChars[t_bossChars[bossChars]+1].char}
	f_selectSimple()
	f_discordMainMenu()
end

--;===========================================================
--; BONUS GAMES MENU (play bonus games)
--;===========================================================
function f_bonusMenu()
	if #t_bonusChars == 0 then
		bonusInfo = true
		infoScreen = true
		return
	end
	cmdInput()
	local cursorPosY = 0
	local moveTxt = 0
	local bonusMenu = 1
	local bufu = 0
	local bufd = 0
	local bufr = 0
	local bufl = 0
	f_sideReset()
	while true do
		if not sideScreen then
			if esc() or commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then
				sndPlay(sndSys, 100, 2)
				break
			elseif commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u') or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30) then
				sndPlay(sndSys, 100, 0)
				bonusMenu = bonusMenu - 1
			elseif commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd') or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30) then
				sndPlay(sndSys, 100, 0)
				bonusMenu = bonusMenu + 1
			end
			if bonusMenu < 1 then
				bonusMenu = #t_bonusMenu
				if #t_bonusMenu > 5 then
					cursorPosY = 5
				else
					cursorPosY = #t_bonusMenu-1
				end
			elseif bonusMenu > #t_bonusMenu then
				bonusMenu = 1
				cursorPosY = 0
			elseif ((commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u')) or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30)) and cursorPosY > 0 then
				cursorPosY = cursorPosY - 1
			elseif ((commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd')) or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30)) and cursorPosY < 5 then
				cursorPosY = cursorPosY + 1
			end
			if cursorPosY == 5 then
				moveTxt = (bonusMenu - 6) * 13
			elseif cursorPosY == 0 then
				moveTxt = (bonusMenu - 1) * 13
			end
			if #t_bonusMenu <= 5 then
				maxBonusMenu = #t_bonusMenu
			elseif bonusMenu - cursorPosY > 0 then
				maxBonusMenu = bonusMenu + 5 - cursorPosY
			else
				maxBonusMenu = 5
			end
			if btnPalNo(p1Cmd, true) > 0 or btnPalNo(p2Cmd, true) > 0 then
				sndPlay(sndSys, 100, 1)
				f_gotoFunction(t_bonusMenu[bonusMenu])
			end
		end
		drawBottomMenuSP()
		for i=1, #t_bonusMenu do
			if i == bonusMenu then
				bank = 5
			else
				bank = 0
			end
			textImgDraw(f_updateTextImg(t_bonusMenu[i].id, jgFnt, bank, 0, t_bonusMenu[i].text, 159, 122+i*13-moveTxt))
		end
		if not sideScreen then
			animSetWindow(cursorBox, 0,125+cursorPosY*13, 316,13)
			f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
			animDraw(f_animVelocity(cursorBox, -1, -1))
		end
		drawMiddleMenuSP()
		textImgDraw(txt_gameFt)
		textImgSetText(txt_gameFt, "MINI-GAMES")
		textImgDraw(txt_version)
		f_sysTime()
		if maxBonusMenu > 6 then
			animDraw(menuArrowUp)
			animUpdate(menuArrowUp)
		end
		if #t_bonusMenu > 6 and maxBonusMenu < #t_bonusMenu then
			animDraw(menuArrowDown)
			animUpdate(menuArrowDown)
		end
		if sideScreen then f_sideSelect() else drawMainMenuInputHints() end
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		if commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu') then
			bufd = 0
			bufu = bufu + 1
		elseif commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd') then
			bufu = 0
			bufd = bufd + 1
		else
			bufu = 0
			bufd = 0
		end
		cmdInput()
		refresh()
	end
end

--;===========================================================
--; BONUS GAME SELECT (clear the bonus game selected)
--;===========================================================
function f_bonusExtras()
	cmdInput()
	f_rushTables()
	bonusExtras = 1 --Need to be public to be readed by above functions
	local cursorPosY = 0
	local moveTxt = 0
	local bufu = 0
	local bufd = 0
	local bufr = 0
	local bufl = 0
	f_sideReset()
	while true do
		if not sideScreen then
			if esc() or commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then
				sndPlay(sndSys, 100, 2)
				break
			elseif commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u') or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30) then
				sndPlay(sndSys, 100, 0)
				bonusExtras = bonusExtras - 1
			elseif commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd') or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30) then
				sndPlay(sndSys, 100, 0)
				bonusExtras = bonusExtras + 1
			end
			if bonusExtras < 1 then
				bonusExtras = #t_bonusExtras
				if #t_bonusExtras > 5 then
					cursorPosY = 5
				else
					cursorPosY = #t_bonusExtras-1
				end
			elseif bonusExtras > #t_bonusExtras then
				bonusExtras = 1
				cursorPosY = 0
			elseif ((commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u')) or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30)) and cursorPosY > 0 then
				cursorPosY = cursorPosY - 1
			elseif ((commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd')) or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30)) and cursorPosY < 5 then
				cursorPosY = cursorPosY + 1
			end
			if cursorPosY == 5 then
				moveTxt = (bonusExtras - 6) * 13
			elseif cursorPosY == 0 then
				moveTxt = (bonusExtras - 1) * 13
			end
			if #t_bonusExtras <= 5 then
				maxBonusExtras = #t_bonusExtras
			elseif bonusExtras - cursorPosY > 0 then
				maxBonusExtras = bonusExtras + 5 - cursorPosY
			else
				maxBonusExtras = 5
			end
			if btnPalNo(p1Cmd, true) > 0 or btnPalNo(p2Cmd, true) > 0 then
				sndPlay(sndSys, 100, 1)
				menuSelect = "bonus"
				sideScreen = true
			end
		end
		drawBottomMenuSP()
		for i=1, #t_bonusExtras do
			if i == bonusExtras then
				bank = 5
			else
				bank = 0
			end
			--Draw Bonus Name
			textImgDraw(f_updateTextImg(t_bonusExtras[i].id, jgFnt, bank, 0, t_bonusExtras[i].text, 159, 122+i*13-moveTxt))
		end
		if not sideScreen then
			animSetWindow(cursorBox, 0,125+cursorPosY*13, 316,13)
			f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
			animDraw(f_animVelocity(cursorBox, -1, -1))
		end
		drawMiddleMenuSP()
		textImgDraw(txt_gameFt)
		textImgSetText(txt_gameFt, "BONUS SELECT")
		textImgDraw(txt_version)
		f_sysTime()
		if maxBonusExtras > 6 then
			animDraw(menuArrowUp)
			animUpdate(menuArrowUp)
		end
		if #t_bonusExtras > 6 and maxBonusExtras < #t_bonusExtras then
			animDraw(menuArrowDown)
			animUpdate(menuArrowDown)
		end
		if sideScreen then f_sideSelect() else drawMainMenuInputHints() end
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		if commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu') then
			bufd = 0
			bufu = bufu + 1
		elseif commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd') then
			bufu = 0
			bufd = bufd + 1
		else
			bufu = 0
			bufd = 0
		end
		cmdInput()
		refresh()
	end
end

--Load Common Settings for Bonus Games Modes
function bonusCfg()
	local bonusDat = t_selChars[t_bonusChars[bonusExtras]+1].displayname
	f_discordUpdate({details = "Bonus Game: "..bonusDat})
	f_default()
	data.gameMode = "singlebonus"
	data.rosterMode = "bonus"
	--data.stageMenu = true
	data.versusScreen = false
	setRoundsToWin(1)
	textImgSetText(txt_mainSelect, bonusDat)
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	sndPlay(sndSys, 100, 1)
end

--HUMAN VS CPU (clear the bonus game selected from left side)
function bonusHumanvsCPU()
	if P2overP1 then
		remapInput(1, 2)
	end
	data.p2In = 1
	data.p2TeamMenu = {mode = 0, chars = 1}
	data.p2Char = {t_selChars[t_bonusChars[bonusExtras]+1].char}
	f_selectSimple()
	P2overP1 = false
	f_discordMainMenu()
end

--CPU VS HUMAN (clear the bonus game selected from right side)
function bonusCPUvsHuman()
	remapInput(1, 2)
	if not P2overP1 then
		remapInput(2, 1)
	end
	setPlayerSide('p1right')
	data.p1In = 2
	data.p2In = 2
	data.p1SelectMenu = false
	data.p1TeamMenu = {mode = 0, chars = 1}
	data.p1Char = {t_selChars[t_bonusChars[bonusExtras]+1].char}
	f_selectSimple()
	P2overP1 = false
	f_discordMainMenu()
end

--;===========================================================
--; BONUS MARATHON MODE (clear all bonus games in a row)
--;===========================================================
function f_bonusrushBoot()
	menuSelect = "bonus rush"
	sideScreen = true
end

--Load Common Settings for Bonus Rush Modes
function bonusrushCfg()
	f_discordUpdate({details = "Bonus Game Marathon"})
	f_default()
	data.gameMode = "bonusrush"
	data.rosterMode = "bonus"
	setRoundsToWin(1)
	--data.stageMenu = true
	data.versusScreen = false
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)			
	sndPlay(sndSys, 100, 1)
end

--HUMAN VS CPU (clear all bonus games in a row from left side)
function bonusrushHumanvsCPU()
	if P2overP1 then
		remapInput(1, 2)
	end
	data.p2In = 1
	data.p2SelectMenu = false
	data.p2TeamMenu = {mode = 0, chars = 1}
	textImgSetText(txt_mainSelect, "BONUS MARATHON")
	f_selectAdvance()
	P2overP1 = false
	f_discordMainMenu()
end

--CPU VS HUMAN (clear all bonus games in a row from right side)
function bonusrushCPUvsHuman()
	remapInput(1, 2)
	if not P2overP1 then
		remapInput(2, 1)
	end
	setPlayerSide('p1right')
	data.p1In = 2
	data.p2In = 2
	data.p1SelectMenu = false
	data.p1TeamMenu = {mode = 0, chars = 1}
	textImgSetText(txt_mainSelect, "BONUS MARATHON")
	f_selectAdvance()
	P2overP1 = false
	f_discordMainMenu()
end

--P1&P2 VS CPU [CO-OP MODE] (team up with another player from left side to clear all bonus games in a row)
function bonusrushP1P2vsCPU()
	data.p2In = 2
	data.p2Faces = true
	data.coop = true
	textImgSetText(txt_mainSelect, "BONUS MARATHON COOPERATIVE")
	f_selectAdvance()
	f_discordMainMenu()
end

--CPU VS P1&P2 [CO-OP MODE] (team up with another player from right side to clear all bonus games in a row)
function bonusrushCPUvsP1P2()
	f_comingSoon()
	--[[
	setPlayerSide('p1right')
	data.p1In = 2
	data.p2In = 2
	data.p2Faces = true
	data.coop = true
	textImgSetText(txt_mainSelect, "BONUS MARATHON COOPERATIVE")
	f_selectAdvance()
	]]
end

--;===========================================================
--; SCORE ATTACK MENU (fight in a series of matches with score conditions)
--;===========================================================
function f_scoreattackMenu()
	cmdInput()
	local cursorPosY = 0
	local moveTxt = 0
	local scoreattackMenu = 1
	local bufu = 0
	local bufd = 0
	local bufr = 0
	local bufl = 0
	f_infoReset()
	f_sideReset()
	while true do
		if not infoScreen and not sideScreen then
			if esc() or commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then
				sndPlay(sndSys, 100, 2)
				break
			elseif commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u') or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30) then
				sndPlay(sndSys, 100, 0)
				scoreattackMenu = scoreattackMenu - 1
			elseif commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd') or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30) then
				sndPlay(sndSys, 100, 0)
				scoreattackMenu = scoreattackMenu + 1
			end
			if scoreattackMenu < 1 then
				scoreattackMenu = #t_scoreattackMenu
				if #t_scoreattackMenu > 5 then
					cursorPosY = 5
				else
					cursorPosY = #t_scoreattackMenu-1
				end
			elseif scoreattackMenu > #t_scoreattackMenu then
				scoreattackMenu = 1
				cursorPosY = 0
			elseif ((commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u')) or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30)) and cursorPosY > 0 then
				cursorPosY = cursorPosY - 1
			elseif ((commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd')) or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30)) and cursorPosY < 5 then
				cursorPosY = cursorPosY + 1
			end
			if cursorPosY == 5 then
				moveTxt = (scoreattackMenu - 6) * 13
			elseif cursorPosY == 0 then
				moveTxt = (scoreattackMenu - 1) * 13
			end
			if #t_scoreattackMenu <= 5 then
				maxscoreattackMenu = #t_scoreattackMenu
			elseif scoreattackMenu - cursorPosY > 0 then
				maxscoreattackMenu = scoreattackMenu + 5 - cursorPosY
			else
				maxscoreattackMenu = 5
			end
			if btnPalNo(p1Cmd, true) > 0 or btnPalNo(p2Cmd, true) > 0 then
				sndPlay(sndSys, 100, 1)
				f_gotoFunction(t_scoreattackMenu[scoreattackMenu])
			end
		end
		drawBottomMenuSP()
		for i=1, #t_scoreattackMenu do
			if i == scoreattackMenu then
				bank = 1
			else
				bank = 0
			end
			textImgDraw(f_updateTextImg(t_scoreattackMenu[i].id, jgFnt, bank, 0, t_scoreattackMenu[i].text, 159, 122+i*13-moveTxt))
		end
		if not infoScreen and not sideScreen then
			animSetWindow(cursorBox, 0,125+cursorPosY*13, 316,13)
			f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
			animDraw(f_animVelocity(cursorBox, -1, -1))
		end
		drawMiddleMenuSP()
		textImgDraw(txt_gameFt)
		textImgSetText(txt_gameFt, "SCORE ATTACK MODES")
		textImgDraw(txt_version)
		f_sysTime()
		if maxscoreattackMenu > 6 then
			animDraw(menuArrowUp)
			animUpdate(menuArrowUp)
		end
		if #t_scoreattackMenu > 6 and maxscoreattackMenu < #t_scoreattackMenu then
			animDraw(menuArrowDown)
			animUpdate(menuArrowDown)
		end
		if not infoScreen and not sideScreen then drawMainMenuInputHints() end
		if sideScreen then f_sideSelect() end
		if infoScreen then f_infoMenu() end
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		if commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu') then
			bufd = 0
			bufu = bufu + 1
		elseif commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd') then
			bufu = 0
			bufd = bufd + 1
		else
			bufu = 0
			bufd = 0
		end
		cmdInput()
		refresh()
	end
end

--;===========================================================
--; SCORE ATTACK MODE (defeat opponents getting high score as possible)
--;===========================================================
function f_scoreattackBoot()
	f_comingSoon()
--[[
	menuSelect = "score attack"
	sideScreen = true
]]
end

--Load Common Settings for Score Attack Modes
function scoreattackCfg()
	f_discordUpdate({details = "Score Attack"})
	f_default()
	data.gameMode = "allroster"
	data.rosterMode = "scoreattack"
	--data.stageMenu = true
	setRoundTime(-1)
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	sndPlay(sndSys, 100, 1)
end

--HUMAN VS CPU (defeat all character roster as quickly as possible, beating previous score records from left side)
function scoreattackHumanvsCPU()
	if P2overP1 then
		remapInput(1, 2)
	end
	data.p2In = 1
	data.p2SelectMenu = false
	textImgSetText(txt_mainSelect, "SCORE ATTACK")
	f_selectAdvance()
	P2overP1 = false
	f_discordMainMenu()
end

--CPU VS HUMAN (defeat all character roster as quickly as possible, beating previous score records from right side)
function scoreattackCPUvsHuman()
	remapInput(1, 2)
	if not P2overP1 then
		remapInput(2, 1)
	end
	setPlayerSide('p1right')
	data.p1In = 2
	data.p2In = 2
	data.p1SelectMenu = false
	textImgSetText(txt_mainSelect, "SCORE ATTACK")
	f_selectAdvance()
	P2overP1 = false
	f_discordMainMenu()
end

--P1&P2 VS CPU [CO-OP MODE] (team up with another player from left side to defeat all character roster as quickly as possible, beating previous score records)
function scoreattackP1P2vsCPU()
	data.p2In = 2
	data.p2Faces = true
	data.coop = true
	textImgSetText(txt_mainSelect, "SCORE ATTACK COOPERATIVE")
	f_selectAdvance()
	f_discordMainMenu()
end

--CPU VS P1&P2 [CO-OP MODE] (team up with another player from right side to defeat all character roster as quickly as possible, beating previous score records)
function scoreattackCPUvsP1P2()
	f_comingSoon()
	--[[
	setPlayerSide('p1right')
	data.p1In = 2
	data.p2In = 2
	data.p2Faces = true
	data.coop = true
	textImgSetText(txt_mainSelect, "SCORE ATTACK COOPERATIVE")
	f_selectAdvance()
	]]
end

--CPU MODE (watch CPU defeat all character roster as quickly as possible, beating previous score records)
function scoreattackCPUvsCPU()
	data.p2In = 1
	data.p2SelectMenu = false
	data.aiFight = true
	data.rosterMode = "cpu"
	textImgSetText(txt_mainSelect, "WATCH SCORE ATTACK")
	f_selectAdvance()
	f_discordMainMenu()
end

--;===========================================================
--; TIME ATTACK MENU (fight in a series of matches with time conditions)
--;===========================================================
function f_timeattackMenu()
	cmdInput()
	local cursorPosY = 0
	local moveTxt = 0
	local timeattackMenu = 1
	local bufu = 0
	local bufd = 0
	local bufr = 0
	local bufl = 0
	f_infoReset()
	f_sideReset()
	while true do
		if not infoScreen and not sideScreen then
			if esc() or commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then
				sndPlay(sndSys, 100, 2)
				break
			elseif commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u') or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30) then
				sndPlay(sndSys, 100, 0)
				timeattackMenu = timeattackMenu - 1
			elseif commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd') or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30) then
				sndPlay(sndSys, 100, 0)
				timeattackMenu = timeattackMenu + 1
			end
			if timeattackMenu < 1 then
				timeattackMenu = #t_timeattackMenu
				if #t_timeattackMenu > 5 then
					cursorPosY = 5
				else
					cursorPosY = #t_timeattackMenu-1
				end
			elseif timeattackMenu > #t_timeattackMenu then
				timeattackMenu = 1
				cursorPosY = 0
			elseif ((commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u')) or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30)) and cursorPosY > 0 then
				cursorPosY = cursorPosY - 1
			elseif ((commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd')) or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30)) and cursorPosY < 5 then
				cursorPosY = cursorPosY + 1
			end
			if cursorPosY == 5 then
				moveTxt = (timeattackMenu - 6) * 13
			elseif cursorPosY == 0 then
				moveTxt = (timeattackMenu - 1) * 13
			end
			if #t_timeattackMenu <= 5 then
				maxtimeattackMenu = #t_timeattackMenu
			elseif timeattackMenu - cursorPosY > 0 then
				maxtimeattackMenu = timeattackMenu + 5 - cursorPosY
			else
				maxtimeattackMenu = 5
			end
			if btnPalNo(p1Cmd, true) > 0 or btnPalNo(p2Cmd, true) > 0 then
				sndPlay(sndSys, 100, 1)
				f_gotoFunction(t_timeattackMenu[timeattackMenu])
			end
		end
		drawBottomMenuSP()
		for i=1, #t_timeattackMenu do
			if i == timeattackMenu then
				bank = 1
			else
				bank = 0
			end
			textImgDraw(f_updateTextImg(t_timeattackMenu[i].id, jgFnt, bank, 0, t_timeattackMenu[i].text, 159, 122+i*13-moveTxt))
		end
		if not infoScreen and not sideScreen then
			animSetWindow(cursorBox, 0,125+cursorPosY*13, 316,13)
			f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
			animDraw(f_animVelocity(cursorBox, -1, -1))
		end
		drawMiddleMenuSP()
		textImgDraw(txt_gameFt)
		textImgSetText(txt_gameFt, "TIME ATTACK MODES")
		textImgDraw(txt_version)
		f_sysTime()
		if maxtimeattackMenu > 6 then
			animDraw(menuArrowUp)
			animUpdate(menuArrowUp)
		end
		if #t_timeattackMenu > 6 and maxtimeattackMenu < #t_timeattackMenu then
			animDraw(menuArrowDown)
			animUpdate(menuArrowDown)
		end
		if not infoScreen and not sideScreen then drawMainMenuInputHints() end
		if sideScreen then f_sideSelect() end
		if infoScreen then f_infoMenu() end
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		if commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu') then
			bufd = 0
			bufu = bufu + 1
		elseif commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd') then
			bufu = 0
			bufd = bufd + 1
		else
			bufu = 0
			bufd = 0
		end
		cmdInput()
		refresh()
	end
end

--;===========================================================
--; TIME ATTACK MODE (defeat opponents as quickly as possible)
--;===========================================================
function f_timeattackBoot()
	f_comingSoon()
--[[
	menuSelect = "time attack"
	sideScreen = true
]]
end

--Load Common Settings for Time Attack Modes
function timeattackCfg()
	f_discordUpdate({details = "Time Attack"})
	f_default()
	data.gameMode = "allroster"
	data.rosterMode = "timeattack"
	--data.stageMenu = true
	setRoundTime(-1)
	setRoundsToWin(1)
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	sndPlay(sndSys, 100, 1)
end

--HUMAN VS CPU (defeat all character roster as quickly as possible, beating previous time records from left side)
function timeattackHumanvsCPU()
	if P2overP1 then
		remapInput(1, 2)
	end
	data.p2In = 1
	data.p2SelectMenu = false
	textImgSetText(txt_mainSelect, "TIME ATTACK")
	f_selectAdvance()
	P2overP1 = false
	f_discordMainMenu()
end

--CPU VS HUMAN (defeat all character roster as quickly as possible, beating previous time records from right side)
function timeattackCPUvsHuman()
	remapInput(1, 2)
	if not P2overP1 then
		remapInput(2, 1)
	end
	setPlayerSide('p1right')
	data.p1In = 2
	data.p2In = 2
	data.p1SelectMenu = false
	textImgSetText(txt_mainSelect, "TIME ATTACK")
	f_selectAdvance()
	P2overP1 = false
	f_discordMainMenu()
end

--P1&P2 VS CPU [CO-OP MODE] (team up with another player from left side to defeat all character roster as quickly as possible, beating previous time records)
function timeattackP1P2vsCPU()
	data.p2In = 2
	data.p2Faces = true
	data.coop = true
	textImgSetText(txt_mainSelect, "TIME ATTACK COOPERATIVE")
	f_selectAdvance()
	f_discordMainMenu()
end

--CPU VS P1&P2 [CO-OP MODE] (team up with another player from right side to defeat all character roster as quickly as possible, beating previous time records)
function timeattackCPUvsP1P2()
	f_comingSoon()
	--[[
	setPlayerSide('p1right')
	data.p1In = 2
	data.p2In = 2
	data.p2Faces = true
	data.coop = true
	textImgSetText(txt_mainSelect, "TIME ATTACK COOPERATIVE")
	f_selectAdvance()
	]]
end

--CPU MODE (watch CPU defeat all character roster as quickly as possible, beating previous time records)
function timeattackCPUvsCPU()
	data.p2In = 1
	data.p2SelectMenu = false
	data.aiFight = true
	data.rosterMode = "cpu"
	textImgSetText(txt_mainSelect, "WATCH TIME ATTACK")
	f_selectAdvance()
	f_discordMainMenu()
end

--;===========================================================
--; TIME RUSH MODE (rush to defeat opponents before time runs out)
--;===========================================================
function f_timerushBoot()
	menuSelect = "time rush"
	sideScreen = true	
end

--Load Common Settings for Time Rush Modes
function timerushCfg()
	f_discordUpdate({details = "???"})
	f_default()
	data.gameMode = "allroster"
	data.rosterMode = "timerush"
	--data.stageMenu = true
	setRoundTime(3600)
	setRoundsToWin(1)
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	sndPlay(sndSys, 100, 1)
end

--HUMAN VS CPU (rush to defeat opponents before time runs out, beating previous time records from left side)
function timerushHumanvsCPU()
	if P2overP1 then
		remapInput(1, 2)
	end
	data.p2In = 1
	data.p2SelectMenu = false
	textImgSetText(txt_mainSelect, "TIME RUSH")
	f_selectAdvance()
	P2overP1 = false
	f_discordMainMenu()
end

--CPU VS HUMAN (rush to defeat opponents before time runs out, beating previous time records from right side)
function timerushCPUvsHuman()
	remapInput(1, 2)
	if not P2overP1 then
		remapInput(2, 1)
	end
	setPlayerSide('p1right')
	data.p1In = 2
	data.p2In = 2
	data.p1SelectMenu = false
	textImgSetText(txt_mainSelect, "TIME RUSH")
	f_selectAdvance()
	P2overP1 = false
	f_discordMainMenu()
end

--P1&P2 VS CPU [CO-OP MODE] (team up with another player from left side to rush to defeat opponents before time runs out, beating previous time records)
function timerushP1P2vsCPU()
	data.p2In = 2
	data.p2Faces = true
	data.coop = true
	textImgSetText(txt_mainSelect, "TIME RUSH COOPERATIVE")
	f_selectAdvance()
	f_discordMainMenu()
end

--CPU VS P1&P2 [CO-OP MODE] (team up with another player from right side to rush to defeat opponents before time runs out, beating previous time records)
function timerushCPUvsP1P2()
	f_comingSoon()
	--[[
	setPlayerSide('p1right')
	data.p1In = 2
	data.p2In = 2
	data.p2Faces = true
	data.coop = true
	textImgSetText(txt_mainSelect, "TIME RUSH COOPERATIVE")
	f_selectAdvance()
	]]
end

--CPU MODE (watch CPU rush to defeat opponents before time runs out, beating previous time records)
function timerushCPUvsCPU()
	data.p2In = 1
	data.p2SelectMenu = false
	data.aiFight = true
	data.rosterMode = "cpu"
	textImgSetText(txt_mainSelect, "WATCH TIME RUSH")
	f_selectAdvance()
	f_discordMainMenu()
end

--;===========================================================
--; VS X KUMITE MODE (defeat as many opponents as you can in predefined "data.kumite" successive matches)
--;===========================================================
function f_kumiteBoot()
	menuSelect = "kumite"
	sideScreen = true	
end

function getKumiteData()
	kumiteDataText = "VS "..data.kumite.." KUMITE"
	return kumiteDataText
end

--Load Common Settings for VS X Kumite Modes
function kumiteCfg()
	f_discordUpdate({details = "VS "..data.kumite.." Kumite"})
	f_default()
	data.gameMode = "vskumite"
	data.rosterMode = "vskumite"
	--data.stageMenu = true
	setRoundsToWin(1)
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	sndPlay(sndSys, 100, 1)
end

--P1 VS HUMAN (see how many characters out of all roster you can take down in 1 Hit from left side)
function kumiteHumanvsCPU()
	if P2overP1 then
		remapInput(1, 2)
	end
	data.p2In = 1
	data.p2SelectMenu = false
	textImgSetText(txt_mainSelect, getKumiteData())
	f_selectAdvance()
	P2overP1 = false
	f_discordMainMenu()
end

--CPU VS HUMAN (see how many characters out of all roster you can take down in 1 Hit from right side)
function kumiteCPUvsHuman()
	remapInput(1, 2)
	if not P2overP1 then
		remapInput(2, 1)
	end
	setPlayerSide('p1right')
	data.p1In = 2
	data.p2In = 2
	data.p1SelectMenu = false
	textImgSetText(txt_mainSelect, getKumiteData())
	f_selectAdvance()
	P2overP1 = false
	f_discordMainMenu()
end

--P1&P2 VS CPU [CO-OP MODE] (team up with another player from left side to see how many characters out of all roster you can take down in 1 Hit)
function kumiteP1P2vsCPU()
	data.p2In = 2
	data.p2Faces = true
	data.coop = true
	textImgSetText(txt_mainSelect, getKumiteData().." COOPERATIVE")
	f_selectAdvance()
	f_discordMainMenu()
end

--CPU VS P1&P2 [CO-OP MODE] (team up with another player from right side to see how many characters out of all roster you can take down in 1 Hit)
function kumiteCPUvsP1P2()
	f_comingSoon()
	--[[
	setPlayerSide('p1right')
	data.p1In = 2
	data.p2In = 2
	data.p2Faces = true
	data.coop = true
	textImgSetText(txt_mainSelect, getKumiteData().." COOPERATIVE")
	f_selectAdvance()
	]]
end

--CPU MODE (see how many characters out of all roster the CPU can take down in 1 Hit)
function kumiteCPUvsCPU()
	data.p2In = 1
	data.p2SelectMenu = false
	data.aiFight = true
	data.rosterMode = "cpu"
	textImgSetText(txt_mainSelect, "WATCH "..getKumiteData())
	f_selectAdvance()
	f_discordMainMenu()
end

--;===========================================================
--; SUDDEN DEATH MODE (defeat opponents in 1 hit)
--;===========================================================
function f_suddendeathBoot()
	menuSelect = "sudden death"
	sideScreen = true
end

--Load Common Settings for Sudden Death Modes
function suddenCfg()
	f_discordUpdate({details = "Sudden Death"})
	f_default()
	data.gameMode = "allroster"
	data.rosterMode = "suddendeath"
	--data.stageMenu = true
	setRoundTime(1000)
	setRoundsToWin(1)
	setLifeMul(0) --overwrite players life
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	sndPlay(sndSys, 100, 1)
end

--P1 VS HUMAN (see how many characters out of all roster you can take down in 1 Hit from left side)
function suddenHumanvsCPU()
	if P2overP1 then
		remapInput(1, 2)
	end
	data.p2In = 1
	data.p2SelectMenu = false
	textImgSetText(txt_mainSelect, "SUDDEN DEATH")
	f_selectAdvance()
	P2overP1 = false
	f_discordMainMenu()
end

--CPU VS HUMAN (see how many characters out of all roster you can take down in 1 Hit from right side)
function suddenCPUvsHuman()
	remapInput(1, 2)
	if not P2overP1 then
		remapInput(2, 1)
	end
	setPlayerSide('p1right')
	data.p1In = 2
	data.p2In = 2
	data.p1SelectMenu = false
	textImgSetText(txt_mainSelect, "SUDDEN DEATH")
	f_selectAdvance()
	P2overP1 = false
	f_discordMainMenu()
end

--P1&P2 VS CPU [CO-OP MODE] (team up with another player from left side to see how many characters out of all roster you can take down in 1 Hit)
function suddenP1P2vsCPU()
	data.p2In = 2
	data.p2Faces = true
	data.coop = true
	textImgSetText(txt_mainSelect, "SUDDEN DEATH COOPERATIVE")
	f_selectAdvance()
	f_discordMainMenu()
end

--CPU VS P1&P2 [CO-OP MODE] (team up with another player from right side to see how many characters out of all roster you can take down in 1 Hit)
function suddenCPUvsP1P2()
	f_comingSoon()
	--[[
	setPlayerSide('p1right')
	data.p1In = 2
	data.p2In = 2
	data.p2Faces = true
	data.coop = true
	textImgSetText(txt_mainSelect, "SUDDEN DEATH COOPERATIVE")
	f_selectAdvance()
	]]
end

--CPU MODE (see how many characters out of all roster the CPU can take down in 1 Hit)
function suddenCPUvsCPU()
	data.p2In = 1
	data.p2SelectMenu = false
	data.aiFight = true
	data.rosterMode = "cpu"
	textImgSetText(txt_mainSelect, "WATCH SUDDEN DEATH")
	f_selectAdvance()
	f_discordMainMenu()
end

--;===========================================================
--; ENDLESS MODE (fight in endless matches)
--;===========================================================
function f_endlessBoot()
	menuSelect = "endless"
	sideScreen = true
end

--Load Common Settings for Endless Modes
function endlessCfg()
	f_discordUpdate({details = "Endless"})
	f_default()
	data.gameMode = "endless"
	data.rosterMode = "endless"
	data.stageMenu = true
	data.versusScreen = false
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	sndPlay(sndSys, 100, 1)
end

--P1 VS HUMAN (choose a fighter to defeat endless CPU controlled opponents from left side)
function endlessHumanvsCPU()
	if P2overP1 then
		remapInput(1, 2)
	end
	data.p2In = 1
	data.p2SelectMenu = false
	textImgSetText(txt_mainSelect, "ENDLESS MODE")
	f_selectAdvance()
	P2overP1 = false
	f_discordMainMenu()
end

--CPU VS HUMAN (choose a fighter to defeat endless CPU controlled opponents from right side)
function endlessCPUvsHuman()
	remapInput(1, 2)
	if not P2overP1 then
		remapInput(2, 1)
	end
	setPlayerSide('p1right')
	data.p1In = 2
	data.p2In = 2
	data.p1SelectMenu = false
	textImgSetText(txt_mainSelect, "ENDLESS MODE")
	f_selectAdvance()
	P2overP1 = false
	f_discordMainMenu()
end

--P1&P2 VS CPU [CO-OP MODE] (team up with another player from left side to defeat endless CPU controlled opponents)
function endlessP1P2vsCPU()
	data.p2In = 2
	data.p2Faces = true
	data.coop = true
	textImgSetText(txt_mainSelect, "ENDLESS COOPERATIVE")
	f_selectAdvance()
	f_discordMainMenu()
end

--CPU VS P1&P2 [CO-OP MODE] (team up with another player from right side to defeat endless CPU controlled opponents)
function endlessCPUvsP1P2()
	f_comingSoon()
	--[[
	setPlayerSide('p1right')
	data.p1In = 2
	data.p2In = 2
	data.p2Faces = true
	data.coop = true
	textImgSetText(txt_mainSelect, "ENDLESS COOPERATIVE")
	f_selectAdvance()
	]]
end

--CPU MODE (choose a fighter to watch endless CPU fights)
function endlessCPUvsCPU()
	data.p2In = 1
	data.p2SelectMenu = false
	data.aiFight = true
	data.rosterMode = "cpu"
	textImgSetText(txt_mainSelect, "WATCH ENDLESS")
	f_selectAdvance()
	f_discordMainMenu()
end

--;===========================================================
--; STAGE VIEWER MODE (watch a selected stage without fight)
--;===========================================================
function f_stageViewer()
	if stageviewer then
		f_discordUpdate({details = "Stage Viewer"})
		f_default()
		data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
		setRoundTime(-1)
		data.p2In = 2
		data.stageMenu = true
		data.versusScreen = false
		data.victoryscreen = false
		data.p1TeamMenu = {mode = 0, chars = 1}			
		data.p2TeamMenu = {mode = 0, chars = 1}
		data.p1Char = {"Stage Viewer"}
		data.p2Char = {"Stage Viewer"}
		data.gameMode = "stage viewer"
		setGameMode('stageviewer')
		textImgSetText(txt_mainSelect, "STAGE VIEWER")
		f_selectSimple()
		f_discordMainMenu()
	else
		stviewerInfo = true
		infoScreen = true
	end
end

--;===========================================================
--; PLAYER RECORDS MENU (display player records data)
--;===========================================================
function f_statsMenu()
	cmdInput()
	local cursorPosY = 1
	local moveTxt = 0
	local statsMenu = 1
	local bufu = 0
	local bufd = 0
	local bufr = 0
	local bufl = 0
	local maxItems = 12
	local back = false
	f_getStats() --Load Stats
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	animSetPos(menuArrowUp, 278, 11)
	animSetPos(menuArrowDown, 278, 201.5)
	while true do
		--f_playTime() --Test Played Time on live...
		if esc() or commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') or back then
			data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
			sndPlay(sndSys, 100, 2)
			f_resetMenuArrowsPos()
			break
		elseif commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u') or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30) then
			sndPlay(sndSys, 100, 0)
			statsMenu = statsMenu - 1
		elseif commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd') or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30) then
			sndPlay(sndSys, 100, 0)
			statsMenu = statsMenu + 1
	--BACK
		elseif (btnPalNo(p1Cmd, true) > 0 or btnPalNo(p2Cmd, true) > 0) and statsMenu == #t_statsMenu then
			back = true
		end
	--Cursor position calculation
		if statsMenu < 1 then
			statsMenu = #t_statsMenu
			if #t_statsMenu > maxItems then
				cursorPosY = maxItems
			else
				cursorPosY = #t_statsMenu
			end
		elseif statsMenu > #t_statsMenu then
			statsMenu = 1
			cursorPosY = 1
		elseif ((commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u')) or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30)) and cursorPosY > 1 then
			cursorPosY = cursorPosY - 1
		elseif ((commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd')) or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30)) and cursorPosY < maxItems then
			cursorPosY = cursorPosY + 1
		end
		if cursorPosY == maxItems then
			moveTxt = (statsMenu - maxItems) * 15
		elseif cursorPosY == 1 then
			moveTxt = (statsMenu - 1) * 15
		end	
		if #t_statsMenu <= maxItems then
			maxStats = #t_statsMenu
		elseif statsMenu - cursorPosY > 0 then
			maxStats = statsMenu + maxItems - cursorPosY
		else
			maxStats = maxItems
		end
		animDraw(f_animVelocity(commonBG0, -1, -1))
	--Draw Transparent Table BG
		animSetScale(commonTBG, 290, maxStats*15)
		animSetWindow(commonTBG, 30,20, 260,180)
		animDraw(commonTBG)
	--Draw Title Menu
		textImgDraw(txt_statsMenu)
		textImgDraw(txt_statsProgress)
	--Draw Stats Table Cursor
		animSetWindow(cursorBox, 30,5+cursorPosY*15, 260,15)
		f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
		animDraw(f_animVelocity(cursorBox, -1, -1))
	--Draw Stats Text for Table
		for i=1, maxStats do
			if i > statsMenu - cursorPosY then
				local align = 1
				local posX = 35
			--Custom Pos for Last items
				if i == #t_statsMenu then
					align = 0
					posX = 160
				end
				if t_statsMenu[i].varID ~= nil then
					textImgDraw(f_updateTextImg(t_statsMenu[i].varID, font2, 0, align, t_statsMenu[i].text, posX, 15+i*15-moveTxt))
					textImgDraw(f_updateTextImg(t_statsMenu[i].varID, font2, 0, -1, t_statsMenu[i].varText, 286, 15+i*15-moveTxt))
				end
			end
		end
	--Draw Up Animated Cursor
		if maxStats > maxItems then
			animDraw(menuArrowUp)
			animUpdate(menuArrowUp)
		end
	--Draw Down Animated Cursor
		if #t_statsMenu > maxItems and maxStats < #t_statsMenu then
			animDraw(menuArrowDown)
			animUpdate(menuArrowDown)
		end
		drawListInputHints()
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		if commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu') then
			bufd = 0
			bufu = bufu + 1
		elseif commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd') then
			bufu = 0
			bufd = bufd + 1
		else
			bufu = 0
			bufd = 0
		end
		cmdInput()
		refresh()
	end
end

--;===========================================================
--; PLAYER SAVE DATA
--;===========================================================
function f_victories()
	stats.wins = stats.wins + 1
	f_saveStats()
end

function f_defeats()
	stats.losses = stats.losses + 1
	f_saveStats()
end

function f_records()
	--[[
	if data.rosterMode == "suddendeath" then
		if winCnt > data.suddenrecord then
			data.suddenrecord = winCnt
		end
	elseif data.rosterMode == "endless" then
		if winCnt > data.endlessrecord then
			data.endlessrecord = winCnt
		end
	end
	f_saveStats()
	]]
end

function f_favoriteChar()
	data.favoriteChar = f_getName(data.t_p1selected[1].cel) --Improve store logic with stats.json
	f_saveStats()
end

function f_favoriteStage()
	data.favoriteStage = getStageName(stageList):gsub('^["%s]*(.-)["%s]*$', '%1') --Improve store logic with stats.json
	f_saveStats()
end

function f_gameState()
--[[
if stats.modes.arcade.clear >= 1 then arcadeProgress = 1 else arcadeProgress = 0 end
if stats.modes.survival.clear >= 1 then survivalProgress = 1 else survivalProgress = 0 end
gameProgress = (arcadeProgress + survivalProgress + stats.modes.mission.clearall + stats.modes.event.clearall + (data.storiesProgress/100))
gameData = (math.floor((gameProgress * 100 / 11) + 0.5))

The number (11) is the sumation of true amount of all gameProgress values:
(arcadeProgress = 1 + survivalProgress = 1 + stats.modes.mission.clearall = 3 + stats.modes.event.clearall = 3 + data.storiesProgress = 3)
]]
gameData = "WIP"
end

t_statsGameModes = {
	{
		displayname = "CPU Match", --Text to Display in Stats Menu
		id = "cpu", --id to compare with data.rosterMode var
		playtime = function() return stats.modes.watch.playtime end,
		setplaytime = function(newtime) stats.modes.watch.playtime = newtime end
	},
	{
		displayname = "Versus",
		id = "versus",
		playtime = function() return stats.modes.versus.playtime end,
		setplaytime = function(newtime) stats.modes.versus.playtime = newtime end
	},
	{
		displayname = "Training",
		id = "training",
		playtime = function() return stats.modes.training.playtime end,
		setplaytime = function(newtime) stats.modes.training.playtime = newtime end
	},
	{
		displayname = "Trials",
		id = "trials",
		playtime = function() return stats.modes.trials.playtime end,
		setplaytime = function(newtime) stats.modes.trials.playtime = newtime end
	},
	{
		displayname = "Tutorial",
		id = "tutorial",
		playtime = function() return stats.modes.tutorial.playtime end,
		setplaytime = function(newtime) stats.modes.tutorial.playtime = newtime end
	},
	{
		displayname = "Arcade",
		id = "arcade",
		playtime = function() return stats.modes.arcade.playtime end,
		setplaytime = function(newtime) stats.modes.arcade.playtime = newtime end
	},
	{
		displayname = "Tourney",
		id = "tourney",
		playtime = function() return stats.modes.tourney.playtime end,
		setplaytime = function(newtime) stats.modes.tourney.playtime = newtime end
	},
	{
		displayname = "Tower",
		id = "tower",
		playtime = function() return stats.modes.tower.playtime end,
		setplaytime = function(newtime) stats.modes.tower.playtime = newtime end
	},
	{
		displayname = "Survival",
		id = "survival",
		playtime = function() return stats.modes.survival.playtime end,
		setplaytime = function(newtime) stats.modes.survival.playtime = newtime end
	},
	{
		displayname = "Abyss",
		id = "abyss",
		playtime = function() return stats.modes.abyss.playtime end,
		setplaytime = function(newtime) stats.modes.abyss.playtime = newtime end
	},
	{
		displayname = "Legion",
		id = "legion",
		playtime = function() return stats.modes.legion.playtime end,
		setplaytime = function(newtime) stats.modes.legion.playtime = newtime end
	},
	{
		displayname = "Boss Fight",
		id = "boss",
		playtime = function() return stats.modes.boss.playtime end,
		setplaytime = function(newtime) stats.modes.boss.playtime = newtime end
	},
	{
		displayname = "Bonus Games",
		id = "bonus",
		playtime = function() return stats.modes.bonus.playtime end,
		setplaytime = function(newtime) stats.modes.bonus.playtime = newtime end
	},
	{
		displayname = "Score Attack",
		id = "scoreattack",
		playtime = function() return stats.modes.scoreattack.playtime end,
		setplaytime = function(newtime) stats.modes.scoreattack.playtime = newtime end
	},
	{
		displayname = "Time Attack",
		id = "timeattack",
		playtime = function() return stats.modes.timeattack.playtime end,
		setplaytime = function(newtime) stats.modes.timeattack.playtime = newtime end
	},
	{
		displayname = "Time Rush",
		id = "timerush",
		playtime = function() return stats.modes.timerush.playtime end,
		setplaytime = function(newtime) stats.modes.timerush.playtime = newtime end
	},
	{
		displayname = "Sudden Death",
		id = "suddendeath",
		playtime = function() return stats.modes.suddendeath.playtime end,
		setplaytime = function(newtime) stats.modes.suddendeath.playtime = newtime end
	},
	{
		displayname = "VSKumite",
		id = "vskumite",
		playtime = function() return stats.modes.vskumite.playtime end,
		setplaytime = function(newtime) stats.modes.vskumite.playtime = newtime end,
		getData = function() return getKumiteData() end
	},
	{
		displayname = "Endless",
		id = "endless",
		playtime = function() return stats.modes.endless.playtime end,
		setplaytime = function(newtime) stats.modes.endless.playtime = newtime end
	},
}

function f_modePlaytime()
	for _, mode in ipairs(t_statsGameModes) do
		if mode.id == data.rosterMode then --Check Current Game Mode
			if type(mode.playtime()) == "number" then
				mode.setplaytime(mode.playtime() + clearTime) --Update Playtime
			end
			break --To exit from loop when find a coincidence
		end
	end
	f_saveStats()
end

function f_getPreferredMode()
	if data.debugLog then f_printTable(t_statsGameModes, "save/debug/t_statsGameModes.log") end
	local maxTime = -1
	local modeName = nil
	local modeDat = nil
	for _, mode in ipairs(t_statsGameModes) do
		if mode.playtime() > maxTime then
			maxTime = mode.playtime() --() Because playtime index uses a function to keep update the values
			modeName = mode.displayname
			modeDat = mode
		end
	end
	if modeName then
		t_statsMenu[7].varText = modeDat.getData and modeDat.getData() or modeName
	else
		t_statsMenu[7].varText = "None"
	end
end

function f_getStats(callback)
--Progress Logic
	f_gameState()
	textImgSetText(txt_statsMenu,"" .. data.userName .. " PROGRESS:")
	textImgSetText(txt_statsProgress,"["..gameData.."%]")
--Get Stats Info
	s = math.floor((stats.playtime%60))
	m = math.floor((stats.playtime%3600)/60)
	h = math.floor((stats.playtime%86400)/3600)
	d = math.floor(stats.playtime/86400)
	--timePlayed = string.format("%d:Days %02d:Hours %02d:Minutes %02d:Seconds", d, h, m, s)
	timePlayed = string.format("%d:Days %02d:Hours %02d:Minutes", d, h, m)
	t_statsMenu[1].varText = timePlayed
	t_statsMenu[2].varText = (stats.wins+stats.losses)
	t_statsMenu[3].varText = stats.wins
	t_statsMenu[4].varText = stats.losses
	t_statsMenu[5].varText = "WIP"--data.favoriteChar
	t_statsMenu[6].varText = "WIP"--data.favoriteStage
	f_getPreferredMode()
	ts = math.floor((stats.modes.training.playtime%60))
	tm = math.floor((stats.modes.training.playtime%3600)/60)
	th = math.floor((stats.modes.training.playtime%86400)/3600)
	td = math.floor(stats.modes.training.playtime/86400)
	--practiceTime = string.format("%d:Days %02d:Hours %02d:Minutes %02d:Seconds", td, th, tm, ts)
	practiceTime = string.format("%d:Days %02d:Hours %02d:Minutes", td, th, tm)
	t_statsMenu[8].varText = practiceTime
	t_statsMenu[9].varText = stats.money.." IKC"
	if callback then callback() end --To call functions from External Modules
end

--;===========================================================
--; LEADERBOARDS SCREEN (display rankings data)
--;===========================================================
function f_rankings()
	--TODO
end

--;===========================================================
--; SOUND TEST MENU (listen music)
--;===========================================================
function f_songMenu()
	f_discordUpdate({details = "Sound Test: Idle"})
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	cmdInput()
	f_confirmSongReset()
	local bufu = 0
	local bufd = 0
	local bufr = 0
	local bufl = 0
	local cursorPosY = 1
	local moveTxt = 0
	local maxItems = 12
	songMenu = 1 --Not local because will be used in other menus
	songFolder = 1
	selectedSong = nil
	folderRefer = "" --To use in random select song
	songChanged = false
	f_soundtrack() --Reload from common.lua
	f_resetListArrowsPos()
	f_resetSoundTestArrowsPos()
	f_resetFadeBGM()
	while true do
		if backSongConfirm == true then
			f_discordMainMenu()
			data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
			f_setCfgSong() --SAVE AND BACK SONG FOR OPTIONS MENU
			f_menuMusic()
			sndPlay(sndSys, 100, 2)
			backSongConfirm = false
			soundTest = false
			f_resetFadeBGM()
			f_resetMenuArrowsPos()
			break
		end
		if not confirmSong then
		--Back Button
			if esc() or commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then
				if soundTest == true or songChanged == false then --Another damn check just to know in what menu where are and if you select something..
					backSongConfirm = true
				else --IF YOU ARE IN SYSTEM SONGS SETTINGS
					confirmSong = true
				end
			elseif commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u') or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30) then
				sndPlay(sndSys, 100, 0)
				songMenu = songMenu - 1
			elseif commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd') or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30) then
				sndPlay(sndSys, 100, 0)
				songMenu = songMenu + 1
			elseif commandGetState(p1Cmd, 'l') or commandGetState(p2Cmd, 'l') or ((commandGetState(p1Cmd, 'holdl') or commandGetState(p2Cmd, 'holdl')) and bufl >= 30) then
				sndPlay(sndSys, 100, 0)
				songFolder = songFolder - 1
				songMenu = 1 --Restart Cursor Values to prevent nil values issues
				cursorPosY = 1 --Restart Cursor Values to prevent nil values issues
			elseif commandGetState(p1Cmd, 'r') or commandGetState(p2Cmd, 'r') or ((commandGetState(p1Cmd, 'holdr') or commandGetState(p2Cmd, 'holdr')) and bufr >= 30) then
				sndPlay(sndSys, 100, 0)
				songFolder = songFolder + 1
				songMenu = 1 --Restart Cursor Values to prevent nil values issues
				cursorPosY = 1 --Restart Cursor Values to prevent nil values issues
		--Mute Button
			elseif commandGetState(p1Cmd, 'q') or commandGetState(p2Cmd, 'q') then
				playBGM(bgmNothing)
				f_discordUpdate({details = "Sound Test: Idle"})
		--Confirm Button
			elseif btnPalNo(p1Cmd, true) > 0 or btnPalNo(p2Cmd, true) > 0 then
				if songMenu == #t_songList[songFolder] then --BACK
					if soundTest == true or songChanged == false then --Same esc logic
						backSongConfirm = true
					else
						confirmSong = true
					end
				elseif songMenu == #t_songList[songFolder]-1 then --RANDOM SELECT
					if not soundTest then --If you are setting system songs in options
						sndPlay(sndSys, 100, 1)
						songChanged = true
						selectedSong = t_songList[songFolder][songMenu].path
						selectedSongName = t_songList[songFolder][songMenu].name
						folderRefer = songFolder
					--Back Copy
						if soundTest == true or songChanged == false then --Same esc logic
							backSongConfirm = true
						else
							confirmSong = true
						end
					else --If you are in sound test
						if #t_songList[data.menuSongFolder]-2 ~= 0 then --If there's songs loaded
							--randomSongFolder = math.random(1, #t_songList) --Get random folder song
							--randomSongSel = math.random(1, #t_songList[randomSongFolder]-2)
							randomSongSel = math.random(1, #t_songList[songFolder]-2) --Get random song (-2 excludes back and random select items)
							selectedSong = t_songList[songFolder][randomSongSel].path --Use random song obtained to get his path
							selectedSongName = t_songList[songFolder][randomSongSel].name
							playBGM(selectedSong) --Play Random Song from Folder Selected
							f_discordUpdate({details = "Sound Test: "..t_songList[songFolder][songMenu].fullname})
						else --If There's no songs loaded
							playBGM(bgmNothing)
						end
					end
				else --Play Selected Song
					if not soundTest then
						sndPlay(sndSys, 100, 1)
						songChanged = true
					end
					selectedSong = t_songList[songFolder][songMenu].path
					selectedSongName = t_songList[songFolder][songMenu].name
					playBGM(selectedSong)
					f_discordUpdate({details = "Sound Test: "..t_songList[songFolder][songMenu].fullname})
				end
			end
		--Folder Select Logic
			if songFolder < 1 then
				songFolder = #t_songList
			elseif songFolder > #t_songList then
				songFolder = 1
			end
		--Cursor position calculation
			if songMenu < 1 then
				songMenu = #t_songList[songFolder]
				if #t_songList[songFolder] > maxItems then
					cursorPosY = maxItems
				else
					cursorPosY = #t_songList[songFolder]
				end
			elseif songMenu > #t_songList[songFolder] then
				songMenu = 1
				cursorPosY = 1
			elseif ((commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u')) or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30)) and cursorPosY > 1 then
				cursorPosY = cursorPosY - 1
			elseif ((commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd')) or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30)) and cursorPosY < maxItems then
				cursorPosY = cursorPosY + 1
			end
			if cursorPosY == maxItems then
				moveTxt = (songMenu - maxItems) * 15
			elseif cursorPosY == 1 then
				moveTxt = (songMenu - 1) * 15
			end	
			if #t_songList[songFolder] <= maxItems then
				maxSongs = #t_songList[songFolder]
			elseif songMenu - cursorPosY > 0 then
				maxSongs = songMenu + maxItems - cursorPosY
			else
				maxSongs = maxItems
			end
		end
	--Draw Menu BG
		animDraw(f_animVelocity(commonBG0, -1, -1))
	--Draw Transparent Table BG
		animSetScale(commonTBG, 240, maxSongs*15)
		animSetWindow(commonTBG, 80,20, 160,180)
		animDraw(commonTBG)
	--Draw Title Menu
		textImgSetText(txt_song, "[".. t_songList[songFolder].folder:upper().."]")
		textImgDraw(txt_song)
		if not confirmSong then
		--Draw Table Cursor
			animSetWindow(cursorBox, 80,5+cursorPosY*15, 160,15)
			f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
			animDraw(f_animVelocity(cursorBox, -1, -1))
		end
	--Draw Text for Table
		for i=1, maxSongs do
			if t_songList[songFolder][i].name:len() > 28 then --If name is too long, shortcut with ...
				songText = string.sub(t_songList[songFolder][i].name, 1, 24)
				songText = tostring(songText .. "...")
			else
				songText = t_songList[songFolder][i].name
			end
			local align = 1
			local posX = 85
		--Custom Pos for Last items
			if i == #t_songList[songFolder] or i == #t_songList[songFolder]-1 then
				align = 0
				posX = 160
			end
			if i > songMenu - cursorPosY then
				t_songList[songFolder][i].id = createTextImg(font2, 0, align, songText, posX, 15+i*15-moveTxt)
				textImgDraw(t_songList[songFolder][i].id)
			end
		end
	--Draw Up Animated Cursor
		if maxSongs > maxItems then
			animDraw(menuArrowUp)
			animUpdate(menuArrowUp)
		end
	--Draw Down Animated Cursor
		if #t_songList[songFolder] > maxItems and maxSongs < #t_songList[songFolder] then
			animDraw(menuArrowDown)
			animUpdate(menuArrowDown)
		end
	--Draw Left Animated Cursor
		if songFolder > 1 then
			animDraw(menuArrowLeft)
			animUpdate(menuArrowLeft)
		end
	--Draw Right Animated Cursor
		if songFolder < #t_songList then
			animDraw(menuArrowRight)
			animUpdate(menuArrowRight)
		end
		if confirmSong then f_confirmSongMenu() else drawSoundTestInputHints() end
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		if commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu') then
			bufd = 0
			bufu = bufu + 1
		elseif commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd') then
			bufu = 0
			bufd = bufd + 1
		elseif commandGetState(p1Cmd, 'holdr') or commandGetState(p2Cmd, 'holdr') then
			bufl = 0
			bufr = bufr + 1
		elseif commandGetState(p1Cmd, 'holdl') or commandGetState(p2Cmd, 'holdl') then
			bufr = 0
			bufl = bufl + 1
		else
			bufu = 0
			bufd = 0
			bufr = 0
			bufl = 0
		end
		if selectedSong == nil then f_fadeOutBGM(1) else f_resetFadeBGM() end
		cmdInput()
		refresh()
	end
end

function f_confirmSongMenu()
	cmdInput()
--Cursor Position
	if commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u') then
		sndPlay(sndSys, 100, 0)
		confirmSongMenu = confirmSongMenu - 1
	elseif commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd') then
		sndPlay(sndSys, 100, 0)
		confirmSongMenu = confirmSongMenu + 1
	end
	if confirmSongMenu < 1 then
		confirmSongMenu = #t_confirmSongMenu
		if #t_confirmSongMenu > 4 then
			cursorPosYSongConfirm = 4
		else
			cursorPosYSongConfirm = #t_confirmSongMenu-1
		end
	elseif confirmSongMenu > #t_confirmSongMenu then
		confirmSongMenu = 1
		cursorPosYSongConfirm = 0
	elseif commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u') and cursorPosYSongConfirm > 0 then
		cursorPosYSongConfirm = cursorPosYSongConfirm - 1
	elseif commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd') and cursorPosYSongConfirm < 4 then
		cursorPosYSongConfirm = cursorPosYSongConfirm + 1
	end
	if cursorPosYSongConfirm == 4 then
		moveTxtSongConfirm = (confirmSongMenu - 5) * 13
	elseif cursorPosYSongConfirm == 0 then
		moveTxtSongConfirm = (confirmSongMenu - 1) * 13
	end
--Draw Fade BG
	animDraw(fadeWindowBG)
--Draw Menu BG
	animDraw(confirmSongWindowBG)
--Draw Title
	textImgDraw(txt_confirmSong)
--Draw Select content
	f_drawQuickText(txt_songSelected, font6, 0, 0, selectedSongName, 160, 120, 0.68, 0.68)
--Draw Table Text
	for i=1, #t_confirmSongMenu do
		if i == confirmSongMenu then
			bank = 5
		else
			bank = 0
		end
		textImgDraw(f_updateTextImg(t_confirmSongMenu[i].id, jgFnt, bank, 0, t_confirmSongMenu[i].text, 159, 120+i*13-moveTxtSongConfirm))
	end
--Draw Cursor
	animSetWindow(cursorBox, 87,123+cursorPosYSongConfirm*13, 144,13)
	f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
	animDraw(f_animVelocity(cursorBox, -1, -1))
--Draw Input Hints Panel
	drawConfirmInputHints()
--Actions
	if btnPalNo(p1Cmd, true) > 0 or btnPalNo(p2Cmd, true) > 0 then
	--YES
		if confirmSongMenu == 1 then
			--sndPlay(sndSys, 100, 1)
	--NO
		else
			selectedSong = nil
		end
		backSongConfirm = true
		f_confirmSongReset()
	end
end

function f_confirmSongReset()
	confirmSong = false
	moveTxtSongConfirm = 0
	--Cursor pos in NO
	cursorPosYSongConfirm = 1
	confirmSongMenu = 2
end

--;===========================================================
--; LICENSES MENU (display engine license files)
--;===========================================================
function f_licenseMenu()
	if data.debugMode then f_loadLicenses() end
	if #t_licenseList == 0 then
		licenseInfo = true
		infoScreen = true
		return
	end
	cmdInput()
	local cursorPosX = 1
	local moveTxt = 0
	local licenseMenu = 1
	local bufu = 0
	local bufd = 0
	local bufr = 0
	local bufl = 0
	local maxItems = 1
	local cursorUpdate = true
	--
	local txtScaleX = 1
	local txtScaleY = 1
	local txtPosX = -50
	local function f_resetYPos() txtPosY = 30 end
	f_resetYPos()
	local txtSpacing = 12
--4:3 Resolution
	if (resolutionHeight / 3 * 4) == resolutionWidth then
		txtPosX = 1
		txtScaleX = 0.75
		txtScaleY = 0.75
--16:10 Resolution
	elseif (resolutionHeight / 10 * 16) == resolutionWidth then
		txtPosX = -25
		txtScaleX = 0.9
		txtScaleY = 0.9
	end
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	while true do
	--BACK
		if esc() or commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then
			data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
			sndPlay(sndSys, 100, 2)
			break
	--PREVIOUS PAGE
		elseif commandGetState(p1Cmd, 'l') or commandGetState(p2Cmd, 'l') or ((commandGetState(p1Cmd, 'holdl') or commandGetState(p2Cmd, 'holdl')) and bufl >= 30) then
			sndPlay(sndSys, 100, 0)
			licenseMenu = licenseMenu - 1
			cursorUpdate = true
	--NEXT PAGE
		elseif commandGetState(p1Cmd, 'r') or commandGetState(p2Cmd, 'r') or ((commandGetState(p1Cmd, 'holdr') or commandGetState(p2Cmd, 'holdr')) and bufr >= 30) then
			sndPlay(sndSys, 100, 0)
			licenseMenu = licenseMenu + 1
			cursorUpdate = true
	--MOVE UP TXT
		elseif ((commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u')) or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 5)) and txtPosY < 30 then
			txtPosY = txtPosY + 1
	--MOVE DOWN TXT
		elseif ((commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd')) or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 5)) then
			txtPosY = txtPosY - 1
		end
		if licenseMenu < 1 then
			licenseMenu = #t_licenseList
			if #t_licenseList > maxItems then
				cursorPosX = maxItems
			else
				cursorPosX = #t_licenseList
			end
		elseif licenseMenu > #t_licenseList then
			licenseMenu = 1
			cursorPosX = 1
		elseif ((commandGetState(p1Cmd, 'l') or commandGetState(p2Cmd, 'l')) or ((commandGetState(p1Cmd, 'holdl') or commandGetState(p2Cmd, 'holdl')) and bufl >= 30)) and cursorPosX > 1 then
			cursorPosX = cursorPosX - 1
		elseif ((commandGetState(p1Cmd, 'r') or commandGetState(p2Cmd, 'r')) or ((commandGetState(p1Cmd, 'holdr') or commandGetState(p2Cmd, 'holdr')) and bufr >= 30)) and cursorPosX < maxItems then
			cursorPosX = cursorPosX + 1
		end
		if cursorPosX == maxItems then
			moveTxt = (licenseMenu - maxItems) * 15
		elseif cursorPosX == 1 then
			moveTxt = (licenseMenu - 1) * 15
		end
		if #t_licenseList <= maxItems then
			maxLicenses = #t_licenseList
		elseif licenseMenu - cursorPosX > 0 then
			maxLicenses = licenseMenu + maxItems - cursorPosX
		else
			maxLicenses = maxItems
		end
		if cursorUpdate then
			f_resetYPos()
			--f_readLicense(t_licenseList[licenseMenu].path) --Get Text Data (old method)
			cursorUpdate = false
		end
		animDraw(f_animVelocity(licenseBG, -0.1, -0.1))
	--Draw License Text Content
		for i=1, #t_licenseList[licenseMenu].content do
			textImgSetText(txt_license, t_licenseList[licenseMenu].content[i])
			textImgSetPos(txt_license, txtPosX, txtPosY + txtSpacing * (i - 1))
			textImgSetScale(txt_license, txtScaleX, txtScaleY)
			textImgDraw(txt_license)
		end
		--f_textRender(txt_license, licenseContent, 0, txtPosX, txtPosY, txtSpacing, 0, -1) --Draw Text from license file (old method)
		animPosDraw(licenseTitleBG, -56, 0) --Draw Title BG
		textImgSetText(txt_licenseTitle, t_licenseList[licenseMenu].name.." LICENSE")
		textImgDraw(txt_licenseTitle) --Draw Menu Title
		drawLicenseInputHints()
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		if commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu') then
			bufd = 0
			bufu = bufu + 1
		elseif commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd') then
			bufu = 0
			bufd = bufd + 1
		else
			bufu = 0
			bufd = 0
		end
		if commandGetState(p1Cmd, 'holdr') or commandGetState(p2Cmd, 'holdr') then
			bufl = 0
			bufr = bufr + 1
		elseif commandGetState(p1Cmd, 'holdl') or commandGetState(p2Cmd, 'holdl') then
			bufr = 0
			bufl = bufl + 1
		else
			bufr = 0
			bufl = 0
		end
		cmdInput()
		refresh()
	end
end

function f_readLicense(path)
licenseFile = io.open(path,"r") --Open .txt file refer in path var in reading mode
licenseContent = licenseFile:read("*all") --Read file content line by line
licenseFile:close() --Close .txt file
end

--;===========================================================
--; REPLAY MENU (watch recorded battles)
--;===========================================================
function f_replayMenu()
	cmdInput()
	local cursorPosY = 0
	local moveTxt = 0
	local replayMenu = 1
	local bufu = 0
	local bufd = 0
	local bufr = 0
	local bufl = 0
	f_infoReset()
	while true do
		if not infoScreen then
			if esc() or commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then
				sndPlay(sndSys, 100, 2)
				break
			elseif commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u') or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30) then
				sndPlay(sndSys, 100, 0)
				replayMenu = replayMenu - 1
			elseif commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd') or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30) then
				sndPlay(sndSys, 100, 0)
				replayMenu = replayMenu + 1
			end
			if replayMenu < 1 then
				replayMenu = #t_replayMenu
				if #t_replayMenu > 5 then
					cursorPosY = 5
				else
					cursorPosY = #t_replayMenu-1
				end
			elseif replayMenu > #t_replayMenu then
				replayMenu = 1
				cursorPosY = 0
			elseif ((commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u')) or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30)) and cursorPosY > 0 then
				cursorPosY = cursorPosY - 1
			elseif ((commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd')) or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30)) and cursorPosY < 5 then
				cursorPosY = cursorPosY + 1
			end
			if cursorPosY == 5 then
				moveTxt = (replayMenu - 6) * 13
			elseif cursorPosY == 0 then
				moveTxt = (replayMenu - 1) * 13
			end
			if #t_replayMenu <= 5 then
				maxreplayMenu = #t_replayMenu
			elseif replayMenu - cursorPosY > 0 then
				maxreplayMenu = replayMenu + 5 - cursorPosY
			else
				maxreplayMenu = 5
			end
			if btnPalNo(p1Cmd, true) > 0 or btnPalNo(p2Cmd, true) > 0 then
				sndPlay(sndSys, 100, 1)
			--ONLINE REPLAYS (watch saved replays of your online matches)
				if replayMenu == 1 then
					--if (resolutionHeight / 3 * 4) ~= resolutionWidth then --To watch an online replay you need to set a 4:3 Resolution to avoid desync
					--if (resolutionHeight / 10 * 16) ~= resolutionWidth then --To watch an online replay you need to set a 16:10 Resolution to avoid desync
					if (math.floor((resolutionHeight / 9 * 16) + 0.5)) ~= resolutionWidth then --To watch an online replay you need to set a 16:9 Resolution to avoid desync
						resolutionInfo = true
						infoScreen = true
					else
						data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
						f_mainReplay()
					end
				--LOCAL REPLAYS (watch saved replays of your local matches)
				elseif replayMenu == 2 then
					f_comingSoon()
				end
			end
		end
		drawBottomMenuSP()
		for i=1, #t_replayMenu do
			if i == replayMenu then
				bank = 2
			else
				bank = 0
			end
			textImgDraw(f_updateTextImg(t_replayMenu[i].id, jgFnt, bank, 0, t_replayMenu[i].text, 159, 122+i*13-moveTxt))
		end
		if not infoScreen then
			animSetWindow(cursorBox, 0,125+cursorPosY*13, 316,13)
			f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
			animDraw(f_animVelocity(cursorBox, -1, -1))
		end
		drawMiddleMenuSP()
		textImgDraw(txt_gameFt)
		textImgSetText(txt_gameFt, "REPLAY MODES")
		textImgDraw(txt_version)
		f_sysTime()
		if maxreplayMenu > 6 then
			animDraw(menuArrowUp)
			animUpdate(menuArrowUp)
		end
		if #t_replayMenu > 6 and maxreplayMenu < #t_replayMenu then
			animDraw(menuArrowDown)
			animUpdate(menuArrowDown)
		end
		if infoScreen then f_infoMenu() else drawMainMenuInputHints() end
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		if commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu') then
			bufd = 0
			bufu = bufu + 1
		elseif commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd') then
			bufu = 0
			bufd = bufd + 1
		else
			bufu = 0
			bufd = 0
		end
		cmdInput()
		refresh()
	end
end

--;===========================================================
--; ONLINE REPLAYS MENU
--;===========================================================
function f_mainReplay()
	cmdInput()
	local cursorPosY = 1
	local moveTxt = 0
	local mainReplay = 1
	local bufu = 0
	local bufd = 0
	local bufr = 0
	local bufl = 0
	local exitReplayMenu = false
	local maxItems = 12
	netPlayer = "Host"
	f_replayTable() --Load table
	f_resetListArrowsPos()
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	while true do
		if exitReplayMenu then
			f_discordMainMenu()
			onlinegame = false --only for identify purposes
			--netPlayer = "" Bloquea el acceso al menu de online en offline dejarlo comentado solo para devs
			assert(loadfile(saveCfgPath))()
			data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
			sndPlay(sndSys, 100, 2)
			f_resetMenuArrowsPos()
			break
		end
		if esc() or commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then exitReplayMenu = true
		elseif commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u') or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30) then
			sndPlay(sndSys, 100, 0)
			mainReplay = mainReplay - 1
		elseif commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd') or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30) then
			sndPlay(sndSys, 100, 0)
			mainReplay = mainReplay + 1
		elseif btnPalNo(p1Cmd, true) > 0 or btnPalNo(p2Cmd, true) > 0 then
		--BACK
			if mainReplay == #t_replayList then exitReplayMenu = true
		--OPEN REPLAY CONTROL MENU
			else
				sndPlay(sndSys, 100, 1)
				textImgSetText(txt_replayName, t_replayList[mainReplay].name)--Show Replay Selected Name
				local fileSize = lfs.attributes(t_replayList[mainReplay].path).size --Size Logic
				if fileSize > 1048576 then
					local replaySize = (math.floor(((fileSize/1048576)+0.50)))--Conversion from Bytes to Megabytes
					textImgSetText(txt_replaySize, replaySize.."MB")
				else
					local replaySize = (math.floor(((fileSize/1024)+0.50)))--Conversion from Bytes to Kilobytes
					textImgSetText(txt_replaySize, replaySize.."KB")
				end
				local replayOption = 2
				f_confirmReset()
				cmdInput()
				while true do
					if not confirmScreen then
						if esc() or commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then
							sndPlay(sndSys, 100, 2)
							break
						elseif commandGetState(p1Cmd, 'r') or commandGetState(p2Cmd, 'r') then
							sndPlay(sndSys, 100, 0)
							replayOption = replayOption + 1
						elseif commandGetState(p1Cmd, 'l') or commandGetState(p2Cmd, 'l') then
							sndPlay(sndSys, 100, 0)
							replayOption = replayOption - 1
						end
						if replayOption < 1 then replayOption = 3 elseif replayOption > 3 then replayOption = 1 end
					end
					if btnPalNo(p1Cmd, true) > 0 or btnPalNo(p2Cmd, true) > 0 then
					--OPEN CONFIRM DELETE REPLAY WINDOW
						if replayOption == 1 then
							sndPlay(sndSys, 100, 1)
							confirmScreen = true
					--WATCH SELECTED REPLAY
						elseif replayOption == 2 then
							onlinegame = true --only for identify purposes
							data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
							sndPlay(sndSys, 100, 1)
						--Set Default values to prevent desync.
							f_loadNETCfg()
							f_onlineDefault()
							f_netsaveCfg()
							enterReplay(t_replayList[mainReplay].path)
							synchronize()
							math.randomseed(sszRandom())
							f_onlineCfg()
							exitNetPlay()
							exitReplay()
							commandBufReset(p1Cmd)
							commandBufReset(p2Cmd)
					--RETURN TO REPLAY SELECT MENU
						elseif replayOption == 3 then
							sndPlay(sndSys, 100, 2)
							break
						end
					end
					animDraw(f_animVelocity(commonBG0, -1, -1))
				--Draw Replay Title
					animSetScale(replayMenuBG, 324, 74)
					animSetWindow(replayMenuBG, 0,5, 324,27)
					animDraw(replayMenuBG)
					textImgDraw(txt_replayName)
					textImgDraw(txt_replaySize)
					textImgDraw(txt_replayData)
				--Draw Mini Menu BG
					animDraw(replayMenuBG2)
				--Draw Replay Option Text
					for i=1, #t_replayOption do
						if i == replayOption + 0 then -- +0 To start center
							textImgSetBank(t_replayOption[i].id, 5)
						else
							textImgSetBank(t_replayOption[i].id, 0)
						end
						textImgDraw(t_replayOption[i].id)
					end
					if not confirmScreen then
						--Draw Cursor
						animSetWindow(cursorBox, -108+replayOption*120,161, 56,15)
						f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
						animDraw(f_animVelocity(cursorBox, -1, -1))
					end
					if confirmScreen then f_confirmMenu() else drawReplayInputHints() end
					--DELETE SELECTED REPLAY
					if deleteReplay then
						os.remove(t_replayList[mainReplay].path)
						t_replayList = nil --Delete the Table
						f_replayTable() --Just reload the table with applied changes
						deleteReplay = false
						break
					end
					animDraw(data.fadeTitle)
					animUpdate(data.fadeTitle)
					cmdInput()
					refresh()
				end
			end
		end
		if mainReplay < 1 then
			mainReplay = #t_replayList
			if #t_replayList > maxItems then
				cursorPosY = maxItems
			else
				cursorPosY = #t_replayList
			end
		elseif mainReplay > #t_replayList then
			mainReplay = 1
			cursorPosY = 1
		elseif ((commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u')) or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30)) and cursorPosY > 1 then
			cursorPosY = cursorPosY - 1
		elseif ((commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd')) or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30)) and cursorPosY < maxItems then
			cursorPosY = cursorPosY + 1
		end
		if cursorPosY == maxItems then
			moveTxt = (mainReplay - maxItems) * 15
		elseif cursorPosY == 1 then
			moveTxt = (mainReplay - 1) * 15
		end
		if #t_replayList <= maxItems then
			maxReplays = #t_replayList
		elseif mainReplay - cursorPosY > 0 then
			maxReplays = mainReplay + maxItems - cursorPosY
		else
			maxReplays = maxItems
		end
		animDraw(f_animVelocity(commonBG0, -1, -1))
		animSetScale(commonTBG, 240, maxReplays*15)
		animSetWindow(commonTBG, 80,20, 160,180)
		animDraw(commonTBG)
		textImgDraw(txt_replay)
		--animSetScale(cursorBox, 160,maxReplays*15) --For Optimized Cursor Box
		animSetWindow(cursorBox, 80,5+cursorPosY*15, 160,15)
		f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
		animDraw(f_animVelocity(cursorBox, -1, -1))
		for i=1, maxReplays do
			if t_replayList[i].name:len() > 28 then
				replayText = string.sub(t_replayList[i].name, 1, 24)
				replayText = tostring(replayText .. "...")
			else
				replayText = t_replayList[i].name
			end
			if i > mainReplay - cursorPosY then
				t_replayList[i].id = createTextImg(font2, 0, 1, replayText, 85, 15+i*15-moveTxt)
				textImgDraw(t_replayList[i].id)
			end
		end
		if maxReplays > maxItems then
			animDraw(menuArrowUp)
			animUpdate(menuArrowUp)
		end
		if #t_replayList > maxItems and maxReplays < #t_replayList then
			animDraw(menuArrowDown)
			animUpdate(menuArrowDown)
		end
		drawListInputHints()
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		if commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu') then
			bufd = 0
			bufu = bufu + 1
		elseif commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd') then
			bufu = 0
			bufd = bufd + 1
		else
			bufu = 0
			bufd = 0
		end
		cmdInput()
		refresh()
	end
end

function f_replayTable()
	t_replayList = {}
	for file in lfs.dir(replaysPath) do
		if file:match('^.*(%.)[Rr][Ee][Pp][Ll][Aa][Yy]$') and not file:match('^data.replay$') then
			row = #t_replayList+1
			t_replayList[row] = {}
			t_replayList[row]['id'] = ''
			t_replayList[row]['name'] = file:gsub('^(.*)[%.][Rr][Ee][Pp][Ll][Aa][Yy]$', '%1')
			t_replayList[row]['path'] = replaysPath.."/"..file
		end
	end
	t_replayList[#t_replayList+1] = {id = '', name = "          BACK"}
	if data.debugLog then f_printTable(t_replayList, "save/debug/t_replayList.log") end
end

--;===========================================================
--; ONLINE MENU (play online)
--;===========================================================
function checkNetplayAccess()
	--if (resolutionHeight / 3 * 4) ~= resolutionWidth then --To play online you need to set a 4:3 Resolution to avoid desync
	--if (resolutionHeight / 10 * 16) ~= resolutionWidth then --To play online you need to set a 16:10 Resolution to avoid desync
	if (math.floor((resolutionHeight / 9 * 16) + 0.5)) ~= resolutionWidth then --To play online you need to set a 16:9 Resolution to avoid desync
		resolutionInfo = true
		infoScreen = true
	else
		f_mainNetplay()
	end
end

function f_mainNetplay()
	--if (resolutionHeight / 3 * 4) ~= resolutionWidth then --To play online you need to set a 4:3 Resolution to avoid desync
	--if (resolutionHeight / 10 * 16) ~= resolutionWidth then --To play online you need to set a 16:10 Resolution to avoid desync
	if (math.floor((resolutionHeight / 9 * 16) + 0.5)) ~= resolutionWidth then --To play online you need to set a 16:9 Resolution to avoid desync
		resolutionInfo = true
		infoScreen = true
		return
	end
	cmdInput()
	local cursorPosY = 0
	local moveTxt = 0
	local mainNetplay = 1
	local bufu = 0
	local bufd = 0
	local bufr = 0
	local bufl = 0
	local cancel = false
	while true do
		if esc() or commandGetState(p1Cmd, 'e') then
			onlinegame = false --only for identify purposes
			assert(loadfile(saveCfgPath))()
			sndPlay(sndSys, 100, 2)
			f_resetMenuInputs()
			return
		end
		if commandGetState(p1Cmd, 'u') or (commandGetState(p1Cmd, 'holdu') and bufu >= 30) then
			sndPlay(sndSys, 100, 0)
			mainNetplay = mainNetplay - 1
		elseif commandGetState(p1Cmd, 'd') or (commandGetState(p1Cmd, 'holdd') and bufd >= 30) then
			sndPlay(sndSys, 100, 0)
			mainNetplay = mainNetplay + 1
		end
		if mainNetplay < 1 then
			mainNetplay = #t_mainNetplay
			if #t_mainNetplay > 5 then
				cursorPosY = 5
			else
				cursorPosY = #t_mainNetplay-1
			end
		elseif mainNetplay > #t_mainNetplay then
			mainNetplay = 1
			cursorPosY = 0
		elseif (commandGetState(p1Cmd, 'u') or (commandGetState(p1Cmd, 'holdu') and bufu >= 30)) and cursorPosY > 0 then
			cursorPosY = cursorPosY - 1
		elseif (commandGetState(p1Cmd, 'd') or (commandGetState(p1Cmd, 'holdd') and bufd >= 30)) and cursorPosY < 5 then
			cursorPosY = cursorPosY + 1
		end
		if cursorPosY == 5 then
			moveTxt = (mainNetplay - 6) * 13
		elseif cursorPosY == 0 then
			moveTxt = (mainNetplay - 1) * 13
		end
		if #t_mainNetplay <= 5 then
			maxMainNetplay = #t_mainNetplay
		elseif mainNetplay - cursorPosY > 0 then
			maxMainNetplay = mainNetplay + 5 - cursorPosY
		else
			maxMainNetplay = 5
		end
		if btnPalNo(p1Cmd, true) > 0 then
			f_discordUpdate({state = "Online Multiplayer", partyMax = 2})
			f_default()
			sndPlay(sndSys, 100, 1)
		--HOST (create online room)
			if mainNetplay == 1 then
				f_discordUpdate({details = "Waiting Opponents"})
				onlinegame = true --only for identify purposes
				f_loadNETCfg()
				f_onlineDefault()
				f_netsaveCfg()
				data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
				cancel = f_create()
				if not cancel then
					synchronize()
					math.randomseed(sszRandom())
					f_onlineCfg()
				end
				exitNetPlay()
				exitReplay()
				commandBufReset(p1Cmd)
				commandBufReset(p2Cmd)
				f_saveReplay()
				f_discordMainMenu()
		--CLIENT/JOIN (join an existing room)
			elseif mainNetplay == 2 then
				f_discordUpdate({details = "Searching Opponents"})
			--Default Connection Method
				if data.connectMode == "Direct" then
					onlinegame = true
					f_loadNETCfg()
					f_onlineDefault()
					f_netsaveCfg()
					data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
					cancel = f_directConnect()
					if not cancel then
						synchronize()
						math.randomseed(sszRandom())
						f_onlineCfg()
					end
					exitNetPlay()
					exitReplay()
					commandBufReset(p1Cmd)
					commandBufReset(p2Cmd)
					f_saveReplay()
			--Host info Stored in a Local Database
				elseif data.connectMode == "Database" then
					f_hostRooms()
				end
				f_discordMainMenu()
			end	
		end
		drawBottomMenuSP()
		for i=1, #t_mainNetplay do
			if i == mainNetplay then
				bank = 3
			else
				bank = 0
			end
			textImgDraw(f_updateTextImg(t_mainNetplay[i].id, jgFnt, bank, 0, t_mainNetplay[i].text, 159, 122+i*13-moveTxt))
		end
		animSetWindow(cursorBox, 0,125+cursorPosY*13, 316,13)
		f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
		animDraw(f_animVelocity(cursorBox, -1, -1))
		drawMiddleMenuSP()
		textImgDraw(txt_gameFt)
		textImgSetText(txt_gameFt, "ONLINE MODE")
		textImgDraw(txt_version)
		f_sysTime()
		if maxMainNetplay > 6 then
			animDraw(menuArrowUp)
			animUpdate(menuArrowUp)
		end
		if #t_mainNetplay > 6 and maxMainNetplay < #t_mainNetplay then
			animDraw(menuArrowDown)
			animUpdate(menuArrowDown)
		end
		drawMainMenuInputHints()
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		if commandGetState(p1Cmd, 'holdu') then
			bufd = 0
			bufu = bufu + 1
		elseif commandGetState(p1Cmd, 'holdd') then
			bufu = 0
			bufd = bufd + 1
		else
			bufu = 0
			bufd = 0
		end
		exitNetPlay()
    	exitReplay()
		cmdInput()
		refresh()
	end
end

--;===========================================================
--; SAVE ONLINE REPLAY
--;===========================================================
function f_saveReplay()
--Create Replay File
	if (data.replayOnline and data.ftcontrol == -1) or (data.replayRanked and data.ftcontrol > 0) then
		local netplayFile = io.open("save/data.replay","rb") --Read origin file
		if netplayFile ~= nil then
			if not createExit or not joinExit then
				if lfs.attributes("save/data.replay", "size") > 0 then --Save replay if have content
					ltn12.pump.all(
					ltn12.source.file(assert(io.open("save/data.replay", "rb"))), --Use this file to make a copy
					ltn12.sink.file(assert(io.open(replaysPath.."/".. os.date("%Y-%m-%d %I-%M%p") .. ".replay", "wb"))) --Save replay with a new name
					)
				end
				netplayFile:close()
				netplayFile = nil
			end
		end
	end
end

--;===========================================================
--; HOST MENU
--;===========================================================
function f_create()
	cmdInput()
	createExit = false
	textImgSetText(txt_hosting, "Waiting for Player 2...")
	enterNetPlay(inputDialogGetStr(inputdia))
	netPlayer = "Host" --For Replay Identify
--[[
	if waitingRoom == "Training" then
		data.p1In = 1
		f_training() --Try to Wait client in Training Mode
	end
]]
	while not netplay() do
		if esc() or commandGetState(p1Cmd, 'e') then --commandGetState() does not work when engine is waiting a connection, only esc, that's why still we can't program an Training Waiting Room
		    data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
			sndPlay(sndSys, 100, 2)
			netPlayer = ""
			return true
		end
	--Draw BG
		animDraw(f_animVelocity(commonBG0, -1, -1))
	--Draw Menu Title
		textImgDraw(txt_hostTitle)
	--Draw Window BG
		animDraw(joinWindowBG)
	--Draw Port Info
		textImgSetText(txt_netPort, "Netplay Port ["..getListenPort().."]")
		textImgDraw(txt_netPort)
	--Draw Cancel Button
		textImgDraw(txt_cancel)
	--Draw Cursor
		animSetWindow(cursorBox, 87,155, 144,13)
		f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
		animDraw(f_animVelocity(cursorBox, -1, -1))
	--Draw Hosting Info
		textImgDraw(txt_hosting)
	--Draw Animated Icon
		animDraw(wirelessBG)
		animUpdate(wirelessBG)
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		cmdInput()
		refresh()
	end
	return false
end

--;===========================================================
--; DIRECT CONNECTION MENU
--;===========================================================
function f_directConnect()
	cmdInput()
	local ip = ""
	local doneIP = false
	local directJoinMenu = 2
	local i = 0
	joinExit = false
	textImgSetText(txt_clientTitle, "SEARCH ROOM")
--ENTER IP SCREEN
	while true do
	--EXIT LOGIC
		if joinExit == true then
			clearInputText()
			netPlayer = ""
			sndPlay(sndSys, 100, 2)
			data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
			return true
		end
	--MAIN SCREEN
		if not doneIP then
			if esc() then
				joinExit = true
			elseif commandGetState(p1Cmd, 'r') then
				sndPlay(sndSys, 100, 0)
				directJoinMenu = directJoinMenu + 1
			elseif commandGetState(p1Cmd, 'l') then
				sndPlay(sndSys, 100, 0)
				directJoinMenu = directJoinMenu - 1
			end
			if directJoinMenu < 1 then directJoinMenu = 2 elseif directJoinMenu > 2 then directJoinMenu = 1 end
			ip = inputText('num',true)
			if clipboardPaste() then
				if string.match(getClipboardText(),'^%d%d?%d?%.%d%d?%d?%.%d%d?%d?%.%d%d?%d?$') then
					setInputText(getClipboardText())
				elseif string.match(getClipboardText(),'^localhost$') then
					setInputText(getClipboardText())
				else
					sndPlay(sndIkemen, 200, 0)
				end
			end
			if ip:match('^%.') then
				ip = ""
				setInputText(ip)
			elseif ip:len() > 15 then
				ip = ip:sub(1,15)
				setInputText(ip)
			elseif ip:match('%.%.+') then
				ip = ip:gsub('%.%.+','.')
				setInputText(ip)
			elseif ip:match('%d%d%d%d+') then
				ip = ip:gsub('(%d%d%d)%d+','%1')
				setInputText(ip)
			elseif ip:match('%d+%.%d+%.%d+%.%d+%.') then
				ip = ip:gsub('(%d+%.%d+%.%d+%.%d+)%.','%1')
				setInputText(ip)
			end
		--BUTTON SELECT
			if btnPalNo(p1Cmd, true) > 0 then
			--BACK
				if directJoinMenu == 1 then
					joinExit = true
			--JOIN
				elseif directJoinMenu == 2 then
					if ip:match('^%d%d?%d?%.%d%d?%d?%.%d%d?%d?%.%d%d?%d?$') then
						doneIP = true
					elseif ip:match('^localhost$') then
						doneIP = true
					else
						sndPlay(sndIkemen, 200, 0)
					end
				end
			end
		--Draw BG
			animDraw(f_animVelocity(commonBG0, -1, -1))
		--Draw Menu Title
			textImgDraw(txt_clientTitle)
		--Draw IP Window BG
			animDraw(textWindowBG)
		--Draw IP Window Title
			textImgDraw(txt_client)
		--Draw IP Text
			textImgSetText(txt_ip,ip)
			textImgDraw(txt_ip)
			if i%60 < 30 then
				textImgPosDraw(txt_bar, 160+(textImgGetWidth(txt_ip)*0.5)+(textImgGetWidth(txt_ip)>0 and 2 or 0), 134)
			end
		--Draw Button Option Text
			for i=1, #t_directJoinMenu do
				if i == directJoinMenu then
					textImgSetBank(t_directJoinMenu[i].id, 5)
				else
					textImgSetBank(t_directJoinMenu[i].id, 0)
				end
				textImgDraw(t_directJoinMenu[i].id)
			end
		--Draw Cursor
			animSetWindow(cursorBox, -9+directJoinMenu*96,141, 48.5,13)
			f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
			animDraw(f_animVelocity(cursorBox, -1, -1))
		end
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		i = i >= 60 and 0 or i + 1
		if doneIP then break end --Exit for this bucle to start connecting
		cmdInput()
		refresh()
	end
--CONNECTING SCREEN
	sndPlay(sndSys, 100, 1)
	enterNetPlay(ip) --Connect to entered IP address
	netPlayer = "Client"
	textImgSetText(txt_connecting, "Now connecting to ["..ip.."]")
	while not netplay() do
	--CANCEL CONNECTION
		if esc() or commandGetState(p1Cmd, 'e') then
			clearInputText()
			data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
			sndPlay(sndSys, 100, 2)
			netPlayer = ""
			joinExit = true
			return true
		end
	--Draw Connecting BG
		animDraw(f_animVelocity(commonBG0, -1, -1))
	--Draw Connecting Menu Title
		textImgSetText(txt_clientTitle, "SEARCHING HOST ROOM")
		textImgDraw(txt_clientTitle)
	--Draw Window BG
		animDraw(joinWindowBG)
	--Draw Port Info
		textImgSetText(txt_netPort, "Netplay Port ["..getListenPort().."]")
		textImgDraw(txt_netPort)
	--Draw Connecting Info
		textImgDraw(txt_connecting)
	--Draw Cancel Button
		textImgDraw(txt_cancel)
	--Draw Cursor
		animSetWindow(cursorBox, 87,155, 144,13)
		f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
		animDraw(f_animVelocity(cursorBox, -1, -1))
	--Draw Animated Icon
		animDraw(wirelessBG)
		animUpdate(wirelessBG)
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		cmdInput()
		refresh()
	end
	clearInputText()
	return false
end

--;===========================================================
--; HOST ROOMS MENU
--;===========================================================
function f_hostTable()
	t_hostList = {{id = textImgNew(), text = "ADD NEW ROOM"},}
	for k, v in pairs(host_rooms.IP) do
		t_hostList[#t_hostList + 1] = {id = textImgNew(), text = k, address = v} --Insert Room Names from Local Database
	end
	t_hostList[#t_hostList+1] = {id = textImgNew(), text = "BACK"}
end

function f_hostRooms()
	cmdInput()
	local cursorPosY = 0
	local moveTxt = 0
	local hostList = 1
	local bufu = 0
	local bufd = 0
	local bufr = 0
	local bufl = 0
	local t_tmp = {}
	f_hostTable()
	f_editHostReset()
	f_crudHostReset()
	--local cancel = false
	while true do
		if editHostScreen == false and crudHostScreen == false then
			if esc() or commandGetState(p1Cmd, 'e') then
				--onlinegame = false
				--assert(loadfile(saveCfgPath))()
				sndPlay(sndSys, 100, 2)
				break
				--return
			end
			if commandGetState(p1Cmd, 'u') or (commandGetState(p1Cmd, 'holdu') and bufu >= 30) then
				sndPlay(sndSys, 100, 0)
				hostList = hostList - 1
			elseif commandGetState(p1Cmd, 'd') or (commandGetState(p1Cmd, 'holdd') and bufd >= 30) then
				sndPlay(sndSys, 100, 0)
				hostList = hostList + 1
			end
			if hostList < 1 then
				hostList = #t_hostList
				if #t_hostList > 5 then
					cursorPosY = 5
				else
					cursorPosY = #t_hostList-1
				end
			elseif hostList > #t_hostList then
				hostList = 1
				cursorPosY = 0
			elseif (commandGetState(p1Cmd, 'u') or (commandGetState(p1Cmd, 'holdu') and bufu >= 30)) and cursorPosY > 0 then
				cursorPosY = cursorPosY - 1
			elseif (commandGetState(p1Cmd, 'd') or (commandGetState(p1Cmd, 'holdd') and bufd >= 30)) and cursorPosY < 5 then
				cursorPosY = cursorPosY + 1
			end
			if cursorPosY == 5 then
				moveTxt = (hostList - 6) * 13
			elseif cursorPosY == 0 then
				moveTxt = (hostList - 1) * 13
			end
			if #t_hostList <= 5 then
				maxhostList = #t_hostList
			elseif hostList - cursorPosY > 0 then
				maxhostList = hostList + 5 - cursorPosY
			else
				maxhostList = 5
			end
			if btnPalNo(p1Cmd, true) > 0 then
				f_default()
			--ADD NEW HOST ADDRESS
				if hostList == 1 then
					sndPlay(sndSys, 100, 1)
					editHostScreen = true
			--BACK
				elseif hostList == #t_hostList then
					sndPlay(sndSys, 100, 2)
					--onlinegame = false
					--assert(loadfile(saveCfgPath))()
					break
			--OPEN CRUD MENU
				else
					sndPlay(sndSys, 100, 1)
					crudHostScreen = true
				end
			end
		end
		drawBottomMenuSP()
		for i=1, #t_hostList do
			if i == hostList then
				bank = 5
			else
				bank = 0
			end
			textImgDraw(f_updateTextImg(t_hostList[i].id, jgFnt, bank, 0, t_hostList[i].text, 159, 122+i*13-moveTxt))
		end
		if editHostScreen == false and crudHostScreen == false then
			animSetWindow(cursorBox, 0,125+cursorPosY*13, 316,13)
			f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
			animDraw(f_animVelocity(cursorBox, -1, -1))
		end
		drawMiddleMenuSP()
		if editHostScreen == false then
			textImgDraw(txt_gameFt)
			textImgSetText(txt_gameFt, "HOST ROOMS")
			textImgDraw(txt_version)
		end
		f_sysTime()
		if crudHostScreen == false then
			if maxhostList > 6 then
				animDraw(menuArrowUp)
				animUpdate(menuArrowUp)
			end
			if #t_hostList > 6 and maxhostList < #t_hostList then
				animDraw(menuArrowDown)
				animUpdate(menuArrowDown)
			end
		end
		if not crudHostScreen and not editHostScreen then drawMainMenuInputHints() end --Draw Input Hints Panel for Host Rooms
		textBar = textBar >= 60 and 0 or textBar + 1
	--CRUD ACTIONS
		hostRoomName = (t_hostList[hostList].text) --Host Name Selected
		hostIP = (t_hostList[hostList].address) --Host IP Address Selected
		if crudHostScreen == true then f_crudHostScreen() end
		if editHostScreen == true then f_editHost() end
	--READ DATA
		if crudHostOption == 2 then
			f_crudHostReset()
			onlinegame = true
			f_loadNETCfg()
			f_onlineDefault()
			f_netsaveCfg()
			data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
			cancel = f_databaseConnect()
			if not cancel then
				synchronize()
				math.randomseed(sszRandom())
				f_onlineCfg()
			end
			exitNetPlay()
			exitReplay()
			commandBufReset(p1Cmd)
			commandBufReset(p2Cmd)
			f_saveReplay()
	--UPDATE DATA
		elseif crudHostOption == 3 then
			f_crudHostReset()
			editHostRoom = true --To Update Data
			editHostScreen = true
	--DELETE DATA
		elseif crudHostOption == 1 then
			f_confirmMenu()
		end
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		if commandGetState(p1Cmd, 'holdu') then
			bufd = 0
			bufu = bufu + 1
		elseif commandGetState(p1Cmd, 'holdd') then
			bufu = 0
			bufd = bufd + 1
		else
			bufu = 0
			bufd = 0
		end
		--exitNetPlay()
    	--exitReplay()
		cmdInput()
		refresh()
	end
end

--;===========================================================
--; CRUD MENU
--;===========================================================
function f_crudHostScreen()
	if crudHostOption ~= 1 then
		cmdInput()
	--Cursor Logic
		if commandGetState(p1Cmd, 'u') then
			sndPlay(sndSys, 100, 0)
			crudHostRow = crudHostRow - 1
			crudHostCursorU = crudHostCursorD
		elseif commandGetState(p1Cmd, 'd') then
			sndPlay(sndSys, 100, 0)
			crudHostRow = crudHostRow + 1
			crudHostCursorD = crudHostCursorU
		end
		if crudHostRow < 1 then
			crudHostRow = 2
		elseif crudHostRow > 2 then
			crudHostRow = 1
		end
		if crudHostRow == 1 then
			if commandGetState(p1Cmd, 'l') then
				sndPlay(sndSys, 100, 0)
				crudHostCursorU = crudHostCursorU - 1
				crudHostCursorD = crudHostCursorD - 1
			elseif commandGetState(p1Cmd, 'r') then
				sndPlay(sndSys, 100, 0)
				crudHostCursorU = crudHostCursorU + 1
				crudHostCursorD = crudHostCursorD + 1
			end
		elseif crudHostRow == 2 then
			if commandGetState(p1Cmd, 'l') then
				sndPlay(sndSys, 100, 0)
				crudHostCursorD = crudHostCursorD - 1
				crudHostCursorU = crudHostCursorU - 1
			elseif commandGetState(p1Cmd, 'r') then
				sndPlay(sndSys, 100, 0)
				crudHostCursorD = crudHostCursorD + 1
				crudHostCursorU = crudHostCursorU + 1
			end
		end
		if crudHostCursorU < 1 then
			crudHostCursorU = #t_crudHostOptionU
		elseif crudHostCursorU > #t_crudHostOptionU then
			crudHostCursorU = 1
		end
		if crudHostCursorD < 1 then
			crudHostCursorD = #t_crudHostOptionD
		elseif crudHostCursorD > #t_crudHostOptionD then
			crudHostCursorD = 1
		end
	--ACTIONS
		if esc() or commandGetState(p1Cmd, 'e') then
			sndPlay(sndSys, 100, 2)
			f_crudHostReset()
	--BUTTON SELECTED
		elseif btnPalNo(p1Cmd, true) > 0 then
		--DELETE HOST ADDRESS
			if crudHostCursorU == 1 and crudHostRow == 1 then
				sndPlay(sndSys, 100, 1)
				f_confirmReset()
				crudHostOption = 1
		--JOIN TO HOST ADDRESS
			elseif crudHostCursorU == 2 and crudHostRow == 1 then
				sndPlay(sndSys, 100, 1)
				crudHostOption = 2
				crudHostScreen = false
		--EDIT HOST ADDRESS
			elseif crudHostCursorD == 1 and crudHostRow == 2 then
				sndPlay(sndSys, 100, 1)
				crudHostOption = 3
				crudHostScreen = false
		--BACK
			elseif crudHostCursorD == 2 and crudHostRow == 2 then
				sndPlay(sndSys, 100, 2)
				f_crudHostReset()
			end
		end
	end
--Draw Crud Window BG
	animDraw(crudHostWindowBG)
--Draw Crud Title
	textImgSetText(txt_crudTitle, hostRoomName.." ROOM")
	textImgDraw(txt_crudTitle)
--Draw Input Hints Panel
	if crudHostOption ~= 1 then drawCrudHostInputHints() end
--Draw Crud Menu Text
	for i=1, #t_crudHostOptionU do
		if i == crudHostCursorU and crudHostRow == 1 then
			bank = 5
		else
			bank = 0
		end
		t_crudHostOptionU[i].id = createTextImg(jgFnt, bank, 0, t_crudHostOptionU[i].text, 12+i*100, 170)
		textImgDraw(t_crudHostOptionU[i].id)
	end
	for i=1, #t_crudHostOptionD do
		if i == crudHostCursorD and crudHostRow == 2 then
			bank = 5
		else
			bank = 0
		end
		t_crudHostOptionD[i].id = createTextImg(jgFnt, bank, 0, t_crudHostOptionD[i].text, 12+i*100, 190)
		textImgDraw(t_crudHostOptionD[i].id)
	end
	if crudHostOption ~= 1 then
		--Draw Cursors
		if crudHostRow == 1 then
			animSetWindow(cursorBox, -16+crudHostCursorU*100,158, 55,16)
			f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
			animDraw(f_animVelocity(cursorBox, -1, -1))
		elseif crudHostRow == 2 then
			animSetWindow(cursorBox, -16+crudHostCursorD*100,178, 55,16)
			f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
			animDraw(f_animVelocity(cursorBox, -1, -1))
		end
	end
end

function f_crudHostReset()
	crudHostScreen = false
	crudHostOption = 0
	--Cursor pos in JOIN
	crudHostRow = 1
	crudHostCursorU = 2
	crudHostCursorD = 2
end

--;===========================================================
--; CREATE/UPDATE HOST DATA
--;===========================================================
function f_editHost()
	cmdInput()
--ENTER HOST NAME
	if not doneName then
		if commandGetState(p1Cmd, 'r') then
			sndPlay(sndSys, 100, 0)
			editHostMenu = editHostMenu + 1
		elseif commandGetState(p1Cmd, 'l') then
			sndPlay(sndSys, 100, 0)
			editHostMenu = editHostMenu - 1
		end
		if editHostMenu < 1 then editHostMenu = 2 elseif editHostMenu > 2 then editHostMenu = 1 end
		editHostName = inputText('',true)
		if clipboardPaste() then
			if string.match(getClipboardText(),'^(.*)') then
				setInputText(getClipboardText())
			else
				sndPlay(sndIkemen, 200, 0)
			end
		end
		if editHostName:len() > 5 then
			editHostName = editHostName:sub(1,16)
			setInputText(editHostName)
		end
		if editHostName ~= '' and editHostName ~= nil then
			if editHostName:match('^"*(%")$') then
				editHostName = editHostName:gsub('^("*)[%"]$','%1')
				setInputText(editHostName)
			end
		end
	--ACTIONS
		if esc() then
			sndPlay(sndSys, 100, 2)
			f_editHostReset()
		--elseif commandGetState(p1Cmd, 's') then
		elseif returnKey() then --If you are using a keyboard, use enter key to accept
		--BACK
			if editHostMenu == 1 then
				sndPlay(sndSys, 100, 2)
				f_editHostReset()
		--SAVE NAME
			elseif editHostMenu == 2 then
				if editHostName ~= '' and editHostName ~= nil then
					clearInputText()
					sndPlay(sndSys, 100, 1)
					hostName = (tostring(editHostName))
					doneName = true
				else
					sndPlay(sndIkemen, 200, 0)
				end
			end
		end
	--Draw Fade BG
		animDraw(fadeWindowBG)
	--Draw Name Window BG
		animDraw(textWindowBG)
	--Draw Name Window Title
		textImgDraw(txt_clientName)
	--Draw Name Text
		textImgSetText(txt_ip,editHostName)
		textImgDraw(txt_ip)
		if textBar%60 < 30 then
			textImgPosDraw(txt_bar, 160+(textImgGetWidth(txt_ip)*0.5)+(textImgGetWidth(txt_ip)>0 and 2 or 0), 134)
		end
	--Draw Button Option Text
		for i=1, #t_editOption do
			if i == editHostMenu then
				textImgSetBank(t_editOption[i].id, 5)
			else
				textImgSetBank(t_editOption[i].id, 0)
			end
			textImgDraw(t_editOption[i].id)
		end
	--Draw Cursor
		animSetWindow(cursorBox, -9+editHostMenu*96,141, 48.5,13)
		f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
		animDraw(f_animVelocity(cursorBox, -1, -1))
	--Draw Hint Info
		textImgDraw(txt_titleFt)
		textImgSetText(txt_titleFt, "COPIED TEXT CAN BE PASTED WITH CTRL V")
--ENTER HOST IP ADDRESS
	else
		if commandGetState(p1Cmd, 'r') then
			sndPlay(sndSys, 100, 0)
			editHostMenu = editHostMenu + 1
		elseif commandGetState(p1Cmd, 'l') then
			sndPlay(sndSys, 100, 0)
			editHostMenu = editHostMenu - 1
		end
		if editHostMenu < 1 then editHostMenu = 2 elseif editHostMenu > 2 then editHostMenu = 1 end
		hostAddress = inputText('num',true)
		if clipboardPaste() then
			if string.match(getClipboardText(),'^%d%d?%d?%.%d%d?%d?%.%d%d?%d?%.%d%d?%d?$') then
				setInputText(getClipboardText())
			elseif string.match(getClipboardText(),'^localhost$') then
				setInputText(getClipboardText())
			else
				sndPlay(sndIkemen, 200, 0)
			end
		end
		if hostAddress:match('^%.') then
			hostAddress = ''
			setInputText(hostAddress)
		elseif hostAddress:len() > 15 then
			hostAddress = hostAddress:sub(1,15)
			setInputText(hostAddress)
		elseif hostAddress:match('%.%.+') then
			hostAddress = hostAddress:gsub('%.%.+','.')
			setInputText(hostAddress)
		elseif hostAddress:match('%d%d%d%d+') then
			hostAddress = hostAddress:gsub('(%d%d%d)%d+','%1')
			setInputText(hostAddress)
		elseif hostAddress:match('%d+%.%d+%.%d+%.%d+%.') then
			hostAddress = hostAddress:gsub('(%d+%.%d+%.%d+%.%d+)%.','%1')
			setInputText(hostAddress)
		end
	--ACTIONS
		if esc() then
			sndPlay(sndSys, 100, 2)
			f_editHostReset()
	--BUTTON SELECTED
		elseif btnPalNo(p1Cmd, true) > 0 then
		--BACK
			if editHostMenu == 1 then
				sndPlay(sndSys, 100, 2)
				f_editHostReset()
		--ENTER IP
			elseif editHostMenu == 2 then
				if hostAddress:match('^%d%d?%d?%.%d%d?%d?%.%d%d?%d?%.%d%d?%d?$') then
					doneAddress = true
				elseif hostAddress:match('^localhost$') then
					doneAddress = true
				else
					sndPlay(sndIkemen, 200, 0)
				end
			end
		end
	--Draw Fade BG
		animDraw(fadeWindowBG)
	--Draw IP Window BG
		animDraw(textWindowBG)
	--Draw IP Window Title
		textImgSetText(txt_client, "Enter Host\'s IPv4")
		textImgDraw(txt_client)
	--Draw IP Text
		textImgSetText(txt_ip,hostAddress)
		textImgDraw(txt_ip)
		if textBar%60 < 30 then
			textImgPosDraw(txt_bar, 160+(textImgGetWidth(txt_ip)*0.5)+(textImgGetWidth(txt_ip)>0 and 2 or 0), 134)
		end
	--Draw Button Option Text
		for i=1, #t_editOption do
			if i == editHostMenu then
				textImgSetBank(t_editOption[i].id, 5)
			else
				textImgSetBank(t_editOption[i].id, 0)
			end
			textImgDraw(t_editOption[i].id)
		end
	--Draw Cursor
		animSetWindow(cursorBox, -9+editHostMenu*96,141, 48.5,13)
		f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
		animDraw(f_animVelocity(cursorBox, -1, -1))
	--Draw Hint Info
		textImgDraw(txt_titleFt)
		textImgSetText(txt_titleFt, "COPIED IP CAN BE PASTED WITH CTRL V")
	end
--SAVE ALL DATA
	if doneAddress == true then
		sndPlay(sndSys, 100, 1)
		if editHostRoom == true then host_rooms.IP[hostRoomName] = nil end --To Update Data
		host_rooms.IP[hostName] = hostAddress
		t_tmp = {}
		for i = 1, #t_hostList do
			if i < #t_hostList then
				t_tmp[i] = t_hostList[i]
			else
				t_tmp[i] = {id = textImgNew(), text = hostName, address = hostAddress}
				t_tmp[i + 1] = t_hostList[i]
			end
		end
		t_hostList = t_tmp
		f_saveOnlineRooms()
		f_hostTable() --Refresh
		f_editHostReset()
	end
	cmdInput()
end

function f_editHostReset()
	clearInputText()
	editHostScreen = false
	editHostRoom = false
	doneAddress = false
	doneName = false
	editHostName = ""
	hostAddress = ""
	textBar = 0
	editHostMenu = 2 --Cursor pos in ENTER
end

--;===========================================================
--; READ LOCAL DATABASE TO CONNECTING MENU
--;===========================================================
function f_databaseConnect()
	cmdInput()
	sndPlay(sndSys, 100, 1)
	joinExit = false
	enterNetPlay(hostIP) --Connect to entered IP address
	netPlayer = "Client"
	textImgSetText(txt_clientTitle, hostRoomName.."'s ROOM")
	textImgSetText(txt_connecting, "Now connecting to ["..hostIP.."]")
	while not netplay() do
	--CANCEL CONNECTION
		if esc() or commandGetState(p1Cmd, 'e') then
			data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
			sndPlay(sndSys, 100, 2)
			netPlayer = ""
			joinExit = true
			return true
		end
	--Draw Connecting BG
		animDraw(f_animVelocity(commonBG0, -1, -1))
	--Draw Connecting Title
		textImgDraw(txt_clientTitle)
	--Draw Window BG
		animDraw(joinWindowBG)
	--Draw Port Info
		textImgSetText(txt_netPort, "Netplay Port ["..getListenPort().."]")
		textImgDraw(txt_netPort)
	--Draw Connecting Info
		textImgDraw(txt_connecting)
	--Draw Cancel Button
		textImgDraw(txt_cancel)
	--Draw Cursor
		animSetWindow(cursorBox, 87,155, 144,13)
		f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
		animDraw(f_animVelocity(cursorBox, -1, -1))
	--Draw Animated Icon
		animDraw(wirelessBG)
		animUpdate(wirelessBG)
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		cmdInput()
		refresh()
	end
	return false
end

--;===========================================================
--; LOBBY MENU
--;===========================================================
function f_mainLobby()
	if not replay() then f_discordUpdate({details = "Netplay Lobby"}) end
	cmdInput()
	local cursorPosY = 0
	local moveTxt = 0
	local mainLobby = 1
	local bufu = 0
	local bufd = 0
	local bufr = 0
	local bufl = 0
	local cancel = false
	while true do
		--assert(loadfile(saveTempPath))()
		if esc() or commandGetState(p1Cmd, 'e') or data.replayDone then
			sndPlay(sndSys, 100, 2)
			data.replayDone = false
			f_saveTemp()
			f_discordMainMenu()
			break
		end
		if commandGetState(p1Cmd, 'u') or (commandGetState(p1Cmd, 'holdu') and bufu >= 30) then
			sndPlay(sndSys, 100, 0)
			mainLobby = mainLobby - 1
		elseif commandGetState(p1Cmd, 'd') or (commandGetState(p1Cmd, 'holdd') and bufd >= 30) then
			sndPlay(sndSys, 100, 0)
			mainLobby = mainLobby + 1
		end
		if mainLobby < 1 then
			mainLobby = #t_mainLobby
			if #t_mainLobby > 5 then
				cursorPosY = 5
			else
				cursorPosY = #t_mainLobby-1
			end
		elseif mainLobby > #t_mainLobby then
			mainLobby = 1
			cursorPosY = 0
		elseif (commandGetState(p1Cmd, 'u') or (commandGetState(p1Cmd, 'holdu') and bufu >= 30)) and cursorPosY > 0 then
			cursorPosY = cursorPosY - 1
		elseif (commandGetState(p1Cmd, 'd') or (commandGetState(p1Cmd, 'holdd') and bufd >= 30)) and cursorPosY < 5 then
			cursorPosY = cursorPosY + 1
		end
		if cursorPosY == 5 then
			moveTxt = (mainLobby - 6) * 13
		elseif cursorPosY == 0 then
			moveTxt = (mainLobby - 1) * 13
		end
		if #t_mainLobby <= 5 then
			maxmainLobby = #t_mainLobby
		elseif mainLobby - cursorPosY > 0 then
			maxmainLobby = mainLobby + 5 - cursorPosY
		else
			maxmainLobby = 5
		end
	--Enter Actions
		if btnPalNo(p1Cmd, true) > 0 or data.ftcontrol > 0 then
			f_default()
			if replay() then
				f_discordUpdate({details = "Watching Online Replay"})
			else
				f_discordUpdate({details = "Playing Online"})
			end
			data.p2In = 2
			data.p2Faces = true
			data.coop = true
			data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
			sndPlay(sndSys, 100, 1)
		--ONLINE VERSUS
			if data.ftcontrol > 0 or mainLobby == 1 then
				data.coop = false
				data.stageMenu = true
				setHomeTeam(1)
				data.gameMode = "versus"
				data.rosterMode = "versus"
				if data.ftcontrol > 0 then
					textImgSetText(txt_mainSelect, "ONLINE RANKED VERSUS")
				else
					textImgSetText(txt_mainSelect, "ONLINE VERSUS")
				end
				setGameMode("vs") --setGameMode("netplayvs")
				f_selectSimple()
		--ONLINE TRAINING
			elseif mainLobby == 2 then
				setRoundTime(-1)
				data.p1TeamMenu = {mode = 0, chars = 1}
				data.p2TeamMenu = {mode = 0, chars = 1}
				data.coop = false
				data.stageMenu = true
				data.versusScreen = false
				data.gameMode = "training"
				data.rosterMode = "training"
				textImgSetText(txt_mainSelect, "ONLINE TRAINING")
				setGameMode("netplaytraining")
				f_selectSimple()
		--ONLINE ARCADE	
			elseif mainLobby == 3 then
				data.serviceScreen = true
				data.gameMode = "arcade"
				data.rosterMode = "arcade"
				textImgSetText(txt_mainSelect, "ONLINE ARCADE COOPERATIVE")
                setGameMode("arcadecoop") --setGameMode("netplayarcade")
				f_selectAdvance()
		--ONLINE TOWER
			elseif mainLobby == 4 then
				--if data.debugMode then f_loadTowers() end
				if #t_selTower ~= 0 then
					data.gameMode = "tower"
					data.rosterMode = "tower"
					--data.arcadeIntro = true
					data.arcadeEnding = true
					setGameMode("towercoop") --setGameMode("netplaytower")
					textImgSetText(txt_mainSelect, "ONLINE TOWER COOPERATIVE")
					f_selectAdvance()
				end
		--ONLINE SURVIVAL	
			elseif mainLobby == 5 then
				setRoundsToWin(1)
				data.gameMode = "survival"
				data.rosterMode = "survival"
				--setGameMode("netplaysurvival")
				textImgSetText(txt_mainSelect, "ONLINE SURVIVAL COOPERATIVE")
				f_selectAdvance()
		--ONLINE ENDLESS
			elseif mainLobby == 6 then
				data.gameMode = "endless"
				data.rosterMode = "endless"
				--setGameMode("netplayendless")
				textImgSetText(txt_mainSelect, "ONLINE ENDLESS COOPERATIVE")
				f_selectAdvance()
		--ONLINE BOSS RUSH
			elseif mainLobby == 7 then
				if #t_bossChars ~= 0 then
					data.gameMode = "bossrush"
					data.rosterMode = "boss"
					--setGameMode("netplaybossrush")
					textImgSetText(txt_mainSelect, "ONLINE BOSS RUSH COOPERATIVE")
					f_selectAdvance()
				end
		--ONLINE BONUS MARATHON
			elseif mainLobby == 8 then
				if #t_bonusChars ~= 0 then
					setRoundsToWin(1)
					data.versusScreen = false
					data.gameMode = "bonusrush"
					data.rosterMode = "bonus"
					--setGameMode("netplaybonus")
					textImgSetText(txt_mainSelect, "ONLINE BONUS MARATHON COOPERATIVE")
					f_selectAdvance()
				end
		--ONLINE TIME RUSH
			elseif mainLobby == 9 then
				setRoundTime(3600)
				setRoundsToWin(1)
				data.gameMode = "allroster"
				data.rosterMode = "timerush"
				--setGameMode("netplaytimerush")
				textImgSetText(txt_mainSelect, "ONLINE TIME RUSH COOPERATIVE")
				f_selectAdvance()
		--[[
		--ONLINE TIME ATTACK
			elseif mainLobby == 10 then
				setRoundsToWin(1)
				data.gameMode = "allroster"
				data.rosterMode = "timeattack"
				setGameMode("netplaytimeattack")
				textImgSetText(txt_mainSelect, "ONLINE TIME ATTACK COOPERATIVE")
				f_selectAdvance()
		--ONLINE SCORE ATTACK
			elseif mainLobby == 11 then
				data.gameMode = "allroster"
				data.rosterMode = "scoreattack"
				setGameMode("netplayscoreattack")
				textImgSetText(txt_mainSelect, "ONLINE SCORE ATTACK COOPERATIVE")
				f_selectAdvance()
		]]
		--ONLINE VS X KUMITE
			elseif mainLobby == 10 then
				setRoundsToWin(1)
				data.gameMode = "vskumite"
				data.rosterMode = "vskumite"
				--setGameMode("netplayvskumite")
				textImgSetText(txt_mainSelect, "ONLINE "..getKumiteData().." COOPERATIVE")
				f_selectAdvance()
		--ONLINE SUDDEN DEATH
			elseif mainLobby == 11 then
				setRoundTime(1000)
				setLifeMul(0)
				setRoundsToWin(1)
				data.gameMode = "allroster"
				data.rosterMode = "suddendeath"
				--setGameMode("netplaysuddendeath")
				textImgSetText(txt_mainSelect, "ONLINE SUDDEN DEATH COOPERATIVE")
				f_selectAdvance()
		--ONLINE SETTINGS
			elseif mainLobby == #t_mainLobby then
				f_discordUpdate({details = "Netplay Lobby"})
				f_onlineCfg()
			end
			f_discordUpdate({details = "Netplay Lobby"})
		end
		drawBottomMenuSP()
		for i=1, #t_mainLobby do
			if i == mainLobby then
				bank = 5
			else
				bank = 0
			end
			textImgDraw(f_updateTextImg(t_mainLobby[i].id, jgFnt, bank, 0, t_mainLobby[i].text, 159, 122+i*13-moveTxt))
		end
		animSetWindow(cursorBox, 0,125+cursorPosY*13, 316,13)
		f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
		animDraw(f_animVelocity(cursorBox, -1, -1))
		drawMiddleMenuSP()
		textImgDraw(txt_gameFt)
		textImgSetText(txt_gameFt, "ONLINE MENU")
		textImgDraw(txt_version)
		f_sysTime()
		if netPlayer == "Host" then
			t_mainLobby[1].text = "VERSUS PLAYER 2"
		elseif netPlayer == "Client" then
			t_mainLobby[1].text = "VERSUS PLAYER 1"
		end
		t_mainLobby[10].text = getKumiteData()
		if maxmainLobby > 6 then
			animDraw(menuArrowUp)
			animUpdate(menuArrowUp)
		end
		if #t_mainLobby > 6 and maxmainLobby < #t_mainLobby then
			animDraw(menuArrowDown)
			animUpdate(menuArrowDown)
		end
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		if commandGetState(p1Cmd, 'holdu') then
			bufd = 0
			bufu = bufu + 1
		elseif commandGetState(p1Cmd, 'holdd') then
			bufu = 0
			bufd = bufd + 1
		else
			bufu = 0
			bufd = 0
		end		
		cmdInput()
		refresh()
	end
end

--;===========================================================
--; UNLOCK INFO SCREEN
--;===========================================================
function f_secret()
	cmdInput()
	local i = 0
	while true do
		if btnPalNo(p1Cmd, true) > 0 or btnPalNo(p2Cmd, true) > 0 then
			sndPlay(sndSys, 100, 2)
			data.fadeTitle = f_fadeAnim(50, 'fadein', 'black', sprFade)
			break
		end
        i = i + 1
        f_textRender(txt_msgMenu, "COMPLETE THE ARCADE MODE TO UNLOCK THIS FEATURE!", i, 20, 178, 15, 1.8, 35)
        animDraw(data.fadeTitle)
        animUpdate(data.fadeTitle)
		cmdInput()
        refresh()
    end
end

--;===========================================================
--; COMING SOON INFO SCREEN
--;===========================================================
function f_comingSoon()
	cmdInput()
	local i = 0
	f_resetMenuInputs()
	while true do
		if btnPalNo(p1Cmd, true) > 0 or btnPalNo(p2Cmd, true) > 0 then
			sndPlay(sndSys, 100, 2)
			data.fadeTitle = f_fadeAnim(50, 'fadein', 'black', sprFade)
			break
		end
        i = i + 1
        f_textRender(txt_msgMenu, "THIS FEATURE WILL BE AVAILABLE COMING SOON...", i, 20, 178, 15, 1.4, 35)
        animDraw(data.fadeTitle)
        animUpdate(data.fadeTitle)
		cmdInput()
        refresh()
    end
end

--;===========================================================
--; F1 MESSAGE
--;===========================================================
function f_infoboxMenu()
	cmdInput()
--Draw Fade BG
	animDraw(fadeWindowBG)
--Draw Info Text
	f_textRender(infoboxCfg, txt_infobox, 0, 2, 10, 8.8, 0, -1)
--Actions
	if esc() or btnPalNo(p1Cmd, true) > 0 or btnPalNo(p2Cmd, true) > 0 or
	commandGetState(p1Cmd, 'e') or commandGetState(p1Cmd, 'u') or commandGetState(p1Cmd, 'd') or commandGetState(p1Cmd, 'l') or commandGetState(p1Cmd, 'r') or
	commandGetState(p2Cmd, 'e') or commandGetState(p2Cmd, 'u') or commandGetState(p2Cmd, 'd') or commandGetState(p2Cmd, 'l') or commandGetState(p2Cmd, 'r') 
	then
		--sndPlay(sndSys, 100, 2)
		f_infoboxReset()
	end
end

function f_infoboxReset()
	infoboxScreen = false
end

--;===========================================================
--; INFORMATION SCREEN
--;===========================================================
function f_infoMenu()
	cmdInput()
	local txt = ""
	local posX = 160
	local posY = 120
	local limit = 200
--Draw Fade BG
	animDraw(fadeWindowBG)
--Draw Menu BG
	animDraw(infoWindowBG)
--Draw Info Title Text
	textImgDraw(txt_infoTitle)
--Draw Info Text
	if stats.firstRun then txt = "WELCOME TO IKEMEN PLUS ULTRA ENGINE!"
	elseif resolutionInfo then txt = "SET A 16:9 RESOLUTION TO AVOID DESYNC"
	elseif licenseInfo then	txt = "NO LICENSES FOUND IN SCREENPACK.LUA"
	elseif vnInfo then txt = "NO VISUAL NOVELS FOUND IN SELECT.DEF"
	elseif vnDataInfo then txt = "NO SAVED GAMES FOUND."
	elseif charsInfo then txt = "NO CHARACTERS FOUND IN SELECT.DEF"
	elseif stagesInfo then txt = "NO STAGES FOUND IN SELECT.DEF"
	elseif configInfo then txt = "NO MAXMATCHES CONFIG FOUND IN SELECT.DEF"
	elseif towerInfo then txt = "NO TOWERS FOUND IN SELECT.DEF"
	elseif stviewerInfo then txt = "NO STAGE VIEWER FOUND IN SELECT.DEF"
	elseif bonusInfo then txt = "NO BONUS GAMES FOUND IN SELECT.DEF"
	elseif bossInfo then txt = "NO BOSSES FOUND IN SELECT.DEF"
	elseif missionInfo then	txt = "NO MISSIONS FOUND IN SCREENPACK.LUA"
	elseif eventInfo then txt = "NO EVENTS FOUND IN SCREENPACK.LUA"
	end
	f_textRender(txt_info, txt, 0, posX, posY, 10, 0, limit)
--[[Draw Cursor
	animSetWindow(cursorBox, 87,141, 144,13)
	f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
	animDraw(f_animVelocity(cursorBox, -1, -1))
]]
--Draw Input Hints Panel
	drawInfoInputHints()
--Accept Button
	if btnPalNo(p1Cmd, true) > 0 or btnPalNo(p2Cmd, true) > 0 then
		sndPlay(sndSys, 100, 2)
		if stats.firstRun then
			stats.firstRun = false
			f_saveStats()
		end
		f_infoReset()
	end
end

function f_infoReset()
	infoScreen = false
	resolutionInfo = false
	licenseInfo = false
	vnInfo = false
	vnDataInfo = false
	charsInfo = false
	stagesInfo = false
	configInfo = false
	towerInfo = false
	stviewerInfo = false
	bonusInfo = false
	bossInfo = false
	missionInfo = false
	eventInfo = false	
end

--;===========================================================
--; CONFIRM SCREEN
--;===========================================================
function f_confirmMenu(txt, font, bank, x, y, scaleX, scaleY, spacing, limit)
	cmdInput()
	local txt = txt or txt_confirmQuestion
	local txtFont = font or jgFnt
	local txtBank = bank or 0
	local txtX = x or 160
	local txtY = y or 96
	local txtScaleX = scaleX or 1
	local txtScaleY = scaleY or 1
	local txtSpacing = spacing or 10
	local txtLimit = limit or 300
--Cursor Position
	if commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u') then
		sndPlay(sndSys, 100, 0)
		confirmMenu = confirmMenu - 1
	elseif commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd') then
		sndPlay(sndSys, 100, 0)
		confirmMenu = confirmMenu + 1
	end
	if confirmMenu < 1 then
		confirmMenu = #t_confirmMenu
	elseif confirmMenu > #t_confirmMenu then
		confirmMenu = 1
	end
--Draw Fade BG
	animDraw(fadeWindowBG)
--Draw Menu BG
	animDraw(confirmWindowBG)
--Draw Title
	f_updateTextImg(txt_confirmTitle, txtFont, txtBank, 0, "", txtX, txtY, txtScaleX, txtScaleY)
	f_textRender(txt_confirmTitle, txt, 0, txtX, txtY, txtSpacing, 0, txtLimit)
--Draw Table Text
	for i=1, #t_confirmMenu do
		if i == confirmMenu then
			bank = 5
		else
			bank = 0
		end
		textImgDraw(f_updateTextImg(t_confirmMenu[i].id, jgFnt, bank, 0, t_confirmMenu[i].text, 159, 124+i*13))
	end
--Draw Cursor
	animSetWindow(cursorBox, 44,114+confirmMenu*13, 231,13)
	f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
	animDraw(f_animVelocity(cursorBox, -1, -1))
--Draw Input Hints Panel
	drawConfirmInputHints()
--Actions
	if commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then
		sndPlay(sndSys, 100, 2)
		f_confirmReset()
	elseif btnPalNo(p1Cmd, true) > 0 or btnPalNo(p2Cmd, true) > 0 then
	--YES
		if confirmMenu == 1 then
			sndPlay(sndSys, 100, 1)
		--CLOSE ENGINE
			if exitScreen then
				f_playTime()
				if restartEngine then
					sszReload()
				end
				os.exit()
		--DELETE HOST DATA
			elseif crudHostOption == 1 then
				f_crudHostReset()
				host_rooms.IP[hostRoomName] = nil
				t_tmp = {}
				for i = 1, #t_hostList do
					if i ~= hostList then
					t_tmp[#t_tmp + 1] = t_hostList[i]
					end
				end
				t_hostList = t_tmp
				f_saveOnlineRooms()
				f_hostTable() --Refresh
		--OTHERS
			else
				deleteReplay = true --For Replay Menu
				tourneyBack = true --For Tournament Menu
				exitAbyss = true --For Abyss Menu
			end
	--NO
		else
			sndPlay(sndSys, 100, 2)
			exitScreen = false
			crudHostOption = 0
		end
		f_confirmReset()
	end
end

function f_confirmReset()
	confirmScreen = false
	confirmMenu = 2 --Cursor pos in NO
end

--;===========================================================
--; EXIT MENU
--;===========================================================
t_exitMenu = {
	{id = textImgNew(), text = "CLOSE ENGINE"},
	{id = textImgNew(), text = "RESTART ENGINE"},
}

function f_exitMenu()
	cmdInput()
	local cursorPosY = 0
	local moveTxt = 0
	local exitMenu = 1
	local bufu = 0
	local bufd = 0
	local bufr = 0
	local bufl = 0
	local question = nil
	f_confirmReset()
	exitScreen = false
	if charsInfo or stagesInfo or configInfo then playBGM(bgmTitle) end
	while true do
		if not confirmScreen and not infoScreen then
			if commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u') or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30) then
				sndPlay(sndSys, 100, 0)
				exitMenu = exitMenu - 1
			elseif commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd') or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30) then
				sndPlay(sndSys, 100, 0)
				exitMenu = exitMenu + 1
			end
			if exitMenu < 1 then
				exitMenu = #t_exitMenu
				if #t_exitMenu > 4 then
					cursorPosY = 4
				else
					cursorPosY = #t_exitMenu-1
				end
			elseif exitMenu > #t_exitMenu then
				exitMenu = 1
				cursorPosY = 0
			elseif ((commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u')) or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30)) and cursorPosY > 0 then
				cursorPosY = cursorPosY - 1
			elseif ((commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd')) or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30)) and cursorPosY < 4 then
				cursorPosY = cursorPosY + 1
			end
			if cursorPosY == 4 then
				moveTxt = (exitMenu - 5) * 13
			elseif cursorPosY == 0 then
				moveTxt = (exitMenu - 1) * 13
			end
		--Enter Actions
			if btnPalNo(p1Cmd, true) > 0 or btnPalNo(p2Cmd, true) > 0 then
				restartEngine = false
			--EXIT FOR ATTRACT MODE (NO CONTENT)
				if exitMenu == 1 and data.attractMode and t_selChars == nil then
					sndPlay(sndSys, 100, 1)
					exitScreen = true
					confirmScreen = true
				elseif exitMenu == 1 and data.attractMode and t_selStages == nil then
					sndPlay(sndSys, 100, 1)
					exitScreen = true
					confirmScreen = true
			--RESTART FOR ATTRACT MODE (NO CONTENT)
				elseif exitMenu == 2 and data.attractMode and t_selChars == nil then
					sndPlay(sndSys, 100, 1)
					restartEngine = true
					exitScreen = true
					confirmScreen = true
				elseif exitMenu == 2 and data.attractMode and t_selStages == nil then
					sndPlay(sndSys, 100, 1)
					restartEngine = true
					exitScreen = true
					confirmScreen = true
			--NORMAL EXIT
				elseif exitMenu == 1 and data.attractMode == false then
					sndPlay(sndSys, 100, 1)
					exitScreen = true
					confirmScreen = true
			--NORMAL RESTART
				elseif exitMenu == 2 and data.attractMode == false then
					sndPlay(sndSys, 100, 1)
					restartEngine = true
					exitScreen = true
					confirmScreen = true
				end
		--BACK
			elseif commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then
				sndPlay(sndSys, 100, 2)
				break
			end
		end
		drawBottomMenuSP()
		for i=1, #t_exitMenu do
			if i == exitMenu then
				bank = 5
			else
				bank = 0
			end
			textImgDraw(f_updateTextImg(t_exitMenu[i].id, jgFnt, bank, 0, t_exitMenu[i].text, 159, 145+i*13-moveTxt))
		end
		if infoScreen then
			table.remove(t_exitMenu,3) --Remove Option 3 in table if characters or stages are not detected
		end
		if not confirmScreen and not infoScreen then
			animSetWindow(cursorBox, 0,148+cursorPosY*13, 316,13)
			f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
			animDraw(f_animVelocity(cursorBox, -1, -1))
		end
		drawMiddleMenuSP()
		textImgDraw(txt_titleFt)
		textImgSetText(txt_titleFt, "CLOSE OR RESTART ENGINE")
		f_sysTime()
		if confirmScreen then
			if restartEngine then question = txt_restartQuestion else question = txt_exitQuestion end
			f_confirmMenu(question) --Show Exit Confirm Message
		elseif infoScreen then
			f_infoMenu() --Show Info Screen Message
		else
			drawMainMenuInputHints()
		end
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		if commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu') then
			bufd = 0
			bufu = bufu + 1
		elseif commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd') then
			bufu = 0
			bufd = bufd + 1
		else
			bufu = 0
			bufd = 0
		end
		cmdInput()
		refresh()
	end
end

--;===========================================================
--; SIDE SELECT SCREEN
--;===========================================================
function f_sideSelect()
	cmdInput() --Read Inputs
--Controller Icon Config
	local p1gamepadPosY = 86.5
	local p2gamepadPosY = 150
	local gamepadScale = 0.10
--Text Config
	local p1txtPosY = 88
	local p2txtPosY = 152
	local txtScale = 0.7
	local txtFont = font13
	local txtP1name = "PLAYER 1"
	local txtP2name = "PLAYER 2"
	local txtP1color = 0
	local txtP2color = 1
--Arrows Confg
	local p1arrowPosY = 107.5
	local p2arrowPosY = 167.5
	local arrowScale = 0.5
--Center X Position
	local gamepadPosXcenter = 122
	local txtPosXcenter = 159
	local arrowLposXcenter = 104
	local arrowRposXcenter = 205
--Left X Position
	local gamepadPosXleft = 5
	local txtPosXleft = 42
	local arrowRposXleft = 88.5
--Right X Position
	local gamepadPosXright = 240
	local txtPosXright = 277
	local arrowLposXright = 220
	local function f_cpuL() f_drawQuickText(txt_sideCPU, font14, 0, 0, "CPU", txtPosXleft, 120) end
	local function f_cpuR() f_drawQuickText(txt_sideCPU, font14, 0, 0, "CPU", txtPosXright, 120) end
--P1 Cursor Position
	if commandGetState(p1Cmd, 'l') then
		if p1Side > -1 then
			sndPlay(sndSys, 100, 0)
			p1Side = p1Side - 1
		end
		sideWarning = false
	elseif commandGetState(p1Cmd, 'r') then
		if p1Side < 1 then
			sndPlay(sndSys, 100, 0)
			p1Side = p1Side + 1
		end
		sideWarning = false
	end
--P2 Cursor Position
	if commandGetState(p2Cmd, 'l') then
		if p2Side > -1 then
			sndPlay(sndSys, 100, 0)
			p2Side = p2Side - 1
		end
		sideWarning = false
	elseif commandGetState(p2Cmd, 'r') then
		if p2Side < 1 then
			sndPlay(sndSys, 100, 0)
			p2Side = p2Side + 1
		end
		sideWarning = false
	end
--Draw Fade BG
	animDraw(fadeWindowBG)
--Draw Screen Title
	textImgDraw(txt_sideTitle)
--Draw Side Texts
	f_drawQuickText(txt_sideInfo, font6, 0, 0, "LEFT SIDE", 42, 25, 0.9, 0.9)
	f_drawQuickText(txt_sideInfo, font6, 0, 0, "RIGHT SIDE", 277, 25, 0.9, 0.9)
--CPU VS CPU
	if p1Side == 0 and p2Side == 0 then
		f_cpuL()
		f_cpuR()
	end
--P1 & P2 VS CPU
	if p1Side == -1 and p2Side == -1 then
		f_cpuR()
	end
--CPU VS P1 & P2 (Not available yet)
	if p1Side == 1 and p2Side == 1 then
		f_cpuL()
	end
--P1 VS CPU
	if p1Side == -1 and p2Side == 0 then
		f_cpuR()
	end
--P2 VS CPU
	if p2Side == -1 and p1Side == 0 then
		f_cpuR()
	end
--CPU VS P1
	if p2Side == 0 and p1Side == 1 then
		f_cpuL()
	end
--CPU VS P2
	if p1Side == 0 and p2Side == 1 then
		f_cpuL()
	end
--Draw Lifebars
	f_drawQuickSpr(lifebarsImg, 3.5, 30, 0.25, 0.25, 200)
--Draw P1 Assets
	if p1Side == 0 then --Draw in Middle
		f_drawQuickSpr(gamepadIcon, gamepadPosXcenter, p1gamepadPosY, gamepadScale, gamepadScale) --Gamepad
		f_drawQuickSpr(sideSelArrowLeft, arrowLposXcenter, p1arrowPosY, arrowScale, arrowScale) --Left Arrow
		f_drawQuickSpr(sideSelArrowRight, arrowRposXcenter, p1arrowPosY, arrowScale, arrowScale) --Right Arrow
		f_drawQuickText(txt_sidePNo, txtFont, txtP1color, 0, txtP1name, txtPosXcenter, p1txtPosY, txtScale, txtScale) --Player ID
	elseif p1Side == -1 then --Draw in Left
		f_drawQuickSpr(gamepadIcon, gamepadPosXleft, p1gamepadPosY, gamepadScale, gamepadScale) --Gamepad
		f_drawQuickSpr(sideSelArrowRight, arrowRposXleft, p1arrowPosY, arrowScale, arrowScale) --Right Arrow
		f_drawQuickText(txt_sidePNo, txtFont, txtP1color, 0, txtP1name, txtPosXleft, p1txtPosY, txtScale, txtScale) --Player ID
	elseif p1Side == 1 then --Draw in Right
		f_drawQuickSpr(gamepadIcon, gamepadPosXright, p1gamepadPosY, gamepadScale, gamepadScale) --Gamepad
		f_drawQuickSpr(sideSelArrowLeft, arrowLposXright, p1arrowPosY, arrowScale, arrowScale) --Left Arrow
		f_drawQuickText(txt_sidePNo, txtFont, txtP1color, 0, txtP1name, txtPosXright, p1txtPosY, txtScale, txtScale) --Player ID
	end
--Draw P2 Assets
	if p2Side == 0 then
		f_drawQuickSpr(gamepadIcon, gamepadPosXcenter, p2gamepadPosY, gamepadScale, gamepadScale)
		f_drawQuickSpr(sideSelArrowLeft, arrowLposXcenter, p2arrowPosY, arrowScale, arrowScale)
		f_drawQuickSpr(sideSelArrowRight, arrowRposXcenter, p2arrowPosY, arrowScale, arrowScale)
		f_drawQuickText(txt_sidePNo, txtFont, txtP2color, 0, txtP2name, txtPosXcenter, p2txtPosY, txtScale, txtScale)
	elseif p2Side == -1 then
		f_drawQuickSpr(gamepadIcon, gamepadPosXleft, p2gamepadPosY, gamepadScale, gamepadScale)
		f_drawQuickSpr(sideSelArrowRight, arrowRposXleft, p2arrowPosY, arrowScale, arrowScale)
		f_drawQuickText(txt_sidePNo, txtFont, txtP2color, 0, txtP2name, txtPosXleft, p2txtPosY, txtScale, txtScale)
	elseif p2Side == 1 then
		f_drawQuickSpr(gamepadIcon, gamepadPosXright, p2gamepadPosY, gamepadScale, gamepadScale)
		f_drawQuickSpr(sideSelArrowLeft, arrowLposXright, p2arrowPosY, arrowScale, arrowScale)
		f_drawQuickText(txt_sidePNo, txtFont, txtP2color, 0, txtP2name, txtPosXright, p2txtPosY, txtScale, txtScale)
	end
--Draw Input Hint Panel
	drawSideInputHints()
--Draw Side Warning Message
	if sideWarning then
		textImgDraw(txt_sideWarning)
		data.p2In = 2 --Keep Active Player 2 Control
	end
--Actions
--Back
	if esc() or commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then
		sndPlay(sndSys, 100, 2)
		f_sideReset()
--Confirm
	elseif btnPalNo(p1Cmd, true) > 0 or btnPalNo(p2Cmd, true) > 0 then
	--Load Common Modes Config
		if menuSelect == "quick match" then randomModeCfg()
		elseif menuSelect == "free battle" then freeModeCfg()
		elseif menuSelect == "arcade" then arcadeCfg()
		elseif menuSelect == "tower" then towerCfg()
		elseif menuSelect == "survival" then survivalCfg()
		elseif menuSelect == "abyss" then abyssCfg()
		elseif menuSelect == "boss" then bossCfg()
		elseif menuSelect == "boss rush" then bossrushCfg()
		elseif menuSelect == "bonus" then bonusCfg()
		elseif menuSelect == "bonus rush" then bonusrushCfg()
		elseif menuSelect == "time rush" then timerushCfg()
		elseif menuSelect == "time attack" then timeattackCfg()
		elseif menuSelect == "score attack" then scoreattackCfg()
		elseif menuSelect == "kumite" then kumiteCfg()
		elseif menuSelect == "sudden death" then suddenCfg()
		elseif menuSelect == "endless" then endlessCfg()
		end
--Reference: -1 (Left Side), 0 (No Side/CPU), 1 (Right Side)
	--CPU VS CPU
		if p1Side == 0 and p2Side == 0 then
			if menuSelect == "quick match" then randomCPUvsCPU()
			elseif menuSelect == "free battle" then freeCPUvsCPU()
			elseif menuSelect == "arcade" then arcadeCPUvsCPU()
			elseif menuSelect == "tower" then towerCPUvsCPU()
			elseif menuSelect == "survival" then survivalCPUvsCPU()
			elseif menuSelect == "abyss" then abyssCPUvsCPU()
			elseif menuSelect == "boss" then bossCPUvsCPU()
			elseif menuSelect == "boss rush" then bossrushCPUvsCPU()
			elseif menuSelect == "time rush" then timerushCPUvsCPU()
			elseif menuSelect == "time attack" then timeattackCPUvsCPU()
			elseif menuSelect == "score attack" then scoreattackCPUvsCPU()
			elseif menuSelect == "kumite" then kumiteCPUvsCPU()
			elseif menuSelect == "sudden death" then suddenCPUvsCPU()
			elseif menuSelect == "endless" then endlessCPUvsCPU()
			end
			if menuSelect ~= "bonus rush" and menuSelect ~= "bonus" then
				sideSelected = true
			else--if you are in bonus rush mode then
				sndPlay(sndIkemen, 200, 0)
				sideWarning = true
				f_discordMainMenu()
			end
		end
	--P1 VS CPU
		if p1Side == -1 and p2Side == 0 then
			if menuSelect == "quick match" then	randomHumanvsCPU()
			elseif menuSelect == "free battle" then freeHumanvsCPU()
			elseif menuSelect == "arcade" then arcadeHumanvsCPU()
			elseif menuSelect == "tower" then towerHumanvsCPU()
			elseif menuSelect == "survival" then survivalHumanvsCPU()
			elseif menuSelect == "abyss" then abyssHumanvsCPU()
			elseif menuSelect == "boss" then bossHumanvsCPU()
			elseif menuSelect == "boss rush" then bossrushHumanvsCPU()
			elseif menuSelect == "bonus" then bonusHumanvsCPU()
			elseif menuSelect == "bonus rush" then bonusrushHumanvsCPU()
			elseif menuSelect == "time rush" then timerushHumanvsCPU()
			elseif menuSelect == "time attack" then timeattackHumanvsCPU()
			elseif menuSelect == "score attack" then scoreattackHumanvsCPU()
			elseif menuSelect == "kumite" then kumiteHumanvsCPU()
			elseif menuSelect == "sudden death" then suddenHumanvsCPU()
			elseif menuSelect == "endless" then endlessHumanvsCPU()
			end
			sideSelected = true
		end
	--P2 VS CPU
		if p2Side == -1 and p1Side == 0 then
			P2overP1 = true --Detects Player 2 Control
			if menuSelect == "quick match" then	randomHumanvsCPU()
			elseif menuSelect == "free battle" then freeHumanvsCPU()
			elseif menuSelect == "arcade" then arcadeHumanvsCPU()
			elseif menuSelect == "tower" then towerHumanvsCPU()
			elseif menuSelect == "survival" then survivalHumanvsCPU()
			elseif menuSelect == "abyss" then abyssHumanvsCPU()
			elseif menuSelect == "boss" then bossHumanvsCPU()
			elseif menuSelect == "boss rush" then bossrushHumanvsCPU()
			elseif menuSelect == "bonus" then bonusHumanvsCPU()
			elseif menuSelect == "bonus rush" then bonusrushHumanvsCPU()
			elseif menuSelect == "time rush" then timerushHumanvsCPU()
			elseif menuSelect == "time attack" then timeattackHumanvsCPU()
			elseif menuSelect == "score attack" then scoreattackHumanvsCPU()
			elseif menuSelect == "kumite" then kumiteHumanvsCPU()
			elseif menuSelect == "sudden death" then suddenHumanvsCPU()
			elseif menuSelect == "endless" then endlessHumanvsCPU()
			end
			sideSelected = true
		end
	--CPU VS P1
		if p2Side == 0 and p1Side == 1 then
			if menuSelect == "quick match" then	randomCPUvsHuman()
			elseif menuSelect == "free battle" then freeCPUvsHuman()
			elseif menuSelect == "arcade" then arcadeCPUvsHuman()
			elseif menuSelect == "tower" then towerCPUvsHuman()
			elseif menuSelect == "survival" then survivalCPUvsHuman()
			elseif menuSelect == "abyss" then abyssCPUvsHuman()
			elseif menuSelect == "boss" then bossCPUvsHuman()
			elseif menuSelect == "boss rush" then bossrushCPUvsHuman()
			elseif menuSelect == "bonus" then bonusCPUvsHuman()
			elseif menuSelect == "bonus rush" then bonusrushCPUvsHuman()
			elseif menuSelect == "time rush" then timerushCPUvsHuman()
			elseif menuSelect == "time attack" then timeattackCPUvsHuman()
			elseif menuSelect == "score attack" then scoreattackCPUvsHuman()
			elseif menuSelect == "kumite" then kumiteCPUvsHuman()
			elseif menuSelect == "sudden death" then suddenCPUvsHuman()
			elseif menuSelect == "endless" then endlessCPUvsHuman()
			end
			sideSelected = true
		end
	--CPU VS P2
		if p1Side == 0 and p2Side == 1 then
			P2overP1 = true --Detects Player 2 Control
			if menuSelect == "quick match" then	randomCPUvsHuman()
			elseif menuSelect == "free battle" then freeCPUvsHuman()
			elseif menuSelect == "arcade" then arcadeCPUvsHuman()
			elseif menuSelect == "tower" then towerCPUvsHuman()
			elseif menuSelect == "survival" then survivalCPUvsHuman()
			elseif menuSelect == "abyss" then abyssCPUvsHuman()
			elseif menuSelect == "boss" then bossCPUvsHuman()
			elseif menuSelect == "boss rush" then bossrushCPUvsHuman()
			elseif menuSelect == "bonus" then bonusCPUvsHuman()
			elseif menuSelect == "bonus rush" then bonusrushCPUvsHuman()
			elseif menuSelect == "time rush" then timerushCPUvsHuman()
			elseif menuSelect == "time attack" then timeattackCPUvsHuman()
			elseif menuSelect == "score attack" then scoreattackCPUvsHuman()
			elseif menuSelect == "kumite" then kumiteCPUvsHuman()
			elseif menuSelect == "sudden death" then suddenCPUvsHuman()
			elseif menuSelect == "endless" then endlessCPUvsHuman()
			end
			sideSelected = true
		end
	--P1 VS P2
		if p1Side == -1 and p2Side == 1 then
			if menuSelect == "quick match" then randomHumanvsHuman()
			elseif menuSelect == "free battle" then freeHumanvsHuman()
			end
			if menuSelect == "quick match" or menuSelect == "free battle" then
				sideSelected = true
			else--if you are not in free versus or quick match modes then
				sndPlay(sndIkemen, 200, 0)
				sideWarning = true
				f_discordMainMenu()
			end
		end
	--P2 VS P1
		if p2Side == -1 and p1Side == 1 then
			P2overP1 = true
			if menuSelect == "quick match" then randomHumanvsHuman()
			elseif menuSelect == "free battle" then freeHumanvsHuman()
			end
			if menuSelect == "quick match" or menuSelect == "free battle" then
				sideSelected = true
			else--if you are not in free versus or quick match modes then
				sndPlay(sndIkemen, 200, 0)
				P2overP1 = false
				sideWarning = true
				f_discordMainMenu()
			end
		end
	--P1&P2 VS CPU [CO-OP MODE]
		if p1Side == -1 and p2Side == -1 then
			--if menuSelect == "quick match" then randomP1P2vsCPU()
			--elseif menuSelect == "free battle" then freeP1P2vsCPU()
			if menuSelect == "arcade" then arcadeP1P2vsCPU()
			elseif menuSelect == "tower" then towerP1P2vsCPU()
			elseif menuSelect == "survival" then survivalP1P2vsCPU()
			elseif menuSelect == "abyss" then abyssP1P2vsCPU()
			elseif menuSelect == "boss rush" then bossrushP1P2vsCPU()
			elseif menuSelect == "bonus rush" then bonusrushP1P2vsCPU()
			elseif menuSelect == "time rush" then timerushP1P2vsCPU()
			elseif menuSelect == "time attack" then timeattackP1P2vsCPU()
			elseif menuSelect == "score attack" then scoreattackP1P2vsCPU()
			elseif menuSelect == "kumite" then kumiteP1P2vsCPU()
			elseif menuSelect == "sudden death" then suddenP1P2vsCPU()
			elseif menuSelect == "endless" then endlessP1P2vsCPU()
			end
			if menuSelect ~= "quick match" and menuSelect ~= "free battle" and menuSelect ~= "bonus" and menuSelect ~= "boss" then
				sideSelected = true
			else
				sndPlay(sndIkemen, 200, 0)
				sideWarning = true
				f_discordMainMenu()
			end
		end
	--CPU VS P1&P2 [CO-OP MODE] (Not available yet)
		if p1Side == 1 and p2Side == 1 then
			--if menuSelect == "quick match" then randomCPUvsP1P2()
			--elseif menuSelect == "free battle" then freeCPUvsP1P2()
			if menuSelect == "arcade" then arcadeCPUvsP1P2()
			elseif menuSelect == "tower" then towerCPUvsP1P2()
			elseif menuSelect == "survival" then survivalCPUvsP1P2()
			elseif menuSelect == "abyss" then abyssCPUvsP1P2()
			elseif menuSelect == "boss rush" then bossrushCPUvsP1P2()
			elseif menuSelect == "bonus rush" then bonusrushCPUvsP1P2()
			elseif menuSelect == "time rush" then timerushCPUvsP1P2()
			elseif menuSelect == "time attack" then timeattackCPUvsP1P2()
			elseif menuSelect == "score attack" then scoreattackCPUvsP1P2()
			elseif menuSelect == "kumite" then kumiteCPUvsP1P2()
			elseif menuSelect == "sudden death" then suddenCPUvsP1P2()
			elseif menuSelect == "endless" then endlessCPUvsP1P2()
			end
			if menuSelect ~= "quick match" and menuSelect ~= "free battle" and menuSelect ~= "bonus" and menuSelect ~= "boss" then
				sideSelected = true
			else
				sndPlay(sndIkemen, 200, 0)
				sideWarning = true
				f_discordMainMenu()
			end
		end
		if sideSelected then f_sideReset() end
	end
end

function f_sideReset()
	sideScreen = false
	sideSelected = false
	sideWarning = false
	p1Side = 0 --P1 Cursor pos in Middle
	p2Side = 0 --P2 Cursor pos in Middle
end

--;===========================================================
--; INTERMISSION (SECRET FIGHT)
--;===========================================================
function f_intermission() --Secret Fight Intro
	cmdInput()
	local intermissionTime = 0
	local intermissionTxt = f_extractText(txt_intermissionBox)
	local black = 0 --alphaS
	local charPortrait = false
	local charAnim = false
	secretSel = t_secretChallenger[math.random(#t_secretChallenger)].cel --pick a random intermission char
	secretChar = t_selChars[secretSel+1] --use previous selection to get table position
	local scaleData = nil
	if secretChar.intermissionSprScale ~= nil then
		scaleData = secretChar.intermissionSprScale
	else
		scaleData = "1.0,1.0"
	end
	local xPortScale, yPortScale = scaleData:match('^([^,]-)%s*,%s*(.-)$')
	if secretChar.sffData ~= nil and secretChar.stand ~= nil then
		charAnim = f_animFromTable(secretChar['stand'], secretChar.sffData, 160, 180, secretChar.xscale, secretChar.yscale, 0, 1, black)
	end
	if secretChar.sffData ~= nil and secretChar.intermissionSpr ~= nil then
		charPortrait = f_animFromTable(secretChar['intermissionSpr'], secretChar.sffData, 0, 40, xPortScale, yPortScale, 0, 1, black)
	end
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	playBGM(bgmIntermission)
	while true do
		if intermissionTime == 500 then
			break
		end
		intermissionTime = intermissionTime + 1
	--Draw BG Assets
		animDraw(f_animVelocity(selectHardBG0, -1, -1))
	--animDraw(f_animVelocity(intermissionBG0, -1, -1))
		animDraw(intermissionBG2)
		animDraw(f_animVelocity(intermissionWindowSlideU, -1.5, 0))
		animDraw(f_animVelocity(intermissionWindowSlideD, 1.5, 0))
	--Draw Warning Text
		textImgDraw(f_textVelocity(txt_warningInterU, -1.5, 0))
		textImgDraw(f_textVelocity(txt_warningInterD, 1.2, 0))
	--Draw Approaching Text
		for i = 1, #intermissionTxt do
			textImgDraw(f_updateTextImg(textImgNew(), jgFnt, 5, 0, intermissionTxt[i], 255, 115 + 12 * (i - 1)))
		end
	--Draw Character Portraits
		if data.portraitDisplay == "Portrait" or data.portraitDisplay == "Mixed" then
			if charPortrait then
				animDraw(charPortrait)
				animUpdate(charPortrait)
			end
		end
	--Draw Character Sprite Animations
		if data.portraitDisplay == "Sprite" or data.portraitDisplay == "Mixed" then
			if charAnim then
				animDraw(charAnim)
				animUpdate(charAnim)
			end
		end
		--animDraw(data.fadeTitle)
		--animUpdate(data.fadeTitle)
		cmdInput()
		refresh()
	end
end

function f_getIntermission()
t_secretChallenger = {} --If you use a char that can appear in the intermission, this table will guarantee when randomizing it you fight against another
for i, c in ipairs(t_intermissionChars) do --Read all table items and save each value in c var
	local intermissionChar = c['path'] --Create variable with name from t_intermissionChars now stored in c var (Since it is in a for, the name will be different in each loop)
	if getPlayerSide() == "p1left" or getPlayerSide() == "p2left" then
		selectaChar = data.t_p1selected[1]['path'] --Create another variable with the first name from data.t_p1selected (Your Selected Character)
	elseif getPlayerSide() == "p1right" or getPlayerSide() == "p2right" then
		selectaChar = data.t_p2selected[1]['path']
	end
	if intermissionChar ~= selectaChar then --Compare both names stored in previous vars and if the names are differents:
	--Add only different intermission chars from the one you are using in this table
		table.insert(t_secretChallenger, {['cel'] = t_charDef[intermissionChar], ['name'] = t_selChars[t_charDef[intermissionChar]+1].name, ['displayname'] = t_selChars[t_charDef[intermissionChar]+1].displayname, ['path'] = intermissionChar, ['author'] = t_selChars[t_charDef[intermissionChar]+1].author})
	end
end
if data.debugLog then f_printTable(t_secretChallenger, "save/debug/t_secretChallenger.log") end
end

function f_secretFight()
	--Load Side Player Data
	if getPlayerSide() == "p1left" or getPlayerSide() == "p2left" then
		keepLSide = true
	elseif getPlayerSide() == "p1right" or getPlayerSide() == "p2right" then
		keepRSide = true
	end
	f_default()
	data.rosterMode = "versus"
	data.gameMode = "intermission"
	setGameMode('intermission')
	setRoundTime(-1)
	data.victoryscreen = false
	--ARCADE PLAYER IS IN LEFT SIDE - SECRET CHALLENGER COMES FROM RIGHT SIDE
	if keepLSide then
		data.p1TeamMenu = {mode = 0, chars = 1} --{mode = p1RestoreTeamMode, chars = p1RestoreCharsNo}
		data.p2TeamMenu = {mode = 0, chars = 1}
		data.p1Char = {data.t_p1selected[1].path} --Get previous Arcade Character Selected
		data.p2Char = {secretChar.char} --Set intermission rival
		data.p1Pal = data.t_p1selected[1].pal --Get previous Palette Selected
		data.p2Pal = 1
		if P2overP1 then
			remapInput(1, 2)
		end
		data.p2In = 1
--ARCADE PLAYER IS IN RIGHT SIDE - SECRET CHALLENGER COMES FROM LEFT SIDE
	elseif keepRSide then
		data.p1TeamMenu = {mode = 0, chars = 1}
		data.p2TeamMenu = {mode = 0, chars = 1} --{mode = p2RestoreTeamMode, chars = p2RestoreCharsNo}
		data.p1Char = {secretChar.char}
		data.p2Char = {data.t_p2selected[1].path}
		data.p1Pal = 1
		data.p2Pal = data.t_p2selected[1].pal
		remapInput(1, 2)
		if not P2overP1 then
			remapInput(2, 1)
		end
		setPlayerSide('p1right')
		data.p1In = 2
		data.p2In = 2
	end
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	f_selectSimple()
	if getPlayerSide() == "p1right" then --Player 1 in Right Side
		if winner == 2 then --Save progress only if you win
			secretTarget = data.t_p1selected --store character data to use for unlocking purposes
			f_secretProgress()
		end
	else --Player 1 in Left Side
		if winner == 1 then
			secretTarget = data.t_p2selected
			f_secretProgress()
		end
	end
end

function f_secretProgress()
local goukiName = "Shin Gouki"
local unlockScreen = t_selChars[secretTarget[1].cel+1]
--Show Unlock Screen if is available
if unlockScreen.UnlockStoryboard ~= nil and io.open(unlockScreen.UnlockStoryboard or '','r') ~= nil then
	f_storyboard(unlockScreen.UnlockStoryboard)
elseif unlockScreen.UnlockVideo ~= nil and io.open(unlockScreen.UnlockVideo or '','r') ~= nil then
	playVideo(unlockScreen.UnlockVideo)
end
if secretTarget[1].displayname == goukiName then stats.unlocks.chars.gouki = true end --Unlock Shin Gouki if you defeat him in arcade intermission
secretTarget = "" --Reset Var
f_saveStats()
end

--;===========================================================
--; CHARACTER SELECT CONFIG
--;===========================================================
--Icon for random select
function f_randomSlot()
cellRandomSprGroup = 151 --System.def cell.random.spr for Group
cellRandomSprIndex = 0 --System.def cell.random.spr for Index
cellRandomSprScaleX = data.cellScaleX
cellRandomSprScaleY = data.cellScaleY
setRandomSpr(sprSys, cellRandomSprGroup, cellRandomSprIndex, cellRandomSprScaleX, cellRandomSprScaleY) --Random Icon
cellRandomSwitchTime = 4 --Time to wait before changing to another random portrait (TODO)
end

function f_rosterReset()
	selectRows = data.selectRows --Get Number of Character Select Rows
	selectColumns = data.selectColumns --Get Number of Character Select Columns
	offsetRows = data.offsetRows --Get Number of Character Select Hidden Rows Slots
	offsetColumns = data.offsetColumns --Get Number of Character Select Hidden Columns Slots (TODO)
	setSelColRow(selectColumns, selectRows)
	--let cursor wrap around
	wrappingX = data.wrappingX --System.def: wrapping for X (true = 1, false = 0)
	wrappingY = data.wrappingY --System.def: wrapping for Y (true = 1, false = 0)
	--Position to draw to
	if data.p2Faces and data.selectType == "Advanced" then --When you play in Multiplayer and Roster Type is like BlazBlue Cross Tag Battle the roster will be divided into 2 and the 2nd player can choose without the screen being cut
		p1FaceX = data.p1FaceX --System.def: pos for X (Left Side)
		p1FaceY = data.p1FaceY --System.def: pos for Y (Left Side)
		p2FaceX = data.p2FaceX --System.def: pos for X (Right Side)
		p2FaceY = data.p2FaceY --System.def: pos for Y (Right Side)
	else --When you play in Single Player or Roster Type is Simple Type
		if data.selectType == "Simple" then
			p1FaceX = data.p1FaceX
			p1FaceY = data.p1FaceY
		elseif data.selectType == "Advanced" then --Custom Positions for Single Play in Advanced Roster Type (TODO: Also configurate this via options)
			p1FaceX = 90
			p1FaceY = data.p1FaceY
		end
		--if not data.p1SelectMenu then
			p2FaceX = data.p1FaceX
			p2FaceY = data.p1FaceY
		--end
		if data.selectType == "Simple" then
			offsetRows = 0
			offsetColumns = 0
		end
	end
	--Empty Cells
	showemptyboxes = true --TODO
	moveoveremptyboxes = false --allow cursor to move over empty boxes (TODO)
	--Size of each cell (in pixels)
	cellSizeX = data.cellSizeX --System.def: cell.size for X
	cellSizeY = data.cellSizeY --System.def: cell.size for Y
	--Space between each cell
	cellSpacingX = data.cellSpacingX --System.def: cell.spacing for X
	cellSpacingY = data.cellSpacingY --System.def: cell.spacing for Y
	setSelCellSize(cellSizeX+cellSpacingX, cellSizeY+cellSpacingY) --Slot Size
	setSelCellScale(data.cellScaleX, data.cellScaleY) --Slot Scale (System.def: cell.bg.scale)
	f_randomSlot()
end

function f_p1sideReset()
p1Cell = nil
p1Portrait = nil
p1memberPreview = nil
f_p1randomReset()
data.t_p1selected = {}
p1TeamEnd = false
p1CharEnd = false
p1PalEnd = false
p1HandicapEnd = false
p1SelEnd = false
p1BG = false
p1SelBack = false
p1TeamBack = true
p1PalSel = 1
p1HandicapSel = 1
p1HandicapCursorPosY = 1
p1HandicapMoveTxt = 0
randomP1Rematch = false
end

function f_p1randomReset()
p1member1Random = false
p1member2Random = false
p1member3Random = false
p1member4Random = false
end

function f_p2sideReset()
p2coopReady = false
p2Cell = nil
p2Portrait = nil
p2memberPreview = nil
f_p2randomReset()
data.t_p2selected = {}
p2TeamEnd = false
p2CharEnd = false
p2PalEnd = false
p2HandicapEnd = false
p2SelEnd = false
p2BG = false
p2SelBack = false
p2TeamBack = true
p2PalSel = 1
p2HandicapSel = 1
p2HandicapCursorPosY = 1
p2HandicapMoveTxt = 0
randomP2Rematch = false
end

function f_p2randomReset()
p2coopRandom = false
p2member1Random = false
p2member2Random = false
p2member3Random = false
p2member4Random = false
end

function f_stageSelectReset()
stageMenuActive = false
exclusiveStageMenu = false
stageChosen = false
stageSelect = true
songSelect = false
p1stage = false
p2stage = false
p1autoSlot = false
p2autoSlot = false
p1song = false
p2song = false
stageAnnouncer = false
announcerTimer = 0
randomStageRematch = false
end

function f_selectReset()
	commandBufReset(p1Cmd)
	commandBufReset(p2Cmd)
	f_rosterReset()
	f_p1sideReset()
	f_p2sideReset()
	selectStart()
	f_stageSelectReset()
	if data.p2In == 1 then
		p2TeamEnd = true
		p2SelEnd = true
	end
	if data.p1In == 2 and data.p2In == 2 then
		p1TeamEnd = true
		p1SelEnd = true
	end
	--if not data.p1SelectMenu then
		--p1SelEnd = true
	--end
	if not data.p2SelectMenu then
		p2SelEnd = true
	end
	keepLSide = false
	keepRSide = false
	selScreenEnd = false
	stageEnd = false
	charSelect = true
	p1numChars = 1
	p2numChars = 1
	p1teamMode = 0
	p2teamMode = 0
	p1numTurns = 2
	p2numTurns = 2
	p1numSimul = 2
	p2numSimul = 2
	matchNo = 0
	setMatchNo(matchNo)
	rematchEnd = false
	battleOption = 0
	battleOption2 = 0
	backScreen = false
	back = false
	serviceBack = false
end

function f_selectInit()
	p1SelX = data.p1SelX --System.def: p1CursorStartcell for X
	p1SelY = data.p1SelY --System.def: p1CursorStartcell for Y
	p2SelX = data.p2SelX --System.def: p2CursorStartcell for X
	p2SelY = data.p2SelY --System.def: p2CursorStartcell for Y
	p1FaceOffset = 0
	p2FaceOffset = 0
	p1OffsetRow = 0
	p2OffsetRow = 0
	p1OffsetColumn = 0
	p2OffsetColumn = 0
	back = false
	--Quick Scrolling Vars
	bufTmu = 0
	bufTmd = 0
	bufTmr = 0
	bufTml = 0
	
	bufTm2u = 0
	bufTm2d = 0
	bufTm2r = 0
	bufTm2l = 0
	--
	bufSelu = 0
	bufSeld = 0
	bufSelr = 0
	bufSell = 0
	
	bufSel2u = 0
	bufSel2d = 0
	bufSel2r = 0
	bufSel2l = 0
	--
	bufPalu = 0
	bufPald = 0
	bufPalr = 0
	bufPall = 0
	
	bufPal2u = 0
	bufPal2d = 0
	bufPal2r = 0
	bufPal2l = 0
	--
	bufHandu = 0
	bufHandd = 0
	bufHandr = 0
	bufHandl = 0
	
	bufHand2u = 0
	bufHand2d = 0
	bufHand2r = 0
	bufHand2l = 0
	--
	bufStageu = 0
	bufStaged = 0
	bufStager = 0
	bufStagel = 0
	--Timers
	selectSeconds = data.selectTime
	stageSeconds = data.stageTime
	rematchSeconds = data.rematchTime
	serviceSeconds = data.serviceTime
	destinySeconds = data.destinyTime
	selectTimer = selectSeconds*gameTick --Set time for Character Select
	stageTimer = stageSeconds*gameTick --Set time for Stage Select
	rematchTimer = rematchSeconds*gameTick --Set time for Rematch Option
	serviceTimer = serviceSeconds*gameTick --Set time for Service Option
	destinyTimer = destinySeconds*gameTick --Set time for Tower/Destiny Select
	if data.rosterAdvanced == true and data.stageMenu == false then
		--For Advanced Modes without Stage Select
	else
		stageList = 0
	end
	musicList = 0
	gameNo = 0
	bossNo = 0
	bonusNo = 0
	p1Wins = 0
	p2Wins = 0
	winner = 0
	winCnt = 0
	looseCnt = 0
	clearTime = 0
	matchTime = 0
	waitingTowerSel = false
end

function f_setRounds()
	local roundsToWin = data.roundsNum --Use default rounds saved in settings
	if (data.p1In == 2 and data.p2In == 2) then --Player 1 in player 2 (right) side
	--Set New Rounds To Win from select.def chars section
		if t_selChars[data.t_p1selected[1].cel+1].rounds ~= nil then
			roundsToWin = t_selChars[data.t_p1selected[1].cel+1].rounds
		end
	else
		if t_selChars[data.t_p2selected[1].cel+1].rounds ~= nil then
			roundsToWin = t_selChars[data.t_p2selected[1].cel+1].rounds
		end
	end
	setRoundsToWin(roundsToWin)
end

function f_setRoundTime()
	local roundTime = data.roundTime --Use default time saved in settings
--Set New Time from select.def ExtraStages section
--[[
	if t_selStages[stageNo].roundtime ~= nil then
		roundTime = t_selChars[stageNo].roundtime
	end
]]
	if (data.p1In == 2 and data.p2In == 2) then --Player 1 in player 2 (right) side
	--Set New Time from select.def chars section
		if t_selChars[data.t_p1selected[1].cel+1].roundtime ~= nil then
			roundTime = t_selChars[data.t_p1selected[1].cel+1].roundtime
		end
	else
		if t_selChars[data.t_p2selected[1].cel+1].roundtime ~= nil then
			roundTime = t_selChars[data.t_p2selected[1].cel+1].roundtime
		end
	end
	setRoundTime(roundTime * 60)
end

function f_setZoom()
	local zoom = data.zoomStage.zoom --data.zoomActive
	if (data.p1In == 2 and data.p2In == 2) then --Player 1 in player 2 (right) side
		if t_selChars[data.t_p1selected[1].cel+1].zoom ~= nil then
			if t_selChars[data.t_p1selected[1].cel+1].zoom == 1 then
				zoom = true
			else
				zoom = false
			end
		elseif t_selStages[stageNo].zoom ~= nil then
			if t_selChars[stageNo].zoom == 1 then
				zoom = true
			else
				zoom = false
			end
		end
	else
		if t_selChars[data.t_p2selected[1].cel+1].zoom ~= nil then
			if t_selChars[data.t_p2selected[1].cel+1].zoom == 1 then
				zoom = true
			else
				zoom = false
			end
		elseif t_selStages[stageNo].zoom ~= nil then
			if t_selChars[stageNo].zoom == 1 then
				zoom = true
			else
				zoom = false
			end
		end
	end
	setZoom(zoom)
	local zoomMin = data.zoomStage.zoomOut --data.zoomMin
	if t_selStages[stageNo].zoommin ~= nil then
		zoomMin = t_selStages[stageNo].zoommin
	end
	setZoomMin(zoomMin)
	local zoomMax = data.zoomStage.zoomIn --data.zoomMax
	if t_selStages[stageNo].zoommax ~= nil then
		zoomMax = t_selStages[stageNo].zoommax
	end
	setZoomMax(zoomMax)
	local zoomSpeed = data.zoomStage.zoomSpeed --data.zoomSpeed
	if t_selStages[stageNo].zoomspeed ~= nil then
		zoomSpeed = t_selStages[stageNo].zoomspeed
	end
	setZoomSpeed(zoomSpeed)
end

function f_makeRoster()
	t_roster = {}
	local t = {}
	local cnt = 0
--Arcade
	if data.gameMode == "arcade" then
		if (data.p1In == 2 and data.p2In == 2) then --Player 1 in player 2 (right) side
			if p1teamMode == 0 then --Single
				t = t_selOptions.arcademaxmatches
			else --Team
				t = t_selOptions.teammaxmatches
			end
		else
			if p2teamMode == 0 then --Single
				t = t_selOptions.arcademaxmatches
			else --Team
				t = t_selOptions.teammaxmatches
			end
		end
		for i=1, #t do --for each order number
			if (data.p1In == 2 and data.p2In == 2) then --Player 1 in player 2 (right) side
				cnt = t[i] * p1numChars --set amount of matches to get from the table
			else
				cnt = t[i] * p2numChars --set amount of matches to get from the table
			end
			if cnt > 0 and t_orderChars[i] ~= nil then --if it's more than 0 and there are characters with such order
				while cnt > 0 do --do the following until amount of matches for particular order is reached
					f_shuffleTable(t_orderChars[i]) --randomize characters table
					for j=1, #t_orderChars[i] do --loop through chars associated with that particular order
						t_roster[#t_roster+1] = t_orderChars[i][j] --and add such character into new table
						cnt = cnt - 1
						if cnt == 0 then --but only if amount of matches for particular order has not been reached yet
							break
						end
					end
				end
			end
		end
--Survival / Boss Rush / Bonus Rush / All Roster / Abyss / Endless
	else
		if data.gameMode == "survival" or data.gameMode == "allroster" or data.gameMode == "abyss" or data.gameMode == "endless" then
			t = t_randomChars
			cnt = #t
			local i = 0
			if (data.p1In == 2 and data.p2In == 2) then --Player 1 in player 2 (right) side
				while cnt / p1numChars ~= math.ceil(cnt / p1numChars) do --not integer
					i = i + 1
					cnt = #t + i
				end
			else
				while cnt / p2numChars ~= math.ceil(cnt / p2numChars) do --not integer
					i = i + 1
					cnt = #t + i
				end
			end
		elseif data.gameMode == "bossrush" or data.gameMode == "bonusrush" then
			if data.gameMode == "bossrush" then t = t_bossChars
			elseif data.gameMode == "bonusrush" then t = t_bonusChars
			end
			cnt = #t
			local i = 0
			if (data.p1In == 2 and data.p2In == 2) then
				while cnt / p1numChars ~= math.ceil(cnt / p1numChars) do
					i = i + 1
					cnt = #t + i
				end
			else
				while cnt / p2numChars ~= math.ceil(cnt / p2numChars) do
					i = i + 1
					cnt = #t + i
				end
			end
		elseif data.gameMode == 'vskumite' then
			t = t_randomChars
			if (data.p1In == 2 and data.p2In == 2) then
				cnt = data.kumite * p1numChars
			else
				cnt = data.kumite * p2numChars
			end
		end
		while cnt > 0 do
			f_shuffleTable(t)
			for i=1, #t do
				t_roster[#t_roster+1] = t[i]
				cnt = cnt - 1
				if cnt == 0 then
					break
				end
			end
		end
	end
	if data.debugLog then f_printTable(t_roster, "save/debug/t_roster.log") end
end

function f_aiRamp()
	local start_match = 0
	local start_diff = 0
	local end_match = 0
	local end_diff = 0
	t_aiRamp = {}
	--Arcade
	if data.gameMode == "arcade" or data.gameMode == "tower" then
		if (data.p1In == 2 and data.p2In == 2) then --Player 1 in player 2 (right) side
			if p1teamMode == 0 then --Single
				start_match = t_selOptions.arcadestart.wins
				start_diff = t_selOptions.arcadestart.offset
				end_match =  t_selOptions.arcadeend.wins
				end_diff = t_selOptions.arcadeend.offset
			else --Team
				start_match = t_selOptions.teamstart.wins
				start_diff = t_selOptions.teamstart.offset
				end_match =  t_selOptions.teamend.wins
				end_diff = t_selOptions.teamend.offset
			end
		else
			if p2teamMode == 0 then --Single
				start_match = t_selOptions.arcadestart.wins
				start_diff = t_selOptions.arcadestart.offset
				end_match =  t_selOptions.arcadeend.wins
				end_diff = t_selOptions.arcadeend.offset
			else --Team
				start_match = t_selOptions.teamstart.wins
				start_diff = t_selOptions.teamstart.offset
				end_match =  t_selOptions.teamend.wins
				end_diff = t_selOptions.teamend.offset
			end
		end
	elseif data.gameMode == "survival" then
		start_match = t_selOptions.survivalstart.wins
		start_diff = t_selOptions.survivalstart.offset
		end_match =  t_selOptions.survivalend.wins
		end_diff = t_selOptions.survivalend.offset
	end
	local startAI = data.difficulty + start_diff
	if startAI > 8 then
		startAI = 8
	elseif startAI < 1 then
		startAI = 1
	end
	local endAI = data.difficulty + end_diff
	if endAI > 8 then
		endAI = 8
	elseif endAI < 1 then
		endAI = 1
	end
	for i=1, lastMatch do
		if i-1 <= start_match then
			t_aiRamp[#t_aiRamp+1] = startAI
		elseif i-1 <= end_match then
			local curMatch = i - (start_match + 1)
			t_aiRamp[#t_aiRamp+1] = math.floor(curMatch * (endAI - startAI) / (end_match - start_match) + startAI)
		else
			t_aiRamp[#t_aiRamp+1] = endAI
		end
	end
	if data.debugLog then f_printTable(t_aiRamp, "save/debug/t_aiRamp.log") end
end

function f_difficulty(player, offset)
	local t = {}
	if player % 2 ~= 0 then --odd value
		pos = math.floor(player / 2 + 0.5)
		t = t_selChars[data.t_p1selected[pos].cel+1]
	else --even value
		pos = math.floor(player / 2)
		t = t_selChars[data.t_p2selected[pos].cel+1]
	end
--Set Difficulty Level Down Service
	if getService() == "aileveldown" then
	--Based on KOF Games, if difficulty is <= 4, AI Level will be 1
		if data.difficulty <= 4 then
			return 1
	--Based on KOF Games, if difficulty is > 4, AI Level will be your difficulty setting - 4
		else
			return data.difficulty - 4
		end
--Set AI Level
	else
		if t.ai ~= nil then
			return t.ai
		else
			return data.difficulty + offset
		end
	end
end

function f_tagMode(player, tagset)
	local t = {}
	if player % 2 ~= 0 then --odd value
		pos = math.floor(player / 2 + 0.5)
		t = t_selChars[data.t_p1selected[pos].cel+1]
	else --even value
		pos = math.floor(player / 2)
		t = t_selChars[data.t_p2selected[pos].cel+1]
	end
	if t.tag ~= nil then
		return t.tag
	else
		return data.tagmode + tagset
	end
end

function f_aiLevel()
	--Offset
	local offset = 0
	local tagset = 0
	--[[
	local tagSystem = 0
		if tagSystem == 0 then
			setTag(1, f_tagMode(1, tagset))
			setTag(2, f_tagMode(2, tagset))
			setTag(3, f_tagMode(3, tagset))
			setTag(4, f_tagMode(4, tagset))
		end
	]]
	if data.aiRamping and data.gameMode == "arcade" or data.gameMode == "tower" or data.gameMode == "survival" then
		offset = t_aiRamp[matchNo] - data.difficulty
	end
	--Coop
	if data.coop then
		setCom(1, 0)
		setCom(2, f_difficulty(2, offset))
		setCom(3, 0)
		setTag(1, f_tagMode(1, tagset))
		setTag(2, f_tagMode(2, tagset))
		setTag(3, f_tagMode(3, tagset))
		if not restoreTeam then
			setCom(4, f_difficulty(4, offset))
			setTag(4, f_tagMode(4, tagset))
		end
	else
	--Player 1
		if p1teamMode == 0 then --Single
			if data.p1In == 1 and not data.aiFight then
				setCom(1, 0)
				setTag(1, f_tagMode(1, tagset))
			else
				setCom(1, f_difficulty(1, offset))
				setTag(1, f_tagMode(1, tagset))
			end
		elseif p1teamMode == 1 then --Simul
			if data.simulType == "Tag" then
				for i=1, p1numChars*2 do
					if i % 2 ~= 0 then --odd value
						if data.p1In == 1 and data.aiFight == false and data.tagmode == 1 then
							setCom(i, 0)
							remapInput(i,1)
							setTag(i, f_tagMode(i, tagset))
						else
							setCom(1, f_difficulty(i, offset))
							setCom(i, f_difficulty(i, offset))
							setTag(i, f_tagMode(i, tagset))
						end
					end
				end
			else --data.simulType == "Assist"
				if data.p1In == 1 and not data.aiFight then
					setCom(1, 0)
					setTag(1, f_tagMode(1, tagset))
				else
					setCom(1, f_difficulty(1, offset))
					setTag(1, f_tagMode(1, tagset))
				end
				for i=3, p1numChars*2 do
					if i % 2 ~= 0 then
						setCom(i, f_difficulty(i, offset))
						setTag(i, f_tagMode(i, tagset))
					end
				end
			end
		elseif p1teamMode == 2 then --Turns
			for i=1, p1numChars*2 do
				if i % 2 ~= 0 then
					if data.p1In == 1 and not data.aiFight then
						setCom(i, 0)
						setTag(i, f_tagMode(i, tagset))
					else
						setCom(i, f_difficulty(i, offset))
						setTag(i, f_tagMode(i, tagset))
					end
				end
			end
		end
	--Player 2
		if p2teamMode == 0 then --Single
			if data.p2In == 2 and not data.aiFight then
				setCom(2, 0)
				setTag(2, f_tagMode(2, tagset))
			else
				setCom(2, f_difficulty(2, offset))
				setTag(2, f_tagMode(2, tagset))
			end
		elseif p2teamMode == 1 then --Simul
			if data.simulType == "Tag" then
				for i=2, p2numChars*2 do
					if i % 2 == 0 then --even value
						if data.p2In == 2 and not data.aiFight and data.tagmode == 1 then
							setCom(i, 0)
							remapInput(i,2)
							setTag(i, f_tagMode(i, tagset))
						else
							setCom(i, f_difficulty(i, offset))
							setTag(i, f_tagMode(i, tagset))
						end
					end
				end
			else --data.simulType == "Assist"
				if data.p2In == 2 and not data.aiFight then
					setCom(2, 0)
					setTag(2, f_tagMode(2, tagset))
				else
					setCom(2, f_difficulty(2, offset))
					setTag(2, f_tagMode(2, tagset))
				end
				for i=4, p2numChars*2 do
					if i % 2 == 0 then
						setCom(i, f_difficulty(i, offset))
						setTag(i, f_tagMode(i, tagset))
					end
				end
			end
		elseif p2teamMode == 2 then --Turns
			for i=2, p2numChars*2 do
				if i % 2 == 0 then
					if data.p2In == 2 and not data.aiFight then
						setCom(i, 0)
						--setTag(i, f_tagMode(i, tagset))
					else
						setCom(i, f_difficulty(i, offset))
						--setTag(i, f_tagMode(i, tagset))
					end
				end
			end
		end
	end
end

function f_selectChar(player, t)
	for i=1, #t do
		selectChar(player, t[i].cel, t[i].pal)
	end
end

function f_checkTeamDuplicates(t, cell)
	if not data.teamDuplicates or t == nil then
		local t_team = t
		local pass = true
		for i=1, #t_team do
			if cell == t_team[i].cel then
				pass = false
				break --exits the cycle once it finds a match
			end
		end
		return pass
	else
		return true
	end
end

function f_findCelYAdd(selY, faceOffset, offsetRow)
	selY = selY + 1
	if selY >= selectRows+offsetRows then
		if wrappingY then
			faceOffset = 0
			offsetRow = 0
			selY = 0
		else
			selY = selY - 1
		end
	elseif selY >= selectRows+offsetRow then
		faceOffset = faceOffset + selectColumns
		offsetRow = offsetRow + 1
	end
	return selY, faceOffset, offsetRow
end

function f_findCelYSub(selY, faceOffset, offsetRow)
	selY = selY - 1
	if selY < 0 then
		if wrappingY then
			faceOffset = offsetRows * selectColumns
			offsetRow = offsetRows
			selY = selectRows + offsetRows - 1
		else
			selY = selY + 1
		end
	elseif selY < offsetRow then
		faceOffset = faceOffset - selectColumns
		offsetRow = offsetRow - 1
	end
	return selY, faceOffset, offsetRow
end

function f_findCelXAdd(selX, wrapX)
	selX = selX + 1
	if selX >= selectColumns then
		if wrapX then
			selX = 0
		else
			selX = selX - 1
		end
	end
	return selX
end

function f_findCelXSub(selX, wrapX)
	selX = selX - 1
	if selX < 0 then
		if wrapX then
			selX = selectColumns - 1
		else
			selX = selX + 1
		end
	end
	return selX
end

--[[ Unfinished Hidden Columns Functions
function f_findCelXAdd(selX, faceOffset, offsetColumn)
	selX = selX + 1
	if selX >= selectColumns+offsetColumns then
		if wrappingX then
			faceOffset = 0
			offsetColumn = 0
			selX = 0
		else
			selX = selX - 1
		end
	elseif selX >= selectColumns+offsetColumn then
		faceOffset = faceOffset + selectRows
		offsetColumn = offsetColumn + 1
	end
	return selX, faceOffset, offsetColumn
end

function f_findCelXSub(selX, faceOffset, offsetColumn)
	selX = selX - 1
	if selX < 0 then
		if wrappingX then
			faceOffset = offsetColumns * selectRows
			offsetColumn = offsetColumns
			selX = selectColumns + offsetColumns - 1
		else
			selX = selX + 1
		end
	elseif selX < offsetColumn then
		faceOffset = faceOffset - selectRows
		offsetColumn = offsetColumn - 1
	end
	return selX, faceOffset, offsetColumn
end
]]

function f_winMoney()
--Increase In-Game Currency Money
	if not replay() then	
		stats.money = stats.money + 5
		--sndPlay(sndIkemen, 400, 0)
		f_saveStats()
	end
end

function f_loseMoney()
--Lose In-Game Currency Money
	if stats.money >= 1 then
		stats.money = stats.money - 1
		f_saveStats()
	end
end

--Services/Handicaps Reset
function f_resetHandicaps()
setService("")
setLifeStateP1(-1)
setLifeStateP2(-1)
setPowerStateP1(-1)
setPowerStateP2(-1)
end

--;===========================================================
--; BACK TO MAIN MENU
--;===========================================================
function f_backMenu()
	cmdInput()
	local noExit = false
--Cursor position
	if commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u') then
		sndPlay(sndSys, 100, 0)
		backMenu = backMenu - 1
	elseif commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd') then
		sndPlay(sndSys, 100, 0)
		backMenu = backMenu + 1
	end
	if backMenu < 1 then
		backMenu = #t_backMenu
	elseif backMenu > #t_backMenu then
		backMenu = 1
	end
--Draw Fade BG
	animDraw(fadeWindowBG)
--Draw Menu BG
	animDraw(backWindowBG)
--Draw Title
	textImgDraw(txt_backquestion)
--Draw Table Text
	for i=1, #t_backMenu do
		if i == backMenu then
			bank = 5
		else
			bank = 0
		end
		textImgDraw(f_updateTextImg(t_backMenu[i].id, jgFnt, bank, 0, t_backMenu[i].text, 159, 120+i*13))
	end
--Draw Cursor
	animSetWindow(cursorBox, 87,110+backMenu*13, 144,13)
	f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
	animDraw(f_animVelocity(cursorBox, -1, -1))
--Draw Input Hints Panel
	drawConfirmInputHints()
--Actions		
	if btnPalNo(p1Cmd, true) > 0 or btnPalNo(p2Cmd, true) > 0 then
	--YES
		if backMenu == 1 then
			sndPlay(sndSys, 100, 2)
			commandBufReset(p1Cmd)
			commandBufReset(p2Cmd)
			data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
			if waitingTowerSel then
				data.tempBack = true
			else
				f_resetHandicaps()
				back = true
			end
			f_backReset()
	--NO
		else
			noExit = true
		end
	elseif commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then
		noExit = true
	end
	if noExit then
		sndPlay(sndSys, 100, 1)
		commandBufReset(p1Cmd)
		commandBufReset(p2Cmd)
		if waitingTowerSel then
			
		else
			if data.gameMode == "arcade" or data.gameMode == "tower" then --Fixed issue in Back Menu from Character Select when selecting NO option in Arcade Mode: https://user-images.githubusercontent.com/18058378/260328520-85c78494-7586-4bfe-acd1-cd703d9e3548.png
				--f_rosterReset() --Delete?
				if (data.p1In == 2 and data.p2In == 2) then --Player 1 in player 2 (right) side
					p2Cell = nil
					p2Portrait = nil
					data.t_p2selected = {}
					p2PalEnd = false
					p2SelEnd = false
				else
					p1Cell = nil
					p1Portrait = nil
					data.t_p1selected = {}
					p1PalEnd = false
					p1SelEnd = false
				end
				if data.coop then
					p2Cell = nil
					p2Portrait = nil
					data.t_p2selected = {}
					p2PalEnd = false
					p2SelEnd = false
				end
			else
				f_selectReset()
			end
			if data.rosterAdvanced == true and data.stageMenu == false then stageEnd = true end
		end
		back = false
		f_backReset()
	end
end

function f_backReset()
	backScreen = false
	backMenu = 1 --Cursor pos in YES
end

function f_exitOnline()
	while true do
		back = true
		break
		cmdInput()
		refresh()
	end
end

function f_resetP2CoopInput()
	if onlinegame and data.coop then
		for i=1, p1numChars+p2numChars do
			setCom(i, 0) --Fix player 2 control lose when exit from online mode, reconnects and re-enter in Co-Op Mode
		end
	end
end

function f_resetMenuAssets()
	data.tempBack = false
	f_saveTemp()
	backtomenu = false --Restart special back for Challenger Mode
	exitAbyss = true
	f_resetMenuInputs()
	if data.attractMode == true then playBGM(bgmTitle) else	f_menuMusic() end
end

function f_exitSelect() --For Simple/Story Select
--Right Side have control in Char Select (CPU Vs Human)
	if (data.p1In == 2 and data.p2In == 2) then
		if p2TeamBack == true then
			if backScreen == false then sndPlay(sndSys, 100, 2) end
			backScreen = true
		end
--Left Side have control in Char Select (Human Vs CPU)
	elseif (data.p2In == 1 or data.p2In == 0) then
		if p1TeamBack == true then
			if backScreen == false then sndPlay(sndSys, 100, 2) end
			backScreen = true
		end
--Left Side and Right Side have control in Char Select (Human Vs Human)
	elseif data.p1In == 1 and data.p2In == 2 then
		if p1TeamBack == true and p2TeamBack == true then
			if backScreen == false then sndPlay(sndSys, 100, 2) end
			backScreen = true
		end
	end
end

function f_exitSelect2() --For Advanced Select
--Right Side have control in Char Select (CPU Vs Human)
	if (data.p1In == 2 and data.p2In == 2) then
		if p2TeamBack == true then
			if backScreen == false then sndPlay(sndSys, 100, 2) end
			backScreen = true
		end
--Left Side have control in Char Select (Human Vs CPU)
	else
		if p1TeamBack == true then
			if backScreen == false then sndPlay(sndSys, 100, 2) end
			backScreen = true
		end
	end
end

function f_exitSelect3() --For Advanced Select after Continue Screen
	if backScreen == false then sndPlay(sndSys, 100, 2) end
	backScreen = true
end

function f_exitToMainMenu() --For Advanced Select
	data.tempBack = false
	f_saveTemp()
	exitAbyss = true
	f_resetMenuInputs()
	f_resetMenuArrowsPos()
	if data.attractMode == true then playBGM(bgmTitle) else	f_menuMusic() end
end

function validCells()
--[[
If added columns and rows are more than inserted characters. Don't start char select because while you are scrolling
at some point you will have a error message related with this and well, we can notify to the user about it with an informative message..
]]
	if (data.selectColumns+data.offsetColumns)*(data.selectRows+data.offsetRows) > #t_selChars then
		return false --Config Not Valid
	else
		return true  --Config Valid
	end
end

txt_msgIce = createTextImg(jgFnt, 0, 1, "", 0, 0)
txt_charsNumpa = createTextImg(jgFnt, 0, 1, "("..#t_selChars..")", 250, 235)
txt_cellIssue = [[
 INVALID CHARACTER SELECT CELLS CONFIG!

GO TO: OPTIONS ->
   SYSTEM SETTINGS ->
      CHARACTER SELECT SETTINGS ->
         [EDIT ROSTER]

AND MAKE SURE THAT:
		   
[ROWS] ADDED + [HIDDEN ROWS] ADDED
MULTIPLIED(*) BY THE NUMBER OF
[COLUMNS] ADDED + [HIDDEN COLUMNS] ADDED

IS NOT GREATER (>) THAN THE NUMBER OF
CHARACTERS SLOTS ADDED IN SELECT.DEF
]]
function f_invalidCells()
	cmdInput()
	while true do
		if esc() or btnPalNo(p1Cmd, true) > 0 or btnPalNo(p2Cmd, true) > 0 then
			sndPlay(sndSys, 100, 2)
			data.fadeTitle = f_fadeAnim(50, 'fadein', 'black', sprFade)
			break
		end
        f_textRender(txt_msgIce, txt_cellIssue, 0, 2, 10, 15, 0, -1)
        textImgDraw(txt_charsNumpa)
		animDraw(data.fadeTitle)
        animUpdate(data.fadeTitle)
		cmdInput()
		refresh()
	end
end

--;===========================================================
--; CHARACTER SELECT SCREEN
--;===========================================================
function f_selectScreen()
--Draw Character Select Last Match Backgrounds
	if matchNo == lastMatch then
		animDraw(f_animVelocity(selectHardBG0, -1, -1)) --Draw Red BG for Final Battle
--Draw Character Select Normal Matchs Backgrounds
	else
		--Draw Black BG only for Tower/Abyss Mode
		if data.gameMode == "tower" or data.gameMode == "abyss" then
			animDraw(f_animVelocity(selectTowerBG0, -1, -1))
		--Draw Red BG for Special Modes
		elseif data.gameMode == "bossrush" or data.gameMode == "singleboss" or data.rosterMode == "suddendeath" or data.gameMode == "intermission" then
			animDraw(f_animVelocity(selectHardBG0, -1, -1))
		--Draw Blue BG for Normal Modes
		else
			animDraw(f_animVelocity(commonBG0, -1, -1))
		end
	end
--Player 1 Selection		
	if not p1TeamEnd then
		f_p1TeamMenu() --Team Mode Select
	elseif data.p1In > 0 or data.p1Char ~= nil then
		f_p1SelectMenu() --Character Select
		if (data.p1In == 2 and data.p2In == 2) then
			--Draw VS Single Bosses Portraits if you are playing in Right Side
			if data.gameMode == "singleboss" then
				if data.portraitDisplay == "Portrait" or data.portraitDisplay == "Mixed" then
					animDraw(f_animVelocity(charBG2, 2, 0))
					drawPortrait(data.t_p1selected[1].cel, 0, 20, 1, 1)
				end
				if data.portraitDisplay == "Sprite" or data.portraitDisplay == "Mixed" then
					for j=#data.t_p1selected, 1, -1 do
						--f_drawCharAnim(t_selChars[data.t_p1selected[j].cel+1], 'p1AnimStand', 100, 158, data.t_p1selected[j].up) --Stand Animation
						f_drawCharAnim(t_selChars[data.t_p1selected[j].cel+1], 'p1AnimWin', 100, 158, data.t_p1selected[j].up) --Selected/Win Animation
					end
				end
				--Draw Author Info Text
				if data.charInfo == "Author" then
					if t_selChars[data.t_p1selected[1].cel+1].author ~= nil then
						textImgSetText(txt_p1Author, txt_authorText..t_selChars[data.t_p1selected[1].cel+1].author)
						textImgDraw(txt_p1Author)
					end
				end
			end
			--Draw VS Single Bonus Portraits
			if data.gameMode == "singlebonus" then
				if data.portraitDisplay == "Portrait" or data.portraitDisplay == "Mixed" then
					animDraw(f_animVelocity(charBG2, 2, 0))
					drawPortrait(data.t_p1selected[1].cel, 0, 20, 1, 1)
				end
				--Draw Author Info Text
				if data.charInfo == "Author" then
					if t_selChars[data.t_p1selected[1].cel+1].author ~= nil then
						textImgSetText(txt_p1Author, txt_authorText..t_selChars[data.t_p1selected[1].cel+1].author)
						textImgDraw(txt_p1Author)
					end
				end
			end
		end
	end
--Player 2 Selection
	if not p2TeamEnd then
		if data.gameMode == "tourney" and not tourneyCharSel then
			p2TeamEnd = true
		else
			f_p2TeamMenu()
		end
	elseif data.p2In > 0 or data.p2Char ~= nil then
		if data.gameMode == "tourney" and not tourneyCharSel then
			p2SelEnd = true
		else
			f_p2SelectMenu()
			if (data.p1In ~= 2 and data.p2In ~= 2) then
				--Draw VS Single Bosses Portraits if you are playing in Left Side
				if data.gameMode == "singleboss" then
					if data.portraitDisplay == "Portrait" or data.portraitDisplay == "Mixed" then
						animDraw(f_animVelocity(charBG3, 2, 0))
						drawPortrait(data.t_p2selected[1].cel, 320, 20, -1, 1)
					end
					if data.portraitDisplay == "Sprite" or data.portraitDisplay == "Mixed" then
						for j=#data.t_p2selected, 1, -1 do
							--f_drawCharAnim(t_selChars[data.t_p2selected[j].cel+1], 'p2AnimStand', 220, 158, data.t_p2selected[j].up) --Stand Animation
							f_drawCharAnim(t_selChars[data.t_p2selected[j].cel+1], 'p2AnimWin', 220, 158, data.t_p2selected[j].up) --Selected/Win Animation
						end
					end
					--Draw Author Info Text
					if data.charInfo == "Author" then
						if t_selChars[data.t_p2selected[1].cel+1].author ~= nil then
							textImgSetText(txt_p2Author, txt_authorText..t_selChars[data.t_p2selected[1].cel+1].author)
							textImgDraw(txt_p2Author)
						end
					end
				end
				--Draw VS Single Bonus Portraits
				if data.gameMode == "singlebonus" then
					if data.portraitDisplay == "Portrait" or data.portraitDisplay == "Mixed" then
						animDraw(f_animVelocity(charBG3, 2, 0))
						drawPortrait(data.t_p2selected[1].cel, 320, 20, -1, 1)
					end
					--Draw Author Info Text
					if data.charInfo == "Author" then
						if t_selChars[data.t_p2selected[1].cel+1].author ~= nil then
							textImgSetText(txt_p2Author, txt_authorText..t_selChars[data.t_p2selected[1].cel+1].author)
							textImgDraw(txt_p2Author)
						end
					end
				end
			end
		end
	end
--Cells
	if not stageMenuActive then
		if data.p2Faces and data.selectType == "Advanced" then
			animDraw(f_animVelocity(selectBG1a, -1, 0))
			animSetWindow(selectBG1a, 0, 0, 147, 219)
			animDraw(f_animVelocity(selectBG1b, -1, 0))
			animSetWindow(selectBG1b, 173, 0, 147, 219)
		else
			animDraw(f_animVelocity(selectBG1c, -1, 0))
			animSetWindow(selectBG1c, 85, 0, 151, 239)
			--animSetWindow(selectBG1c, 85, 0, 151, 239)
		end
	end
	animDraw(f_animVelocity(selectBG2a, -1, 0))
	animDraw(f_animVelocity(selectBG2b, -3, 0))
	animDraw(f_animVelocity(selectBG2c, -6, 0))
	if not exclusiveStageMenu then
		textImgSetPos(txt_mainSelect, 159, 13)
		textImgDraw(txt_mainSelect)
	end
	if not stageMenuActive then
		drawFace(p1FaceX, p1FaceY, p1FaceOffset) --Draw Character Face Portrait
		for i=0, selectColumns-1 do
			for j=0, selectRows-1 do
				animPosDraw(selectCell, p1FaceX+i*(cellSizeX+cellSpacingX), p1FaceY+j*(cellSizeY+cellSpacingY)) --Draw cell sprite for each selectColumns and selectRow
				animSetScale(selectCell, data.cellScaleX, data.cellScaleY)
			--[[Draw Locked Icon
				local items = (i + selectColumns * j) + 1
				if items <= #t_selChars then
					if t_unlockLua.chars[t_selChars[items].char] ~= nil and not onlinegame then
						animPosDraw(cellLock, p1FaceX+i*(cellSizeX+cellSpacingX), p1FaceY+j*(cellSizeY+cellSpacingY)) --Draw Lock Icon if the character is locked
					end
				end
			--]]
			end
		end
		if (data.p2Faces and data.selectType == "Advanced") or not data.p1SelectMenu then
			drawFace(p2FaceX, p2FaceY, p2FaceOffset)
			for i=0, selectColumns-1 do
				for j=0, selectRows-1 do
					animPosDraw(selectCell, p2FaceX+i*(cellSizeX+cellSpacingX), p2FaceY+j*(cellSizeY+cellSpacingY))
					animSetScale(selectCell, data.cellScaleX, data.cellScaleY)
				end
			end
		end
		--Draw Active Cursors
		if p1TeamEnd and not p1SelEnd then
			animPosDraw(p1ActiveCursor, p1FaceX+p1SelX*(cellSizeX+cellSpacingX), p1FaceY+(p1SelY-p1OffsetRow)*(cellSizeY+cellSpacingY))
			animSetScale(p1ActiveCursor, data.cellScaleX, data.cellScaleY)
		end
		if p2TeamEnd and not p2SelEnd then
			animPosDraw(p2ActiveCursor, p2FaceX+p2SelX*(cellSizeX+cellSpacingX), p2FaceY+(p2SelY-p2OffsetRow)*(cellSizeY+cellSpacingY))
			animSetScale(p2ActiveCursor, data.cellScaleX, data.cellScaleY)
		end
	end
--Character Select Timer
	if data.gameMode == "arcade" or data.gameMode == "tower" or data.ftcontrol > 0 or data.attractMode == true then
		charTimeNumber = selectTimer/gameTick --Convert Ticks to Seconds
		nodecimalCharTime = string.format("%.0f",charTimeNumber) --Delete Decimals
		textImgSetText(txt_charTime, nodecimalCharTime)
		if selectTimer > 0 then
			if not backScreen then selectTimer = selectTimer - 0.5 end --Activate Character Select Timer
			textImgDraw(txt_charTime)
		else --when selectTimer <= 0
			
		end
	end
--Win Count
	if (data.gameMode == "versus" or data.gameMode == "tourney") and data.vsDisplayWin then
		textImgSetText(txt_p1Wins, "WINS: " .. p1Wins)
		textImgSetText(txt_p2Wins, "WINS: " .. p2Wins)
		textImgDraw(txt_p1Wins)
		textImgDraw(txt_p2Wins)
	end
--Palette Select
	if data.palType == "Modern" then
		--Player1
		if p1CharEnd and not p1PalEnd then
			cmdInput() --Remove to allow player 2 move his cursor during player 1 pal select
			f_p1SelectPal()
		end
		--Player2
		if p2CharEnd and not p2PalEnd then
			cmdInput() --Remove to allow player 1 move his cursor during player 2 pal select
			f_p2SelectPal()
		end
	end
--Handicap Select
	if data.gameMode == "versus" or data.ftcontrol == -1 then
		--Player1
		if p1PalEnd and not p1HandicapEnd then
			cmdInput()
			f_p1SelectHandicap()
		end
		--Player2
		if p2PalEnd and not p2HandicapEnd then
			cmdInput()
			f_p2SelectHandicap()
		end
	end
--Stage select
	if p1SelEnd and p2SelEnd then
		charSelect = false
		selectTimer = 0 --Disappear Char Select Timer to don't disturb Stage Timer
		if not stageEnd then
			if data.gameMode ~= "tourney" then
				f_selectStage()
			else
				stageMenuActive = false
				exclusiveStageMenu = false
				selScreenEnd = true
			end
		else
			stageMenuActive = false
			exclusiveStageMenu = false
			selScreenEnd = true
		end
	end
--Activate Stage Announcer Timer
	if stageAnnouncer == true then
		announcerTimer = announcerTimer + 1
	end
--Deselect Character for Left Side
	if data.coop then
		if commandGetState(p1Cmd, 'e') and p1SelEnd then
			sndPlay(sndSys, 100, 2)
			p1SelEnd = false
			data.t_p1selected = {}
			p1memberPreview = 1
			f_p1randomReset()
		end
	else
		--[[
		if commandGetState(p1Cmd, 'e') and p1SelEnd and charSelect == true then
			sndPlay(sndSys, 100, 2)
			p1SelEnd = false
			data.t_p1selected = {}
			p1memberPreview = 1
			f_p1randomReset()
			if data.p2In == 1 then
				p2TeamEnd = true
				p2SelEnd = true
				p2Portrait = nil
				p2memberPreview = 1
				f_p2randomReset()
			end
		end
		]]
	end
--Deselect Character for Right Side
	if data.p2In == 2 then
		if data.coop then
			if commandGetState(p2Cmd, 'e') and p2SelEnd then
				sndPlay(sndSys, 100, 2)
				--if data.p2In == 2 then
					p2SelEnd = false
				--end
				data.t_p2selected = {}
				--p2memberPreview = 1
				f_p2randomReset()
				p2coopReady = false
			end
		else
			--[[
			if commandGetState(p2Cmd, 'e') and p2SelEnd and charSelect == true then 
				sndPlay(sndSys, 100, 2)
				--if data.p2In == 2 then
					p2SelEnd = false
				--end
				data.t_p2selected = {}
				p2memberPreview = 1
				f_p2randomReset()
			end
			]]
		end
	end
--Show Back Menu
	if backScreen then
		if not onlinegame then
			f_backMenu()
		else
			f_exitOnline()
		end
	else
		if not stageMenuActive then
			drawSelectInputHints()
		else
			drawStageInputHints()
		end
	end
--When Attract Mode is Enabled
	if data.attractMode then
		drawAttractStatus(2, 318, 10, -1)
		f_attractCredits(318, 218, -1)
	end
	animDraw(data.fadeSelect)
	animUpdate(data.fadeSelect)
	animDraw(data.fadeTitle)
	animUpdate(data.fadeTitle)
	cmdInput()
	refresh()
end

--;===========================================================
--; PLAYER 1 TEAM SELECT
--;===========================================================
function f_p1TeamMenu()
	if data.coop then --Simul coop
		p1teamMode = 1
		p1numChars = 2
		setTeamMode(1, p1teamMode, p1numChars)
		p1TeamEnd = true
		p1BG = true
		p1memberPreview = 1
	elseif data.p1TeamMenu ~= nil then
		p1numChars = data.p1TeamMenu.chars
		p1teamMode = data.p1TeamMenu.mode
		setTeamMode(1, p1teamMode, p1numChars)
		p1TeamEnd = true
		p1BG = true
		p1memberPreview = 1
	else
		--Back logic when you are selecting CPU Team Mode in CPU Vs Human
		if commandGetState(p2Cmd, 'e') and (data.p1In == 2 and data.p2In == 2) then --p2Cmd because human is in right side
			if p1TeamBack == true then
				if (data.p1In == 2 and data.p2In == 2) then
					sndPlay(sndSys, 100, 2)
					f_p1sideReset()
					p1TeamEnd = true
					p1SelEnd = true
					f_p2sideReset()
					p2TeamEnd = true
					p2BG = true
					p2memberPreview = 1
					p2SelBack = true
					p2TeamBack = false
				end
			end
		end
		if backScreen == false then
			if commandGetState(p1Cmd, 'u') or (commandGetState(p1Cmd, 'holdu') and bufTmu >= 30) then
				sndPlay(sndSys, 100, 0)
				p1teamMode = p1teamMode - 1
				if p1teamMode < 0 then p1teamMode = #t_p1selTeam-1 end
				if bufTml then bufTml = 0 end
				if bufTmr then bufTmr = 0 end
			elseif commandGetState(p1Cmd, 'd') or (commandGetState(p1Cmd, 'holdd') and bufTmd >= 30) then
				sndPlay(sndSys, 100, 0)
				p1teamMode = p1teamMode + 1
				if p1teamMode > #t_p1selTeam-1 then p1teamMode = 0 end
				if bufTml then bufTml = 0 end
				if bufTmr then bufTmr = 0 end
			elseif p1teamMode == 1 then --Simul
				if commandGetState(p1Cmd, 'l') or (commandGetState(p1Cmd, 'holdl') and bufTml >= 30) then
					if commandGetState(p1Cmd, 'l') and p1numSimul > 2 then sndPlay(sndSys, 100, 0) end
					p1numSimul = p1numSimul - 1
					if p1numSimul < 2 then p1numSimul = 2 end
					if bufTmu then bufTmu = 0 end
					if bufTmd then bufTmd = 0 end
				elseif commandGetState(p1Cmd, 'r') or (commandGetState(p1Cmd, 'holdr') and bufTmr >= 30) then
					if commandGetState(p1Cmd, 'r') and p1numSimul < data.numSimul then sndPlay(sndSys, 100, 0) end
					p1numSimul = p1numSimul + 1
					if p1numSimul > data.numSimul then p1numSimul = data.numSimul end
					if bufTmu then bufTmu = 0 end
					if bufTmd then bufTmd = 0 end
				end
				if commandGetState(p1Cmd, 'holdr') then
					bufTml = 0
					bufTmr = bufTmr + 1
				elseif commandGetState(p1Cmd, 'holdl') then
					bufTmr = 0
					bufTml = bufTml + 1
				else
					bufTmr = 0
					bufTml = 0
				end
			elseif p1teamMode == 2 then --Turns
				if commandGetState(p1Cmd, 'l') or (commandGetState(p1Cmd, 'holdl') and bufTml >= 30) then
					if commandGetState(p1Cmd, 'l') and p1numTurns > 2 then sndPlay(sndSys, 100, 0) end
					p1numTurns = p1numTurns - 1
					if p1numTurns < 2 then p1numTurns = 2 end
					if bufTmu then bufTmu = 0 end
					if bufTmd then bufTmd = 0 end
				elseif commandGetState(p1Cmd, 'r') or (commandGetState(p1Cmd, 'holdr') and bufTmr >= 30) then
					if commandGetState(p1Cmd, 'r') and p1numTurns < data.numTurns then sndPlay(sndSys, 100, 0) end
					p1numTurns = p1numTurns + 1
					if p1numTurns > data.numTurns then p1numTurns = data.numTurns end
					if bufTmu then bufTmu = 0 end
					if bufTmd then bufTmd = 0 end
				end
				if commandGetState(p1Cmd, 'holdr') then
					bufTml = 0
					bufTmr = bufTmr + 1
				elseif commandGetState(p1Cmd, 'holdl') then
					bufTmr = 0
					bufTml = bufTml + 1
				else
					bufTmr = 0
					bufTml = 0
				end
			end
			if commandGetState(p1Cmd, 'holdu') then
				bufTmd = 0
				bufTmu = bufTmu + 1
			elseif commandGetState(p1Cmd, 'holdd') then
				bufTmu = 0
				bufTmd = bufTmd + 1
			else
				bufTmu = 0
				bufTmd = 0
			end
		end
		if data.p1In == 2 then
			textImgDraw(IASelTmTxt)
		elseif data.rosterMode == "cpu" then
			textImgDraw(IASelTmTxt)
		else
			textImgDraw(p1SelTmTxt)
		end
		for i=1, #t_p1selTeam do
			if i == p1teamMode + 1 then
				textImgSetBank(t_p1selTeam[i].id, 3)
			else
				textImgSetBank(t_p1selTeam[i].id, 0)
			end
			textImgDraw(t_p1selTeam[i].id)
		end
	--Only appears until you select a team mode
	--Simul Icons
		for i=1, data.numSimul do
			animPosDraw(p1TmEmpty, 74 + i*6, 66)
		end
		for i=1, p1numSimul do
			animPosDraw(p1TmIcon, 74 + i*6, 66)
		end
	--Turns Icons
		for i=1, data.numTurns do
			animPosDraw(p1TmEmpty, 74 + i*6, 81)
		end
		for i=1, p1numTurns do
			animPosDraw(p1TmIcon, 74 + i*6, 81)
		end
		animPosDraw(p1TmCursor, 10, 50 + p1teamMode*15)
		if btnPalNo(p1Cmd, true) > 0 or selectTimer == 0 then
			sndPlay(sndSys, 100, 1)
			if p1teamMode == 0 then --Single
				p1numChars = 1
			elseif p1teamMode == 1 then --Simul
				p1numChars = p1numSimul
			elseif p1teamMode == 2 then --Turns
				p1numChars = p1numTurns
			end
			setTeamMode(1, p1teamMode, p1numChars)
			p1TeamEnd = true
			p1BG = true
			p1memberPreview = 1
			p1SelBack = true
			p1TeamBack = false
			cmdInput()
		end
	end
end

--;===========================================================
--; PLAYER 1 CHARACTER SELECTING
--;===========================================================
function f_p1SelectMenu()
--Load P1 Custom Character
	if data.p1Char ~= nil then
		local t_p1CharID = {} --Create new table to store data.p1Char information and avoid overwrite that data
		for i, v in ipairs(data.p1Char) do
			t_p1CharID[i] = string.lower(v) --Convert each element to lowercase to avoid issues
		end
		for item=1, #t_p1CharID do
			t_p1CharID[item] = t_charDef[t_p1CharID[item]] --Convert each element to character ID
		end
		local t = {}
		local palp1 = nil
		for i=1, #t_p1CharID do
			local updateAnim = false
			if t[t_p1CharID[i]] == nil then
				updateAnim = true
				t[t_p1CharID[i]] = ''
			end
			if data.p1Pal ~= nil then --Set Manual Palette
				--data.t_p1selected[i] = {['cel'] = t_p1CharID[i], ['pal'] = data.p1Pal, ['handicap'] = p1HandicapSel, ['up'] = updateAnim, ['name'] = t_selChars[t_p1CharID[i]+1].name, ['displayname'] = t_selChars[t_p1CharID[i]+1].displayname, ['path'] = t_selChars[t_p1CharID[i]+1].char, ['author'] = t_selChars[t_p1CharID[i]+1].author, ['discordkey'] = t_selChars[t_p1CharID[i]+1].discordkey}
				palp1 = data.p1Pal
			else
				palp1 = math.random(1,12)
			end
			data.t_p1selected[i] = {['cel'] = t_p1CharID[i], ['pal'] = palp1, ['handicap'] = p1HandicapSel, ['up'] = updateAnim, ['name'] = t_selChars[t_p1CharID[i]+1].name, ['displayname'] = t_selChars[t_p1CharID[i]+1].displayname, ['path'] = t_selChars[t_p1CharID[i]+1].char, ['author'] = t_selChars[t_p1CharID[i]+1].author, ['discordkey'] = t_selChars[t_p1CharID[i]+1].discordkey}
			if data.debugLog then f_printTable(data.t_p1selected, "save/debug/data.t_p1selected.log") end
		end
		p1Portrait = t_p1CharID[1]
		--local numChars = p1numChars
		--if data.coop then numChars = 1 end
		p1SelEnd = true
--Skip P1 Character Select
	elseif not data.p1SelectMenu then
		if data.gameMode == "challenger" then
			data.t_p1selected = t_p1selectedTemp --Get previous arcade selected characters
			if data.debugLog then f_printTable(data.t_p1selected, "save/debug/data.t_p1selected.log") end
		end
		p1SelEnd = true
--Start P1 Character Select
	else
		if not exclusiveStageMenu then
			if data.portraitDisplay == "Portrait" or data.portraitDisplay == "Mixed" then
				if p1BG == true then animDraw(f_animVelocity(charBG2, -2, 0)) end --Draw P1 Portrait BG
			end
		end
		local numChars = p1numChars
		local alphaS = 200
		if data.coop then numChars = 1 end
		if p1Cell then
		--Waiting Selection
			if numChars ~= #data.t_p1selected then
				local updateAnim = true
				for i=1, #data.t_p1selected do
					if data.t_p1selected[i].cel == p1Cell then 
						updateAnim = false
					end
				end
			--Cursor in Random Select Slot
				if getCharName(p1Cell) == "Random" then
					--sndPlay(sndSys, 100, 0) --Play Cursor SFX...
				--DRAW RANDOM PORTRAITS
					if data.portraitDisplay == "Portrait" or data.portraitDisplay == "Mixed" then
						--drawPortrait(t_randomChars[math.random(#t_randomChars)], 0+60*(#data.t_p1selected-1), 20, 1, 1) --Draw P1 RANDOM PREVIEW Portrait with automatic X position for all members (instead of use p1numChars logic)
					--SINGLE MODE
						if p1numChars == 1 then
							if data.randomPortrait == "Simple" or data.randomPortrait == "Fixed" then
								f_drawQuickSpr(p1randomPortrait, 0, 20)
							elseif data.randomPortrait == "Roulette" then --Draw P1 RANDOM PREVIEW Portrait (showing all characters loaded)
								drawPortrait(t_randomChars[math.random(#t_randomChars)], 0, 20, 1, 1)
							end
					--TEAM MODE WITH 2 MEMBERS
						elseif p1numChars == 2 then
						--Draw P1 Member 1 RANDOM PREVIEW Portrait
							if p1memberPreview == 1 then
								if data.randomPortrait == "Simple" or data.randomPortrait == "Fixed" then
									if data.portraitDisplay == "Portrait" then
										f_drawQuickSpr(p1randomPortrait, 0, 20, 1, 0.5)
									elseif data.portraitDisplay == "Mixed" then
										f_drawQuickSpr(p1randomPortrait, 0, 20, 0.5, 0.5)
									end
								elseif data.randomPortrait == "Roulette" then
									if data.portraitDisplay == "Portrait" then
										drawPortrait(t_randomChars[math.random(#t_randomChars)], 0, 20, 1, 0.5)
									elseif data.portraitDisplay == "Mixed" then
										drawPortrait(t_randomChars[math.random(#t_randomChars)], 0, 20, 0.5, 0.5)
									end
								end
							end
						--Draw P1 Member 2 RANDOM PREVIEW Portrait
							if p1memberPreview == 2 then
								if data.randomPortrait == "Simple" or data.randomPortrait == "Fixed" then
									if data.portraitDisplay == "Portrait" then
										f_drawQuickSpr(p1randomPortrait, 0, 90, 1, 0.5)
									elseif data.portraitDisplay == "Mixed" then
										f_drawQuickSpr(p1randomPortrait, 0, 90, 0.5, 0.5)
									end
								elseif data.randomPortrait == "Roulette" then
									if data.portraitDisplay == "Portrait" then
										drawPortrait(t_randomChars[math.random(#t_randomChars)], 0, 90, 1, 0.5)
									elseif data.portraitDisplay == "Mixed" then
										drawPortrait(t_randomChars[math.random(#t_randomChars)], 0, 90, 0.5, 0.5)
									end
								end
							end
					--TEAM MODE WITH 3 MEMBERS
						elseif p1numChars == 3 then
						--Draw P1 Member 1 RANDOM PREVIEW Portrait
							if p1memberPreview == 1 then
								if data.randomPortrait == "Simple" or data.randomPortrait == "Fixed" then
									if data.portraitDisplay == "Portrait" then
										f_drawQuickSpr(p1randomPortrait, 0, 20, 1, 0.5)
									elseif data.portraitDisplay == "Mixed" then
										f_drawQuickSpr(p1randomPortrait, 30, 20, 0.5, 0.5)
									end
								elseif data.randomPortrait == "Roulette" then
									if data.portraitDisplay == "Portrait" then
										drawPortrait(t_randomChars[math.random(#t_randomChars)], 0, 20, 1, 0.5)
									elseif data.portraitDisplay == "Mixed" then
										drawPortrait(t_randomChars[math.random(#t_randomChars)], 30, 20, 0.5, 0.5)
									end
								end
							end
						--Draw P1 Member 2 RANDOM PREVIEW Portrait
							if p1memberPreview == 2 then
								if data.randomPortrait == "Simple" or data.randomPortrait == "Fixed" then
									f_drawQuickSpr(p1randomPortrait, 0, 90, 0.5, 0.5)
								elseif data.randomPortrait == "Roulette" then
									drawPortrait(t_randomChars[math.random(#t_randomChars)], 0, 90, 0.5, 0.5)
								end
							end
						--Draw P1 Member 3 RANDOM PREVIEW Portrait
							if p1memberPreview == 3 then
								if data.randomPortrait == "Simple" or data.randomPortrait == "Fixed" then
									f_drawQuickSpr(p1randomPortrait, 60, 90, 0.5, 0.5)
								elseif data.randomPortrait == "Roulette" then
									drawPortrait(t_randomChars[math.random(#t_randomChars)], 60, 90, 0.5, 0.5)
								end
							end
					--TEAM MODE WITH 4 MEMBERS
						elseif p1numChars == 4 then
						--Draw P1 Member 1 RANDOM PREVIEW Portrait
							if p1memberPreview == 1 then
								if data.randomPortrait == "Simple" or data.randomPortrait == "Fixed" then
									f_drawQuickSpr(p1randomPortrait, 0, 20, 0.5, 0.5)
								elseif data.randomPortrait == "Roulette" then
									drawPortrait(t_randomChars[math.random(#t_randomChars)], 0, 20, 0.5, 0.5)
								end
							end
						--Draw P1 Member 2 RANDOM PREVIEW Portrait
							if p1memberPreview == 2 then
								if data.randomPortrait == "Simple" or data.randomPortrait == "Fixed" then
									f_drawQuickSpr(p1randomPortrait, 60, 20, 0.5, 0.5)
								elseif data.randomPortrait == "Roulette" then
									drawPortrait(t_randomChars[math.random(#t_randomChars)], 60, 20, 0.5, 0.5)
								end
							end
						--Draw P1 Member 3 RANDOM PREVIEW Portrait
							if p1memberPreview == 3 then
								if data.randomPortrait == "Simple" or data.randomPortrait == "Fixed" then
									f_drawQuickSpr(p1randomPortrait, 0, 90, 0.5, 0.5)
								elseif data.randomPortrait == "Roulette" then
									drawPortrait(t_randomChars[math.random(#t_randomChars)], 0, 90, 0.5, 0.5)
								end
							end
						--Draw P1 Member 4 RANDOM PREVIEW Portrait
							if p1memberPreview == 4 then
								if data.randomPortrait == "Simple" or data.randomPortrait == "Fixed" then
									f_drawQuickSpr(p1randomPortrait, 60, 90, 0.5, 0.5)
								elseif data.randomPortrait == "Roulette" then
									drawPortrait(t_randomChars[math.random(#t_randomChars)], 60, 90, 0.5, 0.5)
								end
							end
					--TEAM MODE WITH MORE THAN 4 MEMBERS (UNUSED)
						--[[
						else
							if data.randomPortrait == "Simple" or data.randomPortrait == "Fixed" then
								f_drawQuickSpr(p1randomPortrait, 125, 16, 0.5, 0.5)
							elseif data.randomPortrait == "Roulette" then
								drawPortrait(t_randomChars[math.random(#t_randomChars)], 125, 16, 0.5, 0.5) --Draw RANDOM portrait preview out of BG Position
							end
						]]
						end
					end
				--DRAW RANDOM SPRITE ANIMATIONS
					if data.portraitDisplay == "Sprite" or data.portraitDisplay == "Mixed" then
						if data.portraitDisplay == "Sprite" then
							if data.coop then
								if data.randomPortrait == "Simple" or data.randomPortrait == "Fixed" then
									f_drawQuickSpr(p1randomSprite, 20, 75)
								elseif data.randomPortrait == "Roulette" then
									f_drawCharAnim(t_selChars[math.random(#t_randomChars)], 'p1AnimStand', 40, 164, true)
								end
							else
								if data.randomPortrait == "Simple" or data.randomPortrait == "Fixed" then
									f_drawQuickSpr(p1randomSprite, 20 + 28*#data.t_p1selected, 75)
								elseif data.randomPortrait == "Roulette" then
									--Draw P1 RANDOM PREVIEW stand animation with automatic X position for all members (instead of use p1numChars logic)
									f_drawCharAnim(t_selChars[math.random(#t_randomChars)], 'p1AnimStand', 40 + 28*#data.t_p1selected, 164, true)
								end
							end
						elseif data.portraitDisplay == "Mixed" then
							if data.randomPortrait == "Roulette" then
							--SINGLE MODE
								if p1numChars == 1 then
									f_drawCharAnim(t_selChars[math.random(#t_randomChars)], 'p1AnimStand', 30, 158, true) --Draw P1 RANDOM PREVIEW stand anim (true means that always will be in a loop updateAnim)
							--TEAM MODE WITH 2 MEMBERS
								elseif p1numChars == 2 then
									if p1memberPreview == 1 then f_drawCharAnim(t_selChars[math.random(#t_randomChars)], 'p1AnimStand', 90, 90, true, 0.5, 0.5) end --0.5,0.5 is the animation scale
									if p1memberPreview == 2 then f_drawCharAnim(t_selChars[math.random(#t_randomChars)], 'p1AnimStand', 90, 158, true, 0.5, 0.5) end --Draw P1 Member 2 RANDOM PREVIEW Stand Anim
							--TEAM MODE WITH 3 MEMBERS
								elseif p1numChars == 3 then
									if p1memberPreview == 1 then f_drawCharAnim(t_selChars[math.random(#t_randomChars)], 'p1AnimStand', 40, 89, true, 0.5, 0.5) end --Draw P1 Member 1 RANDOM PREVIEW Stand Anim
									if p1memberPreview == 2 then f_drawCharAnim(t_selChars[math.random(#t_randomChars)], 'p1AnimStand', 10, 158, true, 0.5, 0.5) end --Draw P1 Member 2 RANDOM PREVIEW Stand Anim
									if p1memberPreview == 3 then f_drawCharAnim(t_selChars[math.random(#t_randomChars)], 'p1AnimStand', 70, 158, true, 0.5, 0.5) end --Draw P1 Member 3 RANDOM PREVIEW Stand Anim
							--TEAM MODE WITH 4 MEMBERS
								elseif p1numChars == 4 then
									if p1memberPreview == 1 then f_drawCharAnim(t_selChars[math.random(#t_randomChars)], 'p1AnimStand', 10, 89, true, 0.5, 0.5) end --Draw P1 Member 1 RANDOM PREVIEW Stand Anim
									if p1memberPreview == 2 then f_drawCharAnim(t_selChars[math.random(#t_randomChars)], 'p1AnimStand', 70, 89, true, 0.5, 0.5) end --Draw P1 Member 2 RANDOM PREVIEW Stand Anim
									if p1memberPreview == 3 then f_drawCharAnim(t_selChars[math.random(#t_randomChars)], 'p1AnimStand', 10, 158, true, 0.5, 0.5) end --Draw P1 Member 3 RANDOM PREVIEW Stand Anim
									if p1memberPreview == 4 then f_drawCharAnim(t_selChars[math.random(#t_randomChars)], 'p1AnimStand', 70, 158, true, 0.5, 0.5) end --Draw P1 Member 4 RANDOM PREVIEW Stand Anim
							--TEAM MODE WITH MORE THAN 4 MEMBERS (UNUSED)
								--else
									--f_drawCharAnim(t_selChars[math.random(#t_randomChars)], 'p1AnimStand', 132, 85, true, 0.5, 0.5) --Draw RANDOM Stand Animation preview out of BG Position
								end
							end
						end
					end
			--Cursor in Character Slot
				else
				--DRAW PORTRAITS
					if data.portraitDisplay == "Portrait" or data.portraitDisplay == "Mixed" then
						if p1Portrait then --To avoid issues when draw Portrait after continue/service screen
							--drawPortrait(p1Portrait, 0+60*(#data.t_p1selected-1), 20, 1, 1) --Draw P1 PREVIEW Portrait with automatic X position for all members (instead of use p1numChars logic)
						--SINGLE MODE
							if p1numChars == 1 then
								drawPortrait(p1Portrait, 0, 20, 1, 1) --Draw P1 Member 1 PREVIEW Portrait
						--TEAM MODE WITH 2 MEMBERS
							elseif p1numChars == 2 then
							--Draw P1 Member 1 PREVIEW Portrait
								if p1memberPreview == 1 then
									if data.portraitDisplay == "Portrait" then
										drawPortrait(p1Portrait, 0, 20, 1, 0.5)
									elseif data.portraitDisplay == "Mixed" then
										drawPortrait(p1Portrait, 0, 20, 0.5, 0.5)
									end
								end
							--Draw P1 Member 2 PREVIEW Portrait
								if p1memberPreview == 2 then
									if data.portraitDisplay == "Portrait" then
										drawPortrait(p1Portrait, 0, 90, 1, 0.5)
									elseif data.portraitDisplay == "Mixed" then
										drawPortrait(p1Portrait, 0, 90, 0.5, 0.5)
									end
								end
						--TEAM MODE WITH 3 MEMBERS
							elseif p1numChars == 3 then
							--Draw P1 Member 1 PREVIEW Portrait
								if p1memberPreview == 1 then
									if data.portraitDisplay == "Portrait" then
										drawPortrait(p1Portrait, 0, 20, 1, 0.5)
									elseif data.portraitDisplay == "Mixed" then
										drawPortrait(p1Portrait, 30, 20, 0.5, 0.5)
									end
								end
								if p1memberPreview == 2 then drawPortrait(p1Portrait, 0, 90, 0.5, 0.5) end --Draw P1 Member 2 PREVIEW Portrait
								if p1memberPreview == 3 then drawPortrait(p1Portrait, 60, 90, 0.5, 0.5) end --Draw P1 Member 3 PREVIEW Portrait
						--TEAM MODE WITH 4 MEMBERS
							elseif p1numChars == 4 then
								if p1memberPreview == 1 then drawPortrait(p1Portrait, 0, 20, 0.5, 0.5) end --Draw P1 Member 1 PREVIEW Portrait
								if p1memberPreview == 2 then drawPortrait(p1Portrait, 60, 20, 0.5, 0.5) end --Draw P1 Member 2 PREVIEW Portrait
								if p1memberPreview == 3 then drawPortrait(p1Portrait, 0, 90, 0.5, 0.5) end --Draw P1 Member 3 PREVIEW Portrait
								if p1memberPreview == 4 then drawPortrait(p1Portrait, 60, 90, 0.5, 0.5) end --Draw P1 Member 4 PREVIEW Portrait
						--TEAM MODE WITH MORE THAN 4 MEMBERS (UNUSED)
							--else
								--drawPortrait(p1Portrait, 125, 16, 0.5, 0.5) --Draw portrait preview out of BG Position
							end
						end
					end
				--DRAW SPRITE ANIMATIONS
					if data.portraitDisplay == "Sprite" or data.portraitDisplay == "Mixed" then
						if data.portraitDisplay == "Sprite" then
							if data.coop then
								f_drawCharAnim(t_selChars[p1Cell+1], 'p1AnimStand', 40, 164, true)
							else
								--Draw P1 Member 1 PREVIEW Stand Animation with automatic X position for all members (instead of use p1numChars logic)
								f_drawCharAnim(t_selChars[p1Cell+1], 'p1AnimStand', 40 + 28*#data.t_p1selected, 164, true)
							end
						elseif data.portraitDisplay == "Mixed" then
						--SINGLE MODE
							if p1numChars == 1 then
								f_drawCharAnim(t_selChars[p1Cell+1], 'p1AnimStand', 30, 158, true, 1, 1) --Draw P1 Member 1 PREVIEW Stand Anim
						--TEAM MODE WITH 2 MEMBERS
							elseif p1numChars == 2 then
								if p1memberPreview == 1 then f_drawCharAnim(t_selChars[p1Cell+1], 'p1AnimStand', 90, 90, true, 0.5, 0.5) end --Draw P1 Member 1 PREVIEW Stand Anim
								if p1memberPreview == 2 then f_drawCharAnim(t_selChars[p1Cell+1], 'p1AnimStand', 90, 158, true, 0.5, 0.5) end --Draw P1 Member 2 PREVIEW Stand Anim
						--TEAM MODE WITH 3 MEMBERS
							elseif p1numChars == 3 then
								if p1memberPreview == 1 then f_drawCharAnim(t_selChars[p1Cell+1], 'p1AnimStand', 40, 89, true, 0.5, 0.5) end --Draw P1 Member 1 PREVIEW Stand Anim
								if p1memberPreview == 2 then f_drawCharAnim(t_selChars[p1Cell+1], 'p1AnimStand', 10, 158, true, 0.5, 0.5) end --Draw P1 Member 2 PREVIEW Stand Anim
								if p1memberPreview == 3 then f_drawCharAnim(t_selChars[p1Cell+1], 'p1AnimStand', 70, 158, true, 0.5, 0.5) end --Draw P1 Member 3 PREVIEW Stand Anim
						--TEAM MODE WITH 4 MEMBERS
							elseif p1numChars == 4 then
								if p1memberPreview == 1 then f_drawCharAnim(t_selChars[p1Cell+1], 'p1AnimStand', 10, 89, true, 0.5, 0.5) end --Draw P1 Member 1 PREVIEW Stand Anim
								if p1memberPreview == 2 then f_drawCharAnim(t_selChars[p1Cell+1], 'p1AnimStand', 70, 89, true, 0.5, 0.5) end --Draw P1 Member 2 PREVIEW Stand Anim
								if p1memberPreview == 3 then f_drawCharAnim(t_selChars[p1Cell+1], 'p1AnimStand', 10, 158, true, 0.5, 0.5) end --Draw P1 Member 3 PREVIEW Stand Anim
								if p1memberPreview == 4 then f_drawCharAnim(t_selChars[p1Cell+1], 'p1AnimStand', 70, 158, true, 0.5, 0.5) end --Draw P1 Member 4 PREVIEW Stand Anim
						--TEAM MODE WITH MORE THAN 4 MEMBERS (UNUSED)
							--else
								--f_drawCharAnim(t_selChars[p1Cell+1], 'p1AnimStand', 132, 85, true, 0.5, 0.5) --Draw Stand Animation preview out of BG Position
							end
						end
					end
				--DRAW LOCKED CHAR STUFF
					if t_unlockLua.chars[t_selChars[p1Cell+1].char] ~= nil and not onlinegame then --If the character is locked draw special stuff
						if data.portraitDisplay == "Portrait" or data.portraitDisplay == "Mixed" then
						--SINGLE MODE
							if p1numChars == 1 then
								f_drawQuickSpr(p1portraitLockWindowBG, 0, 20, 120, 140, 256, 102)
								f_drawQuickSpr(p1portraitLock, 24.5, 50, 0.20, 0.20)
						--TEAM MODE WITH 2 MEMBERS
							elseif p1numChars == 2 then
								if p1memberPreview == 1 then
									f_drawQuickSpr(p1portraitLockWindowBG, 0, 20, 120, 70, 256, 102)
									f_drawQuickSpr(p1portraitLock, 42, 36, 0.10, 0.10)
								elseif p1memberPreview == 2 then
									f_drawQuickSpr(p1portraitLockWindowBG, 0, 90, 120, 70, 256, 102)
									f_drawQuickSpr(p1portraitLock, 42, 106, 0.10, 0.10)
								end
						--TEAM MODE WITH 3 MEMBERS
							elseif p1numChars == 3 then
								if p1memberPreview == 1 then
									f_drawQuickSpr(p1portraitLockWindowBG, 0, 20, 120, 70, 256, 102)
									f_drawQuickSpr(p1portraitLock, 42, 36, 0.10, 0.10)
								elseif p1memberPreview == 2 then
									f_drawQuickSpr(p1portraitLockWindowBG, 0, 90, 60, 70, 256, 102)
									f_drawQuickSpr(p1portraitLock, 12, 106, 0.10, 0.10)
								elseif p1memberPreview == 3 then
									f_drawQuickSpr(p1portraitLockWindowBG, 60, 90, 60, 70, 256, 102)
									f_drawQuickSpr(p1portraitLock, 72, 106, 0.10, 0.10)
								end
						--TEAM MODE WITH 4 MEMBERS
							elseif p1numChars == 4 then
								if p1memberPreview == 1 then
									f_drawQuickSpr(p1portraitLockWindowBG, 0, 20, 60, 70, 256, 102)
									f_drawQuickSpr(p1portraitLock, 12, 36, 0.10, 0.10)
								elseif p1memberPreview == 2 then
									f_drawQuickSpr(p1portraitLockWindowBG, 60, 20, 60, 70, 256, 102)
									f_drawQuickSpr(p1portraitLock, 72, 36, 0.10, 0.10)
								elseif p1memberPreview == 3 then
									f_drawQuickSpr(p1portraitLockWindowBG, 0, 90, 60, 70, 256, 102)
									f_drawQuickSpr(p1portraitLock, 12, 106, 0.10, 0.10)
								elseif p1memberPreview == 4 then
									f_drawQuickSpr(p1portraitLockWindowBG, 60, 90, 60, 70, 256, 102)
									f_drawQuickSpr(p1portraitLock, 72, 106, 0.10, 0.10)
								end
							end
						elseif data.portraitDisplay == "Sprite" then
							f_drawQuickSpr(p1portraitLock, 20 + 28*#data.t_p1selected, 75, 0.15, 0.15)
						end
					end
				end
			end
		--When a Character is Selected
			for j=#data.t_p1selected, 1, -1 do
			--DRAW PORTRAITS
				if not exclusiveStageMenu then
					if data.portraitDisplay == "Portrait" or data.portraitDisplay == "Mixed" then
						--drawPortrait(data.t_p1selected[j].cel, 0+60*(j-1), 20, 1, 1) --Draw P1 SELECTED Portrait with automatic X position for all members (instead of use p1numChars logic)
					--SINGLE MODE
						if p1numChars == 1 then
							if data.randomPortrait == "Fixed" and p1member1Random == true then
								f_drawQuickSpr(p1randomPortrait, 0, 20)
							else
								drawPortrait(data.t_p1selected[1].cel, 0, 20, 1, 1)
							end
					--TEAM MODE WITH 2 MEMBERS
						elseif p1numChars == 2 then
						--Draw P1 Member 2 SELECTED Portrait
							if j == 2 then
								if data.randomPortrait == "Fixed" and p1member2Random == true then
									if data.portraitDisplay == "Portrait" then
										f_drawQuickSpr(p1randomPortrait, 0, 90, 1, 0.5)
									elseif data.portraitDisplay == "Mixed" then
										f_drawQuickSpr(p1randomPortrait, 0, 90, 0.5, 0.5)
									end
								else
									if data.portraitDisplay == "Portrait" then
										drawPortrait(data.t_p1selected[2].cel, 0, 90, 1, 0.5)
									elseif data.portraitDisplay == "Mixed" then
										drawPortrait(data.t_p1selected[2].cel, 0, 90, 0.5, 0.5)
									end
								end
							end
							--remember that lastest draw have priority on screen
						--Draw P1 Member 1 SELECTED Portrait
							if data.randomPortrait == "Fixed" and p1member1Random == true then
								if data.portraitDisplay == "Portrait" then
									f_drawQuickSpr(p1randomPortrait, 0, 20, 1, 0.5)
								elseif data.portraitDisplay == "Mixed" then
									f_drawQuickSpr(p1randomPortrait, 0, 20, 0.5, 0.5)
								end
							else
								if data.portraitDisplay == "Portrait" then
									drawPortrait(data.t_p1selected[1].cel, 0, 20, 1, 0.5)
								elseif data.portraitDisplay == "Mixed" then
									drawPortrait(data.t_p1selected[1].cel, 0, 20, 0.5, 0.5)
								end
							end
					--TEAM MODE WITH 3 MEMBERS
						elseif p1numChars == 3 then
						--Draw P1 Member 3 SELECTED Portrait
							if j == 3 then
								if data.randomPortrait == "Fixed" and p1member3Random == true then
									f_drawQuickSpr(p1randomPortrait, 60, 90, 0.5, 0.5)
								else
									drawPortrait(data.t_p1selected[3].cel, 60, 90, 0.5, 0.5)
								end
							end
						--Draw P1 Member 2 SELECTED Portrait
							if j == 2 then
								if data.randomPortrait == "Fixed" and p1member2Random == true then
									f_drawQuickSpr(p1randomPortrait, 0, 90, 0.5, 0.5)
								else
									drawPortrait(data.t_p1selected[2].cel, 0, 90, 0.5, 0.5)
								end
							end
						--Draw P1 Member 1 SELECTED Portrait
							if data.randomPortrait == "Fixed" and p1member1Random == true then
								if data.portraitDisplay == "Portrait" then
									f_drawQuickSpr(p1randomPortrait, 0, 20, 1, 0.5)
								elseif data.portraitDisplay == "Mixed" then
									f_drawQuickSpr(p1randomPortrait, 30, 20, 0.5, 0.5)
								end
							else
								if data.portraitDisplay == "Portrait" then
									drawPortrait(data.t_p1selected[1].cel, 0, 20, 1, 0.5)
								elseif data.portraitDisplay == "Mixed" then
									drawPortrait(data.t_p1selected[1].cel, 30, 20, 0.5, 0.5)
								end
							end
					--TEAM MODE WITH 4 MEMBERS
						elseif p1numChars == 4 then
						--Draw P1 Member 4 SELECTED Portrait
							if j == 4 then
								if data.randomPortrait == "Fixed" and p1member4Random == true then
									f_drawQuickSpr(p1randomPortrait, 60, 90, 0.5, 0.5)
								else
									drawPortrait(data.t_p1selected[4].cel, 60, 90, 0.5, 0.5)
								end
							end
						--Draw P1 Member 3 SELECTED Portrait
							if j == 3 then
								if data.randomPortrait == "Fixed" and p1member3Random == true then
									f_drawQuickSpr(p1randomPortrait, 0, 90, 0.5, 0.5)
								else
									drawPortrait(data.t_p1selected[3].cel, 0, 90, 0.5, 0.5)
								end
							end
						--Draw P1 Member 2 SELECTED Portrait
							if j == 2 then
								if data.randomPortrait == "Fixed" and p1member2Random == true then
									f_drawQuickSpr(p1randomPortrait, 60, 20, 0.5, 0.5)
								else
									drawPortrait(data.t_p1selected[2].cel, 60, 20, 0.5, 0.5)
								end
							end
						--Draw P1 Member 1 SELECTED Portrait
							if data.randomPortrait == "Fixed" and p1member1Random == true then
								f_drawQuickSpr(p1randomPortrait, 0, 20, 0.5, 0.5)
							else
								drawPortrait(data.t_p1selected[1].cel, 0, 20, 0.5, 0.5)
							end
						end
					end
				--DRAW SPRITE ANIMATIONS
					if data.portraitDisplay == "Sprite" or data.portraitDisplay == "Mixed" then
						if data.portraitDisplay == "Sprite" then
							if data.coop then
								f_drawCharAnim(t_selChars[data.t_p1selected[1].cel+1], 'p1AnimWin', 40, 164, data.t_p1selected[1].up, 1, 1, alphaS) --200 is the alphas value
							else
							--Draw P1 Member 4 SELECTED Animation
								if j == 4 then
									if data.randomPortrait == "Fixed" and p1member4Random == true then
										f_drawQuickSpr(p1randomSprite, 104, 75)
									else
										f_drawCharAnim(t_selChars[data.t_p1selected[4].cel+1], 'p1AnimWin', 124, 164, data.t_p1selected[4].up, 1, 1, alphaS)
									end
								end
							--Draw P1 Member 3 SELECTED Animation
								if j == 3 then
									if data.randomPortrait == "Fixed" and p1member3Random == true then
										f_drawQuickSpr(p1randomSprite, 76, 75)
									else
										f_drawCharAnim(t_selChars[data.t_p1selected[3].cel+1], 'p1AnimWin', 96, 164, data.t_p1selected[3].up, 1, 1, alphaS)
									end
								end
							--Draw P1 Member 2 SELECTED Animation
								if j == 2 then
									if data.randomPortrait == "Fixed" and p1member2Random == true then
										f_drawQuickSpr(p1randomSprite, 48, 75)
									else
										f_drawCharAnim(t_selChars[data.t_p1selected[2].cel+1], 'p1AnimWin', 68, 164, data.t_p1selected[2].up, 1, 1, alphaS)
									end
								end
							--Draw P1 Member 1 SELECTED Animation
								if data.randomPortrait == "Fixed" and p1member1Random == true then
									f_drawQuickSpr(p1randomSprite, 20, 75)
								else
									f_drawCharAnim(t_selChars[data.t_p1selected[1].cel+1], 'p1AnimWin', 40, 164, data.t_p1selected[1].up, 1, 1, alphaS)
								end
								--Draw P1 SELECTED/Win Animation with automatic X position for all members (instead of use p1numChars logic)
								--f_drawCharAnim(t_selChars[data.t_p1selected[j].cel+1], 'p1AnimWin', 40 + 28*(j-1), 164, data.t_p1selected[j].up, 1, 1, alphaS)
							end
						elseif data.portraitDisplay == "Mixed" then
						--SINGLE MODE
							if p1numChars == 1 then
								if data.randomPortrait == "Fixed" and p1member1Random == true then
									--You can put your own sprite for random select but as also we are using the portrait logic is not necessary
								else
									f_drawCharAnim(t_selChars[data.t_p1selected[1].cel+1], 'p1AnimWin', 30, 158, data.t_p1selected[1].up, 1, 1, alphaS)
								end
						--TEAM MODE WITH 2 MEMBERS
							elseif p1numChars == 2 then
							--Draw P1 Member 2 SELECTED Animation
								if j == 2 then
									if data.randomPortrait == "Fixed" and p1member2Random == true then
										
									else
										f_drawCharAnim(t_selChars[data.t_p1selected[2].cel+1], 'p1AnimWin', 90, 158, data.t_p1selected[2].up, 0.5, 0.5, alphaS)
									end
								end
							--Draw P1 Member 1 SELECTED Animation
								if data.randomPortrait == "Fixed" and p1member1Random == true then
									
								else
									f_drawCharAnim(t_selChars[data.t_p1selected[1].cel+1], 'p1AnimWin', 90, 90, data.t_p1selected[1].up, 0.5, 0.5, alphaS) --The lastest f_drawCharAnim have draw priority on screen
								end
						--TEAM MODE WITH 3 MEMBERS
							elseif p1numChars == 3 then
							--Draw P1 Member 3 SELECTED Animation
								if j == 3 then
									if data.randomPortrait == "Fixed" and p1member3Random == true then
										
									else
										f_drawCharAnim(t_selChars[data.t_p1selected[3].cel+1], 'p1AnimWin', 70, 158, data.t_p1selected[3].up, 0.5, 0.5, alphaS)
									end
								end
							--Draw P1 Member 2 SELECTED Animation
								if j == 2 then
									if data.randomPortrait == "Fixed" and p1member2Random == true then
										
									else
										f_drawCharAnim(t_selChars[data.t_p1selected[2].cel+1], 'p1AnimWin', 10, 158, data.t_p1selected[2].up, 0.5, 0.5, alphaS)
									end
								end
							--Draw P1 Member 1 SELECTED Animation
								if data.randomPortrait == "Fixed" and p1member1Random == true then
									
								else
									f_drawCharAnim(t_selChars[data.t_p1selected[1].cel+1], 'p1AnimWin', 40, 89, data.t_p1selected[1].up, 0.5, 0.5, alphaS)
								end
						--TEAM MODE WITH 4 MEMBERS
							elseif p1numChars == 4 then
							--Draw P1 Member 4 SELECTED Animation
								if j == 4 then
									if data.randomPortrait == "Fixed" and p1member4Random == true then
										
									else
										f_drawCharAnim(t_selChars[data.t_p1selected[4].cel+1], 'p1AnimWin', 70, 158, data.t_p1selected[4].up, 0.5, 0.5, alphaS)
									end
								end
							--Draw P1 Member 3 SELECTED Animation
								if j == 3 then
									if data.randomPortrait == "Fixed" and p1member3Random == true then
										
									else
										f_drawCharAnim(t_selChars[data.t_p1selected[3].cel+1], 'p1AnimWin', 10, 158, data.t_p1selected[3].up, 0.5, 0.5, alphaS)
									end
								end
							--Draw P1 Member 2 SELECTED Animation
								if j == 2 then
									if data.randomPortrait == "Fixed" and p1member2Random == true then
										
									else
										f_drawCharAnim(t_selChars[data.t_p1selected[2].cel+1], 'p1AnimWin', 70, 89, data.t_p1selected[2].up, 0.5, 0.5, alphaS)
									end
								end
							--Draw P1 Member 1 SELECTED Animation
								if data.randomPortrait == "Fixed" and p1member1Random == true then
									
								else
									f_drawCharAnim(t_selChars[data.t_p1selected[1].cel+1], 'p1AnimWin', 10, 89, data.t_p1selected[1].up, 0.5, 0.5, alphaS)
								end
							end
						end
					end
				end
			end
		end
		for j=#data.t_p1selected, 1, -1 do --Again to set priority over sprites
		--DRAW CHARACTER NAMES
			if not exclusiveStageMenu then
				if data.portraitDisplay == "Portrait" or data.portraitDisplay == "Mixed" then
				--SINGLE MODE
					if p1numChars == 1 then
						if data.randomPortrait == "Fixed" and p1member1Random == true then
							f_drawQuickText(txt_p1RandomMember1, jgFnt, 5, 1, "RANDOM SELECT 1", 10, 165, 0.8, 0.8)
						else
							f_drawSelectName(txt_p1Name, data.t_p1selected[1], 10, 165)
						end
				--TEAM MODE WITH 2 MEMBERS
					elseif p1numChars == 2 then
					--Draw P1 Member 2 SELECTED Name
						if j == 2 then
							if data.portraitDisplay == "Portrait" then
								if data.randomPortrait == "Fixed" and p1member2Random == true then
									f_drawQuickText(txt_p1RandomMember2, jgFnt, 5, 1, "RANDOM SELECT 2", 2, 100, 0.8, 0.8)
								else
									f_drawSelectName(txt_p1Name, data.t_p1selected[2], 2, 100)
								end
							elseif data.portraitDisplay == "Mixed" then
								if data.randomPortrait == "Fixed" and p1member2Random == true then
									f_drawQuickText(txt_p1RandomMember2, jgFnt, 5, 1, "RANDOM SELECT 2", 66, 100, 0.5, 0.5)
								else
									f_drawSelectName(txt_p1Name, data.t_p1selected[2], 66, 100, 0.5, 0.5)
								end
							end
						end
					--Draw P1 Member 1 SELECTED Name
						if data.portraitDisplay == "Portrait" then
							if data.randomPortrait == "Fixed" and p1member1Random == true then
								f_drawQuickText(txt_p1RandomMember1, jgFnt, 5, 1, "RANDOM SELECT 1", 2, 88, 0.8, 0.8)
							else
								f_drawSelectName(txt_p1Name, data.t_p1selected[1], 2, 88)
							end
						elseif data.portraitDisplay == "Mixed" then
							if data.randomPortrait == "Fixed" and p1member1Random == true then
								f_drawQuickText(txt_p1RandomMember1, jgFnt, 5, 1, "RANDOM SELECT 1", 66, 30, 0.5, 0.5)
							else
								f_drawSelectName(txt_p1Name, data.t_p1selected[1], 66, 30, 0.5, 0.5)
							end
						end
				--TEAM MODE WITH 3 MEMBERS
					elseif p1numChars == 3 then
					--Draw P1 Member 3 SELECTED Name
						if j == 3 then
							if data.randomPortrait == "Fixed" and p1member3Random == true then
								f_drawQuickText(txt_p1RandomMember3, jgFnt, 5, 1, "RANDOM SELECT 3", 66, 100, 0.5, 0.5)
							else
								f_drawSelectName(txt_p1Name, data.t_p1selected[3], 66, 100, 0.5, 0.5)
							end
						end
					--Draw P1 Member 2 SELECTED Name
						if j == 2 then
							if data.randomPortrait == "Fixed" and p1member2Random == true then
								f_drawQuickText(txt_p1RandomMember2, jgFnt, 5, 1, "RANDOM SELECT 2", 0, 100, 0.5, 0.5)
							else
								f_drawSelectName(txt_p1Name, data.t_p1selected[2], 0, 100, 0.5, 0.5)
							end
						end
					--Draw P1 Member 1 SELECTED Name
						if data.portraitDisplay == "Portrait" then
							if data.randomPortrait == "Fixed" and p1member1Random == true then
								f_drawQuickText(txt_p1RandomMember1, jgFnt, 5, 1, "RANDOM SELECT 1", 2, 88, 0.8, 0.8)
							else
								f_drawSelectName(txt_p1Name, data.t_p1selected[1], 2, 88)
							end
						elseif data.portraitDisplay == "Mixed" then
							if data.randomPortrait == "Fixed" and p1member1Random == true then
								f_drawQuickText(txt_p1RandomMember1, jgFnt, 5, 1, "RANDOM SELECT 1", 30, 30, 0.5, 0.5)
							else
								f_drawSelectName(txt_p1Name, data.t_p1selected[1], 30, 30, 0.5, 0.5)
							end
						end
				--TEAM MODE WITH 4 MEMBERS
					elseif p1numChars == 4 then
					--Draw P1 Member 4 SELECTED Name
						if j == 4 then
							if data.randomPortrait == "Fixed" and p1member4Random == true then
								f_drawQuickText(txt_p1RandomMember4, jgFnt, 5, 1, "RANDOM SELECT 4", 66, 100, 0.5, 0.5)
							else
								f_drawSelectName(txt_p1Name, data.t_p1selected[4], 66, 100, 0.5, 0.5)
							end
						end
					--Draw P1 Member 3 SELECTED Name
						if j == 3 then
							if data.randomPortrait == "Fixed" and p1member3Random == true then
								f_drawQuickText(txt_p1RandomMember3, jgFnt, 5, 1, "RANDOM SELECT 3", 0, 100, 0.5, 0.5)
							else
								f_drawSelectName(txt_p1Name, data.t_p1selected[3], 0, 100, 0.5, 0.5)
							end
						end
					--Draw P1 Member 2 SELECTED Name
						if j == 2 then
							if data.randomPortrait == "Fixed" and p1member2Random == true then
								f_drawQuickText(txt_p1RandomMember2, jgFnt, 5, 1, "RANDOM SELECT 2", 66, 30, 0.5, 0.5)
							else
								f_drawSelectName(txt_p1Name, data.t_p1selected[2], 66, 30, 0.5, 0.5)
							end
						end
					--Draw P1 Member 1 SELECTED Name
						if data.randomPortrait == "Fixed" and p1member1Random == true then
							f_drawQuickText(txt_p1RandomMember1, jgFnt, 5, 1, "RANDOM SELECT 1", 0, 30, 0.5, 0.5)
						else
							f_drawSelectName(txt_p1Name, data.t_p1selected[1], 0, 30, 0.5, 0.5)
						end
					end
				elseif data.portraitDisplay == "Sprite" then
				--Draw P1 Member 4 SELECTED Name
					if j == 4 then
						if data.randomPortrait == "Fixed" and p1member4Random == true then
							f_drawQuickText(txt_p1RandomMember4, jgFnt, 5, 1, "RANDOM SELECT 4", 12, 166, 0.8, 0.8)
						else
							f_drawSelectName(txt_p1Name, data.t_p1selected[4], 12, 166)
						end
					end
				--Draw P1 Member 3 SELECTED Name
					if j == 3 then
						if data.randomPortrait == "Fixed" and p1member3Random == true then
							f_drawQuickText(txt_p1RandomMember3, jgFnt, 5, 1, "RANDOM SELECT 3", 8, 160, 0.8, 0.8)
						else
							f_drawSelectName(txt_p1Name, data.t_p1selected[3], 8, 160)
						end
					end
				--Draw P1 Member 2 SELECTED Name
					if j == 2 then
						if data.randomPortrait == "Fixed" and p1member2Random == true then
							f_drawQuickText(txt_p1RandomMember2, jgFnt, 5, 1, "RANDOM SELECT 2", 4, 154, 0.8, 0.8)
						else
							f_drawSelectName(txt_p1Name, data.t_p1selected[2], 4, 154)
						end
					end
				--Draw P1 Member 1 SELECTED Name
					if data.randomPortrait == "Fixed" and p1member1Random == true then
						f_drawQuickText(txt_p1RandomMember1, jgFnt, 5, 1, "RANDOM SELECT 1", 0, 148, 0.8, 0.8)
					else
						f_drawSelectName(txt_p1Name, data.t_p1selected[1], 0, 148)
					end
				end
			end
		end
		--Scroll Logic
		if not p1SelEnd then
			local tmpCelX = p1SelX
			local tmpCelY = p1SelY
			if backScreen == false and not p1CharEnd then
				if commandGetState(p1Cmd, 'u') or (commandGetState(p1Cmd, 'holdu') and bufSelu >= 30) then
					local foundCel = false
					while true do
						if foundCel then
							break
						end
						p1SelY, p1FaceOffset, p1OffsetRow = f_findCelYSub(p1SelY, p1FaceOffset, p1OffsetRow)
						if getCharName(p1SelX+selectColumns*p1SelY) ~= '' then
							foundCel = true
						else
							for i=0, tmpCelX do
								p1SelX = f_findCelXSub(p1SelX, false)
								if getCharName(p1SelX+selectColumns*p1SelY) ~= '' then
									foundCel = true
									break
								end
							end
							if not foundCel then
								p1SelX = tmpCelX
								for i=1, selectColumns-tmpCelX do
									p1SelX = f_findCelXAdd(p1SelX, false)
									if getCharName(p1SelX+selectColumns*p1SelY) ~= '' then
										foundCel = true
										break
									end
								end
								if not foundCel then
									p1SelX = tmpCelX
								end
							end
						end
					end
					if tmpCelY ~= p1SelY or tmpCelX ~= p1SelX then
						sndPlay(sndSys, 100, 0)
					end
				elseif commandGetState(p1Cmd, 'd') or (commandGetState(p1Cmd, 'holdd') and bufSeld >= 30) then
					local foundCel = false
					while true do
						if foundCel then
							break
						end
						p1SelY, p1FaceOffset, p1OffsetRow = f_findCelYAdd(p1SelY, p1FaceOffset, p1OffsetRow)
						if getCharName(p1SelX+selectColumns*p1SelY) ~= '' then
							foundCel = true
						else
							for i=1, selectColumns-tmpCelX do
								p1SelX = f_findCelXAdd(p1SelX, false)
								if getCharName(p1SelX+selectColumns*p1SelY) ~= '' then
									foundCel = true
									break
								end
							end
							if not foundCel then
								p1SelX = tmpCelX
								for i=0, tmpCelX do
									p1SelX = f_findCelXSub(p1SelX, false)
									if getCharName(p1SelX+selectColumns*p1SelY) ~= '' then
										foundCel = true
										break
									end
								end
								if not foundCel then
									p1SelX = tmpCelX
								end
							end
						end
					end
					if tmpCelY ~= p1SelY or tmpCelX ~= p1SelX then
						sndPlay(sndSys, 100, 0)
					end
				elseif commandGetState(p1Cmd, 'l') or (commandGetState(p1Cmd, 'holdl') and bufSell >= 30) then
					while true do
						p1SelX = f_findCelXSub(p1SelX, wrappingX)
						if getCharName(p1SelX+selectColumns*p1SelY) ~= '' then break end
					end
					if tmpCelX ~= p1SelX then
						sndPlay(sndSys, 100, 0)
					end
				elseif commandGetState(p1Cmd, 'r') or (commandGetState(p1Cmd, 'holdr') and bufSelr >= 30) then
					while true do
						p1SelX = f_findCelXAdd(p1SelX, wrappingX)
						if getCharName(p1SelX+selectColumns*p1SelY) ~= '' then break end
					end
					if tmpCelX ~= p1SelX then
						sndPlay(sndSys, 100, 0)
					end
				end
				if commandGetState(p1Cmd, 'holdu') then
					bufSeld = 0
					bufSelu = bufSelu + 1
				elseif commandGetState(p1Cmd, 'holdd') then
					bufSelu = 0
					bufSeld = bufSeld + 1
				elseif commandGetState(p1Cmd, 'holdr') then
					bufSell = 0
					bufSelr = bufSelr + 1
				elseif commandGetState(p1Cmd, 'holdl') then
					bufSelr = 0
					bufSell = bufSell + 1
				else
					bufSelu = 0
					bufSeld = 0
					bufSelr = 0
					bufSell = 0
				end
			end
			p1Cell = p1SelX + selectColumns*p1SelY
			p1Portrait = p1Cell
		--Draw Author Info Text Preview
			if data.charInfo == "Author" then
				if t_selChars[p1Cell+1].author ~= nil or getCharName(p1Cell) == "Random" then
					if t_selChars[p1Cell+1].author ~= nil then
						textImgSetText(txt_p1Author, txt_authorText..t_selChars[p1Cell+1].author)
					else --Set Text for Random Select
						textImgSetText(txt_p1Author, txt_authorText.."???")
					end
					textImgScalePosDraw(txt_p1Author, 0, 20, 0.65, 0.65) --Restart text pos
					--textImgDraw(txt_p1Author)
				end
			end
		--Set Preview Character Name
			textImgSetBank(txt_p1Name, 0) --Restart color for not selected character
			textImgSetText(txt_p1Name, f_getName(p1Cell))
			if data.portraitDisplay == "Portrait" or data.portraitDisplay == "Mixed" then
				--For Single Mode
				if p1numChars == 1 then
					textImgScalePosDraw(txt_p1Name, 10, 165, 0.8, 0.8)
				--For Team Mode with 2 Players
				elseif p1numChars == 2 then
					if p1memberPreview == 1 then
						if data.portraitDisplay == "Portrait" then
							textImgScalePosDraw(txt_p1Name, 2, 88, 0.8, 0.8)
						elseif data.portraitDisplay == "Mixed" then
							textImgScalePosDraw(txt_p1Name, 66, 30, 0.5, 0.5)
						end
					end
					if p1memberPreview == 2 then
						if data.portraitDisplay == "Portrait" then
							textImgScalePosDraw(txt_p1Name, 2, 100, 0.8, 0.8)
						elseif data.portraitDisplay == "Mixed" then
							textImgScalePosDraw(txt_p1Name, 66, 100, 0.5, 0.5)
						end
					end
				--For Team Mode with 3 Players
				elseif p1numChars == 3 then
					if p1memberPreview == 1 then
						if data.portraitDisplay == "Portrait" then
							textImgScalePosDraw(txt_p1Name, 2, 88, 0.8, 0.8)
						elseif data.portraitDisplay == "Mixed" then
							textImgScalePosDraw(txt_p1Name, 30, 30, 0.5, 0.5)
						end
					end
					if p1memberPreview == 2 then textImgScalePosDraw(txt_p1Name, 0, 100, 0.5, 0.5) end
					if p1memberPreview == 3 then textImgScalePosDraw(txt_p1Name, 66, 100, 0.5, 0.5) end
				--For Team Mode with 4 Players
				elseif p1numChars == 4 then
					if p1memberPreview == 1 then textImgScalePosDraw(txt_p1Name, 0, 30, 0.5, 0.5) end
					if p1memberPreview == 2 then textImgScalePosDraw(txt_p1Name, 66, 30, 0.5, 0.5) end
					if p1memberPreview == 3 then textImgScalePosDraw(txt_p1Name, 0, 100, 0.5, 0.5) end
					if p1memberPreview == 4 then textImgScalePosDraw(txt_p1Name, 66, 100, 0.5, 0.5) end
				end
			elseif data.portraitDisplay == "Sprite" then
				if p1memberPreview == 1 then
					textImgPosDraw(txt_p1Name, 0, 148)
				elseif p1memberPreview == 2 then
					textImgPosDraw(txt_p1Name, 4, 154)
				elseif p1memberPreview == 3 then
					textImgPosDraw(txt_p1Name, 8, 160)
				elseif p1memberPreview == 4 then
					textImgPosDraw(txt_p1Name, 12, 166)
				end
			end
		--Back to Team Menu Logic
			if (data.p1In == 2 and data.p2In == 2) then --Player 1 in player 2 (right) side
				if commandGetState(p2Cmd, 'e') and p1SelBack == true and not data.coop then
					sndPlay(sndSys, 100, 2)
					f_p1sideReset()
				end
			else
				if commandGetState(p1Cmd, 'e') then
					if serviceBack == true then
						f_p1sideReset()
						p1TeamEnd = true
						p1BG = true
						p1memberPreview = 1
					elseif p1SelBack == true then
						sndPlay(sndSys, 100, 2)
						f_p1sideReset()
					end
				end
			end
			if btnPalNo(p1Cmd, true) > 0 then
				if t_unlockLua.chars[t_selChars[p1Cell+1].char] == nil and f_checkTeamDuplicates(data.t_p1selected, p1Cell) or onlinegame then --This character is unlocked
					f_p1Selection()
				else--if t_unlockLua.chars[t_selChars[p1Cell+1].char] ~= nil and not f_checkTeamDuplicates(data.t_p1selected, p1Cell) and not onlinegame then --Character locked
					sndPlay(sndIkemen, 200, 0)
				end
			elseif selectTimer == 0 then
				local getRandomCell = nil
			--Select random character to prevent issues when time to select is over
				if not data.teamDuplicates or t_unlockLua.chars[t_selChars[p1Cell+1].char] ~= nil then
					for i=1, #data.t_p1selected do
						for available=1, #t_randomChars do
							if t_randomChars[available] ~= data.t_p1selected[i].cel then
								getRandomCell = t_randomChars[available]
								break --exits the cycle once it finds a match
							end
						end
					end
				else--if data.teamDuplicates or t_unlockLua.chars[t_selChars[p1Cell+1].char] == nil then
					getRandomCell = t_randomChars[math.random(#t_randomChars)]
				end
				p1Cell = getRandomCell
				f_p1Selection()
			end
		--When all selections are finished for 1 character
			if p1HandicapEnd and p1PalEnd and p1CharEnd then
				local cel = p1Cell
				if getCharName(cel) == "Random" then
					randomP1Rematch = true
					cel = t_randomChars[math.random(#t_randomChars)] --include exclude chars: cel = math.random(1, #t_randomChars)-1
					if p1memberPreview == 1 then p1member1Random = true	end
					if p1memberPreview == 2 then p1member2Random = true	end
					if p1memberPreview == 3 then p1member3Random = true	end
					if p1memberPreview == 4 then p1member4Random = true	end
				end
				f_p1charAnnouncer(cel) --Character Voice when is selected Example for Player 1 Side
				if t_selChars[cel+1].p1AnimWin then animReset(t_selChars[cel+1].p1AnimWin) end
			--Change p1memberPreview on each char selection
				if p1numChars > 1 and not data.coop then --For Team Modes
					if p1memberPreview == 1 then p1memberPreview = 2
					elseif p1memberPreview == 2 then p1memberPreview = 3
					elseif p1memberPreview == 3 then p1memberPreview = 4
					elseif p1memberPreview == 4 then p1memberPreview = 1 --To Restart
					end
				end
			--Store data selected in Tables
				local updateAnim = true
				for i=1, #data.t_p1selected do
					if data.t_p1selected[i].cel == p1Cell then 
						updateAnim = false
					end
				end
				if data.coop then
					data.t_p1selected[1] = {['cel'] = cel, ['name'] = t_selChars[cel+1].name, ['displayname'] = t_selChars[cel+1].displayname, ['path'] = t_selChars[cel+1].char, ['pal'] = p1PalSel, ['handicap'] = p1HandicapSel, ['up'] = updateAnim, ['author'] = t_selChars[cel+1].author, ['discordkey'] = t_selChars[cel+1].discordkey}
					p1SelEnd = true
				else
					data.t_p1selected[#data.t_p1selected+1] = {['cel'] = cel, ['name'] = t_selChars[cel+1].name, ['displayname'] = t_selChars[cel+1].displayname, ['path'] = t_selChars[cel+1].char, ['pal'] = p1PalSel, ['handicap'] = p1HandicapSel, ['up'] = updateAnim, ['author'] = t_selChars[cel+1].author, ['discordkey'] = t_selChars[cel+1].discordkey}
				--When characters selected are equal to team mode amount selected
					if #data.t_p1selected == p1numChars then
						if data.p2In == 1 and matchNo == 0 then
							p2TeamEnd = false
							p2SelEnd = false
						--[[
							commandBufReset(p1Cmd)
							commandBufReset(p2Cmd)
						]]
						end
						p1SelEnd = true
				--Reset specific char vars for the new member select
					else
						p1HandicapEnd = false
						p1PalEnd = false
						p1CharEnd = false
					end
				end
				if data.debugLog then f_printTable(data.t_p1selected, "save/debug/data.t_p1selected.log") end
			end
		end
	end
end

--Actions when you select a Character
function f_p1Selection()
	sndPlay(sndSys, 100, 1)
--Classic Palette Select
	if data.palType == "Classic" then
		p1PalSel = btnPalNo(p1Cmd, true)
		if selectTimer == 0 then p1PalSel = 1 end --Avoid freeze when Character Select timer is over and there is not are a palette selected
		p1PalEnd = true
--Modern Palette Select Random Select Case
	else
		if getCharName(p1Cell) == "Random" then
			p1PalSel = math.random(1,12) --Set Random Palette for random select
			p1PalEnd = true
		end
	end
--No Handicap Allowed
	if data.gameMode ~= "versus" or data.ftcontrol > 0 then
		p1HandicapSel = 1 --Set Normal Handicap as Default
		p1HandicapEnd = true
	end
	p1CharEnd = true
	cmdInput()
end

--;===========================================================
--; PLAYER 1 PALETTE SELECT
--;===========================================================
function f_p1SelectPal()
--Cursor
	if (commandGetState(p1Cmd, 'r') or commandGetState(p1Cmd, 'u') or (commandGetState(p1Cmd, 'holdu') and bufPalu >= 30) or (commandGetState(p1Cmd, 'holdr') and bufPalr >= 30)) and p1PalSel <= 11 then --p1PalSel <= Number of your Palette List Limit
		sndPlay(sndSys, 100, 0)
		p1PalSel = p1PalSel + 1
	elseif (commandGetState(p1Cmd, 'l') or commandGetState(p1Cmd, 'd') or (commandGetState(p1Cmd, 'holdd') and bufPald >= 30) or (commandGetState(p1Cmd, 'holdl') and bufPall >= 30)) and p1PalSel > 1 then --Keep in palette 1 when press left until finish
		sndPlay(sndSys, 100, 0)
		p1PalSel = p1PalSel - 1
	end
	if commandGetState(p1Cmd, 'holdu') then
		bufPald = 0
		bufPalu = bufPalu + 1
	elseif commandGetState(p1Cmd, 'holdd') then
		bufPalu = 0
		bufPald = bufPald + 1
	elseif commandGetState(p1Cmd, 'holdr') then
		bufPall = 0
		bufPalr = bufPalr + 1
	elseif commandGetState(p1Cmd, 'holdl') then
		bufPalr = 0
		bufPall = bufPall + 1
	else
		bufPalu = 0
		bufPald = 0
		bufPalr = 0
		bufPall = 0
	end
--Draw Assets
	--animSetPal(t_selChars[p1Cell+1]['p1AnimStand'], p1PalSel) --Only works if the .sff file have pals added
	animPosDraw(palSelBG, palSelBGP1posX, palSelBGP1posY) --Draw Palette Select BG
	textImgDraw(txt_p1Pal)
	textImgSetText(txt_p1PalNo, p1PalSel)
	textImgDraw(txt_p1PalNo)
	if p1PalSel > 1 then
		animPosDraw(palSelArrowLeft, palSelArrowLP1posX, palSelArrowLP1posY)
	end
	if p1PalSel <= 11 then
		animPosDraw(palSelArrowRight, palSelArrowRP1posX, palSelArrowRP1posY)
	end
--Confirm Palette
	if btnPalNo(p1Cmd, true) > 0 or selectTimer == 0 then
		sndPlay(sndSys, 100, 1)
		p1PalEnd = true
		cmdInput()
--Back to Character Selection
	elseif commandGetState(p1Cmd, 'e') then
		sndPlay(sndSys, 100, 2)
		p1CharEnd = false
		cmdInput()
	end
end

--;===========================================================
--; PLAYER 1 HANDICAP SELECT
--;===========================================================
function f_p1SelectHandicap()
	local maxItems = 3
	if commandGetState(p1Cmd, 'u') or (commandGetState(p1Cmd, 'holdu') and bufHandu >= 30) then
		sndPlay(sndSys, 100, 0)
		p1HandicapSel = p1HandicapSel - 1
	elseif commandGetState(p1Cmd, 'd') or (commandGetState(p1Cmd, 'holdd') and bufHandd >= 30) then
		sndPlay(sndSys, 100, 0)
		p1HandicapSel = p1HandicapSel + 1
	end
--Cursor position calculation
	if p1HandicapSel < 1 then
		p1HandicapSel = #t_handicapSelect
		if #t_handicapSelect > maxItems then
			p1HandicapCursorPosY = maxItems
		else
			p1HandicapCursorPosY = #t_handicapSelect
		end
	elseif p1HandicapSel > #t_handicapSelect then
		p1HandicapSel = 1
		p1HandicapCursorPosY = 1
	elseif (commandGetState(p1Cmd, 'u') or (commandGetState(p1Cmd, 'holdu') and bufHandu >= 30)) and p1HandicapCursorPosY > 1 then
		p1HandicapCursorPosY = p1HandicapCursorPosY - 1
	elseif (commandGetState(p1Cmd, 'd') or (commandGetState(p1Cmd, 'holdd') and bufHandd >= 30)) and p1HandicapCursorPosY < maxItems then
		p1HandicapCursorPosY = p1HandicapCursorPosY + 1
	end
	if p1HandicapCursorPosY == maxItems then
		p1HandicapMoveTxt = (p1HandicapSel - maxItems) * 13
	elseif p1HandicapCursorPosY == 1 then
		p1HandicapMoveTxt = (p1HandicapSel - 1) * 13
	end
	if #t_handicapSelect <= maxItems then
		maxP1Handicap = #t_handicapSelect
	elseif p1HandicapSel - p1HandicapCursorPosY > 0 then
		maxP1Handicap = p1HandicapSel + maxItems - p1HandicapCursorPosY
	else
		maxP1Handicap = maxItems
	end
	if commandGetState(p1Cmd, 'holdu') then
		bufHandd = 0
		bufHandu = bufHandu + 1
	elseif commandGetState(p1Cmd, 'holdd') then
		bufHandu = 0
		bufHandd = bufHandd + 1
	elseif commandGetState(p1Cmd, 'holdr') then
		bufHandl = 0
		bufHandr = bufHandr + 1
	elseif commandGetState(p1Cmd, 'holdl') then
		bufHandr = 0
		bufHandl = bufHandl + 1
	else
		bufHandu = 0
		bufHandd = 0
		bufHandr = 0
		bufHandl = 0
	end
--Draw Assets
	animPosDraw(handicapWindowBG, handicapSelBGP1posX, handicapSelBGP1posY) --Draw Handicap Select BG
	textImgDraw(txt_handicapP1) --Draw Title
--Set Color and Text Position
	for i=1, maxP1Handicap do
		if i > p1HandicapSel - p1HandicapCursorPosY then
			if i == p1HandicapSel then
				p1Handbank = 5
			else
				p1Handbank = 0
			end
		--Draw Handicaps Names
			if t_handicapSelect[i].id ~= nil then
				textImgDraw(f_updateTextImg(t_handicapSelect[i].id, jgFnt, p1Handbank, 0, t_handicapSelect[i].text, 76, 168+i*13-p1HandicapMoveTxt, 0.95, 0.95))
			end
		end
	end
--Draw Cursor
	animSetWindow(cursorBox, 4, 158+p1HandicapCursorPosY*13, 145, 13)
	f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
	animDraw(f_animVelocity(cursorBox, -1, -1))
--Draw Arrows
	if maxP1Handicap > maxItems then
		animPosDraw(handicapSelArrowUp, handicapSelArrowUP1posX, handicapSelArrowUP1posY)
	end
	if #t_handicapSelect > maxItems and maxP1Handicap < #t_handicapSelect then
		animPosDraw(handicapSelArrowDown, handicapSelArrowDP1posX, handicapSelArrowDP1posY)
	end
--Confirm Handicap
	if btnPalNo(p1Cmd, true) > 0 or selectTimer == 0 then
		sndPlay(sndSys, 100, 1)
		p1HandicapEnd = true
		cmdInput()
--Back to Palette Selection
	elseif commandGetState(p1Cmd, 'e') then
		sndPlay(sndSys, 100, 2)
		p1PalEnd = false
		cmdInput()
	end
end

--;===========================================================
--; PLAYER 2 TEAM SELECT
--;===========================================================
function f_p2TeamMenu()
	if data.coop then --Simul co-op
		--if data.gameMode == "tower" then  --Co-Op enemy team for tower mode
			--p2teamMode = 0
			--p2numChars = 2
		--else
			if data.coopenemy == "Single" then --CPU Co-op Players uses Co-Op CPU Team Mode setting.
				p2teamMode = 0
				p2numChars = 2 --Fix AI Fight Error When p2numChars = 1 (Take reference of Arcade Bonus in co-op)
			elseif data.coopenemy == "Simul" then
				p2teamMode = 1
				p2numChars = 2
			elseif data.coopenemy == "Turns" then
				p2teamMode = 2
				p2numChars = 3
			end
		--end
		setTeamMode(2, p2teamMode, p2numChars)
		p2TeamEnd = true
		--p2BG = true
		--p2memberPreview = 1
	elseif data.p2TeamMenu ~= nil then
		p2numChars = data.p2TeamMenu.chars
		p2teamMode = data.p2TeamMenu.mode
		setTeamMode(2, p2teamMode, p2numChars)
		p2TeamEnd = true
		p2BG = true
		p2memberPreview = 1
	else
		--Back logic when you are selecting CPU Team Mode in Human Vs CPU
		if commandGetState(p1Cmd, 'e') and (data.p1In ~= 2 and data.p2In ~= 2) then --p1Cmd because Human is in left side
			if p2TeamBack == true then
				if data.p2In == 1 then
					sndPlay(sndSys, 100, 2)
					f_p2sideReset()
					p2TeamEnd = true
					p2SelEnd = true
					f_p1sideReset()
					p1TeamEnd = true
					p1BG = true
					p1memberPreview = 1
					p1SelBack = true
					p1TeamBack = false
				end
			end
		end
		if backScreen == false then	
			if commandGetState(p2Cmd, 'u') or (commandGetState(p2Cmd, 'holdu') and bufTm2u >= 30) then
				sndPlay(sndSys, 100, 0)
				p2teamMode = p2teamMode - 1
				if p2teamMode < 0 then p2teamMode = #t_p2selTeam-1 end
				if bufTm2l then bufTm2l = 0 end
				if bufTm2r then bufTm2r = 0 end
			elseif commandGetState(p2Cmd, 'd') or (commandGetState(p2Cmd, 'holdd') and bufTm2d >= 30) then
				sndPlay(sndSys, 100, 0)
				p2teamMode = p2teamMode + 1
				if p2teamMode > #t_p2selTeam-1 then p2teamMode = 0 end
				if bufTm2l then bufTm2l = 0 end
				if bufTm2r then bufTm2r = 0 end
			elseif p2teamMode == 1 then --Simul
				if commandGetState(p2Cmd, 'r') or (commandGetState(p2Cmd, 'holdr') and bufTm2r >= 30) then
					if commandGetState(p2Cmd, 'r') and p2numSimul > 2 then sndPlay(sndSys, 100, 0) end
					p2numSimul = p2numSimul - 1
					if p2numSimul < 2 then p2numSimul = 2 end
					if bufTm2u then bufTm2u = 0 end
					if bufTm2d then bufTm2d = 0 end
				elseif commandGetState(p2Cmd, 'l') or (commandGetState(p2Cmd, 'holdl') and bufTm2l >= 30) then
					if commandGetState(p2Cmd, 'l') and p2numSimul < data.numSimul then sndPlay(sndSys, 100, 0) end
					p2numSimul = p2numSimul + 1
					if p2numSimul > data.numSimul then p2numSimul = data.numSimul end
					if bufTm2u then bufTm2u = 0 end
					if bufTm2d then bufTm2d = 0 end
				end
				if commandGetState(p2Cmd, 'holdr') then
					bufTm2l = 0
					bufTm2r = bufTm2r + 1
				elseif commandGetState(p2Cmd, 'holdl') then
					bufTm2r = 0
					bufTm2l = bufTm2l + 1
				else
					bufTm2r = 0
					bufTm2l = 0
				end
			elseif p2teamMode == 2 then --Turns
				if commandGetState(p2Cmd, 'r') or (commandGetState(p2Cmd, 'holdr') and bufTm2r >= 30) then
					if commandGetState(p2Cmd, 'r') and p2numTurns > 2 then sndPlay(sndSys, 100, 0) end
					p2numTurns = p2numTurns - 1
					if p2numTurns < 2 then p2numTurns = 2 end
					if bufTm2u then bufTm2u = 0 end
					if bufTm2d then bufTm2d = 0 end
				elseif commandGetState(p2Cmd, 'l') or (commandGetState(p2Cmd, 'holdl') and bufTm2l >= 30) then
					if commandGetState(p2Cmd, 'l') and p2numTurns < data.numTurns then sndPlay(sndSys, 100, 0) end
					p2numTurns = p2numTurns + 1
					if p2numTurns > data.numTurns then p2numTurns = data.numTurns end
					if bufTm2u then bufTm2u = 0 end
					if bufTm2d then bufTm2d = 0 end
				end
				if commandGetState(p2Cmd, 'holdr') then
					bufTm2l = 0
					bufTm2r = bufTm2r + 1
				elseif commandGetState(p2Cmd, 'holdl') then
					bufTm2r = 0
					bufTm2l = bufTm2l + 1
				else
					bufTm2r = 0
					bufTm2l = 0
				end
			end
			if commandGetState(p2Cmd, 'holdu') then
				bufTm2d = 0
				bufTm2u = bufTm2u + 1
			elseif commandGetState(p2Cmd, 'holdd') then
				bufTm2u = 0
				bufTm2d = bufTm2d + 1
			else
				bufTm2u = 0
				bufTm2d = 0
			end
		end
		if data.p2In == 2 then
			textImgDraw(p2SelTmTxt)
		elseif data.rosterMode == "cpu" then
			textImgDraw(IASelTmTxt2)
		else
			textImgDraw(IASelTmTxt2)
		end
		for i=1, #t_p2selTeam do
			if i == p2teamMode + 1 then
				textImgSetBank(t_p2selTeam[i].id, 1)
			else
				textImgSetBank(t_p2selTeam[i].id, 0)
			end
			textImgDraw(t_p2selTeam[i].id)
		end
	--Simul Icons
		for i=1, data.numSimul do
			animPosDraw(p2TmEmpty, 246 - i*6, 66)
		end
		for i=1, p2numSimul do
			animPosDraw(p2TmIcon, 246 - i*6, 66)
		end
	--Turns Icons
		for i=1, data.numTurns do
			animPosDraw(p2TmEmpty, 246 - i*6, 81)
		end
		for i=1, p2numTurns do
			animPosDraw(p2TmIcon, 246 - i*6, 81)
		end
		animPosDraw(p2TmCursor, 310, 50 + p2teamMode*15)
		if btnPalNo(p2Cmd, true) > 0 or selectTimer == 0 then
			sndPlay(sndSys, 100, 1)
			if p2teamMode == 0 then --Single
				p2numChars = 1
			elseif p2teamMode == 1 then --Simul
				p2numChars = p2numSimul
			elseif p2teamMode == 2 then --Turns
				p2numChars = p2numTurns
			end
			setTeamMode(2, p2teamMode, p2numChars)
			p2TeamEnd = true
			p2BG = true
			p2memberPreview = 1
			p2SelBack = true
			p2TeamBack = false
			cmdInput()
		end
	end
end

--;===========================================================
--; PLAYER 2 CHARACTER SELECT
--;===========================================================
function f_p2SelectMenu()
	if data.p2Char ~= nil then
		local t_p2CharID = {}
		for i, v in ipairs(data.p2Char) do
			t_p2CharID[i] = string.lower(v)
		end
		for item=1, #t_p2CharID do
			t_p2CharID[item] = t_charDef[t_p2CharID[item]]
		end
		local t = {}
		local palp2 = nil
		for i=1, #t_p2CharID do
			local updateAnim = false
			if t[t_p2CharID[i]] == nil then
				updateAnim = true
				t[t_p2CharID[i]] = ''
			end
			if data.p2Pal ~= nil then
				--data.t_p2selected[i] = {['cel'] = t_p2CharID[i], ['pal'] = data.p2Pal, ['handicap'] = p2HandicapSel, ['up'] = updateAnim, ['name'] = t_selChars[t_p2CharID[i]+1].name, ['displayname'] = t_selChars[t_p2CharID[i]+1].displayname, ['path'] = t_selChars[t_p2CharID[i]+1].char, ['author'] = t_selChars[t_p2CharID[i]+1].author, ['discordkey'] = t_selChars[t_p2CharID[i]+1].discordkey}
				palp2 = data.p2Pal
			else
				palp2 = math.random(1,12)
			end
			data.t_p2selected[i] = {['cel'] = t_p2CharID[i], ['pal'] = palp2, ['handicap'] = p2HandicapSel, ['up'] = updateAnim, ['name'] = t_selChars[t_p2CharID[i]+1].name, ['displayname'] = t_selChars[t_p2CharID[i]+1].displayname, ['path'] = t_selChars[t_p2CharID[i]+1].char, ['author'] = t_selChars[t_p2CharID[i]+1].author, ['discordkey'] = t_selChars[t_p2CharID[i]+1].discordkey}
			if data.debugLog then f_printTable(data.t_p2selected, "save/debug/data.t_p2selected.log") end
		end
		p2Portrait = t_p2CharID[1]
		--local numChars = p2numChars
		--local t_selected = data.t_p2selected
		--if data.coop then
			--numChars = 1
			--t_selected = {}
		--end
		p2SelEnd = true
	elseif not data.p2SelectMenu then
		if data.gameMode == "challenger" then
			data.t_p2selected = t_p2selectedTemp --Get previous arcade selected characters
			if data.debugLog then f_printTable(data.t_p2selected, "save/debug/data.t_p2selected.log") end
		end
		p2SelEnd = true
	else
		if not exclusiveStageMenu then
			if data.portraitDisplay == "Portrait" or data.portraitDisplay == "Mixed" then
				if p2BG == true then animDraw(f_animVelocity(charBG3, 2, 0)) end
			end
		end
		local numChars = p2numChars
		local alphaS = 200
		local t_selected = data.t_p2selected
		if data.coop then
			numChars = 1
			t_selected = {} --Reset table to store p2 data to send to data.t_p1selected in co-op modes
		end
		if p2Cell then
			if numChars ~= #t_selected then
				local updateAnim = true
				for i=1, #t_selected do
					if t_selected[i].cel == p2Cell then 
						updateAnim = false
					end
				end
				if getCharName(p2Cell) == "Random" then
					if getCharName(p1Cell) ~= "Random" then --Play Random Cursor SFX only when p1 it is not on the same cell type to overlap the sfx
						--sndPlay(sndSys, 100, 0)
					end
					if data.portraitDisplay == "Portrait" or data.portraitDisplay == "Mixed" then
						--drawPortrait(t_randomChars[math.random(#t_randomChars)], 320 - 60*(#t_selected-1), 20, -1, 1)
						if p2numChars == 1 then
							if data.randomPortrait == "Simple" or data.randomPortrait == "Fixed" then
								f_drawQuickSpr(p2randomPortrait, 320, 20)
							elseif data.randomPortrait == "Roulette" then
								drawPortrait(t_randomChars[math.random(#t_randomChars)], 320, 20, -1, 1)
							end
						elseif p2numChars == 2 then
							if data.coop then
								if data.randomPortrait == "Simple" or data.randomPortrait == "Fixed" then
									if data.portraitDisplay == "Portrait" then
										f_drawQuickSpr(p2randomPortrait, 120, 90, 1, 0.5)
									elseif data.portraitDisplay == "Mixed" then
										f_drawQuickSpr(p2randomPortrait, 60, 90, 0.5, 0.5)
									end
								elseif data.randomPortrait == "Roulette" then
									if data.portraitDisplay == "Portrait" then
										drawPortrait(t_randomChars[math.random(#t_randomChars)], 0, 90, 1, 0.5)
									elseif data.portraitDisplay == "Mixed" then
										drawPortrait(t_randomChars[math.random(#t_randomChars)], 0, 90, 0.5, 0.5)
									end
								end
							else
								if p2memberPreview == 1 then
									if data.randomPortrait == "Simple" or data.randomPortrait == "Fixed" then
										if data.portraitDisplay == "Portrait" then
											f_drawQuickSpr(p2randomPortrait, 320, 20, 1, 0.5)
										elseif data.portraitDisplay == "Mixed" then
											f_drawQuickSpr(p2randomPortrait, 320, 20, 0.5, 0.5)
										end
									elseif data.randomPortrait == "Roulette" then
										if data.portraitDisplay == "Portrait" then
											drawPortrait(t_randomChars[math.random(#t_randomChars)], 320, 20, -1, 0.5)
										elseif data.portraitDisplay == "Mixed" then
											drawPortrait(t_randomChars[math.random(#t_randomChars)], 320, 20, -0.5, 0.5)
										end
									end
								end
								if p2memberPreview == 2 then
									if data.randomPortrait == "Simple" or data.randomPortrait == "Fixed" then
										if data.portraitDisplay == "Portrait" then
											f_drawQuickSpr(p2randomPortrait, 320, 90, 1, 0.5)
										elseif data.portraitDisplay == "Mixed" then
											f_drawQuickSpr(p2randomPortrait, 320, 90, 0.5, 0.5)
										end
									elseif data.randomPortrait == "Roulette" then
										if data.portraitDisplay == "Portrait" then
											drawPortrait(t_randomChars[math.random(#t_randomChars)], 320, 90, -1, 0.5)
										elseif data.portraitDisplay == "Mixed" then
											drawPortrait(t_randomChars[math.random(#t_randomChars)], 320, 90, -0.5, 0.5)
										end
									end
								end
							end
						elseif p2numChars == 3 then
							if p2memberPreview == 1 then
								if data.randomPortrait == "Simple" or data.randomPortrait == "Fixed" then
									if data.portraitDisplay == "Portrait" then
										f_drawQuickSpr(p2randomPortrait, 320, 20, 1, 0.5)
									elseif data.portraitDisplay == "Mixed" then
										f_drawQuickSpr(p2randomPortrait, 290, 20, 0.5, 0.5)
									end
								elseif data.randomPortrait == "Roulette" then
									if data.portraitDisplay == "Portrait" then
										drawPortrait(t_randomChars[math.random(#t_randomChars)], 320, 20, -1, 0.5)
									elseif data.portraitDisplay == "Mixed" then
										drawPortrait(t_randomChars[math.random(#t_randomChars)], 290, 20, -0.5, 0.5)
									end
								end
							end
							if p2memberPreview == 2 then
								if data.randomPortrait == "Simple" or data.randomPortrait == "Fixed" then
									f_drawQuickSpr(p2randomPortrait, 320, 90, 0.5, 0.5)
								elseif data.randomPortrait == "Roulette" then
									drawPortrait(t_randomChars[math.random(#t_randomChars)], 320, 90, -0.5, 0.5)
								end
							end
							if p2memberPreview == 3 then
								if data.randomPortrait == "Simple" or data.randomPortrait == "Fixed" then
									f_drawQuickSpr(p2randomPortrait, 260, 90, 0.5, 0.5)
								elseif data.randomPortrait == "Roulette" then
									drawPortrait(t_randomChars[math.random(#t_randomChars)], 260, 90, -0.5, 0.5)
								end
							end
						elseif p2numChars == 4 then
							if p2memberPreview == 1 then
								if data.randomPortrait == "Simple" or data.randomPortrait == "Fixed" then
									f_drawQuickSpr(p2randomPortrait, 320, 20, 0.5, 0.5)
								elseif data.randomPortrait == "Roulette" then
									drawPortrait(t_randomChars[math.random(#t_randomChars)], 320, 20, -0.5, 0.5)
								end
							end
							if p2memberPreview == 2 then
								if data.randomPortrait == "Simple" or data.randomPortrait == "Fixed" then
									f_drawQuickSpr(p2randomPortrait, 260, 20, 0.5, 0.5)
								elseif data.randomPortrait == "Roulette" then
									drawPortrait(t_randomChars[math.random(#t_randomChars)], 260, 20, -0.5, 0.5)
								end
							end
							if p2memberPreview == 3 then
								if data.randomPortrait == "Simple" or data.randomPortrait == "Fixed" then
									f_drawQuickSpr(p2randomPortrait, 320, 90, 0.5, 0.5)
								elseif data.randomPortrait == "Roulette" then
									drawPortrait(t_randomChars[math.random(#t_randomChars)], 320, 90, -0.5, 0.5)
								end
							end
							if p2memberPreview == 4 then
								if data.randomPortrait == "Simple" or data.randomPortrait == "Fixed" then
									f_drawQuickSpr(p2randomPortrait, 260, 90, 0.5, 0.5)
								elseif data.randomPortrait == "Roulette" then
									drawPortrait(t_randomChars[math.random(#t_randomChars)], 260, 90, -0.5, 0.5)
								end
							end
						--[[
						--else
							if data.randomPortrait == "Simple" or data.randomPortrait == "Fixed" then
								f_drawQuickSpr(p2randomPortrait, 195, 36, 0.5, 0.5)
							elseif data.randomPortrait == "Roulette" then
								drawPortrait(t_randomChars[math.random(#t_randomChars)], 195, 36, -0.5, 0.5)
							end
						]]
						end
					end
					if data.portraitDisplay == "Sprite" or data.portraitDisplay == "Mixed" then
						if data.portraitDisplay == "Sprite" then
							if data.coop then
								if data.randomPortrait == "Simple" or data.randomPortrait == "Fixed" then
									f_drawQuickSpr(p2randomSprite, 110, 75)
								elseif data.randomPortrait == "Roulette" then
									f_drawCharAnim(t_selChars[math.random(#t_randomChars)], 'p1AnimStand', 114, 164, true) --p1AnimStand because sprite animation will see to right
								end
							else
								if data.randomPortrait == "Simple" or data.randomPortrait == "Fixed" then
									f_drawQuickSpr(p2randomSprite, 260 - 28*#t_selected, 75)
								elseif data.randomPortrait == "Roulette" then
									f_drawCharAnim(t_selChars[math.random(#t_randomChars)], 'p2AnimStand', 280 - 28*#t_selected, 164, true)
								end
							end
						elseif data.portraitDisplay == "Mixed" then
							if data.randomPortrait == "Roulette" then
								if p2numChars == 1 then
									f_drawCharAnim(t_selChars[math.random(#t_randomChars)], 'p2AnimStand', 290, 158, true)
								elseif p2numChars == 2 then
									if data.coop then
										f_drawCharAnim(t_selChars[math.random(#t_randomChars)], 'p1AnimStand', 90, 158, true, 0.5, 0.5)
									else
										if p2memberPreview == 1 then f_drawCharAnim(t_selChars[math.random(#t_randomChars)], 'p2AnimStand', 230, 90, true, 0.5, 0.5) end
										if p2memberPreview == 2 then f_drawCharAnim(t_selChars[math.random(#t_randomChars)], 'p2AnimStand', 230, 158, true, 0.5, 0.5) end
									end
								elseif p2numChars == 3 then
									if p2memberPreview == 1 then f_drawCharAnim(t_selChars[math.random(#t_randomChars)], 'p2AnimStand', 280, 89, true, 0.5, 0.5) end
									if p2memberPreview == 2 then f_drawCharAnim(t_selChars[math.random(#t_randomChars)], 'p2AnimStand', 310, 158, true, 0.5, 0.5) end
									if p2memberPreview == 3 then f_drawCharAnim(t_selChars[math.random(#t_randomChars)], 'p2AnimStand', 250, 158, true, 0.5, 0.5) end
								elseif p2numChars == 4 then
									if p2memberPreview == 1 then f_drawCharAnim(t_selChars[math.random(#t_randomChars)], 'p2AnimStand', 310, 89, true, 0.5, 0.5) end
									if p2memberPreview == 2 then f_drawCharAnim(t_selChars[math.random(#t_randomChars)], 'p2AnimStand', 250, 89, true, 0.5, 0.5) end
									if p2memberPreview == 3 then f_drawCharAnim(t_selChars[math.random(#t_randomChars)], 'p2AnimStand', 310, 158, true, 0.5, 0.5) end
									if p2memberPreview == 4 then f_drawCharAnim(t_selChars[math.random(#t_randomChars)], 'p2AnimStand', 250, 158, true, 0.5, 0.5) end
								--else
									--f_drawCharAnim(t_selChars[math.random(#t_randomChars)], 'p2AnimStand', 132, 105, true, 0.5, 0.5)
								end
							end
						end
					end
				else
					if data.portraitDisplay == "Portrait" or data.portraitDisplay == "Mixed" then
						if p2Portrait then --To avoid issues when draw Portrait after continue/service screen
							--drawPortrait(p2Portrait, 320 - 60*(#t_selected-1), 20, -1, 1)
							if p2numChars == 1 then
								drawPortrait(p2Portrait, 320, 20, -1, 1)
							elseif p2numChars == 2 then
								if data.coop then
									if data.portraitDisplay == "Portrait" then
										drawPortrait(p2Portrait, 0, 90, 1, 0.5)
									elseif data.portraitDisplay == "Mixed" then
										drawPortrait(p2Portrait, 0, 90, 0.5, 0.5)
									end
								else
									if p2memberPreview == 1 then
										if data.portraitDisplay == "Portrait" then
											drawPortrait(p2Portrait, 320, 20, -1, 0.5)
										elseif data.portraitDisplay == "Mixed" then
											drawPortrait(p2Portrait, 320, 20, -0.5, 0.5)
										end
									end
									if p2memberPreview == 2 then
										if data.portraitDisplay == "Portrait" then
											drawPortrait(p2Portrait, 320, 90, -1, 0.5)
										elseif data.portraitDisplay == "Mixed" then
											drawPortrait(p2Portrait, 320, 90, -0.5, 0.5)
										end
									end
								end
							elseif p2numChars == 3 then
								if p2memberPreview == 1 then
									if data.portraitDisplay == "Portrait" then
										drawPortrait(p2Portrait, 320, 20, -1, 0.5)
									elseif data.portraitDisplay == "Mixed" then
										drawPortrait(p2Portrait, 290, 20, -0.5, 0.5)
									end
								end
								if p2memberPreview == 2 then drawPortrait(p2Portrait, 320, 90, -0.5, 0.5) end
								if p2memberPreview == 3 then drawPortrait(p2Portrait, 260, 90, -0.5, 0.5) end
							elseif p2numChars == 4 then
								if p2memberPreview == 1 then drawPortrait(p2Portrait, 320, 20, -0.5, 0.5) end
								if p2memberPreview == 2 then drawPortrait(p2Portrait, 260, 20, -0.5, 0.5) end
								if p2memberPreview == 3 then drawPortrait(p2Portrait, 320, 90, -0.5, 0.5) end
								if p2memberPreview == 4 then drawPortrait(p2Portrait, 260, 90, -0.5, 0.5) end
							--else
								--drawPortrait(p2Portrait, 195, 36, -0.5, 0.5)
							end
						end
					end
					if data.portraitDisplay == "Sprite" or data.portraitDisplay == "Mixed" then
						if data.portraitDisplay == "Sprite" then
							if data.coop then
								f_drawCharAnim(t_selChars[p2Cell+1], 'p1AnimStand', 114, 164, true)
							else
								f_drawCharAnim(t_selChars[p2Cell+1], 'p2AnimStand', 280 - 28*#t_selected, 164, true)
							end
						elseif data.portraitDisplay == "Mixed" then
							if p2numChars == 1 then
								f_drawCharAnim(t_selChars[p2Cell+1], 'p2AnimStand', 290, 158, true, 1, 1)
							elseif p2numChars == 2 then
								if data.coop then
									f_drawCharAnim(t_selChars[p2Cell+1], 'p1AnimStand', 90, 158, true, 0.5, 0.5)
								else
									if p2memberPreview == 1 then f_drawCharAnim(t_selChars[p2Cell+1], 'p2AnimStand', 230, 90, true, 0.5, 0.5) end
									if p2memberPreview == 2 then f_drawCharAnim(t_selChars[p2Cell+1], 'p2AnimStand', 230, 158, true, 0.5, 0.5) end
								end
							elseif p2numChars == 3 then
								if p2memberPreview == 1 then f_drawCharAnim(t_selChars[p2Cell+1], 'p2AnimStand', 280, 89, true, 0.5, 0.5) end
								if p2memberPreview == 2 then f_drawCharAnim(t_selChars[p2Cell+1], 'p2AnimStand', 310, 158, true, 0.5, 0.5) end
								if p2memberPreview == 3 then f_drawCharAnim(t_selChars[p2Cell+1], 'p2AnimStand', 250, 158, true, 0.5, 0.5) end
							elseif p2numChars == 4 then
								if p2memberPreview == 1 then f_drawCharAnim(t_selChars[p2Cell+1], 'p2AnimStand', 310, 89, true, 0.5, 0.5) end
								if p2memberPreview == 2 then f_drawCharAnim(t_selChars[p2Cell+1], 'p2AnimStand', 250, 89, true, 0.5, 0.5) end
								if p2memberPreview == 3 then f_drawCharAnim(t_selChars[p2Cell+1], 'p2AnimStand', 310, 158, true, 0.5, 0.5) end
								if p2memberPreview == 4 then f_drawCharAnim(t_selChars[p2Cell+1], 'p2AnimStand', 250, 158, true, 0.5, 0.5) end
							--else
								--f_drawCharAnim(t_selChars[p2Cell+1], 'p2AnimStand', 132, 105, true, 0.5, 0.5)
							end
						end
					end
					if t_unlockLua.chars[t_selChars[p2Cell+1].char] ~= nil and not onlinegame then
						if data.portraitDisplay == "Portrait" or data.portraitDisplay == "Mixed" then
							if p2numChars == 1 then
								f_drawQuickSpr(p2portraitLockWindowBG, 320, 20, 120, 140, 256, 102)
								f_drawQuickSpr(p2portraitLock, 295.5, 50, 0.20, 0.20)
							elseif p2numChars == 2 then
								if data.coop then
									f_drawQuickSpr(p1portraitLockWindowBG, 0, 90, 120, 70, 256, 102)
									f_drawQuickSpr(p1portraitLock, 42, 106, 0.10, 0.10)
								else
									if p2memberPreview == 1 then
										f_drawQuickSpr(p2portraitLockWindowBG, 320, 20, 120, 70, 256, 102)
										f_drawQuickSpr(p2portraitLock, 278, 36, 0.10, 0.10)
									elseif p2memberPreview == 2 then
										f_drawQuickSpr(p2portraitLockWindowBG, 320, 90, 120, 70, 256, 102)
										f_drawQuickSpr(p2portraitLock, 278, 106, 0.10, 0.10)
									end
								end
							elseif p2numChars == 3 then
								if p2memberPreview == 1 then
									f_drawQuickSpr(p2portraitLockWindowBG, 320, 20, 120, 70, 256, 102)
									f_drawQuickSpr(p2portraitLock, 278, 36, 0.10, 0.10)
								elseif p2memberPreview == 2 then
									f_drawQuickSpr(p2portraitLockWindowBG, 320, 90, 60, 70, 256, 102)
									f_drawQuickSpr(p2portraitLock, 308, 106, 0.10, 0.10)
								elseif p2memberPreview == 3 then
									f_drawQuickSpr(p2portraitLockWindowBG, 260, 90, 60, 70, 256, 102)
									f_drawQuickSpr(p2portraitLock, 248, 106, 0.10, 0.10)
								end
							elseif p2numChars == 4 then
								if p2memberPreview == 1 then
									f_drawQuickSpr(p2portraitLockWindowBG, 320, 20, 60, 70, 256, 102)
									f_drawQuickSpr(p2portraitLock, 308, 36, 0.10, 0.10)
								elseif p2memberPreview == 2 then
									f_drawQuickSpr(p2portraitLockWindowBG, 260, 20, 60, 70, 256, 102)
									f_drawQuickSpr(p2portraitLock, 248, 36, 0.10, 0.10)
								elseif p2memberPreview == 3 then
									f_drawQuickSpr(p2portraitLockWindowBG, 320, 90, 60, 70, 256, 102)
									f_drawQuickSpr(p2portraitLock, 308, 106, 0.10, 0.10)
								elseif p2memberPreview == 4 then
									f_drawQuickSpr(p2portraitLockWindowBG, 260, 90, 60, 70, 256, 102)
									f_drawQuickSpr(p2portraitLock, 248, 106, 0.10, 0.10)
								end
							end
						elseif data.portraitDisplay == "Sprite" then
							if data.coop then
								f_drawQuickSpr(p1portraitLock, 110, 75, 0.15, 0.15)
							else
								f_drawQuickSpr(p2portraitLock, 300 - 28*#t_selected, 75, 0.15, 0.15)
							end
						end
					end
				end
			end
			for j=#t_selected, 1, -1 do
				if not exclusiveStageMenu then
					if data.portraitDisplay == "Portrait" or data.portraitDisplay == "Mixed" then
						--drawPortrait(t_selected[j].cel, 320 - 60*(j-1), 20, -1, 1)
						if p2numChars == 1 then
							if data.randomPortrait == "Fixed" and p2member1Random == true then
								f_drawQuickSpr(p2randomPortrait, 320, 20)
							else
								drawPortrait(t_selected[1].cel, 320, 20, -1, 1)
							end
						elseif p2numChars == 2 then
							if j == 2 then
								if data.randomPortrait == "Fixed" and p2member2Random == true then
									if data.portraitDisplay == "Portrait" then
										f_drawQuickSpr(p2randomPortrait, 320, 90, 1, 0.5)
									elseif data.portraitDisplay == "Mixed" then
										f_drawQuickSpr(p2randomPortrait, 320, 90, 0.5, 0.5)
									end
								else
									if data.portraitDisplay == "Portrait" then
										drawPortrait(t_selected[2].cel, 320, 90, -1, 0.5)
									elseif data.portraitDisplay == "Mixed" then
										drawPortrait(t_selected[2].cel, 320, 90, -0.5, 0.5)
									end
								end
							end
							if data.randomPortrait == "Fixed" and p2member1Random == true then
								if data.portraitDisplay == "Portrait" then
									f_drawQuickSpr(p2randomPortrait, 320, 20, 1, 0.5)
								elseif data.portraitDisplay == "Mixed" then
									f_drawQuickSpr(p2randomPortrait, 320, 20, 0.5, 0.5)
								end
							else
								if data.portraitDisplay == "Portrait" then
									drawPortrait(t_selected[1].cel, 320, 20, -1, 0.5)
								elseif data.portraitDisplay == "Mixed" then
									drawPortrait(t_selected[1].cel, 320, 20, -0.5, 0.5)
								end
							end
						elseif p2numChars == 3 then
							if j == 3 then
								if data.randomPortrait == "Fixed" and p2member3Random == true then
									f_drawQuickSpr(p2randomPortrait, 260, 90, 0.5, 0.5)
								else
									drawPortrait(t_selected[3].cel, 260, 90, -0.5, 0.5)
								end
							end
							if j == 2 then
								if data.randomPortrait == "Fixed" and p2member2Random == true then
									f_drawQuickSpr(p2randomPortrait, 320, 90, 0.5, 0.5)
								else
									drawPortrait(t_selected[2].cel, 320, 90, -0.5, 0.5)
								end
							end
							if data.randomPortrait == "Fixed" and p2member1Random == true then
								if data.portraitDisplay == "Portrait" then
									f_drawQuickSpr(p2randomPortrait, 320, 20, 1, 0.5)
								elseif data.portraitDisplay == "Mixed" then
									f_drawQuickSpr(p2randomPortrait, 290, 20, 0.5, 0.5)
								end
							else
								if data.portraitDisplay == "Portrait" then
									drawPortrait(t_selected[1].cel, 320, 20, -1, 0.5)
								elseif data.portraitDisplay == "Mixed" then
									drawPortrait(t_selected[1].cel, 290, 20, -0.5, 0.5)
								end
							end
						elseif p2numChars == 4 then
							if j == 4 then
								if data.randomPortrait == "Fixed" and p2member4Random == true then
									f_drawQuickSpr(p2randomPortrait, 260, 90, 0.5, 0.5)
								else
									drawPortrait(t_selected[4].cel, 260, 90, -0.5, 0.5)
								end
							end
							if j == 3 then
								if data.randomPortrait == "Fixed" and p2member3Random == true then
									f_drawQuickSpr(p2randomPortrait, 320, 90, 0.5, 0.5)
								else
									drawPortrait(t_selected[3].cel, 320, 90, -0.5, 0.5)
								end
							end
							if j == 2 then
								if data.randomPortrait == "Fixed" and p2member2Random == true then
									f_drawQuickSpr(p2randomPortrait, 260, 20, 0.5, 0.5)
								else
									drawPortrait(t_selected[2].cel, 260, 20, -0.5, 0.5)
								end
							end
							if data.randomPortrait == "Fixed" and p2member1Random == true then
								f_drawQuickSpr(p2randomPortrait, 320, 20, 0.5, 0.5)
							else
								drawPortrait(t_selected[1].cel, 320, 20, -0.5, 0.5)
							end
						end
					end
					if data.portraitDisplay == "Sprite" or data.portraitDisplay == "Mixed" then
						if data.portraitDisplay == "Sprite" then
							if j == 4 then
								if data.randomPortrait == "Fixed" and p2member4Random == true then
									f_drawQuickSpr(p2randomSprite, 176, 75)
								else
									f_drawCharAnim(t_selChars[t_selected[4].cel+1], 'p2AnimWin', 196, 164, t_selected[4].up, 1, 1, alphaS)
								end
							end
							if j == 3 then
								if data.randomPortrait == "Fixed" and p2member3Random == true then
									f_drawQuickSpr(p2randomSprite, 204, 75)
								else
									f_drawCharAnim(t_selChars[t_selected[3].cel+1], 'p2AnimWin', 224, 164, t_selected[3].up, 1, 1, alphaS)
								end
							end
							if j == 2 then
								if data.randomPortrait == "Fixed" and p2member2Random == true then
									f_drawQuickSpr(p2randomSprite, 232, 75)
								else
									f_drawCharAnim(t_selChars[t_selected[2].cel+1], 'p2AnimWin', 252, 164, t_selected[2].up, 1, 1, alphaS)
								end
							end
							if data.randomPortrait == "Fixed" and p2member1Random == true then
								f_drawQuickSpr(p2randomSprite, 260, 75)
							else
								f_drawCharAnim(t_selChars[t_selected[1].cel+1], 'p2AnimWin', 280, 164, t_selected[1].up, 1, 1, alphaS)
							end
							--f_drawCharAnim(t_selChars[t_selected[j].cel+1], 'p2AnimWin', 280 - 28*(j-1), 164, t_selected[j].up, 1, 1, alphaS)
						elseif data.portraitDisplay == "Mixed" then
							if p2numChars == 1 then
								if data.randomPortrait == "Fixed" and p2member1Random == true then
									--You can put your own sprite for random select but as also we are using the portrait logic is not necessary
								else
									f_drawCharAnim(t_selChars[t_selected[1].cel+1], 'p2AnimWin', 290, 158, t_selected[1].up, 1, 1, alphaS)
								end
							elseif p2numChars == 2 then
								if j == 2 then
									if data.randomPortrait == "Fixed" and p2member2Random == true then
										
									else
										f_drawCharAnim(t_selChars[t_selected[2].cel+1], 'p2AnimWin', 230, 158, t_selected[2].up, 0.5, 0.5, alphaS)
									end
								end
								if data.randomPortrait == "Fixed" and p2member1Random == true then
									
								else
									f_drawCharAnim(t_selChars[t_selected[1].cel+1], 'p2AnimWin', 230, 90, t_selected[1].up, 0.5, 0.5, alphaS)
								end
							elseif p2numChars == 3 then
								if j == 3 then
									if data.randomPortrait == "Fixed" and p2member3Random == true then
										
									else
										f_drawCharAnim(t_selChars[t_selected[3].cel+1], 'p2AnimWin', 250, 158, t_selected[3].up, 0.5, 0.5, alphaS)
									end
								end
								if j == 2 then
									if data.randomPortrait == "Fixed" and p2member2Random == true then
										
									else
										f_drawCharAnim(t_selChars[t_selected[2].cel+1], 'p2AnimWin', 310, 158, t_selected[2].up, 0.5, 0.5, alphaS)
									end
								end
								if data.randomPortrait == "Fixed" and p2member1Random == true then
									
								else
									f_drawCharAnim(t_selChars[t_selected[1].cel+1], 'p2AnimWin', 280, 89, t_selected[1].up, 0.5, 0.5, alphaS)
								end
							elseif p2numChars == 4 then
								if j == 4 then
									if data.randomPortrait == "Fixed" and p2member4Random == true then
										
									else
										f_drawCharAnim(t_selChars[t_selected[4].cel+1], 'p2AnimWin', 250, 158, t_selected[4].up, 0.5, 0.5, alphaS)
									end
								end
								if j == 3 then
									if data.randomPortrait == "Fixed" and p2member3Random == true then
										
									else
										f_drawCharAnim(t_selChars[t_selected[3].cel+1], 'p2AnimWin', 310, 158, t_selected[3].up, 0.5, 0.5, alphaS)
									end
								end
								if j == 2 then
									if data.randomPortrait == "Fixed" and p2member2Random == true then
										
									else
										f_drawCharAnim(t_selChars[t_selected[2].cel+1], 'p2AnimWin', 250, 89, t_selected[2].up, 0.5, 0.5, alphaS)
									end
								end
								if data.randomPortrait == "Fixed" and p2member1Random == true then
									
								else
									f_drawCharAnim(t_selChars[t_selected[1].cel+1], 'p2AnimWin', 310, 89, t_selected[1].up, 0.5, 0.5, alphaS)
								end
							end
						end
					end
				end
			end
		end
		for j=#t_selected, 1, -1 do --Again to set priority over sprites
			if not exclusiveStageMenu then
				if data.portraitDisplay == "Portrait" or data.portraitDisplay == "Mixed" then
					if p2numChars == 1 then
						if data.randomPortrait == "Fixed" and p2member1Random == true then
							f_drawQuickText(txt_p2RandomMember1, jgFnt, 5, -1, "RANDOM SELECT 1", 310, 165, 0.8, 0.8)
						else
							f_drawSelectName(txt_p2Name, t_selected[1], 310, 165)
						end
					elseif p2numChars == 2 then
						if j == 2 then
							if data.portraitDisplay == "Portrait" then
								if data.randomPortrait == "Fixed" and p2member2Random == true then
									f_drawQuickText(txt_p2RandomMember2, jgFnt, 5, -1, "RANDOM SELECT 2", 318, 100, 0.8, 0.8)
								else
									f_drawSelectName(txt_p2Name, t_selected[2], 318, 100)
								end
							elseif data.portraitDisplay == "Mixed" then
								if data.randomPortrait == "Fixed" and p2member2Random == true then
									f_drawQuickText(txt_p2RandomMember2, jgFnt, 5, -1, "RANDOM SELECT 2", 254, 100, 0.5, 0.5)
								else
									f_drawSelectName(txt_p2Name, t_selected[2], 254, 100, 0.5, 0.5)
								end
							end
						end
						if data.portraitDisplay == "Portrait" then
							if data.randomPortrait == "Fixed" and p2member1Random == true then
								f_drawQuickText(txt_p2RandomMember1, jgFnt, 5, -1, "RANDOM SELECT 1", 318, 88, 0.8, 0.8)
							else
								f_drawSelectName(txt_p2Name, t_selected[1], 318, 88)
							end
						elseif data.portraitDisplay == "Mixed" then
							if data.randomPortrait == "Fixed" and p2member1Random == true then
								f_drawQuickText(txt_p2RandomMember1, jgFnt, 5, -1, "RANDOM SELECT 1", 254, 30, 0.5, 0.5)
							else
								f_drawSelectName(txt_p2Name, t_selected[1], 254, 30, 0.5, 0.5)
							end
						end
					elseif p2numChars == 3 then
						if j == 3 then
							if data.randomPortrait == "Fixed" and p2member3Random == true then
								f_drawQuickText(txt_p2RandomMember3, jgFnt, 5, -1, "RANDOM SELECT 3", 254, 100, 0.5, 0.5)
							else
								f_drawSelectName(txt_p2Name, t_selected[3], 254, 100, 0.5, 0.5)
							end
						end
						if j == 2 then
							if data.randomPortrait == "Fixed" and p2member2Random == true then
								f_drawQuickText(txt_p2RandomMember2, jgFnt, 5, -1, "RANDOM SELECT 2", 320, 100, 0.5, 0.5)
							else
								f_drawSelectName(txt_p2Name, t_selected[2], 320, 100, 0.5, 0.5)
							end
						end
						if data.portraitDisplay == "Portrait" then
							if data.randomPortrait == "Fixed" and p2member1Random == true then
								f_drawQuickText(txt_p2RandomMember1, jgFnt, 5, -1, "RANDOM SELECT 1", 318, 88, 0.8, 0.8)
							else
								f_drawSelectName(txt_p2Name, t_selected[1], 318, 88)
							end
						elseif data.portraitDisplay == "Mixed" then
							if data.randomPortrait == "Fixed" and p2member1Random == true then
								f_drawQuickText(txt_p2RandomMember1, jgFnt, 5, -1, "RANDOM SELECT 1", 290, 30, 0.5, 0.5)
							else
								f_drawSelectName(txt_p2Name, t_selected[1], 290, 30, 0.5, 0.5)
							end
						end
					elseif p2numChars == 4 then
						if j == 4 then
							if data.randomPortrait == "Fixed" and p2member4Random == true then
								f_drawQuickText(txt_p2RandomMember4, jgFnt, 5, -1, "RANDOM SELECT 4", 254, 100, 0.5, 0.5)
							else
								f_drawSelectName(txt_p2Name, t_selected[4], 254, 100, 0.5, 0.5)
							end
						end
						if j == 3 then
							if data.randomPortrait == "Fixed" and p2member3Random == true then
								f_drawQuickText(txt_p2RandomMember3, jgFnt, 5, -1, "RANDOM SELECT 3", 320, 100, 0.5, 0.5)
							else
								f_drawSelectName(txt_p2Name, t_selected[3], 320, 100, 0.5, 0.5)
							end
						end
						if j == 2 then
							if data.randomPortrait == "Fixed" and p2member2Random == true then
								f_drawQuickText(txt_p2RandomMember2, jgFnt, 5, -1, "RANDOM SELECT 2", 254, 30, 0.5, 0.5)
							else
								f_drawSelectName(txt_p2Name, t_selected[2], 254, 30, 0.5, 0.5)
							end
						end
						if data.randomPortrait == "Fixed" and p2member1Random == true then
							f_drawQuickText(txt_p2RandomMember1, jgFnt, 5, -1, "RANDOM SELECT 1", 320, 30, 0.5, 0.5)
						else
							f_drawSelectName(txt_p2Name, t_selected[1], 320, 30, 0.5, 0.5)
						end
					end
				elseif data.portraitDisplay == "Sprite" then
					if j == 4 then
						if data.randomPortrait == "Fixed" and p2member4Random == true then
							f_drawQuickText(txt_p2RandomMember4, jgFnt, 5, -1, "RANDOM SELECT 4", 308, 166, 0.8, 0.8)
						else
							f_drawSelectName(txt_p2Name, t_selected[4], 308, 166)
						end
					end
					if j == 3 then
						if data.randomPortrait == "Fixed" and p2member3Random == true then
							f_drawQuickText(txt_p2RandomMember3, jgFnt, 5, -1, "RANDOM SELECT 3", 312, 160, 0.8, 0.8)
						else
							f_drawSelectName(txt_p2Name, t_selected[3], 312, 160)
						end
					end
					if j == 2 then
						if data.randomPortrait == "Fixed" and p2member2Random == true then
							f_drawQuickText(txt_p2RandomMember2, jgFnt, 5, -1, "RANDOM SELECT 2", 316, 154, 0.8, 0.8)
						else
							f_drawSelectName(txt_p2Name, t_selected[2], 316, 154)
						end
					end
					if data.randomPortrait == "Fixed" and p2member1Random == true then
						f_drawQuickText(txt_p2RandomMember1, jgFnt, 5, -1, "RANDOM SELECT 1", 320, 148, 0.8, 0.8)
					else
						f_drawSelectName(txt_p2Name, t_selected[1], 320, 148)
					end
				end
			end
		end
	--Draw Player 2 Selected Assets for Co-Op Mode
		if p2coopReady then
		--Portrait
			if data.portraitDisplay == "Portrait" or data.portraitDisplay == "Mixed" then
				if data.randomPortrait == "Fixed" and p2coopRandom == true then
					if data.portraitDisplay == "Portrait" then
						f_drawQuickSpr(p1randomPortrait, 0, 90, 1, 0.5)
					elseif data.portraitDisplay == "Mixed" then
						f_drawQuickSpr(p1randomPortrait, 0, 90, 0.5, 0.5)
					end
				else
					if data.portraitDisplay == "Portrait" then
						drawPortrait(data.t_p1selected[2].cel, 0, 90, 1, 0.5)
					elseif data.portraitDisplay == "Mixed" then
						drawPortrait(data.t_p1selected[2].cel, 0, 90, 0.5, 0.5)
					end
				end
			end
		--Animated Sprite
			if data.portraitDisplay == "Sprite" or data.portraitDisplay == "Mixed" then
				if data.portraitDisplay == "Sprite" then
					if data.randomPortrait == "Fixed" and p2coopRandom == true then
						f_drawQuickSpr(p1randomSprite, 48, 75)
					else
						f_drawCharAnim(t_selChars[data.t_p1selected[2].cel+1], 'p1AnimWin', 68, 164, data.t_p1selected[2].up, 1, 1, alphaS)
					end
				elseif data.portraitDisplay == "Mixed" then
					if data.randomPortrait == "Fixed" and p2coopRandom == true then
						--
					else
						f_drawCharAnim(t_selChars[data.t_p1selected[2].cel+1], 'p1AnimWin', 90, 158, data.t_p1selected[2].up, 0.5, 0.5, alphaS)
					end
				end
			end
		--Name
			if data.portraitDisplay == "Portrait" then
				if data.randomPortrait == "Fixed" and p2coopRandom == true then
					f_drawQuickText(txt_p2RandomMember2, jgFnt, 5, -1, "RANDOM SELECT 2", 116, 100, 0.8, 0.8)
				else
					f_drawSelectName(txt_p2Name, data.t_p1selected[2], 116, 100)
				end	
			elseif data.portraitDisplay == "Mixed" then
				if data.randomPortrait == "Fixed" and p2coopRandom == true then
					f_drawQuickText(txt_p2RandomMember2, jgFnt, 5, 1, "RANDOM SELECT 2", 66, 100, 0.5, 0.5)
				else
					f_drawSelectName(txt_p2Name, data.t_p1selected[2], 66, 100, 0.5, 0.5)
				end
			end
		end
		if not p2SelEnd then
			local tmpCelX = p2SelX
			local tmpCelY = p2SelY
			if backScreen == false and not p2CharEnd then
				if commandGetState(p2Cmd, 'u') or (commandGetState(p2Cmd, 'holdu') and bufSel2u >= 30) then
					local foundCel = false
					while true do
						if foundCel then
							break
						end
						p2SelY, p2FaceOffset, p2OffsetRow = f_findCelYSub(p2SelY, p2FaceOffset, p2OffsetRow)
						if getCharName(p2SelX+selectColumns*p2SelY) ~= '' then
							foundCel = true
						else
							for i=0, tmpCelX do
								p2SelX = f_findCelXSub(p2SelX, false)
								if getCharName(p2SelX+selectColumns*p2SelY) ~= '' then
									foundCel = true
									break
								end
							end
							if not foundCel then
								p2SelX = tmpCelX
								for i=1, selectColumns-tmpCelX do
									p2SelX = f_findCelXAdd(p2SelX, false)
									if getCharName(p2SelX+selectColumns*p2SelY) ~= '' then
										foundCel = true
										break
									end
								end
								if not foundCel then
									p2SelX = tmpCelX
								end
							end
						end
					end
					if tmpCelY ~= p2SelY or tmpCelX ~= p2SelX then
						sndPlay(sndSys, 100, 0)
					end
				elseif commandGetState(p2Cmd, 'd') or (commandGetState(p2Cmd, 'holdd') and bufSel2d >= 30) then
					local foundCel = false
					while true do
						if foundCel then
							break
						end
						p2SelY, p2FaceOffset, p2OffsetRow = f_findCelYAdd(p2SelY, p2FaceOffset, p2OffsetRow)
						if getCharName(p2SelX+selectColumns*p2SelY) ~= '' then
							foundCel = true
						else
							for i=1, selectColumns-tmpCelX do
								p2SelX = f_findCelXAdd(p2SelX, false)
								if getCharName(p2SelX+selectColumns*p2SelY) ~= '' then
									foundCel = true
									break
								end
							end
							if not foundCel then
								p2SelX = tmpCelX
								for i=0, tmpCelX do
									p2SelX = f_findCelXSub(p2SelX, false)
									if getCharName(p2SelX+selectColumns*p2SelY) ~= '' then
										foundCel = true
										break
									end
								end
								if not foundCel then
									p2SelX = tmpCelX
								end
							end
						end
					end
					if tmpCelY ~= p2SelY or tmpCelX ~= p2SelX then
						sndPlay(sndSys, 100, 0)
					end
				elseif commandGetState(p2Cmd, 'l') or (commandGetState(p2Cmd, 'holdl') and bufSel2l >= 30) then
					while true do
						p2SelX = f_findCelXSub(p2SelX, wrappingX)
						if getCharName(p2SelX+selectColumns*p2SelY) ~= '' then break end
					end
					if tmpCelX ~= p2SelX then
						sndPlay(sndSys, 100, 0)
					end
				elseif commandGetState(p2Cmd, 'r') or (commandGetState(p2Cmd, 'holdr') and bufSel2r >= 30) then
					while true do
						p2SelX = f_findCelXAdd(p2SelX, wrappingX)
						if getCharName(p2SelX+selectColumns*p2SelY) ~= '' then break end
					end
					if tmpCelX ~= p2SelX then
						sndPlay(sndSys, 100, 0)
					end
				end
				if commandGetState(p2Cmd, 'holdu') then
					bufSel2d = 0
					bufSel2u = bufSel2u + 1
				elseif commandGetState(p2Cmd, 'holdd') then
					bufSel2u = 0
					bufSel2d = bufSel2d + 1
				elseif commandGetState(p2Cmd, 'holdr') then
					bufSel2l = 0
					bufSel2r = bufSel2r + 1
				elseif commandGetState(p2Cmd, 'holdl') then
					bufSel2r = 0
					bufSel2l = bufSel2l + 1
				else
					bufSel2u = 0
					bufSel2d = 0
					bufSel2r = 0
					bufSel2l = 0
				end
			end
			p2Cell = p2SelX + selectColumns*p2SelY
			p2Portrait = p2Cell
			if data.charInfo == "Author" then
				if t_selChars[p2Cell+1].author ~= nil or getCharName(p2Cell) == "Random" then
					if t_selChars[p2Cell+1].author ~= nil then
						textImgSetText(txt_p2Author, txt_authorText..t_selChars[p2Cell+1].author)
					else
						textImgSetText(txt_p2Author, txt_authorText.."???")
					end
					if data.coop then
						textImgSetAlign(txt_p2Author, 1)
						if data.portraitDisplay == "Sprite" then
							textImgScalePosDraw(txt_p2Author, 0, 30, 0.65, 0.65)
						else
							textImgScalePosDraw(txt_p2Author, 0, 165, 0.65, 0.65)
						end
					else
						textImgSetAlign(txt_p2Author, -1)
						textImgScalePosDraw(txt_p2Author, 320, 20, 0.65, 0.65)
						--textImgDraw(txt_p2Author)
					end
				end
			end
			textImgSetBank(txt_p2Name, 0)
			textImgSetText(txt_p2Name, f_getName(p2Cell))
			if data.portraitDisplay == "Portrait" or data.portraitDisplay == "Mixed" then
				if p2numChars == 1 then
					textImgScalePosDraw(txt_p2Name, 310, 165, 0.8, 0.8)
				elseif p2numChars == 2 then
					if data.coop then
						if data.portraitDisplay == "Portrait" then
							textImgScalePosDraw(txt_p2Name, 116, 100, 0.8, 0.8)
						elseif data.portraitDisplay == "Mixed" then
							textImgScalePosDraw(txt_p2Name, 116, 100, 0.5, 0.5)
						end
					else
						if p2memberPreview == 1 then
							if data.portraitDisplay == "Portrait" then
								textImgScalePosDraw(txt_p2Name, 318, 88, 0.8, 0.8)
							elseif data.portraitDisplay == "Mixed" then
								textImgScalePosDraw(txt_p2Name, 254, 30, 0.5, 0.5)
							end
						end
						if p2memberPreview == 2 then
							if data.portraitDisplay == "Portrait" then
								textImgScalePosDraw(txt_p2Name, 318, 100, 0.8, 0.8)
							elseif data.portraitDisplay == "Mixed" then
								textImgScalePosDraw(txt_p2Name, 254, 100, 0.5, 0.5)
							end
						end
					end
				elseif p2numChars == 3 then
					if p2memberPreview == 1 then
						if data.portraitDisplay == "Portrait" then
							textImgScalePosDraw(txt_p2Name, 318, 88, 0.8, 0.8)
						elseif data.portraitDisplay == "Mixed" then
							textImgScalePosDraw(txt_p2Name, 290, 30, 0.5, 0.5)
						end
					end
					if p2memberPreview == 2 then textImgScalePosDraw(txt_p2Name, 320, 100, 0.5, 0.5) end
					if p2memberPreview == 3 then textImgScalePosDraw(txt_p2Name, 254, 100, 0.5, 0.5) end
				elseif p2numChars == 4 then
					if p2memberPreview == 1 then textImgScalePosDraw(txt_p2Name, 320, 30, 0.5, 0.5) end
					if p2memberPreview == 2 then textImgScalePosDraw(txt_p2Name, 254, 30, 0.5, 0.5) end
					if p2memberPreview == 3 then textImgScalePosDraw(txt_p2Name, 320, 100, 0.5, 0.5) end
					if p2memberPreview == 4 then textImgScalePosDraw(txt_p2Name, 254, 100, 0.5, 0.5) end
				end
			elseif data.portraitDisplay == "Sprite" then
				if data.coop then
					textImgPosDraw(txt_p2Name, 150, 156)
				else
					if p2memberPreview == 1 then
						textImgPosDraw(txt_p2Name, 320, 148)
					elseif p2memberPreview == 2 then
						textImgPosDraw(txt_p2Name, 316, 154)
					elseif p2memberPreview == 3 then
						textImgPosDraw(txt_p2Name, 312, 160)
					elseif p2memberPreview == 4 then
						textImgPosDraw(txt_p2Name, 308, 166)
					end
				end
			end
		--Back to Team Menu Logic
			if (data.p1In == 2 and data.p2In == 2) then --Player 1 in player 2 (right) side
				if commandGetState(p2Cmd, 'e') then
					if serviceBack == true then
						f_p2sideReset()
						p2TeamEnd = true
						p2BG = true
						p2memberPreview = 1
					elseif p2SelBack == true then
						sndPlay(sndSys, 100, 2)
						f_p2sideReset()
					end
				end
			else
				if commandGetState(p1Cmd, 'e') and p2SelBack == true and not data.coop then
					sndPlay(sndSys, 100, 2)
					f_p2sideReset()
				end
			end
			if btnPalNo(p2Cmd, true) > 0 then
				if t_unlockLua.chars[t_selChars[p2Cell+1].char] == nil and f_checkTeamDuplicates(data.t_p2selected, p2Cell) or onlinegame then
					f_p2Selection()
				else--if t_unlockLua.chars[t_selChars[p2Cell+1].char] ~= nil and not f_checkTeamDuplicates(data.t_p2selected, p2Cell) and not onlinegame then
					sndPlay(sndIkemen, 200, 0)
				end
			elseif selectTimer == 0 then
				if t_unlockLua.chars[t_selChars[p2Cell+1].char] ~= nil and not f_checkTeamDuplicates(data.t_p2selected, p2Cell) then
					p2Cell = t_randomChars[math.random(#t_randomChars)]
				end
				f_p2Selection()
			end
			if p2HandicapEnd and p2PalEnd and p2CharEnd then
				local cel = p2Cell
				if getCharName(cel) == "Random" then
					randomP2Rematch = true
					cel = t_randomChars[math.random(#t_randomChars)]
					if data.coop then p2coopRandom = true end
					if p2memberPreview == 1 then p2member1Random = true	end
					if p2memberPreview == 2 then p2member2Random = true	end
					if p2memberPreview == 3 then p2member3Random = true	end
					if p2memberPreview == 4 then p2member4Random = true	end
				end
				f_p2charAnnouncer(cel)
				if t_selChars[cel+1].p2AnimWin then animReset(t_selChars[cel+1].p2AnimWin) end
				if p2numChars > 1 and not data.coop then
					if p2memberPreview == 1 then p2memberPreview = 2
					elseif p2memberPreview == 2 then p2memberPreview = 3
					elseif p2memberPreview == 3 then p2memberPreview = 4
					elseif p2memberPreview == 4 then p2memberPreview = 1
					end
				end
				local updateAnim = true
				if data.coop then
					for i=1, #data.t_p1selected do
						if data.t_p1selected[i].cel == p2Cell then 
							updateAnim = false
						end
					end
					data.t_p1selected[2] = {['cel'] = cel, ['name'] = t_selChars[cel+1].name, ['displayname'] = t_selChars[cel+1].displayname, ['path'] = t_selChars[cel+1].char, ['pal'] = p2PalSel, ['handicap'] = p2HandicapSel, ['up'] = updateAnim, ['author'] = t_selChars[cel+1].author, ['discordkey'] = t_selChars[cel+1].discordkey}
					p2coopReady = true
					p2SelEnd = true
				else
					for i=1, #data.t_p2selected do
						if data.t_p2selected[i].cel == p2Cell then 
							updateAnim = false
						end
					end
					data.t_p2selected[#data.t_p2selected+1] = {['cel'] = cel, ['name'] = t_selChars[cel+1].name, ['displayname'] = t_selChars[cel+1].displayname, ['path'] = t_selChars[cel+1].char, ['pal'] = p2PalSel, ['handicap'] = p2HandicapSel, ['up'] = updateAnim, ['author'] = t_selChars[cel+1].author, ['discordkey'] = t_selChars[cel+1].discordkey}
					if #data.t_p2selected == p2numChars then
						--
						if data.p1In == 2 and matchNo == 0 then
							p1TeamEnd = false
							p1SelEnd = false
						--[[
							commandBufReset(p1Cmd)
							commandBufReset(p2Cmd)
						]]
						end
						--
						p2SelEnd = true
					else
						p2HandicapEnd = false
						p2PalEnd = false
						p2CharEnd = false
					end
				end
				if data.debugLog then
					f_printTable(data.t_p2selected, "save/debug/data.t_p2selected.log")
					f_printTable(t_selected, "save/debug/t_selected.log")
				end
			end
		end
	end
end

function f_p2Selection()
	sndPlay(sndSys, 100, 1)
	if data.palType == "Classic" then
		p2PalSel = btnPalNo(p2Cmd, true)
		if selectTimer == 0 then p2PalSel = 1 end --Avoid freeze when Character Select timer is over and there is not are a palette selected
		p2PalEnd = true
	else
		if getCharName(p2Cell) == "Random" then
			p2PalSel = math.random(1,12) --Set Random Palette for random select
			p2PalEnd = true
		end
	end
	if data.gameMode ~= "versus" or data.ftcontrol > 0 then
		p2HandicapSel = 1 --Set Normal Handicap as Default
		p2HandicapEnd = true
	end
	p2CharEnd = true
	cmdInput()
end

--;===========================================================
--; PLAYER 2 PALETTE SELECT
--;===========================================================
function f_p2SelectPal()
	if (commandGetState(p2Cmd, 'r') or commandGetState(p2Cmd, 'u') or (commandGetState(p2Cmd, 'holdu') and bufPal2u >= 30) or (commandGetState(p2Cmd, 'holdr') and bufPal2r >= 30)) and p2PalSel <= 11 then
		sndPlay(sndSys, 100, 0)
		p2PalSel = p2PalSel + 1
	elseif (commandGetState(p2Cmd, 'l') or commandGetState(p2Cmd, 'd') or (commandGetState(p2Cmd, 'holdd') and bufPal2d >= 30) or (commandGetState(p2Cmd, 'holdl') and bufPal2l >= 30)) and p2PalSel > 1 then
		sndPlay(sndSys, 100, 0)
		p2PalSel = p2PalSel - 1
	end
	if commandGetState(p2Cmd, 'holdu') then
		bufPal2d = 0
		bufPal2u = bufPal2u + 1
	elseif commandGetState(p2Cmd, 'holdd') then
		bufPal2u = 0
		bufPal2d = bufPal2d + 1
	elseif commandGetState(p2Cmd, 'holdr') then
		bufPal2l = 0
		bufPal2r = bufPal2r + 1
	elseif commandGetState(p2Cmd, 'holdl') then
		bufPal2r = 0
		bufPal2l = bufPal2l + 1
	else
		bufPal2u = 0
		bufPal2d = 0
		bufPal2r = 0
		bufPal2l = 0
	end
	animPosDraw(palSelBG, palSelBGP2posX, palSelBGP2posY)
	textImgDraw(txt_p2Pal)
	textImgSetText(txt_p2PalNo, p2PalSel)
	textImgDraw(txt_p2PalNo)
	if p2PalSel > 1 then
		animPosDraw(palSelArrowLeft, palSelArrowLP2posX, palSelArrowLP2posY)
	end
	if p2PalSel <= 11 then
		animPosDraw(palSelArrowRight, palSelArrowRP2posX, palSelArrowRP2posY)
	end
	if btnPalNo(p2Cmd, true) > 0 or selectTimer == 0 then
		sndPlay(sndSys, 100, 1)
		p2PalEnd = true
		cmdInput()
	elseif commandGetState(p2Cmd, 'e') then
		sndPlay(sndSys, 100, 2)
		p2CharEnd = false
		cmdInput()
	end
end

--;===========================================================
--; PLAYER 2 HANDICAP SELECT
--;===========================================================
function f_p2SelectHandicap()
	local maxItems = 3
	if commandGetState(p2Cmd, 'u') or (commandGetState(p2Cmd, 'holdu') and bufHand2u >= 30) then
		sndPlay(sndSys, 100, 0)
		p2HandicapSel = p2HandicapSel - 1
	elseif commandGetState(p2Cmd, 'd') or (commandGetState(p2Cmd, 'holdd') and bufHand2d >= 30) then
		sndPlay(sndSys, 100, 0)
		p2HandicapSel = p2HandicapSel + 1
	end
	if p2HandicapSel < 1 then
		p2HandicapSel = #t_handicapSelect2
		if #t_handicapSelect2 > maxItems then
			p2HandicapCursorPosY = maxItems
		else
			p2HandicapCursorPosY = #t_handicapSelect2
		end
	elseif p2HandicapSel > #t_handicapSelect2 then
		p2HandicapSel = 1
		p2HandicapCursorPosY = 1
	elseif (commandGetState(p2Cmd, 'u') or (commandGetState(p2Cmd, 'holdu') and bufHand2u >= 30)) and p2HandicapCursorPosY > 1 then
		p2HandicapCursorPosY = p2HandicapCursorPosY - 1
	elseif (commandGetState(p2Cmd, 'd') or (commandGetState(p2Cmd, 'holdd') and bufHand2d >= 30)) and p2HandicapCursorPosY < maxItems then
		p2HandicapCursorPosY = p2HandicapCursorPosY + 1
	end
	if p2HandicapCursorPosY == maxItems then
		p2HandicapMoveTxt = (p2HandicapSel - maxItems) * 13
	elseif p2HandicapCursorPosY == 1 then
		p2HandicapMoveTxt = (p2HandicapSel - 1) * 13
	end
	if #t_handicapSelect2 <= maxItems then
		maxP2Handicap = #t_handicapSelect2
	elseif p2HandicapSel - p2HandicapCursorPosY > 0 then
		maxP2Handicap = p2HandicapSel + maxItems - p2HandicapCursorPosY
	else
		maxP2Handicap = maxItems
	end
	if commandGetState(p2Cmd, 'holdu') then
		bufHand2d = 0
		bufHand2u = bufHand2u + 1
	elseif commandGetState(p2Cmd, 'holdd') then
		bufHand2u = 0
		bufHand2d = bufHand2d + 1
	elseif commandGetState(p2Cmd, 'holdr') then
		bufHand2l = 0
		bufHand2r = bufHand2r + 1
	elseif commandGetState(p2Cmd, 'holdl') then
		bufHand2r = 0
		bufHand2l = bufHand2l + 1
	else
		bufHand2u = 0
		bufHand2d = 0
		bufHand2r = 0
		bufHand2l = 0
	end
	animPosDraw(handicapWindowBG, handicapSelBGP2posX, handicapSelBGP2posY)
	textImgDraw(txt_handicapP2)
	for i=1, maxP2Handicap do
		if i > p2HandicapSel - p2HandicapCursorPosY then
			if i == p2HandicapSel then
				p2Handbank = 5
			else
				p2Handbank = 0
			end
			if t_handicapSelect2[i].id ~= nil then
				textImgDraw(f_updateTextImg(t_handicapSelect2[i].id, jgFnt, p2Handbank, 0, t_handicapSelect2[i].text, 244, 168+i*13-p2HandicapMoveTxt, 0.95, 0.95))
			end
		end
	end
	animSetWindow(cursorBox, 172, 158+p2HandicapCursorPosY*13, 145, 13)
	f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
	animDraw(f_animVelocity(cursorBox, -1, -1))
	if maxP2Handicap > maxItems then
		animPosDraw(handicapSelArrowUp, handicapSelArrowUP2posX, handicapSelArrowUP2posY)
	end
	if #t_handicapSelect2 > maxItems and maxP2Handicap < #t_handicapSelect2 then
		animPosDraw(handicapSelArrowDown, handicapSelArrowDP2posX, handicapSelArrowDP2posY)
	end
	if btnPalNo(p2Cmd, true) > 0 or selectTimer == 0 then
		sndPlay(sndSys, 100, 1)
		p2HandicapEnd = true
		cmdInput()
	elseif commandGetState(p2Cmd, 'e') then
		sndPlay(sndSys, 100, 2)
		p2PalEnd = false
		cmdInput()
	end
end

--;===========================================================
--; STAGE SELECT MENU
--;===========================================================
function f_selectStage()
	if data.debugLog then f_printTable(data.t_p1selected, "save/debug/data.t_p1selected.log") end
	if data.stageMenu then --If Stage Select is Enabled
		stageMenuActive = true --To Delete content from previous menu
		if data.rosterAdvanced == true then
			f_loadCharResources() --Because in selectAdvanced for some side, there's not a character loaded
		else --selectSimple game modes
		--Logic For Auto Characters Song
			p1charSong = ""
			if t_selChars[data.t_p1selected[1].cel+1].music ~= nil then
				p1charSong = math.random(1,#t_selChars[data.t_p1selected[1].cel+1].music) --if there are more than 1 song assigned for that character, pick 1 of them via randomizer
				p1charSong = t_selChars[data.t_p1selected[1].cel+1].music[p1charSong].bgmusic --data.t_p1selected[1] means that data (music) will taken from 1st char member selected in any team mode, but if you set data.t_p1selected[2] will get data from the 2nd member of a team mode.
				p1song = true
			else --If there no music assigned for left side character
				p1song = false
			end
			p2charSong = ""
			if t_selChars[data.t_p2selected[1].cel+1].music ~= nil then
				p2charSong = math.random(1,#t_selChars[data.t_p2selected[1].cel+1].music)
				p2charSong = t_selChars[data.t_p2selected[1].cel+1].music[p2charSong].bgmusic
				p2song = true
			else --If there no music assigned for right side character
				p2song = false
			end
		--Logic For Auto Characters Stage
			if t_selChars[data.t_p1selected[1].cel+1].stage ~= nil then
				p1charStage = math.random(1,#t_selChars[data.t_p1selected[1].cel+1].stage) --if there are more than 1 stage assigned for that character, pick 1 of them via randomizer
				p1charStage = t_selChars[data.t_p1selected[1].cel+1].stage[p1charStage] --data.t_p1selected[1] means that data (stage) will taken from 1st char member selected in any team mode, but if you set data.t_p1selected[2] will get data from the 2nd member of a team mode.
				p1stage = true
			else --If there no stage assigned for left side character
				p1stage = false
			end
			if t_selChars[data.t_p2selected[1].cel+1].stage ~= nil then
				p2charStage = math.random(1,#t_selChars[data.t_p2selected[1].cel+1].stage)
				p2charStage = t_selChars[data.t_p2selected[1].cel+1].stage[p2charStage]
				p2stage = true
			else
				--If there no stage assigned for right side character
				p2stage = false
			end
		end
	--Set screen Assets
		if data.stageType == "Classic" then
			--Info Text
			textImgSetPos(txt_selStage, 160, 239)
			
			textImgSetPos(txt_selectMusic, 158, 170.5)
			textImgSetScale(txt_selectMusic, 0.5, 0.5)
			
			textImgSetPos(txt_stageAuthor, 206.5, 186)
			textImgSetScale(txt_stageAuthor, 0.5, 0.5)
			textImgSetAlign(txt_stageAuthor, 1)
			textImgSetBank(txt_stageAuthor, 0)
			
			textImgSetPos(txt_stageLocation, 159, 227)
			textImgSetScale(txt_stageLocation, 0.5, 0.5)
			textImgSetBank(txt_stageLocation, 0)
			
			textImgSetPos(txt_stageDayTime, 112, 186)
			textImgSetScale(txt_stageDayTime, 0.5, 0.5)
			textImgSetAlign(txt_stageDayTime, -1)
			textImgSetBank(txt_stageDayTime, 0)
		elseif data.stageType == "Modern" then
			exclusiveStageMenu = true
			--Info Text
			textImgSetPos(txt_selStage, 160, 205)
			
			textImgSetPos(txt_selectMusic, 158, 60)
			textImgSetScale(txt_selectMusic, 1, 1)
			
			textImgSetPos(txt_stageAuthor, 159, 235)
			textImgSetScale(txt_stageAuthor, 1, 1)
			textImgSetAlign(txt_stageAuthor, 0)
			textImgSetBank(txt_stageAuthor, 0)
			
			textImgSetPos(txt_stageLocation, 159, 220)
			textImgSetScale(txt_stageLocation, 1, 1)
			textImgSetBank(txt_stageLocation, 0)
			
			textImgSetPos(txt_stageDayTime, 159, 190)
			textImgSetScale(txt_stageDayTime, 1, 1)
			textImgSetAlign(txt_stageDayTime, 0)
			textImgSetBank(txt_stageDayTime, 0)
			--Draw Stage Select Title BG
			animDraw(f_animVelocity(selectSTBG2a, -1, 0))
			animDraw(f_animVelocity(selectSTBG2b, -3, 0))
			animDraw(f_animVelocity(selectSTBG2c, -6, 0))
			--Draw Stage Name BG
			animDraw(f_animVelocity(selectSBG2a, 1, 0))
			animDraw(f_animVelocity(selectSBG2b, 3, 0))
			animDraw(f_animVelocity(selectSBG2c, 6, 0))
			--Draw Stage Title Text
			textImgDraw(txt_stageSelect)
		end
		--if stageAnnouncer == false then
			if backScreen == false and stageAnnouncer == false then
				if commandGetState(p1Cmd, 's') or commandGetState(p2Cmd, 's') then
					if stageSelect == true then
						--sndPlay(sndSys, 100, 0)
						--TO-DO: Alternative Stage Code Like Ikemen Go Chars Slots
					end
					if songSelect == true then --Song Preview
						if stageList == 0 then
						--Do Nothing because Song Preview for Random Stage will get an Error because it can't detect which Stage will be Selected (can be resolved by adding a Song selection Menu Apart from the stage selection, it will work when a Stage was selected)
						else 
							f_musicPreview()
						end
					end
				elseif commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u') then
					sndPlay(sndSys, 100, 0)
					if bufStagel then bufStagel = 0 end
					if bufStager then bufStager = 0 end
					--Allow Stage Select
					if stageSelect then stageSelect = false
					else stageSelect = true
					end
					--Allow Song Select
					if songSelect then songSelect = false
					else songSelect = true
					end
				elseif commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd') then
					sndPlay(sndSys, 100, 0)
					if bufStagel then bufStagel = 0 end
					if bufStager then bufStager = 0 end
					--Allow Stage Select
					if stageSelect then stageSelect = false
					else stageSelect = true
					end
					--Allow Song Select
					if songSelect then songSelect = false
					else songSelect = true
					end
				elseif (commandGetState(p1Cmd, 'r') or commandGetState(p2Cmd, 'r')) or ((commandGetState(p1Cmd, 'holdr') or commandGetState(p2Cmd, 'holdr')) and bufStager >= 30) then
					sndPlay(sndSys, 100, 0)
					if stageSelect == true then
					--Auto Right Side Stage Logic
						if stageList == 0 and not p1autoSlot then
							if p2stage == true and not p2autoSlot then --Go to Auto Stage
								p2autoSlot = true
								--stageList = 0
							elseif not p2stage then --Skip Player 2 Stage if is not assigned (Go to next stage)
								stageList = stageList + 1
							elseif p2stage == true and p2autoSlot == true then --Go to first stage loaded
								p2autoSlot = false
								stageList = stageList + 1
							end
						elseif stageList ~= 0 then --Normal scrolling between stages loaded
							if not p1autoSlot and not p2autoSlot then
								stageList = stageList + 1
							end
						end
					--Auto Left Side Stage Logic
						if stageList == data.includestage + 1 then
							if p1stage == true and not p1autoSlot then --Go to Auto Stage
								p1autoSlot = true
								stageList = 0
							elseif not p1stage then --Skip Player 1 Stage if is not assigned (Go to random select)
								--p1autoSlot = false
								stageList = 0
							end
						elseif stageList == 0 and p1autoSlot == true then --Go to random select
							p1autoSlot = false
							stageList = 0
						end
					end
					if songSelect == true then
						musicList = musicList + 1
						if musicList == #t_selMusic-1 and not p1song then musicList = musicList + 1 end --Skip Player 1 Song if is not assigned
						if musicList == 1 and not p2song then musicList = musicList + 1 end --Skip Player 2 Song if is not assigned
						if musicList > #t_selMusic-1 then musicList = 0 end
					end
				elseif (commandGetState(p1Cmd, 'l') or commandGetState(p2Cmd, 'l')) or ((commandGetState(p1Cmd, 'holdl') or commandGetState(p2Cmd, 'holdl')) and bufStagel >= 30) then
					sndPlay(sndSys, 100, 0)
					if stageSelect == true then
					--Auto Left Side Stage Logic
						if stageList == 0 and not p2autoSlot then
							if p1stage == true and not p1autoSlot then --Go to Auto Stage
								p1autoSlot = true
								stageList = 0
							elseif not p1stage then --Skip Player 1 Stage if is not assigned (Go to lastest stage loaded)
								stageList = data.includestage
							elseif p1stage == true and p1autoSlot == true then --Go to lastest stage loaded
								p1autoSlot = false
								stageList = data.includestage
							end
						elseif stageList ~= 0 then --Normal scrolling between stages loaded
							if not p1autoSlot and not p2autoSlot then
								stageList = stageList - 1
							end
						end
						--Auto Right Side Stage Logic
						if stageList == 0 and p2autoSlot == true then --Go to random select
							p2autoSlot = false
							stageList = 0
						elseif stageList == 0 and not p1autoSlot then
							if p2stage == true and not p2autoSlot then --Go to Auto Stage
								p2autoSlot = true
								stageList = 0
							elseif not p2stage then --Skip Player 2 Stage if is not assigned (Go to random select)
								stageList = 0
							end
						end
					end
					if songSelect == true then
						musicList = musicList - 1
						if musicList < 0 then musicList = #t_selMusic-1 end
						if musicList == #t_selMusic-1 and not p1song then musicList = musicList - 1 end
						if musicList == 1 and not p2song then musicList = musicList - 1 end
					end
				end
			end
		--end
		if commandGetState(p1Cmd, 'holdr') or commandGetState(p2Cmd, 'holdr') then
			bufStagel = 0
			bufStager = bufStager + 1
		elseif commandGetState(p1Cmd, 'holdl') or commandGetState(p2Cmd, 'holdl') then
			bufStager = 0
			bufStagel = bufStagel + 1
		else
			bufStager = 0
			bufStagel = 0
		end
		if data.stageType == "Classic" then
			animUpdate(selStage)
			animDraw(selStage)
		elseif data.stageType == "Modern" then
			animUpdate(selStageM) --Because is an animation need this
			animDraw(selStageM)
		end
	--Stage Data
		if stageList == 0 then
			if p1autoSlot == true then
			--[[Draw Auto Stage Preview
				if data.stageType == "Classic" then
					animUpdate(stagep1)
					animDraw(stagep1)
				elseif data.stageType == "Modern" then
					animUpdate(stagep1M)
					animDraw(stagep1M)
				end
			]]
			--Set Auto Stage Name
				textImgSetText(txt_selStage, "STAGE: AUTO [LEFT SIDE]")
			elseif p2autoSlot == true then
				--[[
				if data.stageType == "Classic" then
					animUpdate(stagep2)
					animDraw(stagep2)
				elseif data.stageType == "Modern" then
					animUpdate(stagep2M)
					animDraw(stagep2M)
				end
				]]
				textImgSetText(txt_selStage, "STAGE: AUTO [RIGHT SIDE]")
			else --random select
				if data.randomStagePortrait == "Roulette" then
					textImgSetText(txt_selStage, "STAGE " .. math.random(1, data.includestage) .. ": " .. t_selStages[math.random(1, data.includestage)].name)
					if data.stageType == "Classic" then
						drawStagePortrait(math.random(1, data.includestage), 114.5, 172, 0.0705, 0.0699)
					elseif data.stageType == "Modern" then
						drawStagePortrait(math.random(1, data.includestage), 64.600, 74.8, 0.149, 0.148)
					end
				elseif data.randomStagePortrait == "Simple" or data.randomStagePortrait == "Fixed" then
					if data.stageType == "Classic" then
						--animUpdate(stage0)
						animDraw(stage0)
					elseif data.stageType == "Modern" then
						--animUpdate(stage0M)
						animDraw(stage0M)
					end
					textImgSetText(txt_selStage, "STAGE: RANDOM SELECT")
				end
			end
		else --Stages Added in select.def
		--Draw Stage Preview (Resolution Recommended for images: 1280x720)
			if data.stageType == "Classic" then
				drawStagePortrait(stageList-1, 114.5, 172, 0.0705, 0.0699)
				if t_unlockLua.stages[t_selStages[stageList].stage] ~= nil and not onlinegame then --Draw Lock stuff
					animDraw(stageLockWindowBG)
					animDraw(stageLock)
				end
			elseif data.stageType == "Modern" then
				drawStagePortrait(stageList-1, 64.600, 74.8, 0.149, 0.148)
				if t_unlockLua.stages[t_selStages[stageList].stage] ~= nil and not onlinegame then
					animDraw(stageMLockWindowBG)
					animDraw(stageMLock)
				end
			end
		--Set Stage Name
			textImgSetText(txt_selStage, "STAGE " .. stageList .. ": " .. t_selStages[stageList].name)
		end
	--BGM Data
		if musicList == #t_selMusic-2 then --Mute
			musicNo = ""
		elseif musicList == #t_selMusic-1 then --Auto Left Side
			musicNo = ""
		elseif musicList == 0 then --Auto Stage
			musicNo = ""
		elseif musicList == 1 then --Auto Right Side
			musicNo = ""
		elseif musicList == 2 then --Random
			musicNo = ""
		else --Loaded Folder Songs
			musicNo = " " .. musicList-2 .. ""
		end
	--Set BGM Name
		textImgSetText(txt_selectMusic, "BGM" .. musicNo .. ": " .. t_selMusic[musicList+1].bgmname)
	--Draw Info Text
		if stageSelect == true then --Draw Stage Cursor Text
			textImgSetBank(txt_selStage, 5)
			textImgSetBank(txt_selectMusic, 0)
			textImgDraw(txt_selStage)
			textImgDraw(txt_selectMusic)
		elseif songSelect == true then --Draw BGM Cursor Text
			textImgSetBank(txt_selStage, 0)
			textImgSetBank(txt_selectMusic, 5)
			textImgDraw(txt_selStage)
			textImgDraw(txt_selectMusic)
		end
	--Set Author Text
		if data.stageInfo == "Author" or data.stageInfo == "All" then
			if stageList == 0 then
				if p1autoSlot == true then --For Auto - Left Side Player Stage
					if t_selStages[p1charStage].author ~= nil and t_selStages[p1charStage].author ~= "" then textImgSetText(txt_stageAuthor, txt_authorStageText..t_selStages[p1charStage].author) end
				elseif p2autoSlot == true then --For Auto - Right Side Player Stage
					if t_selStages[p2charStage].author ~= nil and t_selStages[p2charStage].author ~= "" then textImgSetText(txt_stageAuthor, txt_authorStageText..t_selStages[p2charStage].author) end
				else --For Random Select
					--if data.randomStagePortrait == "Roulette" then
						--if t_selStages[math.random(1, data.includestage)].author ~= nil and t_selStages[math.random(1, data.includestage)].author ~= "" then
							--textImgSetText(txt_stageAuthor, txt_authorStageText..t_selStages[math.random(1, data.includestage)].author)
						--end
					--elseif data.randomStagePortrait == "Simple" or data.randomStagePortrait == "Fixed" then
						textImgSetText(txt_stageAuthor, txt_authorStageText.."???")
					--end
				end
			else --For loaded stages
				if t_selStages[stageList].author ~= nil and t_selStages[stageList].author ~= "" then
					textImgSetText(txt_stageAuthor, txt_authorStageText..t_selStages[stageList].author)
				else
					textImgSetText(txt_stageAuthor, txt_authorStageText.."???")
				end
			end
			if stageAnnouncer == false then textImgDraw(txt_stageAuthor) end --Draw Info Text
		end
	--Set Location Text
		if data.stageInfo == "Location" or data.stageInfo == "All" then
			if stageList == 0 then
				if p1autoSlot == true then
					if t_selStages[p1charStage].location ~= nil and t_selStages[p1charStage].location ~= "" then textImgSetText(txt_stageLocation, txt_locationStageText..t_selStages[p1charStage].location) end
				elseif p2autoSlot == true then
					if t_selStages[p2charStage].location ~= nil and t_selStages[p2charStage].location ~= "" then textImgSetText(txt_stageLocation, txt_locationStageText..t_selStages[p2charStage].location) end
				else
					--if data.randomStagePortrait == "Roulette" then
						--if t_selStages[math.random(1, data.includestage)].location ~= nil and t_selStages[math.random(1, data.includestage)].location ~= "" then
							--textImgSetText(txt_stageLocation, txt_locationStageText..t_selStages[math.random(1, data.includestage)].location)
						--end
					--elseif data.randomStagePortrait == "Simple" or data.randomStagePortrait == "Fixed" then
						textImgSetText(txt_stageLocation, txt_locationStageText.."???")
					--end
				end
			else
				if t_selStages[stageList].location ~= nil and t_selStages[stageList].location ~= "" then
					textImgSetText(txt_stageLocation, txt_locationStageText..t_selStages[stageList].location)
				else
					textImgSetText(txt_stageLocation, txt_locationStageText.."???")
				end
			end
			if stageAnnouncer == false then textImgDraw(txt_stageLocation) end
		end
	--Set Time Text
		if data.stageInfo == "Time" or data.stageInfo == "All" then
			if stageList == 0 then
				if p1autoSlot == true then
					if t_selStages[p1charStage].daytime ~= nil and t_selStages[p1charStage].daytime ~= "" then textImgSetText(txt_stageDayTime, txt_daytimeStageText..t_selStages[p1charStage].daytime) end
				elseif p2autoSlot == true then
					if t_selStages[p2charStage].daytime ~= nil and t_selStages[p2charStage].daytime ~= "" then textImgSetText(txt_stageDayTime, txt_daytimeStageText..t_selStages[p2charStage].daytime) end
				else
					--if data.randomStagePortrait == "Roulette" then
						--if t_selStages[math.random(1, data.includestage)].daytime ~= nil and t_selStages[math.random(1, data.includestage)].daytime ~= "" then
							--textImgSetText(txt_stageDayTime, txt_daytimeStageText..t_selStages[math.random(1, data.includestage)].daytime)
						--end
					--elseif data.randomStagePortrait == "Simple" or data.randomStagePortrait == "Fixed" then
						textImgSetText(txt_stageDayTime, txt_daytimeStageText.."???")
					--end
				end
			else
				if t_selStages[stageList].daytime ~= nil and t_selStages[stageList].daytime ~= "" then
					textImgSetText(txt_stageDayTime, txt_daytimeStageText..t_selStages[stageList].daytime)
				else
					textImgSetText(txt_stageDayTime, txt_daytimeStageText.."???")
				end
			end
			if stageAnnouncer == false then textImgDraw(txt_stageDayTime) end
		end
		--Stage Select Timer
		if data.gameMode == "arcade" or data.gameMode == "tower" or data.ftcontrol > 0 or data.attractMode == true then
			if data.stageType == "Classic" then textImgSetPos(txt_stageTime, 160, 70)
			elseif data.stageType == "Modern" then textImgSetPos(txt_stageTime, 160, 105)
			end
			stageTimeNumber = stageTimer/gameTick
			nodecimalStageTime = string.format("%.0f",stageTimeNumber)
			textImgSetText(txt_stageTime, nodecimalStageTime)
			if stageTimer > 0 then
				if not backScreen then stageTimer = stageTimer - 0.5 end--Activate Stage Select Timer
				textImgDraw(txt_stageTime)
			else --when stageTimer <= 0
				
			end
		end
		--When you select the stage
		if (btnPalNo(p1Cmd, true) > 0 or btnPalNo(p2Cmd, true) > 0 or stageTimer == 0) and stageAnnouncer == false then
			if stageList == 0 then --For random or character sides stages
				stageChosen = true
			else --For visible stages
				if t_unlockLua.stages[t_selStages[stageList].stage] == nil or onlinegame then --This stage is unlocked
					stageChosen = true
				elseif t_unlockLua.stages[t_selStages[stageList].stage] ~= nil and not onlinegame then --stage locked
					if stageTimer == 0 then --Select Random Stage to prevent issues when time to select is over
						stageList = 0
						stageChosen = true
					else
						stageChosen = false
						sndPlay(sndIkemen, 200, 0)
					end
				end
			end
		--After to verifications, this is the true selection
			if stageChosen then
				stageSelect = false
				songSelect = false
				stageAnnouncer = true
				sndPlay(sndSys, 100, 1)
				f_stageAnnouncer()
				f_loadStage()
			end
		end
		--create a timer to hear full announcer voice
		if announcerTimer > 55 then
			if data.coop == true then --To avoid issues in Stage Select with Arcade Co-Op
				p2Cell = nil
				p2Portrait = nil
				data.t_p2selected = {}
				p2PalEnd = false
				p2SelEnd = false
			end
			stageEnd = true
			cmdInput()
			--announcerTimer = 0 --Restart Stage Announcer Timer
		end
	--When stage has been selected/announcer is active:
		if stageAnnouncer == true then
			--Apply Color
			textImgSetBank(txt_selectMusic, 2)
			textImgSetBank(txt_selStage, 2)
			textImgSetBank(txt_stageAuthor, 2)
			textImgSetBank(txt_stageLocation, 2)
			textImgSetBank(txt_stageDayTime, 2)
			if stageList == 0 then --For random select
				if data.randomStagePortrait == "Simple" or data.randomStagePortrait == "Roulette" then
					textImgSetText(txt_selStage, "STAGE " .. stageNo .. ": " .. t_selStages[stageNo].name) --Load Selected Stage Name
					if t_selStages[stageNo].author ~= nil and t_selStages[stageNo].author ~= "" then textImgSetText(txt_stageAuthor, txt_authorStageText..t_selStages[stageNo].author) end --Load Selected Stage Author IF is assigned
					if t_selStages[stageNo].location ~= nil and t_selStages[stageNo].location ~= "" then textImgSetText(txt_stageLocation, txt_locationStageText..t_selStages[stageNo].location) end --Load Selected Stage Location IF is assigned
					if t_selStages[stageNo].daytime ~= nil and t_selStages[stageNo].daytime ~= "" then textImgSetText(txt_stageDayTime, txt_daytimeStageText..t_selStages[stageNo].daytime) end --Load Selected Stage Day Time IF is assigned
					if data.stageType == "Classic" then
						drawStagePortrait(stageNo-1, 114.5, 172, 0.0705, 0.0699) --Load Selected Stage Portrait
					elseif data.stageType == "Modern" then
						drawStagePortrait(stageNo-1, 64.600, 74.8, 0.149, 0.148)
					end
				end
			end
			--Re-Draw Selected Stuff
			textImgDraw(txt_selectMusic)
			textImgDraw(txt_selStage)
			if data.stageInfo == "Author" or data.stageInfo == "All" then textImgDraw(txt_stageAuthor) end
			if data.stageInfo == "Location" or data.stageInfo == "All" then textImgDraw(txt_stageLocation) end
			if data.stageInfo == "Time" or data.stageInfo == "All" then textImgDraw(txt_stageDayTime) end
		end
	else --If Stage Select is Disabled
		if data.stage == nil then --Assign Auto Stage via Select.def
			if (data.p1In == 2 and data.p2In == 2) then --Player 1 in player 2 (right) side
				if t_selChars[data.t_p1selected[1].cel+1].stage ~= nil then
					stageNo = math.random(1,#t_selChars[data.t_p1selected[1].cel+1].stage)
					stageNo = t_selChars[data.t_p1selected[1].cel+1].stage[stageNo]
				else
					stageNo = math.random(1, data.includestage)
				end
			else
				if t_selChars[data.t_p2selected[1].cel+1].stage ~= nil then
					stageNo = math.random(1,#t_selChars[data.t_p2selected[1].cel+1].stage)
					stageNo = t_selChars[data.t_p2selected[1].cel+1].stage[stageNo]
				else
					stageNo = math.random(1, data.includestage)
				end
			end
		else --if data.stage ~= nil then Assign Custom Stage Loaded in select.def via lua script, with data.stage
			data.stage = data.stage:lower() --Convert to lower case to avoid issues
			local stageID = t_stageDef[data.stage] --Get stage number from table t_stageDef
		--Get stage info
			t_stageSelected = {
				['cel'] = stageID,
				['name'] = t_selStages[stageID].name,
				['discordkey'] = t_selStages[stageID].discordkey,
				['path'] = t_selStages[stageID].stage,
				['author'] = t_selStages[stageID].author,
				['location'] = t_selStages[stageID].location,
				['daytime'] = t_selStages[stageID].daytime
			}
			if data.debugLog then f_printTable(t_stageSelected, "save/debug/t_stageSelected.log") end
			--stagePortrait = t_stageSelected.cel
			stageNo = t_stageSelected.cel
		end
		setStage(stageNo)
		selectStage(stageNo)
		stageEnd = true
	end
end

function f_loadCharResources()
	if (data.p1In == 2 and data.p2In == 2) then --Player 1 in player 2 (right) side
	--Logic For Characters Song
		p1song = false
		p2charSong = ""
		if t_selChars[data.t_p2selected[1].cel+1].music ~= nil then
			p2charSong = math.random(1,#t_selChars[data.t_p2selected[1].cel+1].music)
			p2charSong = t_selChars[data.t_p2selected[1].cel+1].music[p2charSong].bgmusic
			p2song = true
		else --If there no music assigned for right side character
			p2song = false
		end
	--Logic For Characters Stages
		p1stage = false
		if t_selChars[data.t_p2selected[1].cel+1].stage ~= nil then
			p2charStage = math.random(1,#t_selChars[data.t_p2selected[1].cel+1].stage)
			p2charStage = t_selChars[data.t_p2selected[1].cel+1].stage[p2charStage]
			p2stage = true
		else
			--If there no stage assigned for right side character
			p2stage = false
		end
	else
		p2song = false
		p1charSong = ""
		if t_selChars[data.t_p1selected[1].cel+1].music ~= nil then
			p1charSong = math.random(1,#t_selChars[data.t_p1selected[1].cel+1].music)
			p1charSong = t_selChars[data.t_p1selected[1].cel+1].music[p1charSong].bgmusic
			p1song = true
		else --If there no music assigned for left side character
			p1song = false
		end
		p2stage = false
		if t_selChars[data.t_p1selected[1].cel+1].stage ~= nil then
			p1charStage = math.random(1,#t_selChars[data.t_p1selected[1].cel+1].stage)
			p1charStage = t_selChars[data.t_p1selected[1].cel+1].stage[p1charStage]
			p1stage = true
		else --If there no stage assigned for left side character
			p1stage = false
		end
	end
end

function f_assignMusic()
	if data.bgm == nil then --Assign Stage Song via stage.def or select.def
		track = ""
		if data.stageMenu then
			if t_selStages[stageNo].music ~= nil then
				track = math.random(1,#t_selStages[stageNo].music)
				track = t_selStages[stageNo].music[track].bgmusic
			end
		else
			if (data.p1In == 2 and data.p2In == 2) then --Player 1 in player 2 (right) side
				if t_selChars[data.t_p1selected[1].cel+1].music ~= nil then
					track = math.random(1,#t_selChars[data.t_p1selected[1].cel+1].music)
					track = t_selChars[data.t_p1selected[1].cel+1].music[track].bgmusic
				elseif t_selStages[stageNo].music ~= nil then
					track = math.random(1,#t_selStages[stageNo].music)
					track = t_selStages[stageNo].music[track].bgmusic
				end
			else
				if t_selChars[data.t_p2selected[1].cel+1].music ~= nil then
					track = math.random(1,#t_selChars[data.t_p2selected[1].cel+1].music)
					track = t_selChars[data.t_p2selected[1].cel+1].music[track].bgmusic
				elseif t_selStages[stageNo].music ~= nil then
					track = math.random(1,#t_selStages[stageNo].music)
					track = t_selStages[stageNo].music[track].bgmusic
				end
			end
			stageEnd = true
		end
	else --Assign Custom Stage Song via lua script, with data.bgm
		track = data.bgm
		stageEnd = true
	end
	if musicList == #t_selMusic-2 then --Mute Song
		playBGM(bgmNothing)
	elseif musicList == #t_selMusic-1 then --Player 1 Song
		playBGM(p1charSong)
	elseif musicList == 0 then --Auto Stage Song
		playBGM(track)
	elseif musicList == 1 then --Player 2 Song
		playBGM(p2charSong)
	elseif musicList == 2 then --Random Song
		local randomBGM = t_selMusic[math.random(3, #t_selMusic)].bgmfile
		playBGM(randomBGM)
	else --Sound Folder Song
		playBGM(t_selMusic[musicList+1].bgmfile)
	end
	f_setStgBGM(getBGM())
end

function f_musicPreview()
	song = ""
	if t_selStages[stageList].music ~= nil then
		song = math.random(1,#t_selStages[stageList].music)
		song = t_selStages[stageList].music[song].bgmusic
	end
	if musicList == #t_selMusic-2 then --playBGM(bgmNothing)
	elseif musicList == #t_selMusic-1 and p1song then playBGM(p1charSong)
	elseif musicList == 0 then playBGM(song)
	elseif musicList == 1 and p2song then playBGM(p2charSong)
	elseif musicList == 2 then --None because Random Preview Will be different of selected
	else
		playBGM(t_selMusic[musicList+1].bgmfile)
	end
end

function f_loadStage()
	if stageList == 0 then
		if p1autoSlot == true then stageNo = p1charStage --Auto - Left Side Player Stage
		elseif p2autoSlot == true then stageNo = p2charStage --Auto - Right Side Player Stage
		else --Random Stage
			if randomStageRematch and data.randomStageRematch == "Fixed" then
				--stageNo = stageNo --Reload Previous Random Stage Selected
			else
				stageNo = math.random(1, data.includestage) --Load a New Random Stage
				randomStageRematch = true
			end
		end
	else stageNo = stageList --Stages Loaded via select.def
	end
	setStage(stageNo)
	selectStage(stageNo)
end

--;===========================================================
--; ARCADE TRAVEL SCREEN
--;===========================================================
function f_arcadeTravel()
	cmdInput()
	local screenTime = 0
	local timeLimit = 880
--Side Logic
	local enemySide = nil
	local enemyData = nil
	local xPortScale = nil
	local yPortScale = nil
	local scaleData = nil
	if (data.p1In == 2 and data.p2In == 2) then --Player 1 in player 2 (right) side
		enemySide = data.t_p1selected
	else
		enemySide = data.t_p2selected
	end
--Portraits Scale Logic
	for i=#enemySide, 1, -1 do
		enemyData = t_selChars[enemySide[i].cel+1]
		if enemyData.vsSprScale ~= nil then
			scaleData = enemyData.vsSprScale
		else
			scaleData = "1.0,1.0"
		end
		xPortScale, yPortScale = scaleData:match('^([^,]-)%s*,%s*(.-)$')
	end
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	playBGM(bgmNextStage)
	while true do
	--Actions
		if screenTime == timeLimit or (btnPalNo(p1Cmd, true) > 0 or btnPalNo(p2Cmd, true) > 0) then
			commandBufReset(p1Cmd)
			commandBufReset(p2Cmd)
			break
		end
	--Draw Versus Screen Last Match Backgrounds
		if data.rosterAdvanced and matchNo >= lastMatch then
			animDraw(f_animVelocity(selectHardBG0, -1, -1)) --Draw Red BG for Final Battle
	--Draw Versus Screen Normal Matchs Backgrounds
		else
		--Draw Black BG only for Tower/Abyss Mode
			if data.gameMode == "tower" or data.gameMode == "abyss" then
				animDraw(f_animVelocity(selectTowerBG0, -1, -1))
		--Draw Red BG for Special Modes
			elseif data.gameMode == "bossrush" or data.gameMode == "singleboss" or data.rosterMode == "suddendeath" or data.gameMode == "intermission" then
				animDraw(f_animVelocity(selectHardBG0, -1, -1))
		--Draw Blue BG for Normal Modes
			else
				animDraw(f_animVelocity(commonBG0, -1, -1))
			end
		end
	--Draw BG Stuff
		drawStagePortrait(stageNo-1, -53, 0, 0.34, 0.34)
		animDraw(fadeWindowBG)
		animDraw(travelBarUp)
	--Draw Character Portraits
		if data.portraitDisplay == "Portrait" or data.portraitDisplay == "Mixed" then
			if #enemySide == 1 then
				drawPortrait(enemySide[1].cel, 100, 45, xPortScale, yPortScale)
			elseif #enemySide == 2 then
				drawPortrait(enemySide[2].cel, 160, 45, xPortScale, yPortScale)
				drawPortrait(enemySide[1].cel, 40, 45, xPortScale, yPortScale)
			elseif #enemySide == 3 then
				drawPortrait(enemySide[3].cel, 0, 45, xPortScale, yPortScale)
				drawPortrait(enemySide[2].cel, 205, 45, xPortScale, yPortScale)
				drawPortrait(enemySide[1].cel, 100, 45, xPortScale, yPortScale)
			elseif #enemySide == 4 then
				drawPortrait(enemySide[4].cel, 205, 45, xPortScale, yPortScale)
				drawPortrait(enemySide[3].cel, 0, 45, xPortScale, yPortScale)
				drawPortrait(enemySide[2].cel, 160, 45, xPortScale, yPortScale)
				drawPortrait(enemySide[1].cel, 40, 45, xPortScale, yPortScale)
			end
		elseif data.portraitDisplay == "Sprite" then
			if #enemySide == 1 then
				f_drawQuickSpr(travelCharPlatform, 108, 178, 0.3, 0.3)
				f_drawCharAnim(t_selChars[enemySide[1].cel+1], 'p1AnimStand', 160, 185, enemySide[1].up)
			elseif #enemySide == 2 then
				f_drawQuickSpr(travelCharPlatform, 67, 173, 0.5, 0.5)
				f_drawCharAnim(t_selChars[enemySide[2].cel+1], 'p1AnimStand', 190, 185, enemySide[2].up)
				f_drawCharAnim(t_selChars[enemySide[1].cel+1], 'p1AnimStand', 120, 185, enemySide[1].up)
			elseif #enemySide == 3 then
				f_drawQuickSpr(travelCharPlatform, 47, 163, 0.65, 0.65)
				f_drawCharAnim(t_selChars[enemySide[3].cel+1], 'p1AnimStand', 100, 172, enemySide[3].up)
				f_drawCharAnim(t_selChars[enemySide[2].cel+1], 'p1AnimStand', 220, 172, enemySide[2].up)
				f_drawCharAnim(t_selChars[enemySide[1].cel+1], 'p1AnimStand', 160, 184, enemySide[1].up)
			elseif #enemySide == 4 then
				f_drawQuickSpr(travelCharPlatform, 47, 163, 0.65, 0.65)
				f_drawCharAnim(t_selChars[enemySide[4].cel+1], 'p1AnimStand', 220, 170, enemySide[4].up)
				f_drawCharAnim(t_selChars[enemySide[3].cel+1], 'p1AnimStand', 100, 170, enemySide[3].up)
				f_drawCharAnim(t_selChars[enemySide[2].cel+1], 'p1AnimStand', 200, 185, enemySide[2].up)
				f_drawCharAnim(t_selChars[enemySide[1].cel+1], 'p1AnimStand', 125, 185, enemySide[1].up)
			end
		end
	--Draw Info
		textImgDraw(txt_nextStage)
		textImgSetText(txt_nextStageName, t_selStages[stageNo].name)
		textImgDraw(txt_nextStageName)
		textImgSetText(txt_nextEnemyName, enemySide[1].displayname)
		textImgDraw(txt_nextEnemyName)
	--Draw Travel Stuff
		animPosDraw(travelArrow, 30*matchNo - 22, 204)
		for enemyRoster=1, lastMatch do
			local enemyPortrait = nil
			if enemyRoster == matchNo then
				enemyPortrait = t_roster[matchNo]
			elseif enemyRoster < matchNo then
				enemyPortrait = t_roster[enemyRoster]
			end
			animPosDraw(travelSlotIcon, 30*enemyRoster - 30, 213)
			if enemyRoster <= matchNo then
				drawFacePortrait(enemyPortrait, 30*enemyRoster - 29, 214) --Enemy Portrait
			else
				animPosDraw(travelRandomIcon, 30*enemyRoster - 29, 214) --Random Icon
			end
		end
	--When Attract Mode is Enabled
		if data.attractMode then
			drawAttractStatus(2, 318, 10, -1)
			--f_attractCredits(318, 210, -1)
		end
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		screenTime = screenTime + 1 --Start Timer for Screen
		cmdInput()
		refresh()
	end
end

--;===========================================================
--; ORDER SELECT SCREEN
--;===========================================================
function f_orderSelect()
--Order Select OFF
	if not data.orderSelect then
		return
--Order Select OFF when playing in CO-OP Mode
	elseif data.coop == true then
		return
--Order Select OFF when P1 and P2 playing in Single Team Mode
	elseif p1teamMode == 0 and p2teamMode == 0 then
		return
--Order Select ON
	else
	--Set Order Select Music
		if data.rosterAdvanced and matchNo >= lastMatch then
			playBGM(bgmSelectOrderFinal)
		else	
			playBGM(bgmSelectOrder)
		end
		if data.orderSelType == "Button" then f_orderSelectButton()
		elseif data.orderSelType == "Cursor" then f_orderSelectCursor()
		end
	end
end

--Order Select Cursor Type Interaction
function f_orderSelectCursor()
	cmdInput()
	local i = 0
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	local bufOrderu = 0
	local bufOrderd = 0
	local bufOrderr = 0
	local bufOrderl = 0
	local bufOrder2u = 0
	local bufOrder2d = 0
	local bufOrder2r = 0
	local bufOrder2l = 0
	local p1Confirmed = false
	local p2Confirmed = false
	local p1Row = 1
	local p2Row = 1
	local t_tmp = {}
	local sndNumber = -1
	local sndTime = 0
	local hintTime = 0
	local seconds = data.orderTime
	local orderTime = seconds*gameTick --Set time for Order Select
	local p1Anim = "p1AnimStand"
	local p2Anim = "p2AnimStand"
	local charDataL = nil
	local charDataR = nil
	local scaleDataL = nil
	local scaleDataR = nil
	local xPortScaleL, yPortScaleL = nil
	local xPortScaleR, yPortScaleR = nil
	textImgSetBank(txt_p1State, 0) --Reset Text Color
	textImgSetBank(txt_p2State, 0)
	animReset(vsLogo)
--Set order time
	if data.p1In == 1 and data.p2In == 2 and (#data.t_p1selected > 1 or #data.t_p2selected > 1) or data.coop == true then
		--orderTime = math.max(#data.t_p1selected, #data.t_p2selected) * 60 --Order Time is setting by the amount of characters selected
	elseif #data.t_p1selected > 1 or data.coop == true then
		--orderTime = #data.t_p1selected * 60 --Order Time is setting by the amount of characters selected
	else
		p1Confirmed = true
		--p2Confirmed = true --Activate to don't order CPU characters in team modes
	end
--Portraits Scale Logic
	for j=#data.t_p1selected, 1, -1 do
		charDataL = t_selChars[data.t_p1selected[j].cel+1]
		if charDataL.orderSprScale ~= nil then
			scaleDataL = charDataL.orderSprScale
		else
			scaleDataL = "1.0,1.0"
		end
		xPortScaleL, yPortScaleL = scaleDataL:match('^([^,]-)%s*,%s*(.-)$')
	end
	for j=#data.t_p2selected, 1, -1 do
		charDataR = t_selChars[data.t_p2selected[j].cel+1]
		if charDataR.orderSprScale ~= nil then
			scaleDataR = charDataR.orderSprScale
		else
			scaleDataR = "1.0,1.0"
		end
		xPortScaleR, yPortScaleR = scaleDataR:match('^([^,]-)%s*,%s*(.-)$')
	end
	while true do
		orderTimeNumber = orderTime/gameTick
		nodecimalOrderTime = string.format("%.0f",orderTimeNumber)
		textImgSetText(txt_orderTime, nodecimalOrderTime)
	--Draw Order Select Last Match Backgrounds
		if data.rosterAdvanced and matchNo >= lastMatch then
			animDraw(f_animVelocity(selectHardBG0, -1, -1)) --Draw Red BG for Final Battle
	--Draw Order Select Normal Matchs Backgrounds
		else
			--Draw Black BG only for Tower/Abyss Mode
			if data.gameMode == "tower" or data.gameMode == "abyss" then
				animDraw(f_animVelocity(selectTowerBG0, -1, -1))
			--Draw Red BG for Special Modes
			elseif data.gameMode == "bossrush" or data.gameMode == "singleboss" or data.rosterMode == "suddendeath" or data.gameMode == "intermission" then
				animDraw(f_animVelocity(selectHardBG0, -1, -1))
			--Draw Blue BG for Normal Modes
			else
				animDraw(f_animVelocity(commonBG0, -1, -1))
			end
		end
	--Draw Window Portraits
		animDraw(f_animVelocity(orderWindowL, -2, 0))
		animDraw(f_animVelocity(orderWindowR, 2, 0))
	--Set Order Status Assets
		if not p1Confirmed then
			--textImgSetBank(txt_p1State, 3) --Set Blue Color
			textImgSetText(txt_p1State, txt_waitingOrder) --Set Text
		else
			textImgSetBank(txt_p1State, 5)
			textImgSetText(txt_p1State, txt_orderFinished)
			p1Anim = "p1AnimWin" --Change Anim when Order Select is complete
		end
		if not p2Confirmed then
			--textImgSetBank(txt_p2State, 1) --Set Red Color
			textImgSetText(txt_p2State, txt_waitingOrder)
		else
			textImgSetBank(txt_p2State, 5)
			textImgSetText(txt_p2State, txt_orderFinished)
			p2Anim = "p2AnimWin"
		end
	--Draw Order Status Text
		textImgDraw(txt_p1State)
		textImgDraw(txt_p2State)
	--Both Sides are Ready
		if p1Confirmed == true and p2Confirmed == true then
			orderTime = 0
			animSetWindow(cursorBox, 20, 9, 120, 16)
			f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
			animDraw(f_animVelocity(cursorBox, -1, -1))
		end
		i = i + 1
		if sndTime > 0 then
			sndTime = sndTime - 1
		end
		sndNumber = -1
		--Adjust characters order if timer is > 0
		if orderTime > 0 then
			orderTime = orderTime - 0.5 --Activate Order Select Timer
			textImgDraw(txt_orderTime)
			
		else --when orderTime <= 0
			
		end
	--if Player 1 has not confirmed the order yet
		if not p1Confirmed and data.p1In ~= 2 then
			if btnPalNo(p1Cmd, true) > 0 then
				if not p1Confirmed then
					sndNumber = 1
					p1Confirmed = true
					commandBufReset(p1Cmd)
				end
				if data.p2In ~= 2 and p2numChars == 1 then --Necessary for Single Boss Mode
					if not p2Confirmed then
						p2Confirmed = true
					end
				end
			elseif commandGetState(p1Cmd, 'u') or (commandGetState(p1Cmd, 'holdu') and bufOrderu >= 30) then
				if #data.t_p1selected > 1 then
					sndNumber = 0
					p1Row = p1Row - 1
					if p1Row == 0 then p1Row = #data.t_p1selected end
				end
			elseif commandGetState(p1Cmd, 'd') or (commandGetState(p1Cmd, 'holdd') and bufOrderd >= 30) then
				if #data.t_p1selected > 1 then
					sndNumber = 0
					p1Row = p1Row + 1
					if p1Row > #data.t_p1selected then p1Row = 1 end
				end
			elseif commandGetState(p1Cmd, 'l') or (commandGetState(p1Cmd, 'holdl') and bufOrderl >= 30) then
				if p1Row-1 > 0 then
					sndNumber = 0
					p1Row = p1Row - 1
					t_tmp = {}
					t_tmp[p1Row] = data.t_p1selected[p1Row+1]
					for i=1, #data.t_p1selected do
						for j=1, #data.t_p1selected do
							if t_tmp[j] == nil and i ~= p1Row+1 then
								t_tmp[j] = data.t_p1selected[i]
								break
							end
						end
					end
					data.t_p1selected = t_tmp
				end
			elseif commandGetState(p1Cmd, 'r') or (commandGetState(p1Cmd, 'holdr') and bufOrderr >= 30) then
				if p1Row+1 <= #data.t_p1selected then
					sndNumber = 0
					p1Row = p1Row + 1
					t_tmp = {}
					t_tmp[p1Row] = data.t_p1selected[p1Row-1]
					for i=1, #data.t_p1selected do
						for j=1, #data.t_p1selected do
							if t_tmp[j] == nil and i ~= p1Row-1 then
								t_tmp[j] = data.t_p1selected[i]
								break
							end
						end
					end
					data.t_p1selected = t_tmp
				end
			end
			animSetWindow(cursorBox, 0,152+p1Row*14, 140,14.5)
			f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
			animDraw(f_animVelocity(cursorBox, -1, -1))
		end
	--if Player 1 has not confirmed the order yet and IS controlled by IA (CPU VS P1)
		if not p1Confirmed and data.p1In == 2 and p2Confirmed == true then
			if btnPalNo(p1Cmd, true) > 0 then
				if not p1Confirmed then
					sndNumber = 1
					p1Confirmed = true
					commandBufReset(p1Cmd)
				end
				if data.p2In ~= 2 and p2numChars == 1 then --Necessary for Single Boss Mode
					if not p2Confirmed then
						p2Confirmed = true
					end
				end
			elseif commandGetState(p1Cmd, 'u') or (commandGetState(p1Cmd, 'holdu') and bufOrderu >= 30) then
				if #data.t_p1selected > 1 then
					sndNumber = 0
					p1Row = p1Row - 1
					if p1Row == 0 then p1Row = #data.t_p1selected end
				end
			elseif commandGetState(p1Cmd, 'd') or (commandGetState(p1Cmd, 'holdd') and bufOrderd >= 30) then
				if #data.t_p1selected > 1 then
					sndNumber = 0
					p1Row = p1Row + 1
					if p1Row > #data.t_p1selected then p1Row = 1 end
				end
			elseif commandGetState(p1Cmd, 'l') or (commandGetState(p1Cmd, 'holdl') and bufOrderl >= 30) then
				if p1Row-1 > 0 then
					sndNumber = 0
					p1Row = p1Row - 1
					t_tmp = {}
					t_tmp[p1Row] = data.t_p1selected[p1Row+1]
					for i=1, #data.t_p1selected do
						for j=1, #data.t_p1selected do
							if t_tmp[j] == nil and i ~= p1Row+1 then
								t_tmp[j] = data.t_p1selected[i]
								break
							end
						end
					end
					data.t_p1selected = t_tmp
				end
			elseif commandGetState(p1Cmd, 'r') or (commandGetState(p1Cmd, 'holdr') and bufOrderr >= 30) then
				if p1Row+1 <= #data.t_p1selected then
					sndNumber = 0
					p1Row = p1Row + 1
					t_tmp = {}
					t_tmp[p1Row] = data.t_p1selected[p1Row-1]
					for i=1, #data.t_p1selected do
						for j=1, #data.t_p1selected do
							if t_tmp[j] == nil and i ~= p1Row-1 then
								t_tmp[j] = data.t_p1selected[i]
								break
							end
						end
					end
					data.t_p1selected = t_tmp
				end
			end
			animSetWindow(cursorBox, 0,152+p1Row*14, 140,14.5)
			f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
			animDraw(f_animVelocity(cursorBox, -1, -1))
		end
	--if Player2 has not confirmed the order yet and IS controlled by IA (P1 VS CPU)
		if not p2Confirmed and data.p2In == 1 and p1Confirmed == true then
			if btnPalNo(p1Cmd, true) > 0 then
				if not p2Confirmed then
					sndNumber = 1
					p2Confirmed = true
				end
			elseif commandGetState(p1Cmd, 'u') or (commandGetState(p1Cmd, 'holdu') and bufOrderu >= 30) then
				if #data.t_p2selected > 1 then
					sndNumber = 0
					p2Row = p2Row - 1
					if p2Row == 0 then p2Row = #data.t_p2selected end
				end
			elseif commandGetState(p1Cmd, 'd') or (commandGetState(p1Cmd, 'holdd') and bufOrderd >= 30) then
				if #data.t_p2selected > 1 then
					sndNumber = 0
					p2Row = p2Row + 1
					if p2Row > #data.t_p2selected then p2Row = 1 end
				end
			elseif commandGetState(p1Cmd, 'l') or (commandGetState(p1Cmd, 'holdl') and bufOrderl >= 30) then
				if p2Row+1 <= #data.t_p2selected then
					sndNumber = 0
					p2Row = p2Row + 1
					t_tmp = {}
					t_tmp[p2Row] = data.t_p2selected[p2Row-1]
					for i=1, #data.t_p2selected do
						for j=1, #data.t_p2selected do
							if t_tmp[j] == nil and i ~= p2Row-1 then
								t_tmp[j] = data.t_p2selected[i]
								break
							end
						end
					end
					data.t_p2selected = t_tmp
				end
			elseif commandGetState(p1Cmd, 'r') or (commandGetState(p1Cmd, 'holdr') and bufOrderr >= 30) then
				if p2Row-1 > 0 then
					sndNumber = 0
					p2Row = p2Row - 1
					t_tmp = {}
					t_tmp[p2Row] = data.t_p2selected[p2Row+1]
					for i=1, #data.t_p2selected do
						for j=1, #data.t_p2selected do
							if t_tmp[j] == nil and i ~= p2Row+1 then
								t_tmp[j] = data.t_p2selected[i]
								break
							end
						end
					end
					data.t_p2selected = t_tmp
				end
			end
			animSetWindow(cursorBox, 180,152+p2Row*14, 140,14.5)
			f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
			animDraw(f_animVelocity(cursorBox, -1, -1))
		end
	--if Player2 has not confirmed the order yet and is not controlled by Player 1 (P1 VS P2)
		if not p2Confirmed and data.p2In ~= 1 then
			if btnPalNo(p2Cmd, true) > 0 then
				if not p2Confirmed then
					sndNumber = 1
					p2Confirmed = true
				end
			elseif commandGetState(p2Cmd, 'u') or (commandGetState(p2Cmd, 'holdu') and bufOrder2u >= 30) then
				if #data.t_p2selected > 1 then
					sndNumber = 0
					p2Row = p2Row - 1
					if p2Row == 0 then p2Row = #data.t_p2selected end
				end
			elseif commandGetState(p2Cmd, 'd') or (commandGetState(p2Cmd, 'holdd') and bufOrder2d >= 30) then
				if #data.t_p2selected > 1 then
					sndNumber = 0
					p2Row = p2Row + 1
					if p2Row > #data.t_p2selected then p2Row = 1 end
				end
			elseif commandGetState(p2Cmd, 'l') or (commandGetState(p2Cmd, 'holdl') and bufOrder2l >= 30) then
				if p2Row+1 <= #data.t_p2selected then
					sndNumber = 0
					p2Row = p2Row + 1
					t_tmp = {}
					t_tmp[p2Row] = data.t_p2selected[p2Row-1]
					for i=1, #data.t_p2selected do
						for j=1, #data.t_p2selected do
							if t_tmp[j] == nil and i ~= p2Row-1 then
								t_tmp[j] = data.t_p2selected[i]
								break
							end
						end
					end
					data.t_p2selected = t_tmp
				end
			elseif commandGetState(p2Cmd, 'r') or (commandGetState(p2Cmd, 'holdr') and bufOrder2r >= 30) then
				if p2Row-1 > 0 then
					sndNumber = 0
					p2Row = p2Row - 1
					t_tmp = {}
					t_tmp[p2Row] = data.t_p2selected[p2Row+1]
					for i=1, #data.t_p2selected do
						for j=1, #data.t_p2selected do
							if t_tmp[j] == nil and i ~= p2Row+1 then
								t_tmp[j] = data.t_p2selected[i]
								break
							end
						end
					end
					data.t_p2selected = t_tmp
				end
			end
			animSetWindow(cursorBox, 180,152+p2Row*14, 140,14.5)
			f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
			animDraw(f_animVelocity(cursorBox, -1, -1))
		end
	--sndPlay separated to not play more than 1 sound at once
		if sndNumber ~= -1 then
			sndPlay(sndSys, 100, sndNumber)
			sndTime = 30
		end
	--Order Time Over
		if orderTime == 0 then
			if not p1Confirmed then
				p1Confirmed = true
			end
			if not p2Confirmed then
				p2Confirmed = true
			end
			if btnPalNo(p1Cmd, true) > 0 or btnPalNo(p2Cmd, true) > 0 then
				if i < 120 then i = 120 end
			end
			data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
			break
		end
	--Draw Character Portraits
		if data.portraitDisplay == "Portrait" or data.portraitDisplay == "Mixed" then
			for j=#data.t_p1selected, 1, -1 do
				drawOrderPortrait(data.t_p1selected[j].cel, 124 - (2*j-1) * 17.9, 25, xPortScaleL, yPortScaleL)
			end
			for j=#data.t_p2selected, 1, -1 do
				drawOrderPortrait(data.t_p2selected[j].cel, 195 + (2*j-1) * 17.9, 25, -xPortScaleR, yPortScaleR)
			end
		end
	--Draw Character Sprite Animations
		if data.portraitDisplay == "Sprite" or data.portraitDisplay == "Mixed" then
		--Left Side
			for j=#data.t_p1selected, 1, -1 do
				f_drawCharAnim(t_selChars[data.t_p1selected[j].cel+1], p1Anim, 139 - (2*j-1) * 18, 163, data.t_p1selected[j].up)
			end
		--Right Side
			for j=#data.t_p2selected, 1, -1 do
				f_drawCharAnim(t_selChars[data.t_p2selected[j].cel+1], p2Anim, 180 + (2*j-1) * 18, 163, data.t_p2selected[j].up)
			end
		end
	--Draw Names
		f_drawNameList(txt_p1NameOrder, 5, data.t_p1selected, 78, 175, 0, 14, p1Row, 0)
		f_drawNameList(txt_p2NameOrder, 5, data.t_p2selected, 241, 175, 0, 14, p2Row, 0)
	--Draw Order Number Assets
		--Left Side
		for n=#data.t_p1selected, 1, -1 do
			animPosDraw(p1OrderCursor, 1, 153+14*n) --Draw Order Icon
			textImgSetText(txt_p1OrderNo, n) --Set Order Number Text
			textImgPosDraw(txt_p1OrderNo, 9, 161+14*n) --Draw Order Number Text
		end
		--Right Side
		for n=#data.t_p2selected, 1, -1 do
			animPosDraw(p2OrderCursor, 305, 153+14*n)
			textImgSetText(txt_p2OrderNo, n)
			textImgPosDraw(txt_p2OrderNo, 310, 161+14*n)
		end
	--Draw Title
		textImgDraw(txt_orderSelect)
	--Draw Assets
		animUpdate(vsLogo)
		animDraw(vsLogo)
		drawOrderInputHints()
	--When Attract Mode is Enabled
		if data.attractMode then
			drawAttractStatus(2, 318, 10, -1)
			f_attractCredits(318, 238, -1)
		end
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		hintTime = hintTime + 1 --Start timer for randoms hints
		if commandGetState(p1Cmd, 'holdu') then
			bufOrderd = 0
			bufOrderu = bufOrderu + 1
		elseif commandGetState(p1Cmd, 'holdd') then
			bufOrderu = 0
			bufOrderd = bufOrderd + 1
		elseif commandGetState(p1Cmd, 'holdr') then
			bufOrderl = 0
			bufOrderr = bufOrderr + 1
		elseif commandGetState(p1Cmd, 'holdl') then
			bufOrderr = 0
			bufOrderl = bufOrderl + 1
		elseif commandGetState(p2Cmd, 'holdu') then
			bufOrder2d = 0
			bufOrder2u = bufOrder2u + 1
		elseif commandGetState(p2Cmd, 'holdd') then
			bufOrder2u = 0
			bufOrder2d = bufOrder2d + 1
		elseif commandGetState(p2Cmd, 'holdr') then
			bufOrder2l = 0
			bufOrder2r = bufOrder2r + 1
		elseif commandGetState(p2Cmd, 'holdl') then
			bufOrder2r = 0
			bufOrder2l = bufOrder2l + 1
		else
			bufOrderu = 0
			bufOrderd = 0
			bufOrderr = 0
			bufOrderl = 0
			bufOrder2u = 0
			bufOrder2d = 0
			bufOrder2r = 0
			bufOrder2l = 0
		end
		cmdInput()
		refresh()
	end
end

--Order Select Button Type Interaction
function f_orderSelectButton()
	cmdInput()
	local i = 0
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	local p1Confirmed = false
	local p2Confirmed = false
	local t_p1Temp = {}
	local t_p2Temp = {}
--To check what pos is missing to define
	local p1Pos1 = false
	local p1Pos2 = false
	local p1Pos3 = false
	local p1Pos4 = false
	
	local p2Pos1 = false
	local p2Pos2 = false
	local p2Pos3 = false
	local p2Pos4 = false
--To check what button is available to press
	local p1BtnA = true
	local p1BtnB = true
	local p1BtnC = true
	local p1BtnD = true
	
	local p2BtnA = true
	local p2BtnB = true
	local p2BtnC = true
	local p2BtnD = true
	
	local orderStateIconPosY = 165
	local sndNumber = -1
	local sndTime = 0
	local hintTime = 0
	local seconds = data.orderTime
	local orderTime = seconds*gameTick --Set time for Order Select
	local p1Anim = "p1AnimStand"
	local p2Anim = "p2AnimStand"
	local charDataL = nil
	local charDataR = nil
	local scaleDataL = nil
	local scaleDataR = nil
	local xPortScaleL, yPortScaleL = nil
	local xPortScaleR, yPortScaleR = nil
	textImgSetBank(txt_p1State, 0) --Reset Text Color
	textImgSetBank(txt_p2State, 0)
	animReset(vsLogo)
--Set order time
	if data.p1In == 1 and data.p2In == 2 and (#data.t_p1selected > 1 or #data.t_p2selected > 1) or data.coop == true then
		--orderTime = math.max(#data.t_p1selected, #data.t_p2selected) * 60 --Order Time is setting by the amount of characters selected
	elseif #data.t_p1selected > 1 or data.coop == true then
		--orderTime = #data.t_p1selected * 60 --Order Time is setting by the amount of characters selected
	else
		p1Confirmed = true
		--p2Confirmed = true --Activate to don't order CPU characters in team modes
	end
--Portraits Scale Logic
	for j=#data.t_p1selected, 1, -1 do
		charDataL = t_selChars[data.t_p1selected[j].cel+1]
		if charDataL.orderSprScale ~= nil then
			scaleDataL = charDataL.orderSprScale
		else
			scaleDataL = "1.0,1.0"
		end
		xPortScaleL, yPortScaleL = scaleDataL:match('^([^,]-)%s*,%s*(.-)$')
	end
	for j=#data.t_p2selected, 1, -1 do
		charDataR = t_selChars[data.t_p2selected[j].cel+1]
		if charDataR.orderSprScale ~= nil then
			scaleDataR = charDataR.orderSprScale
		else
			scaleDataR = "1.0,1.0"
		end
		xPortScaleR, yPortScaleR = scaleDataR:match('^([^,]-)%s*,%s*(.-)$')
	end
	while true do
		orderTimeNumber = orderTime/gameTick
		nodecimalOrderTime = string.format("%.0f",orderTimeNumber)
		textImgSetText(txt_orderTime, nodecimalOrderTime)
	--Draw Order Select Last Match Backgrounds
		if data.rosterAdvanced and matchNo >= lastMatch then
			animDraw(f_animVelocity(selectHardBG0, -1, -1)) --Draw Red BG for Final Battle
	--Draw Order Select Normal Matchs Backgrounds
		else
			--Draw Black BG only for Tower/Abyss Mode
			if data.gameMode == "tower" or data.gameMode == "abyss" then
				animDraw(f_animVelocity(selectTowerBG0, -1, -1))
			--Draw Red BG for Special Modes
			elseif data.gameMode == "bossrush" or data.gameMode == "singleboss" or data.rosterMode == "suddendeath" or data.gameMode == "intermission" then
				animDraw(f_animVelocity(selectHardBG0, -1, -1))
			--Draw Blue BG for Normal Modes
			else
				animDraw(f_animVelocity(commonBG0, -1, -1))
			end
		end
	--Draw Window Portraits
		animDraw(f_animVelocity(orderWindowL, -2, 0))
		animDraw(f_animVelocity(orderWindowR, 2, 0))
	--Set Order Status Assets
		if not p1Confirmed then
			--textImgSetBank(txt_p1State, 3) --Set Blue Color
			textImgSetText(txt_p1State, txt_waitingOrder) --Set Text
		else
			textImgSetBank(txt_p1State, 5)
			textImgSetText(txt_p1State, txt_orderFinished)
			p1Anim = "p1AnimWin" --Change Anim when Order Select is complete
		end
		if not p2Confirmed then
			--textImgSetBank(txt_p2State, 1) --Set Red Color
			textImgSetText(txt_p2State, txt_waitingOrder)
		else
			textImgSetBank(txt_p2State, 5)
			textImgSetText(txt_p2State, txt_orderFinished)
			p2Anim = "p2AnimWin"
		end
	--Draw Order Status Text
		textImgDraw(txt_p1State)
		textImgDraw(txt_p2State)
	--Both Sides are Ready
		if p1Confirmed == true and p2Confirmed == true then
			orderTime = 0
			data.t_p1selected = t_p1Temp
			data.t_p2selected = t_p2Temp
		end
		i = i + 1
		if sndTime > 0 then
			sndTime = sndTime - 1
		end
		sndNumber = -1
		--Adjust characters order if timer is > 0
		if orderTime > 0 then
			orderTime = orderTime - 0.5 --Activate Order Select Timer
			textImgDraw(txt_orderTime)
			
		else --when orderTime <= 0
			
		end
	--if Player 1 has not confirmed the order yet
		if not p1Confirmed and data.p1In ~= 2 then
		--Set Random Order Select
			if not p1Pos1 and not p1Pos2 and not p1Pos3 and not p1Pos4 and commandGetState(p1Cmd, 's') then
				if not p1Confirmed then
					sndNumber = 1
					p1Confirmed = true
					commandBufReset(p1Cmd)
				end
				if data.p2In ~= 2 and p2numChars == 1 then --Necessary for Single Boss Mode
					if not p2Confirmed then
						p2Confirmed = true
					end
				end
			end
		--Set Pos 1
			if not p1Pos1 then
				if commandGetState(p1Cmd, 'a') then
					sndNumber = 1
					t_p1Temp[1] = data.t_p1selected[1]
					p1BtnA = false
					p1Pos1 = true
				elseif commandGetState(p1Cmd, 'b') then
					sndNumber = 1
					t_p1Temp[1] = data.t_p1selected[2]
					p1BtnB = false
					p1Pos1 = true
				elseif commandGetState(p1Cmd, 'c') then
					sndNumber = 1
					t_p1Temp[1] = data.t_p1selected[3]
					p1BtnC = false
					p1Pos1 = true
				elseif commandGetState(p1Cmd, 'x') then
					sndNumber = 1
					t_p1Temp[1] = data.t_p1selected[4]
					p1BtnD = false
					p1Pos1 = true
				end
			else
			--Set Pos 2
				if not p1Pos2 then
					if commandGetState(p1Cmd, 'a') and p1BtnA then
						sndNumber = 1
						t_p1Temp[2] = data.t_p1selected[1]
						p1BtnA = false
						p1Pos2 = true
					elseif commandGetState(p1Cmd, 'b') and p1BtnB then
						sndNumber = 1
						t_p1Temp[2] = data.t_p1selected[2]
						p1BtnB = false
						p1Pos2 = true
					elseif commandGetState(p1Cmd, 'c') and p1BtnC then
						sndNumber = 1
						t_p1Temp[2] = data.t_p1selected[3]
						p1BtnC = false
						p1Pos2 = true
					elseif commandGetState(p1Cmd, 'x') and p1BtnD then
						sndNumber = 1
						t_p1Temp[2] = data.t_p1selected[4]
						p1BtnD = false
						p1Pos2 = true
					end
				else
				--Set Pos 3
					if not p1Pos3 then
						if commandGetState(p1Cmd, 'a') and p1BtnA then
							sndNumber = 1
							t_p1Temp[3] = data.t_p1selected[1]
							p1BtnA = false
							p1Pos3 = true
						elseif commandGetState(p1Cmd, 'b') and p1BtnB then
							sndNumber = 1
							t_p1Temp[3] = data.t_p1selected[2]
							p1BtnB = false
							p1Pos3 = true
						elseif commandGetState(p1Cmd, 'c') and p1BtnC then
							sndNumber = 1
							t_p1Temp[3] = data.t_p1selected[3]
							p1BtnC = false
							p1Pos3 = true
						elseif commandGetState(p1Cmd, 'x') and p1BtnD then
							sndNumber = 1
							t_p1Temp[3] = data.t_p1selected[4]
							p1BtnD = false
							p1Pos3 = true
						end
					else
					--Set Pos 4 (Auto assigned)
						if not p1Pos4 then
							if p1BtnA then
								sndNumber = 1
								t_p1Temp[4] = data.t_p1selected[1]
								p1BtnA = false
								p1Pos4 = true
							elseif p1BtnB then
								sndNumber = 1
								t_p1Temp[4] = data.t_p1selected[2]
								p1BtnB = false
								p1Pos4 = true
							elseif p1BtnC then
								sndNumber = 1
								t_p1Temp[4] = data.t_p1selected[3]
								p1BtnC = false
								p1Pos4 = true
							elseif p1BtnD then
								sndNumber = 1
								t_p1Temp[4] = data.t_p1selected[4]
								p1BtnD = false
								p1Pos4 = true
							end
							if data.debugLog then f_printTable(t_p1Temp, "save/debug/OrderSelectP1Temp.log") end
						end
					end
				end
			end
		end
	--if Player 1 has not confirmed the order yet and IS controlled by IA (CPU VS P1)
		if not p1Confirmed and data.p1In == 2 and p2Confirmed == true then
		--TODO: Make Random Select Order for CPU
			if btnPalNo(p1Cmd, true) > 0 then
				if not p1Confirmed then
					sndNumber = 1
					p1Confirmed = true
					commandBufReset(p1Cmd)
				end
				if data.p2In ~= 2 and p2numChars == 1 then --Necessary for Single Boss Mode
					if not p2Confirmed then
						p2Confirmed = true
					end
				end
			end
		end
	--if Player2 has not confirmed the order yet and IS controlled by IA (P1 VS CPU)
		if not p2Confirmed and data.p2In == 1 and p1Confirmed == true then
		--Set Automatic Order
			if not p2Confirmed then
				sndNumber = 1
				p2Pos1 = true
				p2Pos2 = true
				p2Pos3 = true
				p2Pos4 = true
				local t_available = {}
				for i=1, #data.t_p2selected do --Make a copy of original table to delete items
					t_available[i] = data.t_p2selected[i]
				end
				for i=1, #data.t_p2selected do
					local randomIndex = math.random(1, #t_available) --Choose a random Index from available items
					t_p2Temp[i] = t_available[randomIndex] --Save item choosen into t_p2Temp
					table.remove(t_available, randomIndex) --Delete choosen item from t_available table, to avoid be reselected
				end
				if data.debugLog then f_printTable(t_p2Temp, "save/debug/OrderSelectP2Temp.log") end
				p2Confirmed = true
			end
		end
	--if Player2 has not confirmed the order yet and is not controlled by Player 1 (P1 VS P2)
		if not p2Confirmed and data.p2In ~= 1 then
			if not p2Pos1 and not p2Pos2 and not p2Pos3 and not p2Pos4 and commandGetState(p2Cmd, 's') then
				if not p2Confirmed then
					sndNumber = 1
					--p2Confirmed = true
					commandBufReset(p2Cmd)
				end
			end
		--Set Pos 1
			if not p2Pos1 then
				if commandGetState(p2Cmd, 'a') then
					sndNumber = 1
					t_p2Temp[1] = data.t_p2selected[1]
					p2BtnA = false
					p2Pos1 = true
				elseif commandGetState(p2Cmd, 'b') then
					sndNumber = 1
					t_p2Temp[1] = data.t_p2selected[2]
					p2BtnB = false
					p2Pos1 = true
				elseif commandGetState(p2Cmd, 'c') then
					sndNumber = 1
					t_p2Temp[1] = data.t_p2selected[3]
					p2BtnC = false
					p2Pos1 = true
				elseif commandGetState(p2Cmd, 'x') then
					sndNumber = 1
					t_p2Temp[1] = data.t_p2selected[4]
					p2BtnD = false
					p2Pos1 = true
				end
			else
			--Set Pos 2
				if not p2Pos2 then
					if commandGetState(p2Cmd, 'a') and p2BtnA then
						sndNumber = 1
						t_p2Temp[2] = data.t_p2selected[1]
						p2BtnA = false
						p2Pos2 = true
					elseif commandGetState(p2Cmd, 'b') and p2BtnB then
						sndNumber = 1
						t_p2Temp[2] = data.t_p2selected[2]
						p2BtnB = false
						p2Pos2 = true
					elseif commandGetState(p2Cmd, 'c') and p2BtnC then
						sndNumber = 1
						t_p2Temp[2] = data.t_p2selected[3]
						p2BtnC = false
						p2Pos2 = true
					elseif commandGetState(p2Cmd, 'x') and p2BtnD then
						sndNumber = 1
						t_p2Temp[2] = data.t_p2selected[4]
						p2BtnD = false
						p2Pos2 = true
					end
				else
				--Set Pos 3
					if not p2Pos3 then
						if commandGetState(p2Cmd, 'a') and p2BtnA then
							sndNumber = 1
							t_p2Temp[3] = data.t_p2selected[1]
							p2BtnA = false
							p2Pos3 = true
						elseif commandGetState(p2Cmd, 'b') and p2BtnB then
							sndNumber = 1
							t_p2Temp[3] = data.t_p2selected[2]
							p2BtnB = false
							p2Pos3 = true
						elseif commandGetState(p2Cmd, 'c') and p2BtnC then
							sndNumber = 1
							t_p2Temp[3] = data.t_p2selected[3]
							p2BtnC = false
							p2Pos3 = true
						elseif commandGetState(p2Cmd, 'x') and p2BtnD then
							sndNumber = 1
							t_p2Temp[3] = data.t_p2selected[4]
							p2BtnD = false
							p2Pos3 = true
						end
					else
					--Set Pos 4 (Auto assigned)
						if not p2Pos4 then
							if p2BtnA then
								sndNumber = 1
								t_p2Temp[4] = data.t_p2selected[1]
								p2BtnA = false
								p2Pos4 = true
							elseif p2BtnB then
								sndNumber = 1
								t_p2Temp[4] = data.t_p2selected[2]
								p2BtnB = false
								p2Pos4 = true
							elseif p2BtnC then
								sndNumber = 1
								t_p2Temp[4] = data.t_p2selected[3]
								p2BtnC = false
								p2Pos4 = true
							elseif p2BtnD then
								sndNumber = 1
								t_p2Temp[4] = data.t_p2selected[4]
								p2BtnD = false
								p2Pos4 = true
							end
							if data.debugLog then f_printTable(t_p2Temp, "save/debug/OrderSelectP2Temp.log") end
						end
					end
				end
			end
		end
	--Check Orders
		if p1Pos1 and p1Pos2 and p1Pos3 and p1Pos4 then p1Confirmed = true end
		if p2Pos1 and p2Pos2 and p2Pos3 and p2Pos4 then p2Confirmed = true end
	--sndPlay separated to not play more than 1 sound at once
		if sndNumber ~= -1 then
			sndPlay(sndSys, 100, sndNumber)
			sndTime = 30
		end
	--Order Time Over
		if orderTime == 0 then
			if not p1Confirmed then
				p1Confirmed = true
			end
			if not p2Confirmed then
				p2Confirmed = true
			end
			if btnPalNo(p1Cmd, true) > 0 or btnPalNo(p2Cmd, true) > 0 then
				if i < 120 then i = 120 end
			end
			data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
			break
		end
	--Draw Character Portraits
		if data.portraitDisplay == "Portrait" or data.portraitDisplay == "Mixed" then
			for j=#data.t_p1selected, 1, -1 do
				drawOrderPortrait(data.t_p1selected[j].cel, 124 - (2*j-1) * 17.9, 25, xPortScaleL, yPortScaleL)
			end
			for j=#data.t_p2selected, 1, -1 do
				drawOrderPortrait(data.t_p2selected[j].cel, 195 + (2*j-1) * 17.9, 25, -xPortScaleR, yPortScaleR)
			end
		end
	--Draw Character Sprite Animations
		if data.portraitDisplay == "Sprite" or data.portraitDisplay == "Mixed" then
		--Left Side
			for j=#data.t_p1selected, 1, -1 do
				f_drawCharAnim(t_selChars[data.t_p1selected[j].cel+1], p1Anim, 139 - (2*j-1) * 18, 163, data.t_p1selected[j].up)
			end
		--Right Side
			for j=#data.t_p2selected, 1, -1 do
				f_drawCharAnim(t_selChars[data.t_p2selected[j].cel+1], p2Anim, 180 + (2*j-1) * 18, 163, data.t_p2selected[j].up)
			end
		end
	--Draw Order Number Assets
	--Left Side
		for n=#data.t_p1selected, 1, -1 do
			f_drawNameList(txt_p1NameOrder, 5, t_p1Temp, 78, 190, 0, 14, n, 0) --Draw Names of players already order
			animPosDraw(p1OrderCursor, 1, 168+14*n) --Draw Order Icon
			textImgSetText(txt_p1OrderNo, n) --Set Order Number Text
			textImgPosDraw(txt_p1OrderNo, 9, 176+14*n) --Draw Order Number Text
			animPosDraw(t_orderButtons[n].spr, 145-n*35, 140)
		--Draw Order State Icon
			if p1Pos1 then animPosDraw(p1OrderDone, 105, orderStateIconPosY) else animPosDraw(p1OrderWaiting1st, 105, orderStateIconPosY) end --Pos 1 State
			if #data.t_p1selected >= 2 then
				if p1Pos2 then animPosDraw(p1OrderDone, 70, orderStateIconPosY) else animPosDraw(p1OrderWaiting2nd, 70, orderStateIconPosY) end --Pos 2 State
			end
			if #data.t_p1selected >= 3 then
				if p1Pos3 then animPosDraw(p1OrderDone, 35, orderStateIconPosY) else animPosDraw(p1OrderWaiting3rd, 35, orderStateIconPosY) end --Pos 3 State
			end
			if #data.t_p1selected >= 4 then
				if p1Pos4 then animPosDraw(p1OrderDone, 0, orderStateIconPosY) else animPosDraw(p1OrderWaiting4th, 0, orderStateIconPosY) end --Pos 4 State
			end
		end
	--Right Side
		for n=#data.t_p2selected, 1, -1 do
			f_drawNameList(txt_p2NameOrder, 5, t_p2Temp, 241, 190, 0, 14, n, 0)
			animPosDraw(p2OrderCursor, 305, 168+14*n)
			textImgSetText(txt_p2OrderNo, n)
			textImgPosDraw(txt_p2OrderNo, 310, 176+14*n)
			animPosDraw(t_orderButtons[n].spr, 150+n*35, 140)
			if p2Pos1 then animPosDraw(p2OrderDone, 173, orderStateIconPosY) else animPosDraw(p2OrderWaiting1st, 173, orderStateIconPosY) end
			if #data.t_p2selected >= 2 then
				if p2Pos2 then animPosDraw(p2OrderDone, 208, orderStateIconPosY) else animPosDraw(p2OrderWaiting2nd, 208, orderStateIconPosY) end
			end
			if #data.t_p2selected >= 3 then
				if p2Pos3 then animPosDraw(p2OrderDone, 243, orderStateIconPosY) else animPosDraw(p2OrderWaiting3rd, 243, orderStateIconPosY) end
			end
			if #data.t_p2selected >= 4 then
				if p2Pos4 then animPosDraw(p2OrderDone, 278, orderStateIconPosY) else animPosDraw(p2OrderWaiting4th, 278, orderStateIconPosY) end
			end
		end
	--Draw Title
		textImgDraw(txt_orderSelect)
	--Draw Random Order Stuff
		animPosDraw(orderBtnS, 150, 205)
		textImgDraw(txt_orderRandom)
	--Draw Assets
		animUpdate(vsLogo)
		animDraw(vsLogo)
	--When Attract Mode is Enabled
		if data.attractMode then
			drawAttractStatus(2, 318, 10, -1)
			f_attractCredits(318, 238, -1)
		end
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		hintTime = hintTime + 1 --Start timer for randoms hints
		cmdInput()
		refresh()
	end
end

--Transfer data.t_p1selected and data.t_p2selected to p1Dat and p2Dat (global access tables) in order to access in pause menu or match.lua scripts
function f_genPlayerDat()
	if data.t_p1selected ~= nil then
		for i=1, #data.t_p1selected do --To set real Player Value to set handicaps and player(data.t_p1selected[i].pn) stuff in match.lua
			local playerID = 1
			if i == 2 then playerID = 3
			elseif i == 3 then playerID = 5
			elseif i == 4 then playerID = 7
			end
			data.t_p1selected[i]['pn'] = playerID
		end
		p1Dat = data.t_p1selected
	end
	if data.t_p2selected ~= nil then
		for i=1, #data.t_p2selected do
			local playerID = 2
			if i == 2 then playerID = 4
			elseif i == 3 then playerID = 6
			elseif i == 4 then playerID = 8
			end
			data.t_p2selected[i]['pn'] = playerID
		end
		p2Dat = data.t_p2selected
	end
	f_savePlayerDat()
end

--;===========================================================
--; VERSUS SCREEN
--;===========================================================
function f_selectVersus()
	cmdInput()
	local i = 0
	local vsScreen = false
	if data.gameMode == "abyss" then f_setAbyssStats() end --Assign Abyss Stats
	f_genPlayerDat() --Generate p1_sav.json and p2_sav Dat
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
--Manage Access to the screen
	if (data.p1In == 2 and data.p2In == 2) then --Player 1 in player 2 (right) side
		if t_selChars[data.t_p1selected[1].cel+1].vsscreen == nil or t_selChars[data.t_p1selected[1].cel+1].vsscreen == 1 then
			vsScreen = true
		end
	else
		if t_selChars[data.t_p2selected[1].cel+1].vsscreen == nil or t_selChars[data.t_p2selected[1].cel+1].vsscreen == 1 then
			vsScreen = true
		end
	end
	if not data.versusScreen or not vsScreen then
		return
	else
		local colorToName = 1
		local screenTime = 0
		local hintTime = 0
		local timeLimit = 150
		f_getVSHint() --Load First Hint
		animReset(vsLogo) --Since the animation stays at -1, this helps it repeat without reload the anim via animNew().
	--Portraits Scale Logic
		local charDataL = t_selChars[data.t_p1selected[1].cel+1]
		local charDataR = t_selChars[data.t_p2selected[1].cel+1]
		if charDataL.vsSprScale ~= nil then
			scaleDataL = charDataL.vsSprScale
		else
			scaleDataL = "1.0,1.0"
		end
		if charDataR.vsSprScale ~= nil then
			scaleDataR = charDataR.vsSprScale
		else
			scaleDataR = "1.0,1.0"
		end
		local xPortScaleL, yPortScaleL = scaleDataL:match('^([^,]-)%s*,%s*(.-)$')
		local xPortScaleR, yPortScaleR = scaleDataR:match('^([^,]-)%s*,%s*(.-)$')
	--Set Versus Screen Music
		if data.gameMode == "bossrush" or data.gameMode == "singleboss" or data.rosterMode == "suddendeath" or (data.rosterAdvanced and matchNo >= lastMatch) then
			playBGM(bgmVSFinal)
		elseif data.gameMode == "intermission" then
			timeLimit = 350
			playBGM(bgmVSSpecial)
		else
			playBGM(bgmVS)
		end
		while true do
		--Actions
			if screenTime == timeLimit then --or (btnPalNo(p1Cmd, true) > 0 or btnPalNo(p2Cmd, true) > 0) then --Disable temporarily to prevent desync in online mode
				commandBufReset(p1Cmd)
				commandBufReset(p2Cmd)
				break
			end
		--Draw Versus Screen Last Match Backgrounds
			if data.rosterAdvanced and matchNo >= lastMatch then
				animDraw(f_animVelocity(selectHardBG0, -1, -1)) --Draw Red BG for Final Battle
		--Draw Versus Screen Normal Matchs Backgrounds
			else
				--Draw Black BG only for Tower/Abyss Mode
				if data.gameMode == "tower" or data.gameMode == "abyss" then
					animDraw(f_animVelocity(selectTowerBG0, -1, -1))
				--Draw Red BG for Special Modes
				elseif data.gameMode == "bossrush" or data.gameMode == "singleboss" or data.rosterMode == "suddendeath" or data.gameMode == "intermission" then
					animDraw(f_animVelocity(selectHardBG0, -1, -1))
				--Draw Blue BG for Normal Modes
				else
					animDraw(f_animVelocity(commonBG0, -1, -1))
				end
			end
		--Draw Window Portraits
			animDraw(f_animVelocity(vsWindowL, -2, 0))
			animDraw(f_animVelocity(vsWindowR, 2, 0))
		--Draw Character Portraits
			if data.portraitDisplay == "Portrait" or data.portraitDisplay == "Mixed" then
				drawPortrait(data.t_p1selected[1].cel, 20, 30, xPortScaleL, yPortScaleL)
				drawPortrait(data.t_p2selected[1].cel, 300, 30, -xPortScaleR, yPortScaleR)
				--You can use drawVSPortrait instead of drawPortrait to draw exclusive Portraits in this screen.
			end
		--Draw Character Sprite Animations
			if data.portraitDisplay == "Sprite" then
				for j=#data.t_p1selected, 1, -1 do
					f_drawCharAnim(t_selChars[data.t_p1selected[j].cel+1], 'p1AnimWin', 139 - (2*j-1) * 18, 168, data.t_p1selected[j].up)
				end
				for j=#data.t_p2selected, 1, -1 do
					f_drawCharAnim(t_selChars[data.t_p2selected[j].cel+1], 'p2AnimWin', 180 + (2*j-1) * 18, 168, data.t_p2selected[j].up)
				end
			end
		--Draw Match Info
			if data.gameMode == "arcade" or data.gameMode == "tower" or data.gameMode == "tourney" or data.gameMode == "abyss" then
				textImgDraw(txt_matchNo)
			elseif data.gameMode == "versus" or data.gameMode == "survival" or data.gameMode == "vskumite" or data.gameMode == "allroster" or data.gameMode == "intermission" then
				textImgDraw(txt_gameNo)
			elseif data.gameMode == "bossrush" then
				textImgDraw(txt_bossNo)
			elseif data.gameMode == "bonusrush" then
				textImgDraw(txt_bonusNo)
			end
		--Draw Names
			f_drawNameList(txt_p1NameVS, 5, data.t_p1selected, 78, 180, 0, 14, colorToName, 0)
			f_drawNameList(txt_p2NameVS, 5, data.t_p2selected, 241, 180, 0, 14, colorToName, 0)
		--Draw Assets
			animUpdate(vsLogo)
			animDraw(vsLogo)
			animDraw(footerBG)
			if hintTime > 150 then --Time to load a new random hint
				f_getVSHint() --Update Hint
				hintTime = 0 --Restart timer for a new random hint
			end
		--Draw Abyss Mode Characters Stats
			if data.gameMode == "abyss" then
				f_abyssProfile(false, true, -155, 130)
				f_abyssProfileCPU(true, 0, 106)
			end
			textImgDraw(txt_hints) --Draw Hints
			--[[
			if data.debugMode and data.gameMode == "abyss" then
				f_drawQuickText(txt_mtcno, font2, 0, 1, "MATCH: "..matchNo, 100, 60)
				f_drawQuickText(txt_abmtcno, font2, 0, 1, "NEXT ABYSS BOSS MATCH: "..abyssBossMatch, 100, 90)
				f_drawQuickText(txt_absmtcno, font2, 0, 1, "NEXT ABYSS SPECIAL BOSS MATCH: "..getAbyssDepthBossSpecial(), 100, 120)
			end
			]]
		--When Attract Mode is Enabled
			if data.attractMode then
				drawAttractStatus(2, 318, 10, -1)
				f_attractCredits(318, 229, -1)
			end
			animDraw(data.fadeTitle)
			animUpdate(data.fadeTitle)
			hintTime = hintTime + 1 --Start Timer for Randoms Hints
			screenTime = screenTime + 1 --Start Timer for Versus Screen
			cmdInput()
			refresh()
		end
	end
end

function f_getVSHint()
	textImgSetText(txt_hints, t_vsHints[math.random(1, #t_vsHints)].text) --Get Random Hint from t_vsHints Table
end

function f_setAbyssStats()
	abyssDat.nosave.itemslot[1] = getAbyssSP1()
	abyssDat.nosave.itemslot[2] = getAbyssSP2()
	abyssDat.nosave.itemslot[3] = getAbyssSP3()
	abyssDat.nosave.itemslot[4] = getAbyssSP4()
	local statsPlus = 0
	local cpuItems = {}
	local difficulty = nil
	setAbyssBossFight(0)
--Prepare Normal Boss Battle
	if matchNo > abyssBossMatch then abyssBossMatch = abyssBossMatch+abyssBossMatchNo end
--[[Each time that this screen start, abyssBossMatch will increase abyssBossMatchNo ONLY if matchNo(depth) > abyssBossMatch
	
	Examples:
		abyssBossMatchNo = 20 --loaded from screenpack.lua
		
		matchNo = 19
		abyssBossMatch = 0+20
		
		matchNo = 21
		abyssBossMatch = 20+20 = 40
		
		matchNo = 41
		abyssBossMatch = 40+20 = 60
	]]
	if matchNo == abyssBossMatch then
		statsPlus = abyssBossStatsIncrease --When enter in a normal boss match set specific cpu stats (loaded from screenpack.lua)
		abyssBossMatch = abyssBossMatch+abyssBossMatchNo --Also increase abyssBossMatch counter to the next boss to avoid boss challenger loop when enter in the match
		setAbyssBossFight(1) --This match is an Abyss Boss Fight
	end
	setAbyssDepthBoss(abyssBossMatch) --Save NORMAL boss depthNo in ssz to manage as ".com.abyssDepthBoss" via fighting.ssz, match.cns, etc
	abyssDat.nosave.nextboss = abyssBossMatch
--Prepare Special Boss Battle
	if t_abyssSel[abyssSel].specialboss ~= nil then
		if t_abyssSel[abyssSel].specialboss[abyssSpecialBossCnt] ~= nil then
			if matchNo == t_abyssSel[abyssSel].specialboss[abyssSpecialBossCnt].depth then
				statsPlus = abyssBossStatsIncrease + t_abyssSel[abyssSel].specialboss[abyssSpecialBossCnt].stats --Set specific cpu stats for a SPECIAL boss
				cpuItems = t_abyssSel[abyssSel].specialboss[abyssSpecialBossCnt].itemslot --Set Special Items
				difficulty = t_abyssSel[abyssSel].specialboss[abyssSpecialBossCnt].ailevel --Set AI Level
				abyssSpecialBossCnt = abyssSpecialBossCnt + 1 --Increase special abyss boss count for next special fight
				setAbyssBossFight(1) --This match is an Abyss Boss Fight
			end
			if t_abyssSel[abyssSel].specialboss[abyssSpecialBossCnt] == nil then
				setAbyssDepthBossSpecial(0) --No more special boss left
			else
				setAbyssDepthBossSpecial(t_abyssSel[abyssSel].specialboss[abyssSpecialBossCnt].depth) --Save SPECIAL boss depthNo in ssz to manage as ".com.abyssDepthBossSpecial" via fighting.ssz, match.cns, etc
			end
			abyssDat.nosave.nextspecialboss = getAbyssDepthBossSpecial()
		end
	end
--Store Abyss Stats for each player
	if (data.p1In == 2 and data.p2In == 2) then --Player 1 in player 2 (right) side
		--TODO
	else
	--PLAYER
		for p=1, #data.t_p1selected do
			data.t_p1selected[p]['life'] = getAbyssLife()
			data.t_p1selected[p]['power'] = getAbyssPower()
			data.t_p1selected[p]['attack'] = getAbyssAttack()
			data.t_p1selected[p]['defence'] = getAbyssDefence()
			data.t_p1selected[p]['itemslot'] = abyssDat.nosave.itemslot --Special Items
		end
	--CPU
		for p=1, #data.t_p2selected do
			data.t_p2selected[p]['life'] = t_abyssSel[abyssSel].cpustats+statsPlus
			data.t_p2selected[p]['power'] = t_abyssSel[abyssSel].cpustats+statsPlus
			data.t_p2selected[p]['attack'] = t_abyssSel[abyssSel].cpustats+statsPlus
			data.t_p2selected[p]['defence'] = t_abyssSel[abyssSel].cpustats+statsPlus
			if cpuItems ~= nil then
				data.t_p2selected[p]['itemslot'] = cpuItems
			else
				data.t_p2selected[p]['itemslot'] = {[1] = "", [2] = "", [3] = "", [4] = ""}
			end
		end
	--Set AI Level
		if difficulty == nil then
			if t_abyssSel[abyssSel].ailevel ~= nil then
				difficulty = t_abyssSel[abyssSel].ailevel
			else
				difficulty = math.random(1,8)
			end
		end
		setCom(2, difficulty) --Set CPU Level
	end
	if matchNo == lastMatch then setAbyssFinalDepth(1) end --To avoid display the save button after win the last fight
	abyssDat.nosave.life = getAbyssLife()
	abyssDat.nosave.power = getAbyssPower()
	abyssDat.nosave.attack = getAbyssAttack()
	abyssDat.nosave.defence = getAbyssDefence()
	abyssDat.nosave.reward = getAbyssReward()
	abyssDat.nosave.depth = getAbyssDepth()
	abyssDat.nosave.lifebarstate = getLifePersistence()
	abyssDat.nosave.specialbosscnt = abyssSpecialBossCnt
	abyssDat.nosave.winsCnt = winCnt
	abyssDat.nosave.stage = data.stage
	if getAbyssDepth() >= abyssNextCheckPoint and not data.challengerAbyss then abyssNextCheckPoint = abyssNextCheckPoint + abyssCheckpointNo end -- Adds +abyssCheckpointNo amount from screenpack.lua to reach the next checkpoint
	abyssDat.nosave.nextcheckpoint = abyssNextCheckPoint
	if data.challengerAbyss then
		data.challengerAbyss = false
		f_saveTemp()
	end
	f_saveAbyss()
end

--;===========================================================
--; LOADING MATCH SCREEN
--;===========================================================
function f_loading(quickLoad)
	local t = 0
	local quickLoad = quickLoad or false
	local teamChar = nil
	local playerSide = nil
	local coop = nil
	if not quickLoad then
		if data.t_p1selected ~= nil and data.t_p2selected ~= nil then
			f_selectChar(1, data.t_p1selected)
			f_selectChar(2, data.t_p2selected)
			if data.coop then coop = "Local Multiplayer" end
			if p1teamMode > 0 then teamChar = "Team " else teamChar = "Character: " end
			if (data.p1In == 2 and data.p2In == 2) then --Player 1 in player 2 (right) side
				playerSide = data.t_p2selected
			else
				playerSide = data.t_p1selected
			end
			f_discordUpdate({
				largeImageKey = t_selStages[stageNo].discordkey, largeImageText = "Stage: "..t_selStages[stageNo].name,
				smallImageKey = playerSide[1].discordkey, smallImageText = teamChar..playerSide[1].displayname,
				state = coop
			})
		end
	end
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	while true do
		if t == 30 then
			cmdInput()
			break
		end
		t = t + 1
		textImgSetText(txt_loading, "LOADING MATCH...")
		textImgDraw(txt_loading)
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		cmdInput()
		refresh()
	end
end

--;===========================================================
--; VICTORY SCREEN
--;===========================================================
function f_selectWin()
	cmdInput()
	local i = 0
	local txt = ""
	local bufRematchu = 0
	local bufRematchd = 0
	local bufRematchr = 0
	local bufRematchl = 0
	local bufRematch2u = 0
	local bufRematch2d = 0
	local bufRematch2r = 0
	local bufRematch2l = 0
	local menuReady = false
	local timeToSkip = 650
	local winnerTeam = nil
	local winnerSide = nil
	local charData = nil
	local scaleData = nil
	local xPortScale, yPortScale = nil
	p1Cursor = 1
	p2Cursor = 1
	p1Ready = false
	p2Ready = false
	f_resetHandicaps()
	f_modePlaytime() --Store Favorite Game Mode (Addressed to Simple Character Select)
--Winner Logic
	if winner == 1 then
		p1Wins = p1Wins + 1
		winnerTeam = p1numChars
		winnerSide = data.t_p1selected
		if (data.p1In == 2 and data.p2In == 2) then --Player 1 in player 2 (right) side
			--Player 1 is not in this side so..:
			f_defeats() --Store Player Losses
			--f_loseMoney()
		else
			f_winMoney() --Add Coins Rewards by win
			f_victories() --Store Player Victories
		end
		if data.winscreen == "Fixed" or not data.victoryscreen then --Permanent Victory Quotes when Left Side Wins
			txt = "READY FOR THE NEXT BATTLE?"
		else --Victory Quotes from Left Side char
			txt = f_winParse(t_selChars[data.t_p1selected[1].cel+1], t_selChars[data.t_p2selected[1].cel+1], data.t_p2selected[1].pal, #data.t_p2selected)
		end
	else--if winner == 2 then
		p2Wins = p2Wins + 1
		winnerTeam = p2numChars
		winnerSide = data.t_p2selected
		if (data.p1In == 2 and data.p2In == 2) then --Player 1 in player 2 (right) side
			--Player 2 is not in this side so..:
			f_winMoney()
			f_victories()
		else
			f_defeats()
			--f_loseMoney()
		end
		if data.winscreen == "Fixed" or not data.victoryscreen then --Permanent Victory Quotes when Right Side Wins
			txt = "READY FOR THE NEXT BATTLE?"
		else --Victory Quotes from Right Side char
			txt = f_winParse(t_selChars[data.t_p2selected[1].cel+1], t_selChars[data.t_p1selected[1].cel+1], data.t_p1selected[1].pal, #data.t_p1selected)
		end
	end
	if txt == "" or txt == nil then txt = "I am the winner!" end --In case that f_winParse returns "nothing"
--Portraits Scale Logic
	for j=#winnerSide, 1, -1 do
		charData = t_selChars[winnerSide[j].cel+1]
		if charData.winSprScale ~= nil then
			scaleData = charData.winSprScale
		else
			scaleData = "1.0,1.0"
		end
		xPortScale, yPortScale = scaleData:match('^([^,]-)%s*,%s*(.-)$')
	end
--Victory BGM
	if data.winscreen == "Fixed" or not data.victoryscreen then
		playBGM(bgmNothing)
	else --Classic/Modern Victory Screen
		playBGM(bgmVictory)
	end
--Online Ranked Match Control
	if onlinegame and data.gameMode == "versus" then
		f_ftcontrol()
	end
	while true do
		if data.victoryscreen then --Only shows if data.victoryscreen == true
		--Draw Winner Screen Last Match Backgrounds
			if data.rosterAdvanced and matchNo >= lastMatch then
				animDraw(f_animVelocity(selectHardBG0, -1, -1)) --Draw Red BG for Final Battle
		--Draw Winner Screen Normal Matchs Backgrounds
			else
				--Draw Black BG only for Tower/Abyss Mode
				if data.gameMode == "tower" or data.gameMode == "abyss" then
					animDraw(f_animVelocity(selectTowerBG0, -1, -1))
				--Draw Red BG for Special Modes
				elseif data.gameMode == "bossrush" or data.gameMode == "singleboss" or data.rosterMode == "suddendeath" or data.gameMode == "intermission" then
					animDraw(f_animVelocity(selectHardBG0, -1, -1))
				--Draw Blue BG for Normal Modes
				else
					animDraw(f_animVelocity(commonBG0, -1, -1))
				end
			end
		--Draw Permanent Victory Quote Message
			if data.winscreen == "Fixed" then
				f_textRender(txt_winquoteFix, txt, i, 20, 175, 15, 2, 59)
			else --Classic/Modern Victory Screen
				if data.winscreen == "Modern" then
					animDraw(f_animVelocity(wincharBG, 0, 1.5))
					--Draw Portraits
					if data.portraitDisplay == "Portrait" or data.portraitDisplay == "Mixed" then
						if winnerTeam == 1 then
							drawWinPortrait(winnerSide[1].cel, 99, 0, xPortScale, yPortScale) --Your char portrait appears in modern win screen
						elseif winnerTeam == 2 then	--Your 2nd char portrait appears in modern win screen
							drawWinPortrait(winnerSide[2].cel, 150, 0, xPortScale, yPortScale)
							drawWinPortrait(winnerSide[1].cel, 45, 0, xPortScale, yPortScale)
						elseif winnerTeam == 3 then	--Your 3rd char portrait appears in modern win screen	
							drawWinPortrait(winnerSide[3].cel, 0, 0, xPortScale, yPortScale)
							drawWinPortrait(winnerSide[2].cel, 205, 0, xPortScale, yPortScale)
							drawWinPortrait(winnerSide[1].cel, 99, 0, xPortScale, yPortScale)
						elseif winnerTeam == 4 then	--Your 4th char portrait appears in modern win screen
							drawWinPortrait(winnerSide[4].cel, 205, 0, xPortScale, yPortScale)
							drawWinPortrait(winnerSide[3].cel, 0, 0, xPortScale, yPortScale)
							drawWinPortrait(winnerSide[2].cel, 150, 0, xPortScale, yPortScale)
							drawWinPortrait(winnerSide[1].cel, 45, 0, xPortScale, yPortScale)
						end
					--Draw Char Animations
					elseif data.portraitDisplay == "Sprite" then
						for j=#data.t_p1selected, 1, -1 do
							f_drawCharAnim(t_selChars[data.t_p1selected[j].cel+1], 'p1AnimWin', 178 - (2*j-1) * 18, 137.5, data.t_p1selected[j].up)
						end
					end
				elseif data.winscreen == "Classic" then
					if winner == 2 then
						--Draw Portraits
						if data.portraitDisplay == "Portrait" or data.portraitDisplay == "Mixed" then
							drawLoserPortrait(data.t_p1selected[1].cel, 32, 5, 1, 1)
						--Draw Char Animations
						elseif data.portraitDisplay == "Sprite" then
							for j=#data.t_p1selected, 1, -1 do
								f_drawCharAnim(t_selChars[data.t_p1selected[j].cel+1], 'p1AnimDizzy', 139 - (2*j-1) * 18, 143, data.t_p1selected[j].up)
							end
						end
					end
					animDraw(f_animVelocity(wincharBGC1, -2, 0))
					if winner == 1 then
						if data.portraitDisplay == "Portrait" or data.portraitDisplay == "Mixed" then
							drawWinPortrait(data.t_p1selected[1].cel, 32, 5, 1, 1)
							drawLoserPortrait(data.t_p2selected[1].cel, 289, 5, -1, 1)
						elseif data.portraitDisplay == "Sprite" then
							for j=#data.t_p1selected, 1, -1 do
								f_drawCharAnim(t_selChars[data.t_p1selected[j].cel+1], 'p1AnimWin', 149 - (2*j-1) * 18, 143, data.t_p1selected[j].up)
							end
							for j=#data.t_p2selected, 1, -1 do
								f_drawCharAnim(t_selChars[data.t_p2selected[j].cel+1], 'p2AnimDizzy', 180 + (2*j-1) * 18, 143, data.t_p2selected[j].up)
							end
						end
					end
					animDraw(f_animVelocity(wincharBGC2, 2, 0))
					if winner == 2 then
						if data.portraitDisplay == "Portrait" or data.portraitDisplay == "Mixed" then
							drawWinPortrait(data.t_p2selected[1].cel, 289, 5, -1, 1)
						elseif data.portraitDisplay == "Sprite" then
							for j=#data.t_p2selected, 1, -1 do
								f_drawCharAnim(t_selChars[data.t_p2selected[j].cel+1], 'p2AnimWin', 170 + (2*j-1) * 18, 143, data.t_p2selected[j].up)
							end
						end
					end
				end
			--Draw Winner Message
				animDraw(f_animVelocity(quoteBG, 2, 0))
				f_textRender(txt_winquote, txt, i, 20, 175, 15, 2, 59)
			--Draw Character Name
				textImgSetText(txt_winnername, f_getName(winnerSide[1].cel))
				textImgDraw(txt_winnername)
			end
		end
	--REMATCH OPTION
		if data.victoryscreen then --If victory screen is enable
			if data.gameMode == "versus" then --Show Rematch Menu for these modes
				if not menuReady then
					if i == timeToSkip or (btnPalNo(p1Cmd, true) > 0 or btnPalNo(p2Cmd, true) > 0) then
						--cmdInput()
						menuReady = true
					end
				elseif menuReady then
					f_rematch()
				end
				if rematchEnd then
					data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
					commandBufReset(p1Cmd)
					commandBufReset(p2Cmd)
					break
				end
			else --Don't Show Rematch Menu
				if i == timeToSkip or (btnPalNo(p1Cmd, true) > 0 or btnPalNo(p2Cmd, true) > 0) then
					--cmdInput()
					commandBufReset(p1Cmd)
					commandBufReset(p2Cmd)
					data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
					if data.orderSelect == true and data.gameMode == "arcade" then f_selectMusic()
					elseif data.gameMode == "tower" then playBGM(bgmTower)
					elseif data.gameMode == "abyss" then playBGM(bgmAbyss)
					elseif data.gameMode == "singleboss" then playBGM(bgmSelectBoss)
					end
					break
				end
			end
		else--If victory screen is disable
			if data.gameMode == "versus" then
				f_rematch()
			else --Don't Show Rematch Menu
				rematchEnd = true
			end
			if rematchEnd then
				commandBufReset(p1Cmd)
				commandBufReset(p2Cmd)
				data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
				if data.orderSelect == true and data.gameMode == "arcade" then f_selectMusic()
				elseif data.gameMode == "tower" then playBGM(bgmTower)
				elseif data.gameMode == "abyss" then playBGM(bgmAbyss)
				elseif data.gameMode == "singleboss" then playBGM(bgmSelectBoss)
				end
				break
			end
		end
	--When Attract Mode is Enabled
		if data.attractMode then
			drawAttractStatus(2, 318, 10, -1)
			f_attractCredits(318, 235, -1)
		end
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		i = i + 1
		cmdInput()
		refresh()
	end
end
--[[
The problem with the following function f_winParse is that since it's outside the match, there are triggers
like those in life that can't be evaluated and are omitted.
There are also cases where using brackets [1,2] causes an error in Lua because they aren't processed that way.
They must be sent to a table.
]]
function f_winParse(winner, looser, pal)
	local quote = -1
	local logVar = winner.name .. '\n'
	if winner.quotes ~= nil then
		if #winner.trigger == 0 then
			logVar = logVar .. '0 triggers found\n'
			local i = 0
			for k,v in pairs(winner.quotes) do
				i = i + 1
			end
			if i ~= 0 then
				logVar = logVar .. 'quote = random value from all ' .. i .. ' available quotes\n'
				quote = math.random(1,i)
				i = 0
				for k,v in pairs(winner.quotes) do
					i = i + 1
					if i == quote then
						quote = k
					end
				end
			else
				logVar = logVar .. '0 quotes found\n'
			end
		else
			for i=1, #winner.trigger do
				local value = 0
				local trigger = false
				local condition = false
				local triggerall = true
				local triggerCnt = 0
				logVar = logVar .. 'condition: ' .. i .. '\n'
				for k,v in pairs(winner.trigger[i]) do
					if k == 'value' then
						logVar = logVar .. ' value\n  before: ' .. v .. '\n'
						v = v:gsub('%s*', '')
						if tonumber(v) then
							value = tonumber(v)
						else
							v = v:gsub('ifelse%s*%([^,]+,[^,]+,(.+)', '(%1') --always return else value
							v = v:gsub('var%s*%(%s*[0-9]+%s*%)%s*[><=!]+', '0*')
							v = v:gsub('var%s*%(%s*[0-9]+%s*%)', '0')
							v = v:gsub('ceil%s*%(', 'math.ceil(')
							v = v:gsub('random', 'math.random(0,999)')
							v = v:gsub('%%', '*1/1000*')
							f = assert(loadstring('return ' .. v))
							value = f()
							if tonumber(value) then
								value = tonumber(value)
								value = math.floor(value)
							else
								value = -1
							end
						end
						logVar = logVar .. '  after: ' .. v .. '\n  result: ' .. value .. '\n'
					else --trigger
						local skip = false
						if k == 'all' then
							logVar = logVar .. ' triggerall' .. '\n  before: ' .. v .. '\n'
							if v:match('numenemy') then
								skip = false --Added condition for numenemy to always be true (WHY THE FUCK WOULD THERE BE NO ENEMY TO READ WINQUOTES OFF OF!!!!)
								--logVar = logVar .. '  after: skipped\n'
							elseif v:match('numpartner') then
								skip = true
								logVar = logVar .. '  after: skipped\n'
							elseif v:match('numhelper') then
								skip = true
								logVar = logVar .. '  after: skipped\n'
							elseif v:match('ishelper') then
								skip = true
								logVar = logVar .. '  after: skipped\n'
							elseif v:match('numtarget') then
								skip = true
								logVar = logVar .. '  after: skipped\n'
							elseif v:match('playeridexist') then
								skip = true
								logVar = logVar .. '  after: skipped\n'
							end
						else
							logVar = logVar .. ' trigger' .. '\n  before: ' .. v .. '\n'
							triggerCnt = triggerCnt + 1
						end
						if not skip then
							if v:match('numexplod') then
								trigger = false
								logVar = logVar .. '  after: false\n  result: false\n'
							elseif v:match('helper%s*%([^,]+,') then
								trigger = false
								logVar = logVar .. '  after: false\n  result: false\n'
							elseif v:match('s?e?l?f?animexist%s*%([^%)]+%)') then
								trigger = false
								logVar = logVar .. '  after: false\n  result: false\n'
							else
								v = v:gsub('^%s*1%s*$', 'true')
								v = v:gsub('!%s*time', 'true')
								v = v:gsub('enemyn?e?a?r?%s*,', '')
								v = v:gsub('ifelse%s*%([^,]+,[^,]+,(.+)', '(%1')
								v = v:gsub('var%s*%(%s*[0-9]+%s*%)%s*(=?)', '0%1%1')
								v = v:gsub('life%s*=', '1000 ==')
								v = v:gsub('life%s*%s*([<>!])', '1000 %1')
								v = v:gsub('winperfect', 'false')
								v = v:gsub('wintime', 'false')
								v = v:gsub('winko', 'false')
								v = v:gsub('ceil%s*%(', 'math.ceil(')
								v = v:gsub('!=', '~=')
								v = v:gsub('!', ' not ')
								v = v:gsub('||', ' or ')
								v = v:gsub('&&', ' and ')
								v = v:gsub('authorname%s*=', '"' .. looser.author .. '"==')
								v = v:gsub('name%s*=', '"' .. looser.name .. '"==')
								v = v:gsub('palno%s*=%s*%[%s*([0-9]+)%s*,%s*([0-9]+)%s*%]', '(' .. pal .. '>=%1 and ' .. pal .. '<=%2)')
								v = v:gsub('palno%s*~=%s*%[%s*([0-9]+)%s*,%s*([0-9]+)%s*%]', '(' .. pal .. '<%1 or ' .. pal .. '>%2)') --Added this case
								v = v:gsub('numenemy', 'true') --ALWAYS assume there was an enemy...
								v = v:gsub('palno%s*=', pal .. '==')
								v = v:gsub('random', 'math.random(0,999)')
								v = v:gsub('%%', '*1/1000*')
								f = assert(loadstring('if ' .. v .. ' then return true else return false end'))
								trigger = f()
								logVar = logVar .. '  after: ' .. v .. '\n  result: ' .. tostring(trigger) .. '\n'
							end
							--triggerall == false
							if k == 'all' and not trigger then
								triggerall = false
							--triggerX == true
							elseif k ~= 'all' and trigger then
								condition = true
							end
						end
					end
				end
				if triggerall and (condition or triggerCnt == 0) then
					quote = value
				end
			end
		end
		quote = tostring(quote) --quotes table keys are strings
		if winner.quotes[quote] ~= nil then
			f_printVar(logVar .. '\nquote: ' .. quote .. '\nexists: yes', 'save/debug/quotes.log')
			return winner.quotes[quote]
		else
			f_printVar(logVar .. '\nquote: ' .. quote .. '\nexists: no', 'save/debug/quotes.log')
			return ''
		end
	else
		f_printVar(logVar .. '0 triggers found\n0 quotes found\n\nquote: -1\nexists: no', 'save/debug/quotes.log')
		return ''
	end
end

--;===========================================================
--; END RANKED MATCH SCREEN
--;===========================================================
function f_ftcontrol()
	if (p1Wins == data.ftcontrol) or (p2Wins == data.ftcontrol) then
	--[[
		f_playTime()
		os.exit() --Exit like Fightcade System
	]]
		cmdInput()
		while true do
		--Draw BG
			animDraw(f_animVelocity(commonBG0, -1, -1))
		--Draw Menu BG
			animDraw(rankWindowBG)
		--Draw Info Text
			f_textRender(txt_rankText, txt_rankMsg, 0, 160, 125, 10, 0, 25)
		--Draw Esc Text
			textImgDraw(txt_rankESC)
		--Draw Cursor
			animSetWindow(cursorBox, 87,141, 144,13)
			f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
			animDraw(f_animVelocity(cursorBox, -1, -1))
		--Draw Info Title Text
			textImgDraw(txt_rankInfo)
		--Actions
			if esc() then
				sndPlay(sndSys, 100, 2)
				break
			end
			animDraw(data.fadeTitle)
			animUpdate(data.fadeTitle)
			cmdInput()
			refresh()
		end
	end
end

--;===========================================================
--; REMATCH MENU
--;===========================================================
function f_rematch()
	cmdInput()
	if not p1Ready then
	--Player 1 Cursor
		if commandGetState(p1Cmd, 'u') or (commandGetState(p1Cmd, 'holdu') and bufRematchu >= 30) then
			sndPlay(sndSys, 100, 0)
			p1Cursor = p1Cursor - 1
		elseif commandGetState(p1Cmd, 'd') or (commandGetState(p1Cmd, 'holdd') and bufRematchd >= 30) then
			sndPlay(sndSys, 100, 0)
			p1Cursor = p1Cursor + 1
		end
		if p1Cursor < 1 then
			p1Cursor = #t_battleOption
		elseif p1Cursor > #t_battleOption then
			p1Cursor = 1
		end
	end
--Draw BG only when Winscreen is off
	if not data.victoryscreen then animDraw(f_animVelocity(commonBG0, -1, -1)) end
	if data.p2In == 1 or (data.p1In == 2 and data.p2In == 2) then --VS CPU
	--Draw Menu BG
		animDraw(rematchCPUWindowBG)
	--Draw Title
		textImgDraw(txt_rematchCPU)
	else
		animDraw(rematchWindowBG)
		textImgDraw(txt_rematch)
	end
--Set Color and Text Position
	for i=1, #t_battleOption do
		if data.p2In == 1 or (data.p1In == 2 and data.p2In == 2) then --VS CPU
			t_battleOption[i].id = createTextImg(jgFnt, 0, 0, t_battleOption[i].text, 159.1, 89.5+i*13,0.95,0.95)
		else
			t_battleOption[i].id = createTextImg(jgFnt, 0, 0, t_battleOption[i].text, 76, 89.5+i*13,0.95,0.95)
		end
		if i == p1Cursor + 0 then
			textImgSetBank(t_battleOption[i].id, 5)
		else
			textImgSetBank(t_battleOption[i].id, 0)
		end
		textImgDraw(t_battleOption[i].id)
	end
	if not p1Ready then
	--Draw Cursor
		if data.p2In == 1 or (data.p1In == 2 and data.p2In == 2) then --VS CPU
			animSetWindow(cursorBox, 87.1, 79.5+p1Cursor*13, 145, 13)
		else
			animSetWindow(cursorBox, 4, 79.5+p1Cursor*13, 145, 13)
		end
		f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
		animDraw(f_animVelocity(cursorBox, -1, -1))
	end
--Player 2 Mirror Assets
	if data.p2In == 2 and data.p1In ~= 2 then
		if not p2Ready then
			if commandGetState(p2Cmd, 'u') or (commandGetState(p2Cmd, 'holdu') and bufRematch2u >= 30) then
				sndPlay(sndSys, 100, 0)
				p2Cursor = p2Cursor - 1
			elseif commandGetState(p2Cmd, 'd') or (commandGetState(p2Cmd, 'holdd') and bufRematch2d >= 30) then
				sndPlay(sndSys, 100, 0)
				p2Cursor = p2Cursor + 1
			end
			if p2Cursor < 1 then
				p2Cursor = #t_battleOption2
			elseif p2Cursor > #t_battleOption2 then
				p2Cursor = 1
			end
		end
		animDraw(rematch2WindowBG)
		textImgDraw(txt_rematch2)
		for i=1, #t_battleOption2 do
			t_battleOption2[i].id = createTextImg(jgFnt, 0, 0, t_battleOption2[i].text, 244, 89.5+i*13,0.9,0.9)
			if i == p2Cursor + 0 then
				textImgSetBank(t_battleOption2[i].id, 5)
			else
				textImgSetBank(t_battleOption2[i].id, 0)
			end
			textImgDraw(t_battleOption2[i].id)
		end
		if not p2Ready then
			animSetWindow(cursorBox, 172, 79.5+p2Cursor*13, 145, 13)
			f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
			animDraw(f_animVelocity(cursorBox, -1, -1))
		end
	end
--Rematch Option Timer
	if data.gameMode == "arcade" or data.gameMode == "tower" or data.ftcontrol > 0 or data.attractMode == true then
		rematchTimeNumber = rematchTimer/gameTick
		nodecimalRematchTime = string.format("%.0f",rematchTimeNumber)
		textImgSetText(txt_rematchTime, nodecimalRematchTime)
		if rematchTimer > 0 then
			rematchTimer = rematchTimer - 0.5 --Activate Rematch Timer
			textImgDraw(txt_rematchTime)
		else --when rematchTimer <= 0
			
		end
	end
	drawRematchInputHints() --Draw Input Hints Panel
	if commandGetState(p1Cmd, 'holdu') then
		bufRematchd = 0
		bufRematchu = bufRematchu + 1
	elseif commandGetState(p2Cmd, 'holdu') then
		bufRematch2d = 0
		bufRematch2u = bufRematch2u + 1
	elseif commandGetState(p1Cmd, 'holdd') then
		bufRematchu = 0
		bufRematchd = bufRematchd + 1
	elseif commandGetState(p2Cmd, 'holdd') then
		bufRematch2u = 0
		bufRematch2d = bufRematch2d + 1
	else
		bufRematchu = 0
		bufRematchd = 0
		bufRematch2u = 0
		bufRematch2d = 0
	end
	if not p1Ready then
		if btnPalNo(p1Cmd, true) > 0 or rematchTimer == 0 then
			if p1Cursor == 1 then
				sndPlay(sndSys, 100, 1)
				battleOption = 1 --Rematch
				p1Ready = true
			elseif p1Cursor == 2 then
				sndPlay(sndSys, 100, 1)
				battleOption = 2 --Back to Character Select
				p1Ready = true
				p2Ready = true
			elseif p1Cursor == 3 then
				sndPlay(sndSys, 100, 1)
				battleOption = 3 --Back to Stage Select
				p1Ready = true
				p2Ready = true
			elseif p1Cursor == 4 then
				sndPlay(sndSys, 100, 2)
				battleOption = 4 --Back to Main Menu
				p1Ready = true
				p2Ready = true
			end
			if data.p2In == 1 or (data.p1In == 2 and data.p2In == 2) then --Logic for CPU
				battleOption2 = battleOption
				p2Ready = true
			end
			--cmdInput()
		end
	end
	if not p2Ready then
		if data.p2In == 2 and data.p1In ~= 2 then
			if btnPalNo(p2Cmd, true) > 0 or rematchTimer == 0 then
				if p2Cursor == 1 then
					sndPlay(sndSys, 100, 1)
					battleOption2 = 1
					p2Ready = true
				elseif p2Cursor == 2 then
					sndPlay(sndSys, 100, 1)
					battleOption2 = 2
					p1Ready = true
					p2Ready = true
				elseif p2Cursor == 3 then
					sndPlay(sndSys, 100, 1)
					battleOption2 = 3
					p1Ready = true
					p2Ready = true
				elseif p2Cursor == 4 then
					sndPlay(sndSys, 100, 2)
					battleOption2 = 4
					p1Ready = true
					p2Ready = true
				end
				--cmdInput()
			end
		end
	end
	if p1Ready and p2Ready then rematchEnd = true end
	if onlinegame then
		if esc() then
			battleOption = 4
			rematchEnd = true
			f_exitOnline()
		end
	end
end

function f_randomRematch()
--Get new random chars for player 1 side
	if randomP1Rematch == true and data.randomCharRematch == "Variable" then
	--Your 1st char will be randomized for your rematch
		if p1numChars == 1 or p1numChars == 2 or p1numChars == 3 or p1numChars == 4 then
			data.t_p1selected[1].cel = t_randomChars[math.random(#t_randomChars)]
			data.t_p1selected[1].pal = math.random(1,12)
		end
	--Your 2nd char will be randomized for your rematch
		if p1numChars == 2 or p1numChars == 3 or p1numChars == 4 then
			data.t_p1selected[2].cel = t_randomChars[math.random(#t_randomChars)]
			data.t_p1selected[2].pal = math.random(1,12)
		end
	--Your 3rd char will be randomized for your rematch
		if p1numChars == 3 or p1numChars == 4 then
			data.t_p1selected[3].cel = t_randomChars[math.random(#t_randomChars)]
			data.t_p1selected[3].pal = math.random(1,12)
		end
	--Your 4th char will be randomized for your rematch
		if p1numChars == 4 then
			data.t_p1selected[4].cel = t_randomChars[math.random(#t_randomChars)]
			data.t_p1selected[4].pal = math.random(1,12)
		end
	end
--Get new random chars for player 2 side
	if randomP2Rematch == true and data.randomCharRematch == "Variable" then
		if p2numChars == 1 or p2numChars == 2 or p2numChars == 3 or p2numChars == 4 then
			data.t_p2selected[1].cel = t_randomChars[math.random(#t_randomChars)]
			data.t_p2selected[1].pal = math.random(1,12)
		end
		if p2numChars == 2 or p2numChars == 3 or p2numChars == 4 then
			data.t_p2selected[2].cel = t_randomChars[math.random(#t_randomChars)]
			data.t_p2selected[2].pal = math.random(1,12)
		end
		if p2numChars == 3 or p2numChars == 4 then
			data.t_p2selected[3].cel = t_randomChars[math.random(#t_randomChars)]
			data.t_p2selected[3].pal = math.random(1,12)
		end
		if p2numChars == 4 then
			data.t_p2selected[4].cel = t_randomChars[math.random(#t_randomChars)]
			data.t_p2selected[4].pal = math.random(1,12)
		end
	end
end

--;===========================================================
--; HERE COMES A NEW CHALLENGER SCREEN
--;===========================================================
function f_selectChallenger()
	local i = 0
	if data.gameMode ~= "abyss" then
		if data.quickCont == true and data.rosterAdvanced == true then return end
		data.rosterMode = "challenger"
	end
	cmdInput()
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	sndPlay(sndIkemen, 500, 0) --Here comes a new Challenger!
	playBGM(bgmNothing)
	while true do
		if i == 150 then
			data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
			break
		end
	--Draw Last Match Backgrounds
		if data.rosterAdvanced and matchNo >= lastMatch then
			animDraw(f_animVelocity(selectHardBG0, -1, -1)) --Draw Red BG for Final Battle
	--Draw Normal Matchs Backgrounds
		else
		--Draw Black BG only for Tower/Abyss Mode
			if data.gameMode == "tower" or data.gameMode == "abyss" then
				animDraw(f_animVelocity(selectTowerBG0, -1, -1))
		--Draw Red BG for Special Modes
			elseif data.gameMode == "bossrush" or data.gameMode == "singleboss" or data.rosterMode == "suddendeath" or data.gameMode == "intermission" then
				animDraw(f_animVelocity(selectHardBG0, -1, -1))
		--Draw Blue BG for Normal Modes
			else
				animDraw(f_animVelocity(commonBG0, -1, -1))
			end
		end
		animDraw(f_animVelocity(challengerWindow, 0, 1.5))
		animDraw(challengerText)
		animUpdate(challengerText)
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		i = i + 1
		if not data.attractMode then cmdInput() end --To avoid add coins in this screen, during attract mode
		refresh()
	end
end

--VS CHALLENGER (use your character selected for arcade mode to defeat a human challenger the winner keep playing the arcade)
function f_challengerVS()
	f_default()
	setGameMode('vs')
	data.gameMode = "challenger"
	data.rosterMode = "versus"
	data.stageMenu = true
	--data.p2Faces = true
	textImgSetText(txt_mainSelect, "CHALLENGER MODE")
--ARCADE PLAYER IS IN LEFT SIDE - NEW CHALLENGER COMES FROM RIGHT SIDE
	if keepLSide then
		data.p1TeamMenu = {mode = p1RestoreTeamMode, chars = p1RestoreCharsNo}
		data.p2TeamMenu = {mode = p1RestoreTeamMode, chars = p1RestoreCharsNo} --Set Challenger Team Mode at same arcade player conditions
		data.p1SelectMenu = false --Character Data will be loaded in f_p1SelectMenu() following this p1SelectMenu condition
		if P2overP1 then
			setHomeTeam(2)
			remapInput(1, 2)
			remapInput(2, 1)
			setPlayerSide('p1right')
		else
			setHomeTeam(1)
		end
--ARCADE PLAYER IS IN RIGHT SIDE - NEW CHALLENGER COMES FROM LEFT SIDE
	elseif keepRSide then
		data.p1TeamMenu = {mode = p2RestoreTeamMode, chars = p2RestoreCharsNo}
		data.p2TeamMenu = {mode = p2RestoreTeamMode, chars = p2RestoreCharsNo}
		data.p2SelectMenu = false
		if not P2overP1 then
			setHomeTeam(2)
			remapInput(1, 2)
			remapInput(2, 1)
			setPlayerSide('p1right')
		else
			setHomeTeam(1)
		end
	end
	data.p2In = 2
end

--;===========================================================
--; SERVICE MENU
--;===========================================================
function f_service()
	cmdInput()
	local cursorPosY = 1
	local moveTxt = 0
	local serviceMenu = 1
	local bufu = 0
	local bufd = 0
	local bufr = 0
	local bufl = 0
	local maxItems = 12
	local noserviceText = ""
	local noService = false
	local actionTime = 0
	local buttonOK = false
	serviceBack = false
	f_resetListArrowsPos()
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	playBGM(bgmService)
	while true do
	--Service Cursor List Interaction Type
		if data.serviceType == "Cursor" and actionTime == 0 then
			if commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u') or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30) then
				sndPlay(sndSys, 100, 0)
				serviceMenu = serviceMenu - 1
				noService = false
			elseif commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd') or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30) then
				sndPlay(sndSys, 100, 0)
				serviceMenu = serviceMenu + 1
				noService = false
			end
		end
	--Service Selected
		if (btnPalNo(p1Cmd, true) > 0 or btnPalNo(p2Cmd, true) > 0) and actionTime == 0 then
			if data.serviceType == "Button" then --Service Button Interaction Type
				for i=1, #t_service do
					if t_service[i].button == (getButton(p1Cmd) or getButton(p2Cmd)) then
						serviceMenu = i --assign item
						buttonOK = true
						break --exits the cycle once it finds a match
					end
				end
			else
				buttonOK = true
			end
		--CHANGE PLAYER TEAM MODE
			if t_service[serviceMenu].service == "team change" then
				if data.coop or data.quickCont then
					noService = true
				else
					sndPlay(sndSys, 100, 1)
					serviceTeam = true
					break
				end
			end
		--Load Service From t_service table
			if buttonOK then
				if noService then
					sndPlay(sndIkemen, 200, 0)
				else
					sndPlay(sndSys, 100, 1)
					setService(t_service[serviceMenu].service)
					serviceBack = true
				end
			end
		end
	--Based in KOF games, set no service when time over or pressing an specific key...
		if serviceTimer == 0 or (data.serviceType == "Cursor" and (commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e'))) then
			if actionTime == 0 then
				commandBufReset(p1Cmd)
				commandBufReset(p2Cmd)
				sndPlay(sndSys, 100, 1)
				setService("")
				serviceBack = true
			end
		end
	--Exit
		if serviceBack then
			actionTime = actionTime + 1 --Wait some seconds before exit from screen
			if actionTime > 100 then break end
		end
		if data.serviceType == "Cursor" and actionTime == 0 then
		--Cursor position calculation
			if serviceMenu < 1 then
				serviceMenu = #t_service
				if #t_service > maxItems then
					cursorPosY = maxItems
				else
					cursorPosY = #t_service
				end
			elseif serviceMenu > #t_service then
				serviceMenu = 1
				cursorPosY = 1
			elseif ((commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u')) or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30)) and cursorPosY > 1 then
				cursorPosY = cursorPosY - 1
			elseif ((commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd')) or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30)) and cursorPosY < maxItems then
				cursorPosY = cursorPosY + 1
			end
			if cursorPosY == maxItems then
				moveTxt = (serviceMenu - maxItems) * 15
			elseif cursorPosY == 1 then
				moveTxt = (serviceMenu - 1) * 15
			end
			if #t_service <= maxItems then
				maxService = #t_service
			elseif serviceMenu - cursorPosY > 0 then
				maxService = serviceMenu + maxItems - cursorPosY
			else
				maxService = maxItems
			end
		end
	--Draw Character Select Last Match Backgrounds
		if data.rosterAdvanced and matchNo >= lastMatch then
			animDraw(f_animVelocity(selectHardBG0, -1, -1)) --Draw Red BG for Final Battle
	--Draw Character Select Normal Matchs Backgrounds
		else
		--Draw Black BG only for Tower Mode
			if data.gameMode == "tower" then
				animDraw(f_animVelocity(selectTowerBG0, -1, -1))
		--Draw Red BG for Special Modes
			elseif data.gameMode == "bossrush" or data.gameMode == "singleboss" or data.rosterMode == "suddendeath" or data.gameMode == "intermission" then
				animDraw(f_animVelocity(selectHardBG0, -1, -1))
		--Draw Blue BG for Normal Modes
			else
				animDraw(f_animVelocity(commonBG0, -1, -1))
			end
		end
	--Draw Title Menu
		textImgDraw(txt_service)
		if data.serviceType == "Cursor" then
		--Draw Transparent Table BG		
			animSetScale(commonTBG, 240, maxService*15)
			animSetWindow(commonTBG, 80,20, 160,180)
			animDraw(commonTBG)
		--Draw Cursor
			animSetWindow(cursorBox, 80,5+cursorPosY*15, 160,15)
			f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
			animDraw(f_animVelocity(cursorBox, -1, -1))
		--Draw Text for Table
			for i=1, maxService do	
				if i > serviceMenu - cursorPosY then
					t_service[i].id = createTextImg(font2, 0, 0, t_service[i].text, 158.5, 15+i*15-moveTxt)
					textImgDraw(t_service[i].id)
				end
			end
		--Draw Up Animated Cursor
			if maxService > maxItems then
				animDraw(menuArrowUp)
				animUpdate(menuArrowUp)
			end
		--Draw Down Animated Cursor
			if #t_service > maxItems and maxService < #t_service then
				animDraw(menuArrowDown)
				animUpdate(menuArrowDown)
			end
			drawServiceInputHints() --Draw Input Hints Panel
		elseif data.serviceType == "Button" then
		--Draw Buttons and Text from Table
			for i=1, #t_service do	
				animPosDraw(t_service[i].spr, 50, -10+i*35)
				t_service[i].id = createTextImg(font20, 4, 1, t_service[i].text, 80, 5+i*35)
				if actionTime > 0 then
					textImgSetBank(t_service[serviceMenu].id, 0)
				end
				textImgDraw(t_service[i].id)
			end
		end
	--Service Option Timer
		serviceTimeNumber = serviceTimer/gameTick
		nodecimalServiceTime = string.format("%.0f",serviceTimeNumber)
		textImgSetText(txt_serviceTime, nodecimalServiceTime)
		if serviceTimer > 0 then
			if actionTime == 0 then
				serviceTimer = serviceTimer - 0.5 --Activate Service Timer
			end
			textImgDraw(txt_serviceTime)
		else --when serviceTimer <= 0
			
		end
	--Draw Service Info
		if noService then
			if data.coop then
				noserviceText = txt_noServiceCoop
			elseif data.quickCont then
				noserviceText = txt_noServiceQuickCont
			end
			textImgSetText(txt_noService, noserviceText)
			textImgDraw(txt_noService)
		end
	--When Attract Mode is Enabled
		if data.attractMode then
			local creditsY = nil
			drawAttractStatus(2, 318, 10, -1)
			if data.serviceType == "Button" then
				creditsY = 238
			elseif data.serviceType == "Cursor" then
				creditsY = 218
			end
			f_attractCredits(318, creditsY, -1)
		end
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		if commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu') then
			bufd = 0
			bufu = bufu + 1
		elseif commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd') then
			bufu = 0
			bufd = bufd + 1
		else
			bufu = 0
			bufd = 0
		end
		cmdInput()
		refresh()
	end
end

--;===========================================================
--; RESULTS SCREEN
--;===========================================================
function f_result(state)
	cmdInput()
	--if state == "win" then
	--elseif state == "lost" then
	--end
	if data.gameMode == "tower" then rosterSize = #t_selTower[destinySelect].kombats
	elseif data.gameMode == "abyss" then
		rosterSize = t_abyssSel[abyssSel].depth
	--Save Max Abyss Depth
		if getAbyssDepth() > stats.modes.abyss.maxdepth then
			stats.modes.abyss.maxdepth = getAbyssDepth()
			f_saveStats()
		end
	elseif data.gameMode == "endless" then rosterSize = 1
	else rosterSize = #t_roster
	end
	local victoriesPercent = (winCnt/rosterSize)*100
	local charPortr = nil
	local charTable = nil
	local scaleData = nil
	if data.gameMode == "survival" or data.gameMode == "abyss" or data.gameMode == "endless" or data.gameMode == "allroster" or data.gameMode == "vskumite" then
	--Common Data
		if (data.p1In == 2 and data.p2In == 2) then --Player 1 in player 2 (right) side
			textImgSetText(txt_resultName, f_getName(data.t_p2selected[1].cel))
			charPortr = data.t_p2selected[1].cel
			charTable = data.t_p2selected
			if p2teamMode > 0 then
				textImgSetText(txt_resultTeam, "TEAM")
			elseif p1teamMode == 0 then
				textImgSetText(txt_resultTeam, "")
			end
		else
			textImgSetText(txt_resultName, f_getName(data.t_p1selected[1].cel))
			charPortr = data.t_p1selected[1].cel
			charTable = data.t_p1selected
			if p1teamMode > 0 then
				textImgSetText(txt_resultTeam, "TEAM")
			elseif p1teamMode == 0 then
				textImgSetText(txt_resultTeam, "")
			end
		end
		if data.gameMode == "survival" then
			textImgSetAlign(txt_resultTeam, -1)
			textImgSetPos(txt_resultTeam, 318, 48)
			textImgSetAlign(txt_resultName, -1)
			textImgSetPos(txt_resultName, 318, 60)
			textImgSetText(txt_resultNo, winCnt.." WINS")
			textImgSetText(txt_resultTitle, "SURVIVAL RESULTS")
		elseif data.gameMode == "abyss" then
			textImgSetAlign(txt_resultTeam, 1)
			textImgSetPos(txt_resultTeam, 2, 50)
			textImgSetAlign(txt_resultName, 1)
			textImgSetPos(txt_resultName, 2, 65)
			textImgSetText(txt_resultTitle, "ABYSS RESULTS")
		else--if data.gameMode == "endless" or data.gameMode == "allroster" or data.gameMode == "vskumite" then
			textImgSetAlign(txt_resultTeam, 1)
			textImgSetPos(txt_resultTeam, 2, 50)
			textImgSetAlign(txt_resultName, 1)
			textImgSetPos(txt_resultName, 2, 65)
			textImgSetText(txt_resultWins, winCnt.." WINS")
			textImgSetText(txt_resultLoses, looseCnt.." LOSES")
			if data.gameMode == "endless" then textImgSetText(txt_resultTitle, "ENDLESS RESULTS")
			elseif data.rosterMode == "suddendeath" then textImgSetText(txt_resultTitle, "SUDDEN DEATH RESULTS")
			elseif data.rosterMode == "timerush" then textImgSetText(txt_resultTitle, "TIME RUSH RESULTS")
			elseif data.rosterMode == "vskumite" then textImgSetText(txt_resultTitle, getKumiteData().." RESULTS")
			--elseif data.rosterMode == "timeattack" then textImgSetText(txt_resultTitle, "TIME ATTACK RESULTS")
			--elseif data.rosterMode == "scoreattack" then textImgSetText(txt_resultTitle, "SCORE ATTACK RESULTS")
			else textImgSetText(txt_resultTitle, "RESULTS")
			end
		end
	else --Boss/Bonus Rush Exit
		return
	end
--Portraits Scale Logic
	local charData = t_selChars[charPortr+1]
	if charData.resultSprScale ~= nil then
		scaleData = charData.resultSprScale
	else
		scaleData = "1.0,1.0"
	end
	local xPortScale, yPortScale = scaleData:match('^([^,]-)%s*,%s*(.-)$')
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	playBGM(bgmResults)
	while true do
		if btnPalNo(p1Cmd, true) > 0 or btnPalNo(p2Cmd, true) > 0 then
			cmdInput()
			break
		end
		if data.gameMode == "survival" then
		--Draw Character Portrait
			if data.portraitDisplay == "Portrait" or data.portraitDisplay == "Mixed" then
				drawResultPortrait(charPortr, 320, 80, -xPortScale, yPortScale)
				animDraw(fadeWindowBG)
		--Draw Character Sprite Animations
			elseif data.portraitDisplay == "Sprite" then
				for j=#charTable, 1, -1 do
					f_drawCharAnim(t_selChars[charTable[j].cel+1], 'p2AnimWin', 180 + (2*j-1) * 18, 206.5, charTable[j].up)
				end
			end
			animDraw(resultBG) --Draw BG
			textImgDraw(txt_resultNo)
			textImgDraw(txt_resultRank)
		--Show Ranks According Some Percentage Rates
			if victoriesPercent < 35 then --0% -- 34%
				animDraw(rankF)
			elseif victoriesPercent >= 35 and victoriesPercent < 40 then --35% -- 39%
				animDraw(rankDM)
			elseif victoriesPercent >= 40 and victoriesPercent < 45 then --40% -- 44%
				animDraw(rankD)
			elseif victoriesPercent >= 45 and victoriesPercent < 50 then --45% -- 49%
				animDraw(rankDP)
			elseif victoriesPercent >= 50 and victoriesPercent < 55 then --50% -- 54%
				animDraw(rankC)
			elseif victoriesPercent >= 55 and victoriesPercent < 60 then --55% -- 59%
				animDraw(rankCP)
			elseif victoriesPercent >= 60 and victoriesPercent < 65 then --60% -- 64%
				animDraw(rankB)
			elseif victoriesPercent >= 65 and victoriesPercent < 70 then --65% -- 69%
				animDraw(rankBP)
			elseif victoriesPercent >= 70 and victoriesPercent < 75 then --70% -- 74%
				animDraw(rankA)
			elseif victoriesPercent >= 75 and victoriesPercent < 80 then --75% -- 79
				animDraw(rankAP)
			elseif victoriesPercent >= 80 and victoriesPercent < 85 then --80% -- 84%
				animDraw(rankS)
			elseif victoriesPercent >= 85 and victoriesPercent < 90 then --85% -- 89%
				animDraw(rankSP)
			elseif victoriesPercent >= 90 and victoriesPercent < 95 then --90% -- 94%
				animDraw(rankXS)
			elseif victoriesPercent >= 95 then --95% -- 100%
				animDraw(rankGDLK)
			end
		else
		--Draw Character Portrait
			if data.portraitDisplay == "Portrait" or data.portraitDisplay == "Mixed" then
				drawResultPortrait(charPortr, 0, 80, xPortScale, yPortScale)
				animDraw(fadeWindowBG)
		--Draw Character Sprite Animations
			elseif data.portraitDisplay == "Sprite" then
				for j=#charTable, 1, -1 do
					f_drawCharAnim(t_selChars[charTable[j].cel+1], 'p1AnimWin', 139 - (2*j-1) * 18, 206.5, charTable[j].up)
				end
			end
			animDraw(resultBG) --Draw BG
			textImgDraw(txt_resultWins)
			textImgDraw(txt_resultLoses)
		end
		if data.gameMode == "abyss" then
			f_drawAbyssResults()
		end
		--textImgDraw(txt_resultTime)
		--textImgDraw(txt_resultScore)
		textImgDraw(txt_resultTitle)
		textImgDraw(txt_resultName)
		textImgDraw(txt_resultTeam)
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		cmdInput()
		refresh()
	end
end

--;===========================================================
--; CONTINUE SCREEN
--;===========================================================
function f_continueReset()
	animReset(contTimer)
	sndPlay(sndIkemen, 900, 11)
end

function f_continue()
	cmdInput()
	local tablePos = ''
	local tablePos2 = ''
	local tablePos3 = ''
	local tablePos4 = ''
	local anim = false
	local anim2 = false
	local anim3 = false
	local anim4 = false
	local animLength = 0
	local animLength2 = 0
	local animLength3 = 0
	local animLength4 = 0
	if (data.p1In == 2 and data.p2In == 2) then --Player 1 in player 2 (right) side
		if p2numChars == 1 or p2numChars == 2 or p2numChars == 3 or p2numChars == 4 then
			tablePos = t_selChars[data.t_p2selected[1].cel+1] --Your 1st char appear in continue screen
		end
		if p2numChars == 2 or p2numChars == 3 or p2numChars == 4 then
			tablePos2 = t_selChars[data.t_p2selected[2].cel+1] --Your 2nd char appears in continue screen
		end
		if p2numChars == 3 or p2numChars == 4 then
			tablePos3 = t_selChars[data.t_p2selected[3].cel+1] --Your 3rd char appears in continue screen
		end
		if p2numChars == 4 then
			tablePos4 = t_selChars[data.t_p2selected[4].cel+1] --Your 4th char appears in continue screen
		end
	else
		if p1numChars == 1 or p1numChars == 2 or p1numChars == 3 or p1numChars == 4 then
			tablePos = t_selChars[data.t_p1selected[1].cel+1]
		end
		if p1numChars == 2 or p1numChars == 3 or p1numChars == 4 then
			tablePos2 = t_selChars[data.t_p1selected[2].cel+1]
		end
		if p1numChars == 3 or p1numChars == 4 then
			tablePos3 = t_selChars[data.t_p1selected[3].cel+1]
		end
		if p1numChars == 4 then
			tablePos4 = t_selChars[data.t_p1selected[4].cel+1]	
		end
	end
	if tablePos.sffData ~= nil and tablePos.dizzy ~= nil then
		anim = f_animFromTable(tablePos['dizzy'], tablePos.sffData, 80, 180, tablePos.xscale, tablePos.yscale, 0, 1)
	end
	if tablePos2.sffData ~= nil and tablePos2.dizzy ~= nil then
		anim2 = f_animFromTable(tablePos2['dizzy'], tablePos2.sffData, 60, 180, tablePos2.xscale, tablePos2.yscale, 0, 1)
	end
	if tablePos3.sffData ~= nil and tablePos3.dizzy ~= nil then
		anim3 = f_animFromTable(tablePos3['dizzy'], tablePos3.sffData, 40, 180, tablePos3.xscale, tablePos3.yscale, 0, 1)
	end
	if tablePos4.sffData ~= nil and tablePos4.dizzy ~= nil then
		anim4 = f_animFromTable(tablePos4['dizzy'], tablePos4.sffData, 100, 180, tablePos4.xscale, tablePos4.yscale, 0, 1)
	end
	attractContinueTimer = 0
	if attractContinueTimer == 0 then f_continueReset() end
	animReset(gameOver)
	textImgSetText(txt_contTimesCfg, txt_contTimes..stats.continueCount)
	setService("")
	serviceTeam = false
	data.continue = 0
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	playBGM(bgmContinue)
	while true do
		animDraw(contBG0)
		attractContinueTimer = attractContinueTimer + 1
		if data.continue == 0 then --waiting for player's decision
			if anim4 then
				animDraw(anim4)
				animUpdate(anim4)
			end
			if anim3 then
				animDraw(anim3)
				animUpdate(anim3)
			end	
			if anim2 then
				animDraw(anim2)
				animUpdate(anim2)
			end
			if anim then
				animDraw(anim)
				animUpdate(anim)
				animDraw(contBG1)
				animDraw(contBG2)
			end
			if (commandGetState(p1Cmd, 's') or commandGetState(p2Cmd, 's')) and (not data.attractMode or data.attractMode and getCredits() > 0) then
				if tablePos.sffData ~= nil and tablePos.win ~= nil then
					anim, animLength = f_animFromTable(tablePos['win'], tablePos.sffData, 80, 180, tablePos.xscale, tablePos.yscale, 0, 1)
				else
					animLength = 0
				end
				if tablePos2.sffData ~= nil and tablePos2.win ~= nil then
					anim2, animLength2 = f_animFromTable(tablePos2['win'], tablePos2.sffData, 60, 180, tablePos2.xscale, tablePos2.yscale, 0, 1)
				else
					animLength2 = 0
				end
				if tablePos3.sffData ~= nil and tablePos3.win ~= nil then
					anim3, animLength3 = f_animFromTable(tablePos3['win'], tablePos3.sffData, 40, 180, tablePos3.xscale, tablePos3.yscale, 0, 1)
				else
					animLength3 = 0
				end
				if tablePos4.sffData ~= nil and tablePos4.win ~= nil then
					anim4, animLength4 = f_animFromTable(tablePos4['win'], tablePos4.sffData, 100, 180, tablePos4.xscale, tablePos4.yscale, 0, 1)
				else
					animLength4 = 0
				end
				if not onlinegame and data.attractMode then
					setCredits(getCredits() - 1)
				else
					--Free Arcade Play
				end
				stats.continueCount = stats.continueCount + 1 --Times Continue
				--f_saveStats()
				textImgSetText(txt_contTimesCfg, txt_contTimes..stats.continueCount) --Update Count
				fadeContinue = f_fadeAnim(30, 'fadeout', 'black', sprFade)
				data.continue = 1
			end
			if attractContinueTimer > 1366 then --Continue = NO
				data.continue = 2
				f_gameOver()
				data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
				break
			end
			animDraw(contTimer)
		--Update Sprites Count
			if (btnPalNo(p1Cmd) > 0 or btnPalNo(p2Cmd) > 0) and attractContinueTimer >= 71 then
				local cnt = 0
				if attractContinueTimer < 135 then
					cnt = 135
				elseif attractContinueTimer <= 262 then
					cnt = 262
				elseif attractContinueTimer < 389 then
					cnt = 389
				elseif attractContinueTimer < 516 then
					cnt = 516
				elseif attractContinueTimer < 643 then
					cnt = 643
				elseif attractContinueTimer < 770 then
					cnt = 770
				elseif attractContinueTimer < 897 then
					cnt = 897
				elseif attractContinueTimer < 1024 then
					cnt = 1024
				elseif attractContinueTimer < 1151 then
					cnt = 1151
				elseif attractContinueTimer < 1278 then
					cnt = 1278
				end
				while attractContinueTimer < cnt do
					attractContinueTimer = attractContinueTimer + 1
					animUpdate(contTimer)
				end
			else
				animUpdate(contTimer)
			end
			if attractContinueTimer == 135 then
				sndPlay(sndIkemen, 900, 9)
			elseif attractContinueTimer == 262 then
				sndPlay(sndIkemen, 900, 8)
			elseif attractContinueTimer == 389 then
				sndPlay(sndIkemen, 900, 7)
			elseif attractContinueTimer == 516 then
				sndPlay(sndIkemen, 900, 6)
			elseif attractContinueTimer == 643 then
				sndPlay(sndIkemen, 900, 5)
			elseif attractContinueTimer == 770 then
				sndPlay(sndIkemen, 900, 4)
			elseif attractContinueTimer == 897 then
				sndPlay(sndIkemen, 900, 3)
			elseif attractContinueTimer == 1024 then
				sndPlay(sndIkemen, 900, 2)
			elseif attractContinueTimer == 1151 then
				sndPlay(sndIkemen, 900, 1)
			elseif attractContinueTimer == 1278 then
				sndPlay(sndIkemen, 900, 0)
			end
			drawContinueInputHints()
		elseif data.continue == 1 then --Continue = YES
			if animLength4+30 > 0 then
					animLength4 = animLength4 - 1
					if anim4 then
						animDraw(anim4)
						if animLength4 > 0 then
							animUpdate(anim4)
						end
					end	
				--if animLength4 < 0 then
					--animDraw(fadeContinue)
					--animUpdate(fadeContinue)
				--end
				if animLength3+30 > 0 then
					animLength3 = animLength3 - 1
					if anim3 then
						animDraw(anim3)
						if animLength3 > 0 then
							animUpdate(anim3)
						end
					end
				end	
				--if animLength3 < 0 then
					--animDraw(fadeContinue)
					--animUpdate(fadeContinue)
				--end
				if animLength2+30 > 0 then
					animLength2 = animLength2 - 1
					if anim2 then
						animDraw(anim2)
						if animLength2 > 0 then
							animUpdate(anim2)
						end
					end
				end	
				--if animLength2 < 0 then
					--animDraw(fadeContinue)
					--animUpdate(fadeContinue)
				--end
				if animLength+30 > 0 then
					animLength = animLength - 1
					if anim then
						animDraw(anim)
						if animLength > 0 then
							animUpdate(anim)
						end
					end
					animDraw(contBG1)
					animDraw(contBG2)
				end
				if animLength < 0 then
					animDraw(fadeContinue)
					animUpdate(fadeContinue)
				end
			else
			--Service Screen
				if data.serviceScreen then
					f_service()
				end
				if not serviceTeam then --Draw Portrait BG when select a service different of Change Team
					if (data.p1In == 2 and data.p2In == 2) then --Player 1 in player 2 (right) side
						p2BG = true
						p2memberPreview = 1
					else
						p1BG = true
						p1memberPreview = 1
					end
					if data.coop then
						--p2BG = true
						--p2memberPreview = 1
						p2coopReady = false
						p2coopRandom = false
					end
				end
			--Challenger Screen
				if data.challengerScreen then
					f_selectChallenger()
					f_challengerMusic()
				else
					f_selectMusic() --play original char select song instead of challenger song
				end
				break
			end
		end
		--if attractContinueTimer >= 71 then --show when count starts counting down
			textImgDraw(txt_contTimesCfg) --Show Times Continue Count
		--end
		if data.debugMode then
			f_drawQuickText(txt_contiTime, font2, 0, 1, "Cntinue Time: "..attractContinueTimer, 80, 90)
			f_drawQuickText(txt_winreveal, font2, 0, 1, "WINNER: "..winner, 80, 60)
		end
		if attractContinueTimer == 0 then f_continueReset() end
	--When Attract Mode is Enabled
		if data.attractMode then
			drawAttractStatus(2, 318, 10, -1)
			f_attractCredits(318, 30, -1)
		end
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		cmdInput()
		refresh()
	end
end

--;===========================================================
--; GAME OVER SCREEN
--;===========================================================
function f_gameOver()
	cmdInput()
	local tablePos = ''
	local tablePos2 = ''
	local tablePos3 = ''
	local tablePos4 = ''
	local anim = false
	local anim2 = false
	local anim3 = false
	local anim4 = false
	local animLength = 0
	local animLength2 = 0
	local animLength3 = 0
	local animLength4 = 0
	local i = 0
	if (data.p1In == 2 and data.p2In == 2) then --Player 1 in player 2 (right) side
		if p2numChars == 1 or p2numChars == 2 or p2numChars == 3 or p2numChars == 4 then
			tablePos = t_selChars[data.t_p2selected[1].cel+1]
		end
		if p2numChars == 2 or p2numChars == 3 or p2numChars == 4 then
			tablePos2 = t_selChars[data.t_p2selected[2].cel+1]
		end
		if p2numChars == 3 or p2numChars == 4 then
			tablePos3 = t_selChars[data.t_p2selected[3].cel+1]
		end
		if p2numChars == 4 then
			tablePos4 = t_selChars[data.t_p2selected[4].cel+1]	
		end
	else
		if p1numChars == 1 or p1numChars == 2 or p1numChars == 3 or p1numChars == 4 then
			tablePos = t_selChars[data.t_p1selected[1].cel+1]
		end
		if p1numChars == 2 or p1numChars == 3 or p1numChars == 4 then
			tablePos2 = t_selChars[data.t_p1selected[2].cel+1]
		end
		if p1numChars == 3 or p1numChars == 4 then
			tablePos3 = t_selChars[data.t_p1selected[3].cel+1]
		end
		if p1numChars == 4 then
			tablePos4 = t_selChars[data.t_p1selected[4].cel+1]	
		end
	end
	if tablePos.sffData ~= nil then
		if tablePos.cheese ~= nil then
			anim, animLength = f_animFromTable(tablePos['cheese'], tablePos.sffData, 80, 180, tablePos.xscale, tablePos.yscale, 0, 1)
		elseif tablePos.lieDown ~= nil then
			anim, animLength = f_animFromTable(tablePos['lieDown'], tablePos.sffData, 80, 180, tablePos.xscale, tablePos.yscale, 0, 1)
		end
	end
	if tablePos2.sffData ~= nil then
		if tablePos2.cheese ~= nil then
			anim2, animLength2 = f_animFromTable(tablePos2['cheese'], tablePos2.sffData, 60, 180, tablePos2.xscale, tablePos2.yscale, 0, 1)
		elseif tablePos2.lieDown ~= nil then
			anim2, animLength2 = f_animFromTable(tablePos2['lieDown'], tablePos2.sffData, 60, 180, tablePos2.xscale, tablePos2.yscale, 0, 1)
		end
	end
	if tablePos3.sffData ~= nil then
		if tablePos3.cheese ~= nil then
			anim3, animLength3 = f_animFromTable(tablePos3['cheese'], tablePos3.sffData, 40, 180, tablePos3.xscale, tablePos3.yscale, 0, 1)
		elseif tablePos3.lieDown ~= nil then
			anim3, animLength3 = f_animFromTable(tablePos3['lieDown'], tablePos3.sffData, 40, 180, tablePos3.xscale, tablePos3.yscale, 0, 1)
		end
	end
	if tablePos4.sffData ~= nil then
		if tablePos4.cheese ~= nil then
			anim4, animLength4 = f_animFromTable(tablePos4['cheese'], tablePos4.sffData, 100, 180, tablePos4.xscale, tablePos4.yscale, 0, 1)
		elseif tablePos4.lieDown ~= nil then
			anim4, animLength4 = f_animFromTable(tablePos4['lieDown'], tablePos4.sffData, 100, 180, tablePos4.xscale, tablePos4.yscale, 0, 1)
		end
	end
	animReset(gameOver)
	sndPlay(sndIkemen, 900, 10)
	playBGM(bgmGameOver)
	while true do
		animDraw(contBG0)
		i = i + 1
		if btnPalNo(p1Cmd, true) > 0 or btnPalNo(p2Cmd, true) > 0 then
			playBGM(bgmTitle)
			break
		else
			if anim4 then
				animDraw(anim4)
				animLength4 = animLength4 - 1
				if animLength4 > 0 then
					animUpdate(anim4)
				end
			end
			if anim3 then
				animDraw(anim3)
				animLength3 = animLength3 - 1
				if animLength3 > 0 then
					animUpdate(anim3)
				end
			end
			if anim2 then
				animDraw(anim2)
				animLength2 = animLength2 - 1
				if animLength2 > 0 then
					animUpdate(anim2)
				end
			end
			if anim then
				animDraw(anim)
				animLength = animLength - 1
				if animLength > 0 then
					animUpdate(anim)
				end
				animDraw(contBG1)
				animDraw(contBG2)
			end
			if i <= 226+60 then
				animDraw(gameOver)
				animUpdate(gameOver)
				if i == 190 then --music is shorter than animation and we don't want looping here
					playBGM("")
				elseif i == 226 then --create fading animation
					fadeGameOver = f_fadeAnim(60, 'fadeout', 'black', sprFade)
				elseif i > 226 then --start fading the screen
					animDraw(fadeGameOver)
					animUpdate(fadeGameOver)
				end
			else
				break
			end
		end
		cmdInput()
		refresh()
	end
end

--;===================================================================================================
--; SIMPLE MODES (VERSUS, TRAINING, RANDOM, MISSIONS, EVENTS, SINGLE BONUS/BOSSES LIST)
--;===================================================================================================
function f_selectSimple()
cmdInput()
if validCells() then
	f_unlock(false)
	f_updateUnlocks()
	f_backReset()
	f_selectInit()
	while true do
		data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
		if data.rosterMode == "challenger" then f_challengerMusic()
		elseif data.gameMode == "singleboss" then playBGM(bgmSelectBoss)
		elseif data.rosterMode == "event" then --playBGM("")
		elseif data.gameMode == "quick match" then --playBGM("")
		elseif data.gameMode == "intermission" then --playBGM("")
		elseif data.gameMode == "demo" then --playBGM("")
		else f_selectMusic()
		end
		if winner < 1 then
			f_selectReset()
		else
			selectStart()
			commandBufReset(p1Cmd)
			commandBufReset(p2Cmd)
		end
		while not selScreenEnd do
			if not onlinegame then
				if commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then f_exitSelect() end
			else
				if esc() then f_exitOnline() end
			end
			f_selectScreen()
		--Return to Main Menu
			assert(loadfile(saveTempPath))()
			if back == true or data.tempBack == true then
				f_resetMenuAssets()
				return
			end
		end
		if winner > 0 then
		--Victory Screen
			if (data.p1In == 2 and data.p2In == 2) then --Player 1 in player 2 (right) side
				if t_selChars[data.t_p1selected[1].cel+1].victoryscreen == nil or t_selChars[data.t_p1selected[1].cel+1].victoryscreen == 1 then
					f_selectWin()
				end
			else
				if t_selChars[data.t_p2selected[1].cel+1].victoryscreen == nil or t_selChars[data.t_p2selected[1].cel+1].victoryscreen == 1 then
					f_selectWin()
				end
			end
			if data.gameMode == "versus" then
			--BACK TO MAIN MENU
				if battleOption == 4 or battleOption2 == 4 then
					f_favoriteChar() --Store Favorite Character (WIP)
					f_favoriteStage() --Store Favorite Stage (WIP)
					f_resetMenuArrowsPos()
					f_resetMenuInputs()
					if data.attractMode == true then playBGM(bgmTitle) else	f_menuMusic() end
					break
			--BACK TO STAGE SELECT
				elseif battleOption == 3 or battleOption2 == 3 then
					f_selectMusic()
					f_randomRematch()
					f_stageSelectReset()
					--selectStart()
					selScreenEnd = false
					stageEnd = false
					charSelect = true
					rematchEnd = false
					battleOption = 0
					battleOption2 = 0
					--backScreen = false
					--back = false
					while not selScreenEnd do
						if onlinegame then
							if esc() then f_exitOnline() end
						end
						f_selectScreen()
						if back == true then
							f_resetMenuAssets()
							return
						end
					end
			--BACK TO CHARACTER SELECT
				elseif battleOption == 2 or battleOption2 == 2 then
					if data.challengerScreen then
						f_selectChallenger()
						f_challengerMusic()
					else
						f_selectMusic() --play original char select song instead of challenger song
					end
					f_selectReset()
					while not selScreenEnd do
						if not onlinegame then
							if commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then f_exitSelect() end
						else
							if esc() then f_exitOnline() end
						end
						f_selectScreen()
						if back == true then
							f_resetMenuAssets()
							return
						end
					end
			--REMATCH
				elseif battleOption == 1 and battleOption2 == 1 then
					rematchEnd = false
					battleOption = 0 --Reset Rematch Battle Option
					battleOption2 = 0
					f_randomRematch()
					f_loadStage()
					f_assignMusic()
				end
		--For Challenger Route in Arcade Mode
			elseif data.gameMode == "challenger" then
				return
		--For Missions, Events, Quick Match, intermission or special quick match Modes
			elseif getPauseVar() == "nogiveup" or data.gameMode == "demo" or data.gameMode == "quick match" or data.gameMode == "intermission" or data.rosterMode == "mission" or data.rosterMode == "event" then
				f_resetMenuInputs()
				if data.gameMode == "demo" then
					--Don't playBGM
				else
					if data.attractMode == true then playBGM(bgmTitle) else	f_menuMusic() end
				end
				return
		--For Single Boss/Bonus
			else
				f_selectReset()
				while not selScreenEnd do
					if commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then f_exitSelect() end
					f_selectScreen()
					if back == true then
						f_resetMenuAssets()
						return
					end
				end
			end
		end
		f_aiLevel()
		assert(loadfile(saveTrainingPath))()
		if data.gameMode == "training" then
			if data.dummyMode == 1 then
				setCom(2, data.AIlevel)
			else
				setCom(2, 0) --Not computer is controlling P2 side, only the human for training dummy
				if data.dummyMode == 3 then remapInput(2, 1) end --Mirror Controls 
			end
		end
		f_matchInfo()
		setMatchNo(gameNo)
		setP1matchWins(p1Wins)
		setP2matchWins(p2Wins)
		f_orderSelect() --Order Select Screen
		f_selectVersus() --Versus Screen
		sndStop()
		f_loading()
		f_setZoom()
		matchTime = os.clock()
		f_assignMusic()
		winner = game() --Get into the fight
		playBGM("")
		matchTime = os.clock() - matchTime
		clearTime = clearTime + matchTime
		selectTimer = selectSeconds*gameTick
		stageTimer = stageSeconds*gameTick
		rematchTimer = rematchSeconds*gameTick
		serviceTimer = serviceSeconds*gameTick
		f_modePlaytime()
		f_favoriteChar() --Store Favorite Character (WIP)
		f_favoriteStage() --Store Favorite Stage (WIP)
		f_unlock(false)
		f_updateUnlocks()
		f_resetP2CoopInput()
		cmdInput()
		refresh()
	end
else
	f_invalidCells()
	return --back to main menu
end

end

--;===================================================================
--; COMMON SIDE ACTIONS
--;===================================================================
function f_arcadeEnd()
	if data.rosterMode == "arcade" then
		stats.modes.arcade.clear = stats.modes.arcade.clear + 1 --Progress
		if getPlayerSide() == "p1right" then --Player 1 in Right Side
			unlockTarget = data.t_p2selected
		else --Player 1 in Left Side
			unlockTarget = data.t_p1selected
		end
		--if unlockTarget[1].displayname == "Suave Dude" then	stats.unlocks.chars.charname = true end --Character Unlock
		f_saveStats()
		unlockTarget = "" --Reset Var
	elseif data.rosterMode == "tower" then
		stats.modes.tower.clear = stats.modes.tower.clear + 1
		f_saveStats()
	end
	--Intermissions Access
	if data.rosterMode == "arcade" and t_intermissionChars ~= nil and (p1teamMode == 0 and p2teamMode == 0) then --TODO enable intermissions in co-op mode
		data.intermission = true
	end
	f_playCredits()
	f_storyboard(storyboardGameOver)
	f_mainOpening()
	f_resetMenuArrowsPos()
	f_resetMenuInputs()
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	if data.attractMode == true then playBGM(bgmTitle) else	f_menuMusic() end
end

function f_noContinue()
	--f_mainOpening()
	f_resetMenuInputs()
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	if data.attractMode == true then playBGM(bgmTitle) else	f_menuMusic() end
end

function f_advancedEnd()
	if data.rosterMode == "survival" then
		stats.modes.survival.clear = stats.modes.survival.clear + 1
	elseif data.rosterMode == "boss" then
		stats.modes.bossrush.clear = stats.modes.bossrush.clear + 1
	end
	if data.gameMode == "abyss" then
		stats.money = stats.money + getAbyssReward() --Get abyss reward when end it
		exitAbyss = true
	end
	f_saveStats()
	f_storyboard(storyboardGameOver)
	f_resetMenuArrowsPos()
	f_resetMenuInputs()
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	if data.attractMode == true then playBGM(bgmTitle) else	f_menuMusic() end
end

function f_winAdvanced()
	f_records() --Save Stats
	f_result('win')
end

function f_loseAdvanced()
	f_records() --Save Stats
	f_result('lost')
	f_gameOver()
	--f_mainOpening()
	exitAbyss = true
	f_resetMenuArrowsPos()
	f_resetMenuInputs()
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	if data.attractMode == true then playBGM(bgmTitle) else	f_menuMusic() end
end

function f_editLeftSide()
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	if serviceTeam == true then p1TeamEnd = false end
	data.t_p1selected = {}
	p1Portrait = nil
	p1CharEnd = false
	p1PalEnd = false
	p1SelEnd = false
	if data.coop then
		p2CharEnd = false
		p2PalEnd = false
		p2SelEnd = false
	end
end

function f_editRightSide()
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	if serviceTeam == true then p2TeamEnd = false end
	data.t_p2selected = {}
	p2Portrait = nil
	p2CharEnd = false
	p2PalEnd = false
	p2SelEnd = false
	if data.coop then
		p1CharEnd = false
		p1PalEnd = false
		p1SelEnd = false
	end
end

function f_1stStageSel()
	--Load first stage selected for all next matches
	if data.stageMenu == true then
		f_loadStage()
		f_assignMusic()
	end
end

function f_nextMatch()
	matchNo = matchNo + 1
	f_1stStageSel()
end

--;===========================================================================================================================
--; ADVANCED MODES (ARCADE, TOWER, SURVIVAL/ABYSS, BOSS/BONUS/TIME RUSH, SUDDEN DEATH, TIME/SCORE ATTACK, VS X KUMITE, ENDLESS)
--;===========================================================================================================================
function f_selectAdvance()
cmdInput()
if validCells() then
	data.rosterAdvanced = true
	f_unlock(false)
	f_updateUnlocks()
	f_backReset()
	f_selectInit()
	f_selectReset()
	if not data.stageMenu then stageEnd = true end
	while true do
		data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
		if data.gameMode == "bossrush" or data.rosterMode == "suddendeath" then playBGM(bgmSelectBoss)
		elseif data.rosterMode == "challenger" then f_challengerMusic()
		elseif data.gameMode == "tower" then playBGM(bgmTower)
		elseif data.gameMode == "abyss" then --playBGM(bgmAbyss)
		else f_selectMusic()
		end
		if loadAbyssDat then --To skip char select during abyss mode load data
			if (data.p1In == 2 and data.p2In == 2) then --Player 1 in player 2 (right) side
				data.t_p2selected = abyssDat.nosave.player
			else
				data.t_p1selected = abyssDat.nosave.player
			end
			selScreenEnd = true
			f_loadAbyssStats() --Only during Continue Game
		else
			selectStart()
			while not selScreenEnd do
				if not onlinegame then
					if commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then f_exitSelect2() end
				else
					if esc() then f_exitOnline() end
				end
				f_selectScreen()
				assert(loadfile(saveTempPath))()
				if back == true or data.tempBack == true then
					f_resetMenuAssets()
					return
				end
			end
		end
	--FIRST MATCH
		if matchNo == 0 then
		--Arcade Intro
			if data.arcadeIntro == true then
				if (data.p1In == 2 and data.p2In == 2) then --Player 1 in player 2 (right) side
					storyBoardSide = t_selChars[data.t_p2selected[1].cel+1]
				else
					storyBoardSide = t_selChars[data.t_p1selected[1].cel+1]
				end
				local tPos = storyBoardSide
				if tPos.intro ~= nil and io.open(tPos.intro or '','r') ~= nil then
					f_storyboard(tPos.intro)
				elseif tPos.intro2 ~= nil and io.open(tPos.intro2 or '','r') ~= nil then
					playVideo(tPos.intro2)
				end
			end
			if data.gameMode == "tower" then
				f_selectDestiny() --Tower Select (Choose Your Destiny Screen)
				if data.tempBack == true then
					f_exitToMainMenu()
					return
				end
				lastMatch = #t_selTower[destinySelect].kombats --get roster selected in tower mode
			elseif data.gameMode == "abyss" then
				if not loadAbyssDat then --Only show during a New Game
					f_abyssMenu() --Go to that Abyss Menu that contains the item shop
					if data.tempBack == true then
						f_exitToMainMenu()
						return
					end
				end
				f_makeRoster()
				lastMatch = t_abyssSel[abyssSel].depth --get roster selected in abyss depth select
			else
			--generate roster for other modes (arcade, survival, etc)
				f_makeRoster()
				if data.gameMode ~= "endless" then --because for endless we gonna make this infinite
					if (data.p1In == 2 and data.p2In == 2) then --Player 1 in player 2 (right) side
						lastMatch = #t_roster / p1numChars
					else
						lastMatch = #t_roster / p2numChars
					end
				end
			end
			matchNo = 1
			setLastMatch(lastMatch)
			if data.gameMode ~= "endless" then f_aiRamp() end --generate AI ramping table
	--Player exit the match via ESC in Endless or All Roster modes (BOTH SIDES)
		elseif winner == -1 and (data.gameMode == "endless" or data.gameMode == "allroster" or data.gameMode == "vskumite") then
			if data.gameMode ~= "endless" then looseCnt = looseCnt + 1 end --because in endless a give up not counts as a loose
			assert(loadfile(saveTempPath))()
			if data.tempBack == true then
				f_exitToMainMenu()
				return
			end
			f_records() --Save Stats
			f_result('lost')
			f_resetMenuInputs()
			data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade) --reset title screen fading
			if data.attractMode == true then playBGM(bgmTitle) else	f_menuMusic() end
			return
	--Endless or All Roster modes (BOTH SIDES)
		elseif data.gameMode == "endless" or data.gameMode == "allroster" or data.gameMode == "vskumite" then
			if (data.p1In == 2 and data.p2In == 2) then --Player 1 in player 2 (right) side
				if winner == 2 then
					winCnt = winCnt + 1
				else
					looseCnt = looseCnt + 1
				end
			else
				if winner == 1 then
					winCnt = winCnt + 1
				else --only true in Endless or All Roster modes
					looseCnt = looseCnt + 1
				end
			end
		--No More Matches Left
			if data.gameMode ~= "endless" and matchNo >= lastMatch then
				f_winAdvanced()
				f_storyboard(storyboardGameOver)
				f_resetMenuInputs()
				data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
				if data.attractMode == true then playBGM(bgmTitle) else	f_menuMusic() end
				return
		--Next Match Available
			else
				f_nextMatch()
			end
	--LEFT SIDE ACTIONS
		elseif winner == 1 then
			--Player 1 (IN RIGHT SIDE):
			if (data.p1In == 2 and data.p2In == 2) then --Player 1 in player 2 (right) side
			--Lose in Survival, Boss/Bonus Rush or don't have coins to continue in (Arcade with Attract Mode)
				if data.gameMode == "survival" or data.gameMode == "abyss" or data.gameMode == "bossrush" or data.gameMode == "bonusrush" or (data.attractMode and getCredits() == 0) then
					looseCnt = looseCnt + 1
				--Victory screen
					if data.gameMode == "arcade" or data.gameMode == "tower" then
						if winner >= 1 and (t_selChars[data.t_p1selected[1].cel+1].victoryscreen == nil or t_selChars[data.t_p1selected[1].cel+1].victoryscreen == 1) then
							f_selectWin()
						end
					end
					assert(loadfile(saveTempPath))()
					if data.tempBack == true then
						f_exitToMainMenu()
						return
					end
					f_loseAdvanced()
					return
				--Lose BUT can Continue (Arcade)
				else
					looseCnt = looseCnt + 1
					assert(loadfile(saveTempPath))()
					if data.tempBack == true then
						f_exitToMainMenu()
						return
					end
					f_records()
				--Victory Screen
					if winner >= 1 and (t_selChars[data.t_p1selected[1].cel+1].victoryscreen == nil or t_selChars[data.t_p1selected[1].cel+1].victoryscreen == 1) then
						f_selectWin()
					end
				--Continue Screen
					f_continue()
					if data.continue == 2 then --Continue = NO
						f_noContinue()
						return
					end
				--Quick Arcade Continue option disable (Character can be Changed after Continue/Services)
					if not data.quickCont then
						f_editRightSide()
						f_rosterReset()
						selScreenEnd = false
						while not selScreenEnd do
							if commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then f_exitSelect3() end
							f_selectScreen()
							if back == true then
								f_resetMenuAssets()
								return
							end
						end
				--Exit
					elseif commandGetState(p1Cmd, 'e') then
						f_resetMenuInputs()
						data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
						sndPlay(sndSys, 100, 2)
						if data.attractMode == true then playBGM(bgmTitle) else	f_menuMusic() end
						return
					end
					f_1stStageSel()
				end
		--Player 1 (IN LEFT SIDE):
			else
			--Wins in (Arcade, Survival, Boss/Bonus Rush)
				if winner == 1 then
					winCnt = winCnt + 1
				else
					looseCnt = looseCnt + 1
				end
			--Victory Screen
				if data.gameMode == "arcade" or data.gameMode == "tower" then
					if t_selChars[data.t_p2selected[1].cel+1].victoryscreen == nil or t_selChars[data.t_p2selected[1].cel+1].victoryscreen == 1 then
						f_selectWin()
					end
				end
			--No More Matches Left
				if matchNo >= lastMatch then
				--Arcade Ending
					if data.arcadeEnding == true then
						local tPos = t_selChars[data.t_p1selected[1].cel+1]
						if tPos.ending ~= nil and io.open(tPos.ending or '','r') ~= nil then
							f_storyboard(tPos.ending)
						elseif tPos.ending2 ~= nil and io.open(tPos.ending2 or '','r') ~= nil then
							playVideo(tPos.ending2)
						end
					end
					if data.gameMode == "abyss" then f_abyssMap() end
					f_winAdvanced()
					if data.gameMode == "arcade" or data.gameMode == "tower" then
						f_arcadeEnd()
						return
					else
						f_advancedEnd()
						return
					end
			--Next Match Available
				else
					f_nextMatch()
				end
			end
	--RIGHT SIDE
		elseif winner == 2 then
		--Player 1 (IN RIGHT SIDE):
			if (data.p1In == 2 and data.p2In == 2) then --Player 1 in player 2 (right) side
			--Wins in (Arcade, Survival, Boss/Bonus Rush)
				if winner == 2 then
					winCnt = winCnt + 1
				else
					looseCnt = looseCnt + 1
				end
			--Victory Screen
				if data.gameMode == "arcade" or data.gameMode == "tower" then
					if t_selChars[data.t_p1selected[1].cel+1].victoryscreen == nil or t_selChars[data.t_p1selected[1].cel+1].victoryscreen == 1 then
						f_selectWin()
					end
				end
			--No More Matches Left
				if matchNo >= lastMatch then
				--Arcade Ending
					if data.arcadeEnding == true then
						local tPos = t_selChars[data.t_p2selected[1].cel+1]
						if tPos.ending ~= nil and io.open(tPos.ending or '','r') ~= nil then
							f_storyboard(tPos.ending)
						elseif tPos.ending2 ~= nil and io.open(tPos.ending2 or '','r') ~= nil then
							playVideo(tPos.ending2)
						end
					end
					f_winAdvanced()
					if data.gameMode == "arcade" or data.gameMode == "tower" then
						f_arcadeEnd()
						return
					else
						f_advancedEnd()
						return
					end
			--Next Match Available
				else
					f_nextMatch()
				end
		--Player 1 (IN LEFT SIDE):
			else
			--Lose in Survival, Boss/Bonus Rush or don't have coins to continue in (Arcade with Attract Mode)
				if data.gameMode == "survival" or data.gameMode == "abyss" or data.gameMode == "bossrush" or data.gameMode == "bonusrush" or (data.attractMode and getCredits() == 0) then
					looseCnt = looseCnt + 1
				--Victory Screen
					if data.gameMode == "arcade" or data.gameMode == "tower" then
						if winner >= 1 and (t_selChars[data.t_p2selected[1].cel+1].victoryscreen == nil or t_selChars[data.t_p2selected[1].cel+1].victoryscreen == 1) then
							f_selectWin()
						end
					end
					assert(loadfile(saveTempPath))()
					if data.tempBack == true then
						f_exitToMainMenu()
						return
					end
					f_loseAdvanced()
					return
			--Lose BUT can Continue (Arcade)
				else
					looseCnt = looseCnt + 1
					assert(loadfile(saveTempPath))()
					if data.tempBack == true then
						f_exitToMainMenu()
						return
					end
					f_records() --Save Stats
				--Victory Screen
					if winner >= 1 and (t_selChars[data.t_p2selected[1].cel+1].victoryscreen == nil or t_selChars[data.t_p2selected[1].cel+1].victoryscreen == 1) then
						f_selectWin()
					end
				--Continue Screen
					f_continue()
					if data.continue == 2 then --Continue = NO
						f_noContinue()
						return
					end
				--Quick Arcade Continue option disable (Character can be Changed after Continue/Services)
					if not data.quickCont then
						f_editLeftSide()
						f_rosterReset()
						selScreenEnd = false
						while not selScreenEnd do
							if commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then f_exitSelect3() end
							f_selectScreen()
							if back == true then
								f_resetMenuAssets()
								return
							end
						end
				--Exit
					elseif commandGetState(p1Cmd, 'e') then
						f_resetMenuInputs()
						data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
						sndPlay(sndSys, 100, 2)
						if data.attractMode == true then playBGM(bgmTitle) else	f_menuMusic() end
						return
					end
					f_1stStageSel()
				end
			end
	--BOTH SIDES - NO WINNER (player exit the match via ESC in Arcade, Survival, Boss/Bonus Rush)
		else --if winner == -1
			assert(loadfile(saveTempPath))()
			if onlinegame and winner == -1 then
				f_exitToMainMenu()
				return
			end
		--Lose Screen for: Survival, Boss/Bonus Rush when GIVE UP option is selected in Pause Menu
			if data.gameMode == "survival" or data.gameMode == "bossrush" or data.gameMode == "bonusrush" or (data.attractMode and getCredits() == 0) then
				looseCnt = looseCnt + 1
				if data.gameMode == "arcade" or data.gameMode == "tower" then --Attract Arcade
					if (data.p1In == 2 and data.p2In == 2) then --Player 1 in player 2 (right) side
						if winner >= 1 and (t_selChars[data.t_p1selected[1].cel+1].victoryscreen == nil or t_selChars[data.t_p1selected[1].cel+1].victoryscreen == 1) then
							f_selectWin()
						end
					else
						if winner >= 1 and (t_selChars[data.t_p2selected[1].cel+1].victoryscreen == nil or t_selChars[data.t_p2selected[1].cel+1].victoryscreen == 1) then
							f_selectWin()
						end
					end
				end
				assert(loadfile(saveTempPath))()
				if data.tempBack == true then
					f_exitToMainMenu()
					return
				end
				f_loseAdvanced()
				return
		--Abyss Boss Challenger
			elseif data.gameMode == "abyss" and data.challengerAbyss then
			--Don't Exit, just prepare stuff
				matchNo = getAbyssDepth()
				f_selectChallenger()
		--Abyss Save and Exit
			elseif data.gameMode == "abyss" and data.saveAbyss then
				matchNo = getAbyssDepth()
				--Now go to versus screen and if data.saveAbyss is true back to main menu to save data
		--Continue Screen for Arcade when GIVE UP option is selected in Pause Menu
			else
				assert(loadfile(saveTempPath))()
			--Here comes a New Challenger Route
				if data.challengerMode then
					data.challengerMode = false
					f_saveTemp()
				--Backup Arcade Data
					t_p1selectedTemp = data.t_p1selected --Get a copy of loaded chars to restore arcade after challenger battle
					t_p2selectedTemp = data.t_p2selected
					p1RestoreTeamMode = p1teamMode --Get a copy of team mode selected
					p2RestoreTeamMode = p2teamMode
					p1RestoreCharsNo = p1numChars --Get a copy of amount of chars selected
					p2RestoreCharsNo = p2numChars
					restoreMatchNo = matchNo --Get a copy of matchNo where arcade was cut
					if data.debugLog then f_printTable(t_p1selectedTemp, "save/debug/t_p1selectedTemp.log") end
					if data.debugLog then f_printTable(t_p2selectedTemp, "save/debug/t_p2selectedTemp.log") end
				--Load Side Player Data
					if getPlayerSide() == "p1left" or getPlayerSide() == "p2left" then
						keepLSide = true
					elseif getPlayerSide() == "p1right" or getPlayerSide() == "p2right" then
						keepRSide = true
					end
				--Go to VS Challenger Mode
					f_challengerVS() --Load Select Config
					backtomenu = false
					f_selectSimple() --Start Char Select
				--Read Winner results from f_selectSimple()
					if getPlayerSide() == "p1right" then --Player 1 in Right Side
						if winner == 1 then --Player 2 in Left Side Wins
							challengerEnd = true
							matchSetting = "humanvscpu"
							P2overP1 = true
						elseif winner == 2 then --Player 1 in Right Side Wins
							challengerEnd = true
							matchSetting = "cpuvshuman"
							P2overP1 = false
						else --No winner (maybe you use pause menu to exit) but what will happen if you come from a draw game?
							backtomenu = true
						end
					else --Player 1 in Left Side
						if winner == 1 then --Player 1 in Left Side Wins
							challengerEnd = true
							matchSetting = "humanvscpu"
							P2overP1 = false
						elseif winner == 2 then --Player 2 in Right Side Wins
							challengerEnd = true
							matchSetting = "cpuvshuman"
							P2overP1 = true
						else --No winner (maybe you use pause menu to exit) but what will happen if you come from a draw game?
							backtomenu = true
						end
					end
				--Restore Arcade Data when f_selectSimple() end
					if challengerEnd then
						if data.gameMode == "arcade" then
							arcadeCfg()
							textImgSetText(txt_mainSelect, "ARCADE")
						elseif data.gameMode == "tower" then
							towerCfg()
							textImgSetText(txt_mainSelect, "TOWER")
						end
						if matchSetting == "humanvscpu" then --is a copy frmo function arcadeHumanvsCPU()
							if P2overP1 then
								remapInput(1, 2)
								setPlayerSide('p2left')
							else
								setPlayerSide('p1left')
							end
							data.p2In = 1
							data.p2SelectMenu = false
						elseif matchSetting == "cpuvshuman" then --is a copy from function arcadeCPUvsHuman()
							remapInput(1, 2)
							if not P2overP1 then
								remapInput(2, 1)
								setPlayerSide('p1right')
							else
								setPlayerSide('p2right')
							end
							data.p1In = 2
							data.p2In = 2
							data.p1SelectMenu = false
						end
						p1teamMode = p1RestoreTeamMode --Restore team mode
						p2teamMode = p2RestoreTeamMode
						p1numChars = p1RestoreCharsNo --Restore chars amount
						p2numChars = p2RestoreCharsNo
						matchNo = restoreMatchNo --Restore matchNo
						challengerEnd = false
						matchSetting = ""
					end
			--Normal Give Up Route
				else
					looseCnt = looseCnt + 1
					if data.tempBack == true then
						f_exitToMainMenu()
						return
					end
					f_records()
					if (data.p1In == 2 and data.p2In == 2) then --Player 1 in player 2 (right) side
						if winner >= 1 and (t_selChars[data.t_p1selected[1].cel+1].victoryscreen == nil or t_selChars[data.t_p1selected[1].cel+1].victoryscreen == 1) then
							f_selectWin()
						end
					else
						if winner >= 1 and (t_selChars[data.t_p2selected[1].cel+1].victoryscreen == nil or t_selChars[data.t_p2selected[1].cel+1].victoryscreen == 1) then
							f_selectWin()
						end
					end
					f_continue()
					if data.continue == 2 then
						f_noContinue()
						return
					end
					if not data.quickCont then
						if (data.p1In == 2 and data.p2In == 2) then --Player 1 in player 2 (right) side
							f_editRightSide()
						else
							f_editLeftSide()
						end
						f_rosterReset()
						selScreenEnd = false
						while not selScreenEnd do
							if commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then f_exitSelect3() end
							f_selectScreen()
							if back == true then
								f_resetMenuAssets()
								return
							end
						end
					elseif commandGetState(p1Cmd, 'e') then
						f_resetMenuInputs()
						data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
						sndPlay(sndSys, 100, 2)
						if data.attractMode == true then playBGM(bgmTitle) else	f_menuMusic() end
						return
					end
					if data.stageMenu == true then
						f_loadStage()
						f_assignMusic()
					end
				end
			--If you exit in char select from challenger mode then back to main menu
				if back == true or backtomenu == true then
					f_resetMenuAssets()
					return
				end
			end
		end
	--Assign enemy team for AI in Player 1 (LEFT SIDE)
		if (data.p1In == 2 and data.p2In == 2) then --Player 1 in player 2 (right) side
			data.t_p1selected = {}
			shuffle = true --was local function
			for i=1, p1numChars do
				if i == 1 and data.gameMode == "arcade" and t_selChars[data.t_p2selected[1].cel+1][matchNo] ~= nil then --Force Arcade Path Fight according to match number: 1, 2, (...)
					p1Cell = t_charDef[t_selChars[data.t_p2selected[1].cel+1][matchNo]]
					shuffle = false
				else
					if data.gameMode == "tower" then
						p1Cell = t_selTower[destinySelect].kombats[matchNo]
					elseif data.gameMode == "endless" or data.gameMode == "abyss" then
						p1Cell = t_roster[#t_roster] --Last char will be used because it will be removed below so that when the t_roster table is empty, f_makeRoster() will happen to renew. This logic will ensure that chars are not repeated until the entire roster is defeated.
					--Fight against boss character predefined at some depth/MatchNo
						if data.gameMode == "abyss" and t_abyssSel[abyssSel].specialboss ~= nil then
							for i=1, #t_abyssSel[abyssSel].specialboss do
								local bossChar = nil
							--[[
								local bossStage = nil
								local bossSong = nil
							]]
								if matchNo == t_abyssSel[abyssSel].specialboss[i].depth then --should replace matchNo with getAbyssDepth()?
								--Pick Specific Char
									if t_abyssSel[abyssSel].specialboss[i].char ~= nil then
										bossChar = t_abyssSel[abyssSel].specialboss[i].char:lower()
								--Pick Random Char
									else
										bossChar = t_selChars[t_roster[math.random(#t_roster)]+1].char:lower()
									end
									p1Cell = t_charDef[bossChar]
								--Set Custom Stage
									if t_abyssSel[abyssSel].specialboss[i].stage ~= nil then
										data.stage = t_abyssSel[abyssSel].specialboss[i].stage
									end
								--Set Custom BGM
									if t_abyssSel[abyssSel].specialboss[i].music ~= nil then
										data.bgm = t_abyssSel[abyssSel].specialboss[i].music
									end
								end
							end
						end
					else
						p1Cell = t_roster[matchNo*p1numChars-i+1]
					end
				end
			--Set AI Palette
				if data.gameMode == "abyss" then
					if matchNo == abyssBossMatch then
						p1Pal = 1 --Normal Boss Specific Palette
					else
						p1Pal = math.random(2,12) --Normal Enemy Random Palette
					end
				--Special Boss character predefined Palette
					if t_abyssSel[abyssSel].specialboss ~= nil then
						for i=1, #t_abyssSel[abyssSel].specialboss do
							if matchNo == t_abyssSel[abyssSel].specialboss[i].depth then
								p1Pal = t_abyssSel[abyssSel].specialboss[i].pal
							end
						end
					end
				else
					if data.aipal == "Default" then
						p1Pal = 1
					elseif data.aipal == "Random" then
						p1Pal = math.random(1,12)
					end
				end
				local updateAnim = true
				for j=1, #data.t_p1selected do
					if data.t_p1selected[j].cel == p1Cell then 
						updateAnim = false
					end
				end
				data.t_p1selected[#data.t_p1selected+1] = {['cel'] = p1Cell, ['name'] = t_selChars[p1Cell+1].name, ['displayname'] = t_selChars[p1Cell+1].displayname, ['path'] = t_selChars[p1Cell+1].char, ['pal'] = p1Pal, ['handicap'] = p1HandicapSel, ['up'] = updateAnim, ['rand'] = false}
				if shuffle then
					f_shuffleTable(data.t_p1selected)
				end
			end
		--Team conversion to Single match
			restoreTeam = false
			teamMode = p1teamMode --was local function
			numChars = p1numChars --was local function
			if p1numChars > 1 then
				for i=1, #data.t_p1selected do
					if (data.gameMode == "tower" and data.coop) or (data.coop and data.coopenemy == "Single") or (t_selChars[data.t_p1selected[i].cel+1].single ~= nil and t_selChars[data.t_p1selected[i].cel+1].single == 1) or (t_selChars[data.t_p1selected[i].cel+1].bonus ~= nil and t_selChars[data.t_p1selected[i].cel+1].bonus == 1) then
						p1teamMode = 0
						p1numChars = 1
						setTeamMode(1, 0, 2) --OR (1, 0, 1) ?
						p1Cell = t_charDef[t_selChars[data.t_p1selected[i].cel+1].char]
						data.t_p1selected = {}
						data.t_p1selected[1] = {['cel'] = p1Cell, ['name'] = t_selChars[p1Cell+1].name, ['displayname'] = t_selChars[p1Cell+1].displayname, ['path'] = t_selChars[p1Cell+1].char, ['pal'] = p1Pal, ['handicap'] = p1HandicapSel, ['up'] = true, ['rand'] = false}
						restoreTeam = true
						break
					end
				end
			end
			if data.gameMode ~= "tower" then
				t_roster[matchNo] = data.t_p1selected[1].cel --Refresh t_roster table
			end
	--Assign enemy team for AI in Player 2 (RIGHT SIDE)
		else
			data.t_p2selected = {}
			shuffle = true --was local function
			for i=1, p2numChars do
				if i == 1 and data.gameMode == "arcade" and t_selChars[data.t_p1selected[1].cel+1][matchNo] ~= nil then
					p2Cell = t_charDef[t_selChars[data.t_p1selected[1].cel+1][matchNo]]
					shuffle = false
				else
					if data.gameMode == "tower" then
						p2Cell = t_selTower[destinySelect].kombats[matchNo]
					elseif data.gameMode == "endless" or data.gameMode == "abyss" then
						p2Cell = t_roster[#t_roster] --Last char will be used because it will be removed below so that when the t_roster table is empty, f_makeRoster() will happen to renew. This logic will ensure that chars are not repeated until the entire roster is defeated.
					--Fight against boss character predefined at some depth/MatchNo
						if data.gameMode == "abyss" and t_abyssSel[abyssSel].specialboss ~= nil then
							for i=1, #t_abyssSel[abyssSel].specialboss do
								if matchNo == t_abyssSel[abyssSel].specialboss[i].depth then --should replace matchNo with getAbyssDepth()?
									local bossChar = nil
								--[[
									local bossStage = nil
									local bossSong = nil
								]]
								--Pick Specific Char
									if t_abyssSel[abyssSel].specialboss[i].char ~= nil then
										bossChar = t_abyssSel[abyssSel].specialboss[i].char:lower()
								--Pick Random Char
									else
										bossChar = t_selChars[t_roster[#t_roster]+1].char:lower()
									end
									p2Cell = t_charDef[bossChar]
								--Set Custom Stage
									if t_abyssSel[abyssSel].specialboss[i].stage ~= nil then
										data.stage = t_abyssSel[abyssSel].specialboss[i].stage
									end
								--Set Custom BGM
									if t_abyssSel[abyssSel].specialboss[i].music ~= nil then
										data.bgm = t_abyssSel[abyssSel].specialboss[i].music
									end
								end
							end
						end
					else
						p2Cell = t_roster[matchNo*p2numChars-i+1]
					end
				end
			--Set AI Palette
				if data.gameMode == "abyss" then
					if matchNo == abyssBossMatch then
						p2Pal = 1 --Normal Boss Specific Palette
					else
						p2Pal = math.random(2,12) --Normal Enemy Random Palette
					end
				--Special Boss character predefined Palette
					if t_abyssSel[abyssSel].specialboss ~= nil then
						for i=1, #t_abyssSel[abyssSel].specialboss do
							if matchNo == t_abyssSel[abyssSel].specialboss[i].depth then
								p2Pal = t_abyssSel[abyssSel].specialboss[i].pal
							end
						end
					end
				else
					if data.aipal == "Default" then
						p2Pal = 1
					elseif data.aipal == "Random" then
						p2Pal = math.random(1,12)
					end
				end
				local updateAnim = true
				for j=1, #data.t_p2selected do
					if data.t_p2selected[j].cel == p2Cell then 
						updateAnim = false
					end
				end
				data.t_p2selected[#data.t_p2selected+1] = {['cel'] = p2Cell, ['name'] = t_selChars[p2Cell+1].name, ['displayname'] = t_selChars[p2Cell+1].displayname, ['path'] = t_selChars[p2Cell+1].char, ['pal'] = p2Pal, ['handicap'] = p2HandicapSel, ['up'] = updateAnim, ['rand'] = false}
				if shuffle then
					f_shuffleTable(data.t_p2selected)
				end
			end
		--Team conversion to Single match
			restoreTeam = false
			teamMode = p2teamMode
			numChars = p2numChars --was local function
			if p2numChars > 1 then
				for i=1, #data.t_p2selected do
					if (data.gameMode == "tower" and data.coop) or (data.coop and data.coopenemy == "Single") or (t_selChars[data.t_p2selected[i].cel+1].single ~= nil and t_selChars[data.t_p2selected[i].cel+1].single == 1) or (t_selChars[data.t_p2selected[i].cel+1].bonus ~= nil and t_selChars[data.t_p2selected[i].cel+1].bonus == 1) then
						p2teamMode = 0
						p2numChars = 1
						setTeamMode(2, 0, 1)
						p2Cell = t_charDef[t_selChars[data.t_p2selected[i].cel+1].char]
						data.t_p2selected = {}
						data.t_p2selected[1] = {['cel'] = p2Cell, ['name'] = t_selChars[p2Cell+1].name, ['displayname'] = t_selChars[p2Cell+1].displayname, ['path'] = t_selChars[p2Cell+1].char, ['pal'] = p2Pal, ['handicap'] = p2HandicapSel, ['up'] = true, ['rand'] = false}
						restoreTeam = true
						break
					end
				end
			end
			if data.gameMode ~= "tower" then
				t_roster[matchNo] = data.t_p2selected[1].cel --Refresh t_roster table
			end
		end
		if data.debugLog then f_printTable(t_roster, "save/debug/t_roster.log") end
		setMatchNo(matchNo)
		f_aiLevel()
		if not data.stageMenu then f_selectStage() end --Avoid display stage select, to load specific stage and music for roster characters
		if data.gameMode == "tower" and #t_selTower[destinySelect].kombats > 1 then f_battlePlan() end --Show Battle Plan Screen for tower mode with more than 1 floor.
		if data.gameMode == "abyss" then
			setMatchNo(getAbyssDepth())
			if not loadAbyssDat then setAbyssReward(getAbyssReward()+(getAbyssDepth()-1)*5) end
			if getAbyssDepth() == 1 or loadAbyssDat or (getAbyssDepth() >= abyssNextCheckPoint) and not data.challengerAbyss and not data.saveAbyss then f_abyssMap() end
		--Stop Exploring Option
			if exitAbyss then
				stats.money = stats.money + getAbyssReward() --Get abyss reward
				f_saveStats()
				f_storyboard(storyboardGameOver)
				f_winAdvanced()
				f_exitToMainMenu() --f_resetMenuInputs()
				return
			end
		end
		f_matchInfo()
	--Back to Main Menu and Save
		if data.saveAbyss then
			f_setAbyssStats() --Assign/Load Abyss Stats
			data.saveAbyss = false
			f_saveTemp()
			f_abyssData("save") --Open Abyss Data Select
			f_exitToMainMenu() --f_resetMenuInputs()
			return
		end
		if data.arcadeTravel then f_arcadeTravel() end
		f_orderSelect()
		f_selectVersus()
		if data.gameMode == "arcade" or data.gameMode == "tower" then
			f_setRoundTime() --Set Round Time for specific characters
			f_setRounds() --Set Rounds to Win for specific characters
		elseif data.gameMode == "abyss" or data.gameMode == "endless" then
			--Remove the last char loaded for the CPU side from t_roster and make a check so that when t_roster is empty, use f_makeRoster() again
			table.remove(t_roster, #t_roster)
			if data.debugLog then f_printTable(t_roster, "save/debug/t_roster.log") end
			if #t_roster == 0 or t_roster == nil then f_makeRoster() end
		end
		f_setZoom()
	--inputs
		if data.coop then
			remapInput(3,2) --P2 controls assigned to P3 character
			--remapInput(2,3) --P3 controls assigned to P2 character
		end
		sndStop()
		f_loading()
		matchTime = os.clock()
		f_assignMusic()
		winner = game() --Get into the fight
		if data.gameMode == "abyss" then data.bgm = nil end --To avoid play special boss music for the next normal depth match
		playBGM("")
		matchTime = os.clock() - matchTime
		clearTime = clearTime + matchTime
		selectTimer = selectSeconds*gameTick
		stageTimer = stageSeconds*gameTick
		rematchTimer = rematchSeconds*gameTick
		serviceTimer = serviceSeconds*gameTick
		destinyTimer = destinySeconds*gameTick
		f_modePlaytime() --Store Favorite Game Mode
		f_favoriteChar() --Store Favorite Character (WIP)
		f_records() --save record progress
		f_unlock(false)
		f_updateUnlocks()
		if (data.p1In == 2 and data.p2In == 2) then --Player 1 in player 2 (right) side
		--restore P1 Team settings if needed
			if restoreTeam then
				p1teamMode = teamMode
				p1numChars = numChars
				setTeamMode(1, p1teamMode, p1numChars)
			end
		else
		--restore P2 Team settings if needed
			if restoreTeam then
				p2teamMode = teamMode
				p2numChars = numChars
				setTeamMode(2, p2teamMode, p2numChars)
			end
		end
		f_resetP2CoopInput()
		cmdInput()
		refresh()
	end
else
	f_invalidCells()
	return --back to main menu
end

end

--;=================================================================================================
--; TOWER DESTINY SELECT
--;=================================================================================================
function f_selectDestiny()
	cmdInput()
	local cursorPosX = 1
	local moveTower = 0
	local bufu = 0
	local bufd = 0
	local bufr = 0
	local bufl = 0
	local selection = 0
	local startCount = false
	waitingTowerSel = true
	destinySelect = 1
	f_resetTowerArrowsPos()
	f_backReset()
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
--Play Choose your destiny SFX
	f_towerAnnouncer(t_selTower.data.sfxannouncer)
	if data.arcadeIntro then playBGM(bgmTower) end
	while true do
	--Actions
		if esc() and onlinegame then data.tempBack = true end --Exit during online mode
		if selection == 0 and not backScreen then
			if esc() or commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then
				sndPlay(sndSys, 100, 2)
				backScreen = true
			end
			if commandGetState(p1Cmd, 'l') or commandGetState(p2Cmd, 'l') or ((commandGetState(p1Cmd, 'holdl') or commandGetState(p2Cmd, 'holdl')) and bufl >= 30) then
				sndPlay(sndSys, 100, 0)
				destinySelect = destinySelect - 1
			elseif commandGetState(p1Cmd, 'r') or commandGetState(p2Cmd, 'r') or ((commandGetState(p1Cmd, 'holdr') or commandGetState(p2Cmd, 'holdr')) and bufr >= 30) then
				sndPlay(sndSys, 100, 0)
				destinySelect = destinySelect + 1
			elseif (btnPalNo(p1Cmd, true) > 0 or btnPalNo(p2Cmd, true) > 0) or destinyTimer == 0 then
				sndStop()
				sndPlay(sndSys, 100, 1)
				f_towerAnnouncer(t_selTower[destinySelect].sfxplay)
				startCount = true
			end
			--Cursor position calculation
			if destinySelect < 1 then
				destinySelect = #t_selTower
				if #t_selTower > 3 then
					cursorPosX = 3
				else
					cursorPosX = #t_selTower
				end
			elseif destinySelect > #t_selTower then
				destinySelect = 1
				cursorPosX = 1
			elseif ((commandGetState(p1Cmd, 'l') or commandGetState(p2Cmd, 'l')) or ((commandGetState(p1Cmd, 'holdl') or commandGetState(p2Cmd, 'holdl')) and bufl >= 30)) and cursorPosX > 1 then
				cursorPosX = cursorPosX - 1
			elseif ((commandGetState(p1Cmd, 'r') or commandGetState(p2Cmd, 'r')) or ((commandGetState(p1Cmd, 'holdr') or commandGetState(p2Cmd, 'holdr')) and bufr >= 30)) and cursorPosX < 3 then
				cursorPosX = cursorPosX + 1
			end
			if cursorPosX == 3 then
				moveTower = (destinySelect - 3) * 105 --Set how many space will move diffcult text
			elseif cursorPosX == 1 then
				moveTower = (destinySelect - 1) * 105
			end
			if #t_selTower <= 3 then
				maxDestiny = #t_selTower
			elseif destinySelect - cursorPosX > 0 then
				maxDestiny = destinySelect + 3 - cursorPosX
			else
				maxDestiny = 3
			end
		elseif selection > 100 then --End Destiny Select
			commandBufReset(p1Cmd)
			commandBufReset(p2Cmd)
			startCount = false
			break
		end
		if data.tempBack then break end --back to main menu
		if startCount then selection = selection + 1 end --Start End Destiny Select count
	--Draw BG
		animDraw(f_animVelocity(selectTowerBG0, -1, -1))
		--animDraw(destinyBG)
	--Set Towers Scroll Logic
		for i=1, maxDestiny do
			if i > destinySelect - cursorPosX then
			--Draw Towers Assets
				for length=#t_selTower[i].kombats, 1, -1 do
					animPosDraw(towerSlot, -87+i*105-moveTower, 220-32*length) --Draw Towers BG According to his size via kombats sub-table
				--Draw Stage Portraits
					if t_selChars[t_selTower[i].kombats[length]+1].stage ~= nil then
						towerStage = math.random(1,#t_selChars[t_selTower[i].kombats[length]+1].stage)
						towerStage = t_selChars[t_selTower[i].kombats[length]+1].stage[1]-1 -- -1 to get the correct stage
						drawStagePortrait(towerStage, -85+i*105-moveTower, 223-32*length, 0.056, 0.035)
					else
						animPosDraw(towerStgPreview, -85+i*105-moveTower, 223-32*length)
					end
				--Draw Chars Preview Portraits
					drawPortrait(t_selTower[i].kombats[length], -85+i*105-moveTower, 223-32*length, 0.18, 0.18)
				end
				if i == destinySelect then
				--Draw Cursor Icon
					animPosDraw(destinyCursor, -70+i*105-moveTower, 180)
				--Draw Difficulty Text for Tower Table
					if t_selTower[i].ID ~= nil then
						textImgDraw(f_updateTextImg(t_selTower[i].ID, fontMK, 0, 0, t_selTower[i].displayname:upper(), -50+i*105-moveTower, 205, 0.85,0.85))
					end
				end
			end
		end
	--Draw Title
		animDraw(f_animVelocity(selectBG2a, -1, 0))
		animDraw(f_animVelocity(selectBG2b, -3, 0))
		animDraw(f_animVelocity(selectBG2c, -6, 0))
		textImgDraw(txt_towerSelect)
	--Draw Left Animated Cursor
		if maxDestiny > 3 then
			animDraw(menuArrowLeft)
			animUpdate(menuArrowLeft)
		end
	--Draw Right Animated Cursor
		if #t_selTower > 3 and maxDestiny < #t_selTower then
			animDraw(menuArrowRight)
			animUpdate(menuArrowRight)
		end
	--Destiny Select Timer
		destinyTimeNumber = destinyTimer/gameTick
		nodecimalDestinyTime = string.format("%.0f",destinyTimeNumber)
		textImgSetText(txt_destinyTime, nodecimalDestinyTime)
		if destinyTimer > 0 then
			if not backScreen and not startCount then destinyTimer = destinyTimer - 0.5 end--Activate Tower Select Timer
			textImgDraw(txt_destinyTime)
		else --when destinyTimer <= 0
			
		end
		if data.debugMode then f_drawQuickText(txt_selectionTime, font3, 0, 0, selection, 163.5, 168) end --For Debug Purposes
		if backScreen then f_backMenu() else drawTowerInputHints() end --Open Back Menu Question
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		if commandGetState(p1Cmd, 'holdr') or commandGetState(p2Cmd, 'holdr') then
			bufl = 0
			bufr = bufr + 1
		elseif commandGetState(p1Cmd, 'holdl') or commandGetState(p2Cmd, 'holdl') then
			bufr = 0
			bufl = bufl + 1
		else
			bufr = 0
			bufl = 0
		end
		cmdInput()
		refresh()
	end
end

function f_towerAnnouncer(data)
	local data = data or nil
	if data ~= nil then
		local sfxGroup, sfxIndex = data:match('^([^,]-)%s*,%s*(.-)$')
		sndPlay(sndTower, sfxGroup, sfxIndex)
	end
end

function f_setTowerStage() --Unfinished
	if not data.stageMenu then
		if t_selChars[t_selTower[i].kombats[length]+1].stage ~= nil then
			data.stage = math.random(1,#t_selChars[t_selTower[i].kombats[length]+1].stage) --if there are more than 1 stage assigned for that character, pick 1 of them via randomizer
			data.stage = t_selChars[t_selTower[i].kombats[length]+1].stage[data.stage]
		end
	end
end

--;=================================================================================================
--; TOWER BATTLE PLAN SCREEN
--;=================================================================================================
function f_battlePlan()
	cmdInput()
	sndStop()
	local loopSfx = 0
	local scroll = 0
	local scrollDown = 0
	local scrollUp = 0
	local HumanslotPosX = 87
	local CPUslotPosX = 170
	local sideSwitch = false
	if (data.p1In == 2 and data.p2In == 2) then --Player 1 in player 2 (right) side
		sideSwitch = true
	else --player 1 in left side
		sideSwitch = false
	end
	if sideSwitch then
		HumanslotPosX = 233
		CPUslotPosX = 4
	end
	startKombat = false
	towerPlanTimer = 0
	towerPlanTimeLimit = 100
	battlePreviewTimer = 0
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	local CPUslotPosY = 170
	local CPUslotSpacingY = 85
	local CPUslotPosYInit = CPUslotPosY --Get initial first battle pos
	if matchNo == 1 then
		CPUslotPosY = CPUslotPosY+(CPUslotSpacingY*#t_selTower[destinySelect].kombats)-CPUslotSpacingY --Portraits Y pos starts in the top of the tower
	else
		CPUslotPosY = CPUslotPosY+(CPUslotSpacingY*matchNo)-CPUslotSpacingY*2 --Portraits Y pos starts in the lastest battle
		playBGM(bgmTower)
	end
	while true do
		if esc() and onlinegame then --Exit during online mode
			data.tempBack = true
			break
		end
		if startKombat then break end --Go to next Screen
		if matchNo == 1 then --Battle Plan Presentation
			if towerPlanTimer < towerPlanTimeLimit then --Intro Time
				towerPlanTimer = towerPlanTimer + 1
			else --when introTime is over. Start Down Scroll
				if CPUslotPosY > CPUslotPosYInit then
					if loopSfx > 45 then --reset sfx loop (time is in ticks)
						loopSfx = 0
					end
					if loopSfx == 0 then sndPlay(sndIkemen, 220, 1) end --Play Scroll Down Sfx
					loopSfx = loopSfx + 1
				--Scroll Logic
					CPUslotPosY = CPUslotPosY - 2
					if (btnPalNo(p1Cmd, true) > 0 or btnPalNo(p2Cmd, true) > 0) then --Skip Battle Plan Preview
						sndStop()
						CPUslotPosY = CPUslotPosYInit+1 -- +1 because position correct below logic
					end
				else --when down scroll finish
					if battlePreviewTimer == 0 then CPUslotPosY = CPUslotPosY+1 end --Position Correct
					f_battlePreview()
				end
			end
		else --Battle Plan Prosecution
			scroll = scrollUp
			if towerPlanTimer < towerPlanTimeLimit then --Intro Time
				towerPlanTimer = towerPlanTimer + 1
			else
				if scrollUp < CPUslotSpacingY then --when introTime is over. Start Up Scroll
					if scroll == 0 then sndPlay(sndIkemen, 220, 2) end --Play Scroll Up Sfx
					scrollUp = scrollUp + 0.8
					if (btnPalNo(p1Cmd, true) > 0 or btnPalNo(p2Cmd, true) > 0) then --Skip Battle Plan Preview
						sndStop()
						scrollUp = CPUslotSpacingY-1 -- -1 because position correct below logic
					end
				else
					if battlePreviewTimer == 0 then scrollUp = scrollUp-1 end --Position Correct
					f_battlePreview()
				end
			end
		end
	--Draw BG
		animDraw(f_animVelocity(selectTowerBG0, 0, 1.5))
		--animDraw(destinyFinalBG)
	--Draw Towers Assets
		for length=#t_selTower[destinySelect].kombats, 1, -1 do
		--Draw Tower Slots According to his size
			animPosDraw(battleSlot, CPUslotPosX, CPUslotPosY-CPUslotSpacingY*length+scroll)
		--Draw Stage Portraits
			if t_selChars[t_selTower[destinySelect].kombats[length]+1].stage ~= nil then
				battleStage = math.random(1,#t_selChars[t_selTower[destinySelect].kombats[length]+1].stage)
				battleStage = t_selChars[t_selTower[destinySelect].kombats[length]+1].stage[1]-1 -- -1 to get the correct stage
				drawStagePortrait(battleStage, CPUslotPosX+3.8, CPUslotPosY+7-CPUslotSpacingY*length+scroll, 0.1077, 0.093)
			else
				animPosDraw(battleStgPreview, CPUslotPosX+3.8, CPUslotPosY+6.97-CPUslotSpacingY*length+scroll)
			end
		--Draw CPU Portraits
			local PortraitXpos = 61.5
			local PortraitXscale = -0.48
			if sideSwitch then
				PortraitXpos = 84
				PortraitXscale = 0.48
			end
			if data.portraitDisplay == "Portrait" or data.portraitDisplay == "Mixed" then
				drawPortrait(t_selTower[destinySelect].kombats[length], CPUslotPosX+PortraitXpos, CPUslotPosY+7-CPUslotSpacingY*length+scroll, PortraitXscale, 0.48)
			end
		--Draw CPU Animations
			if data.portraitDisplay == "Sprite" or data.portraitDisplay == "Mixed" then
				local animPos = 30
				local cpuAnimType = 'p2AnimStand'
				if sideSwitch then
					cpuAnimType = 'p1AnimStand'
					if data.portraitDisplay == "Sprite" then animPos = 115 end
				end
				if data.portraitDisplay == "Mixed" then
					if not sideSwitch then animPos = 90 end
				end
				f_drawCharAnim(t_selChars[t_selTower[destinySelect].kombats[length]+1], cpuAnimType, CPUslotPosX+animPos, CPUslotPosY+73-CPUslotSpacingY*length+scroll, true, 0.60, 0.60)
			end
		--Draw CPU Names
			if sideSwitch then
				f_drawQuickText(cpuNamebtp, font14, 0, -1, t_selChars[t_selTower[destinySelect].kombats[length]+1].displayname, CPUslotPosX+141, CPUslotPosY+73-CPUslotSpacingY*length+scroll, 0.75, 0.75)
			else
				f_drawQuickText(cpuNamebtp, font14, 0, 1, t_selChars[t_selTower[destinySelect].kombats[length]+1].displayname, CPUslotPosX+4, CPUslotPosY+73-CPUslotSpacingY*length+scroll, 0.75, 0.75)
			end
		end
	--Draw Player Portrait
		local battleSlotPosX = 3
		if sideSwitch then battleSlotPosX = 170 end
		animPosDraw(battleSlot, battleSlotPosX, CPUslotPosYInit-CPUslotSpacingY) --Slot BG
		if data.portraitDisplay == "Portrait" or data.portraitDisplay == "Mixed" then
			local charPScaleX = 0.48
			local charPaddPosX = 22
			local charPSpacingPosX = 22
			if sideSwitch then --Right Side
				charPaddPosX = -23.5
				if p2numChars == 4 then
					charPScaleX = 0.30
					charPaddPosX = -40
					charPSpacingPosX = 17
				end
				for j=#data.t_p2selected, 1, -1 do
					drawPortrait(data.t_p2selected[j].cel, HumanslotPosX+charPaddPosX+(2*j-1)*charPSpacingPosX, CPUslotPosYInit-CPUslotSpacingY+7, -charPScaleX, 0.48)
				end
			else --Left Side
				if p1numChars == 4 then --Modify Some Portrait Params
					charPScaleX = 0.30
					charPaddPosX = 38
					charPSpacingPosX = 17
				end
				for j=#data.t_p1selected, 1, -1 do
					drawPortrait(data.t_p1selected[j].cel, HumanslotPosX+charPaddPosX-(2*j-1)*charPSpacingPosX, CPUslotPosYInit-CPUslotSpacingY+7, charPScaleX, 0.48)
				end
			end
		end
	--Draw Player Animations
		if data.portraitDisplay == "Sprite" or data.portraitDisplay == "Mixed" then
			local charAnimScaleX = 0.60
			local charAnimScaleY = 0.60
			local charAnimPosX = 139
			if sideSwitch then --Right Side
				if data.portraitDisplay == "Mixed" and p2numChars == 1 then
					charAnimPosX = 235
				else
					charAnimPosX = 182
				end
				for j=#data.t_p2selected, 1, -1 do
					f_drawCharAnim(t_selChars[data.t_p2selected[j].cel+1], 'p2AnimStand', charAnimPosX+(2*j-1)*18, 158, data.t_p2selected[j].up, charAnimScaleX, charAnimScaleY)
				end
			else --Left Side
				if data.portraitDisplay == "Mixed" and p1numChars == 1 then
					charAnimPosX = 85
				end
				for j=#data.t_p1selected, 1, -1 do
					f_drawCharAnim(t_selChars[data.t_p1selected[j].cel+1], 'p1AnimStand', charAnimPosX-(2*j-1)*18, 158, data.t_p1selected[j].up, charAnimScaleX, charAnimScaleY)
				end
			end
		end
	--Draw Player Name
		local pNameScaleX = 0.75
		local pNameScaleY = 0.75
		if sideSwitch then
			f_drawQuickText(playerNamebtp, font14, 0, 1, data.t_p2selected[1].displayname, HumanslotPosX-57, CPUslotPosYInit-CPUslotSpacingY+73, pNameScaleX, pNameScaleY)
			if p2numChars > 1 then f_drawQuickText(teamNamebtp, font14, 0, 1, "TEAM", HumanslotPosX-57, CPUslotPosYInit-CPUslotSpacingY+63, pNameScaleX, pNameScaleY) end
		else
			f_drawQuickText(playerNamebtp, font14, 0, -1, data.t_p1selected[1].displayname, HumanslotPosX+57, CPUslotPosYInit-CPUslotSpacingY+73, pNameScaleX, pNameScaleY)
			if p1numChars > 1 then f_drawQuickText(teamNamebtp, font14, 0, -1, "TEAM", HumanslotPosX+57, CPUslotPosYInit-CPUslotSpacingY+63, pNameScaleX, pNameScaleY) end
		end
		animDraw(vsPreview)
	--Draw Screen Info
		f_drawQuickText(txt_towerPlan, jgFnt, 0, 0, "BATTLE PLAN", 159, CPUslotPosY-65-CPUslotSpacingY*#t_selTower[destinySelect].kombats+scroll)
		if sideSwitch then
			f_drawQuickText(txt_towerDifficult, jgFnt, 0, -1, "DIFFICULTY: "..t_selTower[destinySelect].displayname:upper(), 315, 82, 0.7, 0.7)
		else
			f_drawQuickText(txt_towerDifficult, jgFnt, 0, 1, "DIFFICULTY: "..t_selTower[destinySelect].displayname:upper(), 5, 82, 0.7, 0.7)
		end
		f_drawQuickText(txt_towerMode, jgFnt, 0, 0, "TOWER MODE", 159, CPUslotPosY+150-CPUslotSpacingY*1+scroll)
		if data.debugMode then
			f_drawQuickText(towerTest, font14, 0, 1, CPUslotPosY, 50, 50) --Test Y Pos
		end
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		cmdInput()
		refresh()
	end
end

function f_battlePreview()
	if battlePreviewTimer == 0 then sndPlay(sndIkemen, 220, 3) end --Play Stop Sfx
	battlePreviewTimer = battlePreviewTimer + 1 --Time to show VS preview
	if battlePreviewTimer == 250 or (btnPalNo(p1Cmd, true) > 0 or btnPalNo(p2Cmd, true) > 0) then
		commandBufReset(p1Cmd)
		commandBufReset(p2Cmd)
		sndStop()
		startKombat = true
	end
end

--;===========================================================
--; TOURNAMENT SETTINGS MENU
--;===========================================================
function f_tourneyCfg()
	f_discordUpdate({details = "Tournament"})
	cmdInput()
	local cursorPosY = 1
	local moveTxt = 0
	local tourneyCfg = 1
	local bufu = 0
	local bufd = 0
	local bufr = 0
	local bufl = 0
	local maxItems = 7
	local teamName = nil
	exitTourney = false
	f_resetListArrowsPos()
	animSetPos(menuArrowDown, 228, 126)
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	playBGM(bgmTourney)
	while true do
		if esc() or commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') or exitTourney then
			f_discordMainMenu()
			sndPlay(sndSys, 100, 2)
			data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
			f_menuMusic()
			f_resetMenuArrowsPos()
			break
		elseif commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u') or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30) then
			sndPlay(sndSys, 100, 0)
			tourneyCfg = tourneyCfg - 1
			if bufl then bufl = 0 end
			if bufr then bufr = 0 end
		elseif commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd') or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30) then
			sndPlay(sndSys, 100, 0)
			tourneyCfg = tourneyCfg + 1
			if bufl then bufl = 0 end
			if bufr then bufr = 0 end
	--Participants/Entries
		elseif tourneyCfg == 1 then
			if commandGetState(p1Cmd, 'r') or (commandGetState(p1Cmd, 'holdr') and bufr >= 30) then
				if commandGetState(p1Cmd, 'r') and data.tourneySize < 16 then sndPlay(sndSys, 100, 0) end
				if data.tourneySize < 16 then
					data.tourneySize = data.tourneySize + data.tourneySize
				end
				modified = 1
			elseif commandGetState(p1Cmd, 'l') or (commandGetState(p1Cmd, 'holdl') and bufl >= 30) then
				if commandGetState(p1Cmd, 'l') and data.tourneySize > 4 then sndPlay(sndSys, 100, 0) end
				if data.tourneySize > 4 then
					data.tourneySize = data.tourneySize - (data.tourneySize/2)
				end
				modified = 1
			end
			if commandGetState(p1Cmd, 'holdr') then
				bufl = 0
				bufr = bufr + 1
			elseif commandGetState(p1Cmd, 'holdl') then
				bufr = 0
				bufl = bufl + 1
			else
				bufr = 0
				bufl = 0
			end
		--[[Format
		elseif tourneyCfg == 2 and (commandGetState(p1Cmd, 'r') or commandGetState(p1Cmd, 'l') or btnPalNo(p1Cmd, true) > 0) then
			sndPlay(sndSys, 100, 0)
			if data.tourneyType == "Single Elimination" then
				data.tourneyType = "Double Elimination"
				modified = 1
			elseif data.tourneyType == "Double Elimination" then
				data.tourneyType = "Single Elimination"
				modified = 1
			end
		]]
		--[[Team Mode
		elseif tourneyCfg == 3 then
			if commandGetState(p1Cmd, 'r') or (commandGetState(p1Cmd, 'holdr') and bufr >= 30) then
				if commandGetState(p1Cmd, 'r') and data.tourneyTeam < 2 then sndPlay(sndSys, 100, 0) end
				if data.tourneyTeam < 2 then
					data.tourneyTeam = data.tourneyTeam + 1
				end
				modified = 1
			elseif commandGetState(p1Cmd, 'l') or (commandGetState(p1Cmd, 'holdl') and bufl >= 30) then
				if commandGetState(p1Cmd, 'l') and data.tourneyTeam > 0 then sndPlay(sndSys, 100, 0) end
				if data.tourneyTeam > 0 then
					data.tourneyTeam = data.tourneyTeam - 1
				end
				modified = 1
			end
			if commandGetState(p1Cmd, 'holdr') then
				bufl = 0
				bufr = bufr + 1
			elseif commandGetState(p1Cmd, 'holdl') then
				bufr = 0
				bufl = bufl + 1
			else
				bufr = 0
				bufl = 0
			end
		]]
	--Allow Character Select
		elseif tourneyCfg == 2 and (commandGetState(p1Cmd, 'r') or commandGetState(p1Cmd, 'l') or btnPalNo(p1Cmd, true) > 0) then
			sndPlay(sndSys, 100, 0)
			if data.tourneyCharSel then
				data.tourneyCharSel = false
				modified = 1
			else
				data.tourneyCharSel = true
				modified = 1
			end
	--Allow Stage Select
		elseif tourneyCfg == 3 and (commandGetState(p1Cmd, 'r') or commandGetState(p1Cmd, 'l') or btnPalNo(p1Cmd, true) > 0) then
			sndPlay(sndSys, 100, 0)
			if data.tourneyStgSel then
				data.tourneyStgSel = false
				modified = 1
			else
				data.tourneyStgSel = true
				modified = 1
			end
	--Round Time
		elseif tourneyCfg == 4 then
			if commandGetState(p1Cmd, 'r') or (commandGetState(p1Cmd, 'holdr') and bufr >= 30) then
				if data.tourneyRoundTime < 1000 then
					data.tourneyRoundTime = data.tourneyRoundTime + 1
				else
					data.tourneyRoundTime = -1
				end
				if commandGetState(p1Cmd, 'r') then sndPlay(sndSys, 100, 0) end
				modified = 1
			elseif commandGetState(p1Cmd, 'l') or (commandGetState(p1Cmd, 'holdl') and bufl >= 30) then
				if data.tourneyRoundTime > -1 then
					data.tourneyRoundTime = data.tourneyRoundTime - 1
				else
					data.tourneyRoundTime = 1000
				end
				if commandGetState(p1Cmd, 'l') then sndPlay(sndSys, 100, 0) end
				modified = 1
			end
			if commandGetState(p1Cmd, 'holdr') then
				bufl = 0
				bufr = bufr + 1
			elseif commandGetState(p1Cmd, 'holdl') then
				bufr = 0
				bufl = bufl + 1
			else
				bufr = 0
				bufl = 0
			end
	--Rounds to Win
		elseif tourneyCfg == 5 then
			if commandGetState(p1Cmd, 'r') or (commandGetState(p1Cmd, 'holdr') and bufr >= 30) then
				if commandGetState(p1Cmd, 'r') and data.tourneyRoundsNum < 5 then sndPlay(sndSys, 100, 0) end
				if data.tourneyRoundsNum < 5 then
					data.tourneyRoundsNum = data.tourneyRoundsNum + 1
				end
				modified = 1
			elseif commandGetState(p1Cmd, 'l') or (commandGetState(p1Cmd, 'holdl') and bufl >= 30) then
				if commandGetState(p1Cmd, 'l') and data.tourneyRoundsNum > 1 then sndPlay(sndSys, 100, 0) end
				if data.tourneyRoundsNum > 1 then
					data.tourneyRoundsNum = data.tourneyRoundsNum - 1
				end
				modified = 1
			end
			if commandGetState(p1Cmd, 'holdr') then
				bufl = 0
				bufr = bufr + 1
			elseif commandGetState(p1Cmd, 'holdl') then
				bufr = 0
				bufl = bufl + 1
			else
				bufr = 0
				bufl = 0
			end
	--Matchs to Win (First To)
		elseif tourneyCfg == 6 then
			if commandGetState(p1Cmd, 'r') or (commandGetState(p1Cmd, 'holdr') and bufr >= 30) then
				if commandGetState(p1Cmd, 'r') and data.tourneyMatchsNum < 5 then sndPlay(sndSys, 100, 0) end
				if data.tourneyMatchsNum < 5 then
					data.tourneyMatchsNum = data.tourneyMatchsNum + 1
				end
				modified = 1
			elseif commandGetState(p1Cmd, 'l') or (commandGetState(p1Cmd, 'holdl') and bufl >= 30) then
				if commandGetState(p1Cmd, 'l') and data.tourneyMatchsNum > 1 then sndPlay(sndSys, 100, 0) end
				if data.tourneyMatchsNum > 1 then
					data.tourneyMatchsNum = data.tourneyMatchsNum - 1
				end
				modified = 1
			end
			if commandGetState(p1Cmd, 'holdr') then
				bufl = 0
				bufr = bufr + 1
			elseif commandGetState(p1Cmd, 'holdl') then
				bufr = 0
				bufl = bufl + 1
			else
				bufr = 0
				bufl = 0
			end
	--CREATE TOURNAMENT
		elseif tourneyCfg == #t_tourneyCfg and (btnPalNo(p1Cmd, true) > 0 or btnPalNo(p2Cmd, true) > 0) then
			sndPlay(sndSys, 100, 1)
			f_saveTourney()
			f_addTourneySlots()
			f_tourneyMenu()
		end
		if tourneyCfg < 1 then
			tourneyCfg = #t_tourneyCfg
			if #t_tourneyCfg > maxItems then
				cursorPosY = maxItems
			else
				cursorPosY = #t_tourneyCfg
			end
		elseif tourneyCfg > #t_tourneyCfg then
			tourneyCfg = 1
			cursorPosY = 1
		elseif ((commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u')) or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30)) and cursorPosY > 1 then
			cursorPosY = cursorPosY - 1
		elseif ((commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd')) or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30)) and cursorPosY < maxItems then
			cursorPosY = cursorPosY + 1
		end
		if cursorPosY == maxItems then
			moveTxt = (tourneyCfg - maxItems) * 15
		elseif cursorPosY == 1 then
			moveTxt = (tourneyCfg - 1) * 15
		end	
		if #t_tourneyCfg <= maxItems then
			maxtourneyCfg = #t_tourneyCfg
		elseif tourneyCfg - cursorPosY > 0 then
			maxtourneyCfg = tourneyCfg + maxItems - cursorPosY
		else
			maxtourneyCfg = maxItems
		end
	--Draw BG
		animDraw(f_animVelocity(commonBG0, -1, -1))
	--Draw Tourney BG Grids
		if data.tourneySize == 4 then
			animSetScale(tourney4, 0.359, 0.341)
			animPosDraw(tourney4, 100, 130)
		elseif data.tourneySize == 8 then
			animSetScale(tourney8, 0.359, 0.341)
			animPosDraw(tourney8, 100, 130)
		elseif data.tourneySize == 16 then
			animSetScale(tourney16, 0.359, 0.341)
			animPosDraw(tourney16, 100, 130)
		end
	--Draw Settings BG
		animSetScale(commonTBG, 240, maxtourneyCfg*15)
		animSetWindow(commonTBG, 80,20, 160,105)
		animDraw(commonTBG)
	--Draw Title
		textImgDraw(txt_tourneyCfg)
	--Draw Cursor
		animSetWindow(cursorBox, 80,5+cursorPosY*15, 160,15)
		f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
		animDraw(f_animVelocity(cursorBox, -1, -1))
	--Set Settings Text
		t_tourneyCfg[1].varText = data.tourneySize
	--[[t_tourneyCfg[2].varText = data.tourneyType
		if data.tourneyTeam == 0 then teamName = "Single"
		elseif data.tourneyTeam == 1 then teamName = "Simul"
		elseif data.tourneyTeam == 2 then teamName = "Turns"
		else teamName = "Unknown"
		end
		t_tourneyCfg[3].varText = teamName
	]]
		if data.tourneyCharSel then t_tourneyCfg[2].varText = "Every Match" else t_tourneyCfg[2].varText = "Fixed" end
		if data.tourneyStgSel then t_tourneyCfg[3].varText = "Every FT" else t_tourneyCfg[3].varText = "First FT" end
		t_tourneyCfg[4].varText = data.tourneyRoundTime
		t_tourneyCfg[5].varText = data.tourneyRoundsNum
		t_tourneyCfg[6].varText = "FT"..data.tourneyMatchsNum
		--t_tourneyCfg[10].varText = data.tourney3rdPlace
	--Draw Settings Text
		for i=1, maxtourneyCfg do
			if i > tourneyCfg - cursorPosY then
				local align = 1
				local posX = 85
			--Custom Pos for Last items
				if i == #t_tourneyCfg then
					align = 0
					posX = 160
				end
				if t_tourneyCfg[i].varID ~= nil then
					textImgDraw(f_updateTextImg(t_tourneyCfg[i].varID, font2, 0, align, t_tourneyCfg[i].text, posX, 15+i*15-moveTxt))
					textImgDraw(f_updateTextImg(t_tourneyCfg[i].varID, font2, 0, -1, t_tourneyCfg[i].varText, 235, 15+i*15-moveTxt))
				end
			end
		end
		if maxtourneyCfg > maxItems then
			animDraw(menuArrowUp)
			animUpdate(menuArrowUp)
		end
		if #t_tourneyCfg > maxItems and maxtourneyCfg < #t_tourneyCfg then
			animDraw(menuArrowDown)
			animUpdate(menuArrowDown)
		end
		drawTourneyInputHints()
		if commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu') then
			bufd = 0
			bufu = bufu + 1
		elseif commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd') then
			bufu = 0
			bufd = bufd + 1
		else
			bufu = 0
			bufd = 0
		end
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		cmdInput()
		refresh()
	end
end

--;===========================================================
--; TOURNAMENT MODE MENU (participate in customizable tournaments)
--;===========================================================
function f_tourneyMenu()
	cmdInput()
	local cursorPosY = 0
	local moveSlotY = 0
	local moveSlotX = 0
	local bufu = 0
	local bufd = 0
	local bufr = 0
	local bufl = 0
	local maxItems = 12
--Iteration Position Logic
	local slotWidth = 29 --Sprite Width
	local slotHeight = 29 --Sprite Height
	local iconWidth = 25
	local iconHeight = 25
	local ctrlWidth = 20
	local ctrlHeight = 7
	--
	local updateStartPosX = 49 --When tourneySize is more small how much the values ââchange from the originals
	local updateSpacingX = 97.5
	local updateStartPosY = 16
	local updateSpacingY = 29.95
	local changeX = 2 --When tourneySize is more small how much will the values ââof the axis change?
	local changeY = 2.92
--Positions for 16 Participants
	--Originals values
		slotStartPosX = 0.3
		slotSpacingX = 261
		slotStartPosY = 0
		slotSpacingY = 1.2
		--
		iconStartPosX = 2.3
		iconSpacingX = 265.2
		iconStartPosY = 1.3
		iconSpacingY = 5.3
		--
		ctrlStartPosX = 2
		ctrlSpacingX = 270
		ctrlStartPosY = 20
		ctrlSpacingY = 23.2
--Positions for 8 Participants
	if data.tourneySize == 8 then
		slotStartPosX = slotStartPosX + updateStartPosX
		slotSpacingX = slotSpacingX - updateSpacingX
		slotStartPosY = slotStartPosY + updateStartPosY
		slotSpacingY = slotSpacingY + updateSpacingY
		--
		iconStartPosX = iconStartPosX + updateStartPosX
		iconSpacingX = iconSpacingX - updateSpacingX
		iconStartPosY = iconStartPosY + updateStartPosY
		iconSpacingY = iconSpacingY + updateSpacingY
		--
		ctrlStartPosX = ctrlStartPosX + updateStartPosX
		ctrlSpacingX = ctrlSpacingX - updateSpacingX
		ctrlStartPosY = ctrlStartPosY + updateStartPosY
		ctrlSpacingY = ctrlSpacingY + updateSpacingY
--Positions for 4 Participants
	elseif data.tourneySize == 4 then
		slotStartPosX = slotStartPosX + (updateStartPosX*changeX)
		slotSpacingX = slotSpacingX - (updateSpacingX*changeX)
		slotStartPosY = slotStartPosY + (updateStartPosY*changeY)
		slotSpacingY = slotSpacingY + (updateSpacingY*changeY)
		--
		iconStartPosX = iconStartPosX + (updateStartPosX*changeX)
		iconSpacingX = iconSpacingX - (updateSpacingX*changeX)
		iconStartPosY = iconStartPosY + (updateStartPosY*changeY)
		iconSpacingY = iconSpacingY + (updateSpacingY*changeY)
		--
		ctrlStartPosX = ctrlStartPosX + (updateStartPosX*changeX)
		ctrlSpacingX = ctrlSpacingX - (updateSpacingX*changeX)
		ctrlStartPosY = ctrlStartPosY + (updateStartPosY*changeY)
		ctrlSpacingY = ctrlSpacingY + (updateSpacingY*changeY)
	end
	--
	local hideMenu = false
	if data.tourneyType == "Single Elimination" then textImgSetText(txt_tourneyType, txt_tourneyType1)
	elseif data.tourneyType == "Double Elimination" then textImgSetText(txt_tourneyType, txt_tourneyType2)
	end
	f_confirmReset()
	tourneyBack = false
	tourneyRow = 1
	tourneyGroup = 1 --1=A, 2=B
	tourneyFightNo = 1 --Tournament Matchs Counter
	tourneyRoundNo = 1 --Tournament Matchs Round State (Initial, Quarterfinals, Semifinals, Final)
	tourneyNextRound = false --Prepare table data for next round
	tourneyCharSel = false --Allow Player 2 Char Select when is active for Every Match
	startTourney = false --Controls when tourney has been started
	endTourney = false --Controls when tourney enter in the last match
	confirmRandomSel = false --Controls when random select occurs
	while true do
		if exitTourney then break end --Back to Main Menu
	--Prepare Final Match
		if (tourneyRoundNo == 4 and data.tourneySize == 16) or (tourneyRoundNo == 3 and data.tourneySize == 8) or (tourneyRoundNo == 2 and data.tourneySize == 4) then endTourney = true end
		if not startTourney then
		--BACK TO TOURNEY SETTINGS
			if esc() or commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then
				sndPlay(sndSys, 100, 2)
				break
		--START TOURNAMENT
			elseif btnPalNo(p1Cmd) > 0 or btnPalNo(p2Cmd) > 0 then
				sndPlay(sndSys, 100, 1)
				f_tourneySelRandomPlayer()
				if not confirmRandomSel then
					startTourney = true
					hideMenu = false
					tourneyGroupNo = 1 --Start tourney from Left Group
					tourneyParticipantNo = 0 --Player Slot ID
					tourneyNextRound = true
					if data.debugLog then f_printTable(t_tourneyMenu, "save/debug/t_tourneyMenu.log") end
					f_tourneySelCfg()
				end
				confirmRandomSel = false
		--SLOT SELECT
			elseif commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u') or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30) then
				sndPlay(sndSys, 100, 0)
				tourneyRow = tourneyRow - 1
			elseif commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd') or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30) then
				sndPlay(sndSys, 100, 0)
				tourneyRow = tourneyRow + 1
		--GROUP SIDE SELECT
			elseif commandGetState(p1Cmd, 'l') or commandGetState(p2Cmd, 'l') or ((commandGetState(p1Cmd, 'holdl') or commandGetState(p2Cmd, 'holdl')) and bufl >= 30) then
				sndPlay(sndSys, 100, 0)
				if tourneyGroup == 1 then
					tourneyGroup = 2
				elseif tourneyGroup == 2 then
					tourneyGroup = 1
				end
				--tourneyGroup = tourneyGroup - 1
			elseif commandGetState(p1Cmd, 'r') or commandGetState(p2Cmd, 'r') or ((commandGetState(p1Cmd, 'holdr') or commandGetState(p2Cmd, 'holdr')) and bufr >= 30) then
				sndPlay(sndSys, 100, 0)
				if tourneyGroup == 1 then
					tourneyGroup = 2
				elseif tourneyGroup == 2 then
					tourneyGroup = 1
				end
				--tourneyGroup = tourneyGroup + 1
		--HIDE INPUT HINTS MENU
			elseif commandGetState(p1Cmd, 'q') or commandGetState(p2Cmd, 'q') then
				if not hideMenu then hideMenu = true else hideMenu = false end
		--SET CHARACTER CONTROL
			elseif commandGetState(p1Cmd, 'w') or commandGetState(p2Cmd, 'w') then
				local slotControl = t_tourneyMenu.Group[tourneyGroup].Round[1][tourneyRow].CharControl
				local slotLevel = t_tourneyMenu.Group[tourneyGroup].Round[1][tourneyRow].AIlevel
				local slotHuman = t_tourneyMenu.Group[tourneyGroup].Round[1][tourneyRow].Player
				if slotControl == "CPU" then
					if slotLevel < 8 then t_tourneyMenu.Group[tourneyGroup].Round[1][tourneyRow].AIlevel = slotLevel+1
					elseif slotLevel == 8 then
						t_tourneyMenu.Group[tourneyGroup].Round[1][tourneyRow].Player = 1
						t_tourneyMenu.Group[tourneyGroup].Round[1][tourneyRow].AIlevel = 0
						t_tourneyMenu.Group[tourneyGroup].Round[1][tourneyRow].CharControl = "HUMAN"
					end
				elseif slotControl == "HUMAN" then
					if slotHuman == 1 then t_tourneyMenu.Group[tourneyGroup].Round[1][tourneyRow].Player = 2
					elseif slotHuman == 2 then
						t_tourneyMenu.Group[tourneyGroup].Round[1][tourneyRow].Player = 0
						t_tourneyMenu.Group[tourneyGroup].Round[1][tourneyRow].AIlevel = 1
						t_tourneyMenu.Group[tourneyGroup].Round[1][tourneyRow].CharControl = "CPU"
					end
				end
		--EDIT CHARACTER SLOT
			elseif commandGetState(p1Cmd, 's') or commandGetState(p2Cmd, 's') then
				sndPlay(sndSys, 100, 1)
				startTourney = false
				f_tourneySelCfg()
				if data.debugLog then f_printTable(t_tourneyMenu, "save/debug/t_tourneyMenu.log") end
			end
		--Cursor position calculation
			if tourneyRow < 1 then
				tourneyRow = #t_tourneyMenu.Group[tourneyGroup].Round[1]
				if #t_tourneyMenu.Group[tourneyGroup].Round[1] > maxItems then
					cursorPosY = maxItems
				else
					cursorPosY = #t_tourneyMenu.Group[tourneyGroup].Round[1]
				end
			elseif tourneyRow > #t_tourneyMenu.Group[tourneyGroup].Round[1] then
				tourneyRow = 1
				cursorPosY = 1
			elseif ((commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u')) or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30)) and cursorPosY > 1 then
				cursorPosY = cursorPosY - 1
			elseif ((commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd')) or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30)) and cursorPosY < maxItems then
				cursorPosY = cursorPosY + 1
			end
			if cursorPosY == maxItems then
				moveSlotY = (tourneyRow - maxItems) * 20
			elseif cursorPosY == 1 then
				moveSlotY = (tourneyRow - 1) * 20
			end
			if #t_tourneyMenu.Group[tourneyGroup].Round[1] <= maxItems then
				maxSlots = #t_tourneyMenu.Group[tourneyGroup].Round[1]
			elseif tourneyRow - cursorPosY > 0 then
				maxSlots = tourneyRow + maxItems - cursorPosY
			else
				maxSlots = maxItems
			end
		else --If tournament has been started
		--BACK TO TOURNEY SETTINGS
			if tourneyBack then
				startTourney = false
				tourneyBack = false
				break
			end
			if esc() or commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then
				sndPlay(sndSys, 100, 2)
				confirmScreen = true
		--HIDE INPUT HINTS MENU
			elseif commandGetState(p1Cmd, 'q') or commandGetState(p2Cmd, 'q') then
				if not hideMenu then hideMenu = true else hideMenu = false end
		--START NEXT MATCH
			elseif btnPalNo(p1Cmd, true) > 0 or btnPalNo(p2Cmd, true) > 0 then
				hideMenu = false
				if data.debugLog then f_printTable(t_tourneyMenu, "save/debug/t_tourneyMenu.log") end
				f_tourneySelCfg()
			end
		end
	--Draw BG
		animDraw(f_animVelocity(commonBG0, -1, -1))
	--Draw Tourney BG Grids
		if data.tourneySize == 4 then
			animSetScale(tourney4, 1.059, 1.041)
			animPosDraw(tourney4, -10, -5)
		elseif data.tourneySize == 8 then
			animSetScale(tourney8, 1.059, 1.041)
			animPosDraw(tourney8, -10, -5)
		elseif data.tourneySize == 16 then
			animSetScale(tourney16, 1.059, 1.041)
			animPosDraw(tourney16, -10, -5)
		end
	--Draw Menu Titles
		textImgDraw(txt_tourneyType)
		f_setTourneyState()
		textImgSetText(txt_tourneyState, tourneyState)
		textImgDraw(txt_tourneyState)
		--[[
		if data.tourneyType == "Double Elimination" then
			textImgSetText(txt_tourneyBracket, txt_tourneyWinners)
			textImgDraw(txt_tourneyBracket)
		end
		]]
		textImgDraw(txt_tourneyTitle)
	--Draw Group A Assets
		for c=1, #t_tourneyMenu.Group[1].Round do
			for d=1, #t_tourneyMenu.Group[1].Round[c] do
			--Set AI Icon
				local ctrlIcon = nil
				local GroupAai = t_tourneyMenu.Group[1].Round[c][d].AIlevel
				if GroupAai == 1 then ctrlIcon = tourneyAI1
				elseif GroupAai == 2 then ctrlIcon = tourneyAI2
				elseif GroupAai == 3 then ctrlIcon = tourneyAI3
				elseif GroupAai == 4 then ctrlIcon = tourneyAI4
				elseif GroupAai == 5 then ctrlIcon = tourneyAI5
				elseif GroupAai == 6 then ctrlIcon = tourneyAI6
				elseif GroupAai == 7 then ctrlIcon = tourneyAI7
				elseif GroupAai == 8 then ctrlIcon = tourneyAI8
				end
			--Set Player Icon
				if t_tourneyMenu.Group[1].Round[c][d].Player == 1 then ctrlIcon = tourneyP1
				elseif t_tourneyMenu.Group[1].Round[c][d].Player == 2 then ctrlIcon = tourneyP2
				end
			--Draw Characters Icon
				local newStartPosX = 0
				local newSpacingX = 0
				local newStartPosY = 0
				local newSpacingY = 0
				local newChangeX = 0
				local newChangeY = 0
				local character = t_tourneyMenu.Group[1].Round[c][d].CharID
				if character == "randomselect" then
					--animSetScale(tourneyRandomIcon, 1.025,1.025)
					animPosDraw(tourneyRandomIcon, iconStartPosX+(1-1)*(iconWidth+iconSpacingX), iconStartPosY+(d-1)*(iconHeight+iconSpacingY))
				else --If a character is stored
					if data.tourneySize == 16 then --To draw assets for next rounds
						if c == 2 then --Quarterfinals
							newStartPosX = updateStartPosX
							newSpacingX = updateSpacingX
							newStartPosY = updateStartPosY
							newSpacingY = updateSpacingY
							newChangeX = 1
							newChangeY = 1
						elseif c == 3 then --Semifinals
							newStartPosX = updateStartPosX
							newSpacingX = updateSpacingX
							newStartPosY = updateStartPosY
							newSpacingY = updateSpacingY
							newChangeX = changeX
							newChangeY = changeY
						elseif c == 4 then --Final
							newStartPosX = updateStartPosX
							newSpacingX = updateSpacingX
							newStartPosY = updateStartPosY
							newSpacingY = updateSpacingY
							newChangeX = 2.97
							newChangeY = 5.3
						end
					elseif data.tourneySize == 8 then
						if c == 2 then --Semifinals
							newStartPosX = updateStartPosX
							newSpacingX = updateSpacingX
							newStartPosY = updateStartPosY
							newSpacingY = updateSpacingY
							newChangeX = 1
							newChangeY = 1.92
						elseif c == 3 then --Final
							newStartPosX = updateStartPosX
							newSpacingX = updateSpacingX
							newStartPosY = updateStartPosY
							newSpacingY = updateSpacingY
							newChangeX = 1.97
							newChangeY = 4.3
						end
					elseif data.tourneySize == 4 then
						if c == 2 then --Final
							newStartPosX = updateStartPosX
							newSpacingX = updateSpacingX
							newStartPosY = updateStartPosY
							newSpacingY = updateSpacingY
							newChangeX = 0.97
							newChangeY = 2.38
						end
					end
				--Draw Face
					drawTourneyPortrait(character-1, (iconStartPosX+(newStartPosX*newChangeX))+(1-1)*(iconWidth+(iconSpacingX-(newSpacingX*newChangeX))), (iconStartPosY+(newStartPosY*newChangeY))+(d-1)*(iconHeight+(iconSpacingY+(newSpacingY*newChangeY))))
				end
			--Draw Control Icon
				animPosDraw(ctrlIcon, (ctrlStartPosX+(newStartPosX*newChangeX))+(1-1)*(ctrlWidth+(ctrlSpacingX-(newSpacingX*newChangeX))), (ctrlStartPosY+(newStartPosY*newChangeY))+(d-1)*(ctrlHeight+(ctrlSpacingY+(newSpacingY*newChangeY))))
			end
		end
	--Draw Group B Assets
		for c=1, #t_tourneyMenu.Group[2].Round do
			for d=1, #t_tourneyMenu.Group[2].Round[c] do
			--Set AI Icon
				local ctrlIcon = nil
				local GroupBai = t_tourneyMenu.Group[2].Round[c][d].AIlevel
				if GroupBai == 1 then ctrlIcon = tourneyAI1
				elseif GroupBai == 2 then ctrlIcon = tourneyAI2
				elseif GroupBai == 3 then ctrlIcon = tourneyAI3
				elseif GroupBai == 4 then ctrlIcon = tourneyAI4
				elseif GroupBai == 5 then ctrlIcon = tourneyAI5
				elseif GroupBai == 6 then ctrlIcon = tourneyAI6
				elseif GroupBai == 7 then ctrlIcon = tourneyAI7
				elseif GroupBai == 8 then ctrlIcon = tourneyAI8
				end
			--Set Player Icon
				if t_tourneyMenu.Group[2].Round[c][d].Player == 1 then ctrlIcon = tourneyP1
				elseif t_tourneyMenu.Group[2].Round[c][d].Player == 2 then ctrlIcon = tourneyP2
				end
			--Draw Characters Icon
				local newStartPosX = 0
				local newSpacingX = 0
				local newStartPosY = 0
				local newSpacingY = 0
				local newChangeX = 0
				local newChangeY = 0
				local character = t_tourneyMenu.Group[2].Round[c][d].CharID
				if character == "randomselect" then
					animPosDraw(tourneyRandomIcon, iconStartPosX+(2-1)*(iconWidth+iconSpacingX), iconStartPosY+(d-1)*(iconHeight+iconSpacingY))
				else --If a character is stored
					if data.tourneySize == 16 then --To draw assets for next rounds
						if c == 2 then --Quarterfinals
							newStartPosX = updateStartPosX
							newSpacingX = updateSpacingX
							newStartPosY = updateStartPosY
							newSpacingY = updateSpacingY
							newChangeX = 1
							newChangeY = 1
						elseif c == 3 then --Semifinals
							newStartPosX = updateStartPosX
							newSpacingX = updateSpacingX
							newStartPosY = updateStartPosY
							newSpacingY = updateSpacingY
							newChangeX = changeX
							newChangeY = changeY
						elseif c == 4 then --Final
							newStartPosX = updateStartPosX
							newSpacingX = updateSpacingX
							newStartPosY = updateStartPosY
							newSpacingY = updateSpacingY
							newChangeX = 2.98
							newChangeY = 8.02
						end
					elseif data.tourneySize == 8 then
						if c == 2 then --Semifinals
							newStartPosX = updateStartPosX
							newSpacingX = updateSpacingX
							newStartPosY = updateStartPosY
							newSpacingY = updateSpacingY
							newChangeX = 1
							newChangeY = 1.92
						elseif c == 3 then --Final
							newStartPosX = updateStartPosX
							newSpacingX = updateSpacingX
							newStartPosY = updateStartPosY
							newSpacingY = updateSpacingY
							newChangeX = 1.98
							newChangeY = 7.02
						end
					elseif data.tourneySize == 4 then
						if c == 2 then --Final
							newStartPosX = updateStartPosX
							newSpacingX = updateSpacingX
							newStartPosY = updateStartPosY
							newSpacingY = updateSpacingY
							newChangeX = 0.98
							newChangeY = 5.1
						end
					end
				--Draw Face
					drawTourneyPortrait(character-1, (iconStartPosX+(newStartPosX*newChangeX))+(2-1)*(iconWidth+(iconSpacingX-(newSpacingX*newChangeX))), (iconStartPosY+(newStartPosY*newChangeY))+(d-1)*(iconHeight+(iconSpacingY+(newSpacingY*newChangeY))))
				end
			--Draw Control Icon
				animPosDraw(ctrlIcon, (ctrlStartPosX+(newStartPosX*newChangeX))+(2-1)*(ctrlWidth+(ctrlSpacingX-(newSpacingX*newChangeX))), (ctrlStartPosY+(newStartPosY*newChangeY))+(d-1)*(ctrlHeight+(ctrlSpacingY+(newSpacingY*newChangeY))))
			end
		end
	--Draw Slot Cursor
		if not startTourney then
			animPosDraw(tourneyP1Cursor, slotStartPosX+(tourneyGroup-1)*(slotWidth+slotSpacingX), slotStartPosY+(tourneyRow-1)*(slotHeight+slotSpacingY))
			if not hideMenu then drawTourneyInputHints2() end --Draw Input Hints
		else
			if confirmScreen then
				f_confirmMenu(txt_tourneyConfirmExit, jgFnt, 0, 160, 96, 0.9, 0.9, 10, 100)
			else
				if not hideMenu then drawTourneyInputHints3() end
			end
		end
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
	--VERTICAL BUF KEY CONTROL
		if commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu') then
			bufd = 0
			bufu = bufu + 1
		elseif commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd') then
			bufu = 0
			bufd = bufd + 1
		else
			bufu = 0
			bufd = 0			
		end
	--LATERAL BUF KEY CONTROL
		if commandGetState(p1Cmd, 'holdr') or commandGetState(p2Cmd, 'holdr') then
			bufl = 0
			bufr = bufr + 1
		elseif commandGetState(p1Cmd, 'holdl') or commandGetState(p2Cmd, 'holdl') then
			bufr = 0
			bufl = bufl + 1
		else
			bufr = 0
			bufl = 0
		end
		cmdInput()
		refresh()
	end
end

function f_tourneySelRandomPlayer()
--Group A
	for i=1, #t_tourneyMenu.Group[1].Round[1] do
		local character = t_tourneyMenu.Group[1].Round[1][i].CharID
		if character == "randomselect" then --When starts the tournament (if some slots have not been set manually than AI level and character is chosen randomly).
			t_tourneyMenu.Group[1].Round[1][i].CharID = t_randomTourneyChars[math.random(#t_randomTourneyChars)]+1
			t_tourneyMenu.Group[1].Round[1][i].pal = math.random(1,12)
			confirmRandomSel = true
		end
	end
--Group B
	for i=1, #t_tourneyMenu.Group[2].Round[1] do
		local character = t_tourneyMenu.Group[2].Round[1][i].CharID
		if character == "randomselect" then
			t_tourneyMenu.Group[2].Round[1][i].CharID = t_randomTourneyChars[math.random(#t_randomTourneyChars)]+1
			t_tourneyMenu.Group[2].Round[1][i].pal = math.random(1,12)
			confirmRandomSel = true
		end
	end
	if data.debugLog then f_printTable(t_tourneyMenu, "save/debug/t_tourneyMenu.log") end
end

--Load Common Settings for Tournament Battles
function f_tourneySelCfg()
	f_default()
	data.gameMode = "tourney"
	data.rosterMode = "tourney"
	data.stageMenu = true
	setRoundTime(data.tourneyRoundTime * 60)
	setRoundsToWin(data.tourneyRoundsNum)
	setFTNo(data.tourneyMatchsNum) --Set Matchs To Wins/FT
	textImgSetText(txt_mainSelect, tourneyState)
	data.p1TeamMenu = {mode = 0, chars = 1}
	data.p2TeamMenu = {mode = 0, chars = 1}
	data.p2In = 2
	data.p2SelectMenu = false
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	sndPlay(sndSys, 100, 1)
	f_selectTourney()
end

function f_tourneySelectReset()
	p1SelX = data.p1SelX --System.def: p1CursorStartcell for X
	p1SelY = data.p1SelY --System.def: p1CursorStartcell for Y
	p2SelX = data.p2SelX --System.def: p2CursorStartcell for X
	p2SelY = data.p2SelY --System.def: p2CursorStartcell for Y
	p1FaceOffset = 0
	p2FaceOffset = 0
	p1OffsetRow = 0
	p2OffsetRow = 0
	p1OffsetColumn = 0
	p2OffsetColumn = 0
	back = false
	--Quick Scrolling Vars
	bufTmu = 0
	bufTmd = 0
	bufTmr = 0
	bufTml = 0

	bufTm2u = 0
	bufTm2d = 0
	bufTm2r = 0
	bufTm2l = 0
	--
	bufSelu = 0
	bufSeld = 0
	bufSelr = 0
	bufSell = 0
	
	bufSel2u = 0
	bufSel2d = 0
	bufSel2r = 0
	bufSel2l = 0
	--
	bufPalu = 0
	bufPald = 0
	bufPalr = 0
	bufPall = 0
	
	bufPal2u = 0
	bufPal2d = 0
	bufPal2r = 0
	bufPal2l = 0
	--
	bufHandu = 0
	bufHandd = 0
	bufHandr = 0
	bufHandl = 0
	
	bufHand2u = 0
	bufHand2d = 0
	bufHand2r = 0
	bufHand2l = 0
	--
	bufStageu = 0
	bufStaged = 0
	bufStager = 0
	bufStagel = 0
	--Timers
	selectSeconds = data.selectTime
	stageSeconds = data.stageTime
	rematchSeconds = data.rematchTime
	serviceSeconds = data.serviceTime
	destinySeconds = data.destinyTime
	selectTimer = selectSeconds*gameTick --Set time for Character Select
	stageTimer = stageSeconds*gameTick --Set time for Stage Select
	rematchTimer = rematchSeconds*gameTick --Set time for Rematch Option
	serviceTimer = serviceSeconds*gameTick --Set time for Service Option
	destinyTimer = destinySeconds*gameTick --Set time for Tower/Destiny Select
	stageList = 0
	musicList = 0
	gameNo = 0
	winner = 0
	winCnt = 0
	looseCnt = 0
	clearTime = 0
	matchTime = 0
end

function f_tourneySelStage()
	f_stageSelectReset()
	stageEnd = false
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	while true do
		if matchNo == lastMatch then animDraw(f_animVelocity(selectHardBG0, -1, -1)) --Draw Red BG for Final Match
		else animDraw(f_animVelocity(commonBG0, -1, -1)) --Draw Blue BG for normal Matches
		end
		f_selectStage()
		if stageEnd then break end --Go to next screen
		--Activate Stage Announcer Timer
		if stageAnnouncer == true then
			announcerTimer = announcerTimer + 1
		end
		drawStageInputHints()
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		cmdInput()
		refresh()
	end
end

function f_tourneyControls()
	if p1Cell.Player == 2 then
		remapInput(1, 2) --P2 control Left Side
	end
	if p2Cell.Player == 1 then
		remapInput(2, 1) --P1 control Right Side
		setPlayerSide('p1right')
	end
	if p1Cell.AIlevel > 0 and p2Cell.AIlevel > 0 then setGameMode("tourneyAI") --this is a AI Battle
	else setGameMode("tourney") --at least there is a human controlling
	end
	setCom(1, p1Cell.AIlevel)
	setCom(2, p2Cell.AIlevel)
	--setTag(1, 0)
end

--;=================================================================================================
--; TOURNAMENT (CHARACTER SELECT/FIGHTS LAUNCHER)
--;=================================================================================================
function f_selectTourney()
cmdInput()
if validCells() then
	f_unlock(false)
	f_updateUnlocks()
	f_backReset()
	f_selectInit()
	if tourneyNextRound then
		t_tourneyMenu.Group[tourneyGroupNo].Round[tourneyRoundNo+1] = {} --To Add New Round Table Row
		tourneyNextRound = false
	end
	while true do
		--f_selectMusic()
		if winner < 1 then
			f_selectReset()
		else
			selectStart()
			commandBufReset(p1Cmd)
			commandBufReset(p2Cmd)
		end
	--Tourney Screen Logic
		if not startTourney then --When tourney has not been started
			while not selScreenEnd do
				if not onlinegame then
					if commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then f_exitSelect() end
				else
					if esc() then f_exitOnline() end
				end
				f_selectScreen()
				--Back from Char Select
				if back == true then return end
			end
		--Save Character Selected Data (Single Team Mode)
			t_tourneyMenu.Group[tourneyGroup].Round[1][tourneyRow].CharID = data.t_p1selected[1].cel+1
			t_tourneyMenu.Group[tourneyGroup].Round[1][tourneyRow].up = data.t_p1selected[1].up
			t_tourneyMenu.Group[tourneyGroup].Round[1][tourneyRow].pal = data.t_p1selected[1].pal
			break --Back to Tournament Menu
		else --When tourney has been started
			matchNo = matchNo + 1 --Go to Next FT
			if p1Wins == data.tourneyMatchsNum or p2Wins == data.tourneyMatchsNum then --If one of participants have reached the FT rule setting
				if not endTourney then
					t_tourneyMenu.Group[tourneyGroupNo].Round[tourneyRoundNo+1][tourneyFightNo] = {} --To Add New Fighter Table Row
					local p1Data = t_tourneyMenu.Group[tourneyGroupNo].Round[tourneyRoundNo][tourneyParticipantNo+1]
					local p2Data = t_tourneyMenu.Group[tourneyGroupNo].Round[tourneyRoundNo][tourneyParticipantNo+2]
				--Save Left Side Winner Data
					if p1Wins == data.tourneyMatchsNum then
						t_tourneyMenu.Group[tourneyGroupNo].Round[tourneyRoundNo+1][tourneyFightNo]['CharID'] = p1Data.CharID
						t_tourneyMenu.Group[tourneyGroupNo].Round[tourneyRoundNo+1][tourneyFightNo]['up'] = p1Data.up
						t_tourneyMenu.Group[tourneyGroupNo].Round[tourneyRoundNo+1][tourneyFightNo]['pal'] = p1Data.pal
						t_tourneyMenu.Group[tourneyGroupNo].Round[tourneyRoundNo+1][tourneyFightNo]['CharControl'] = p1Data.CharControl
						t_tourneyMenu.Group[tourneyGroupNo].Round[tourneyRoundNo+1][tourneyFightNo]['AIlevel'] = p1Data.AIlevel
						t_tourneyMenu.Group[tourneyGroupNo].Round[tourneyRoundNo+1][tourneyFightNo]['Player'] = p1Data.Player
						t_tourneyMenu.Group[tourneyGroupNo].Round[tourneyRoundNo+1][tourneyFightNo]['Loser'] = p1Data.Loser
						t_tourneyMenu.Group[tourneyGroupNo].Round[tourneyRoundNo+1][tourneyFightNo]['Active'] = p1Data.Active
						p2Data.Loser = true
						if data.tourneyType == "Single Elimination" then p2Data.Active = false --The loser of each match will be immediately eliminated from the tournament
						--elseif data.tourneyType == "Double Elimination" then --A participant gets eliminated upon having lost two games or matches.
						end
				--Save Right Side Winner Data
					elseif p2Wins == data.tourneyMatchsNum then
						t_tourneyMenu.Group[tourneyGroupNo].Round[tourneyRoundNo+1][tourneyFightNo]['CharID'] = p2Data.CharID
						t_tourneyMenu.Group[tourneyGroupNo].Round[tourneyRoundNo+1][tourneyFightNo]['up'] = p2Data.up
						t_tourneyMenu.Group[tourneyGroupNo].Round[tourneyRoundNo+1][tourneyFightNo]['pal'] = p2Data.pal
						t_tourneyMenu.Group[tourneyGroupNo].Round[tourneyRoundNo+1][tourneyFightNo]['CharControl'] = p2Data.CharControl
						t_tourneyMenu.Group[tourneyGroupNo].Round[tourneyRoundNo+1][tourneyFightNo]['AIlevel'] = p2Data.AIlevel
						t_tourneyMenu.Group[tourneyGroupNo].Round[tourneyRoundNo+1][tourneyFightNo]['Player'] = p2Data.Player
						t_tourneyMenu.Group[tourneyGroupNo].Round[tourneyRoundNo+1][tourneyFightNo]['Loser'] = p2Data.Loser
						t_tourneyMenu.Group[tourneyGroupNo].Round[tourneyRoundNo+1][tourneyFightNo]['Active'] = p2Data.Active
						p1Data.Loser = true
						if data.tourneyType == "Single Elimination" then p1Data.Active = false end
					end
					tourneyFightNo = tourneyFightNo + 1
					tourneyParticipantNo = tourneyParticipantNo + 2 --Get participants for next Tourney Match
				--When fights from one group are done
					if tourneyParticipantNo >= #t_tourneyMenu.Group[tourneyGroupNo].Round[tourneyRoundNo] then
					--Reset for new group
						tourneyParticipantNo = 0
						tourneyFightNo = 1
						if tourneyGroupNo == 1 then
							tourneyGroupNo = 2
						elseif tourneyGroupNo == 2 then
							tourneyGroupNo = 1
							tourneyRoundNo = tourneyRoundNo + 1 --Reset for the new round
						end
						tourneyNextRound = true
					end
				else --After final match show tourney awards screen
					f_tourneyChampion()
				end
			--Back to Tourney Menu
				f_resetMenuInputs()
				if data.debugLog then f_printTable(t_tourneyMenu, "save/debug/t_tourneyMenu.log") end
				break
			end
		--Show Character Select every Match
			if data.tourneyCharSel then
				if (p1Wins > 0 or p2Wins > 0) or tourneyRoundNo > 1 then
					tourneyCharSel = true
					data.p2Faces = true
					data.p2SelectMenu = true
					local p1Data = t_tourneyMenu.Group[tourneyGroupNo].Round[tourneyRoundNo][tourneyParticipantNo+1]
					local p2Data = t_tourneyMenu.Group[tourneyGroupNo].Round[tourneyRoundNo][tourneyParticipantNo+2]
					if endTourney then --Rewritte data to avoid issue with p2Data 
						p1Data = t_tourneyMenu.Group[1].Round[tourneyRoundNo][1] --Pick the only character left in Group A
						p2Data = t_tourneyMenu.Group[2].Round[tourneyRoundNo][1] --Pick the only character left in Group B
					end
					if p1Data.AIlevel == 0 and p2Data.AIlevel == 0 then --VS HUMAN (1P and 2P controls his sides in Character Select)
						data.p2In = 2
						if p1Data.Player == 2 then
							remapInput(1, 2) --P2 control Left Side
						end
						if p2Data.Player == 1 then
							remapInput(2, 1) --P1 control Right Side
							setPlayerSide('p1right')
						end
					else --VS CPU (1P or 2P controls both sides in Character Select)
						data.p2In = 1
						if p1Data.Player == 2 then
							--data.p1In = 2 --Test
							remapInput(1, 2) --P2 control Left Side
						end
						if p2Data.Player == 1 then
							data.p1In = 2
							data.p2In = 2
							remapInput(2, 1) --P1 control Right Side
							setPlayerSide('p1right')
						end
					end
					--f_tourneySelectReset() --(Unused) to restart cursor position
					f_selectReset()
					--selectStart()
					while not selScreenEnd do
						if not onlinegame then
							if commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then f_exitSelect() end
						else
							if esc() then f_exitOnline() end
						end
						f_selectScreen()
					--Back from Char Select
						if back == true then
							exitTourney = true
							break
						end
					end
					if exitTourney then
						f_resetMenuInputs()
						if data.attractMode == true then playBGM(bgmTitle) else	f_menuMusic() end
						break
					end
				--Save Character Selected Data (Single Team Mode)
					t_tourneyMenu.Group[tourneyGroupNo].Round[tourneyRoundNo][tourneyParticipantNo+1].CharID = data.t_p1selected[1].cel+1
					t_tourneyMenu.Group[tourneyGroupNo].Round[tourneyRoundNo][tourneyParticipantNo+1].up = data.t_p1selected[1].up
					t_tourneyMenu.Group[tourneyGroupNo].Round[tourneyRoundNo][tourneyParticipantNo+1].pal = data.t_p1selected[1].pal
					--t_tourneyMenu.Group[tourneyGroupNo].Round[tourneyRoundNo][tourneyParticipantNo+1].handicap = data.t_p1selected[1].handicap
				--Player 2 Data
					local player2Data = tourneyParticipantNo+2
					local player2Group = tourneyGroupNo
					if endTourney then --Rewritte data to avoid issue with p2Data (Picking the only character left in Group B)
						player2Data = 1
						player2Group = 2
					end
					t_tourneyMenu.Group[player2Group].Round[tourneyRoundNo][player2Data].CharID = data.t_p2selected[1].cel+1
					t_tourneyMenu.Group[player2Group].Round[tourneyRoundNo][player2Data].up = data.t_p2selected[1].up
					t_tourneyMenu.Group[player2Group].Round[tourneyRoundNo][player2Data].pal = data.t_p2selected[1].pal
					--t_tourneyMenu.Group[player2Group].Round[tourneyRoundNo][player2Data].handicap = data.t_p2selected[1].handicap
					if data.debugLog then f_printTable(t_tourneyMenu, "save/debug/t_tourneyMenu.log") end
				end
			end
		--Assign Characters to the Match
			data.t_p1selected = {}
			data.t_p2selected = {}
			if not endTourney then
				p1Cell = t_tourneyMenu.Group[tourneyGroupNo].Round[tourneyRoundNo][tourneyParticipantNo+1]
				p2Cell = t_tourneyMenu.Group[tourneyGroupNo].Round[tourneyRoundNo][tourneyParticipantNo+2]
			else
				p1Cell = t_tourneyMenu.Group[1].Round[tourneyRoundNo][1] --Pick the only character left in Group A
				p2Cell = t_tourneyMenu.Group[2].Round[tourneyRoundNo][1] --Pick the only character left in Group B
			end
			data.t_p1selected[#data.t_p1selected+1] = {['cel'] = p1Cell.CharID-1, ['name'] = t_selChars[p1Cell.CharID].name, ['displayname'] = t_selChars[p1Cell.CharID].displayname, ['path'] = t_selChars[p1Cell.CharID].char, ['pal'] = p1Cell.pal, ['up'] = p1Cell.up, ['rand'] = false}
			data.t_p2selected[#data.t_p2selected+1] = {['cel'] = p2Cell.CharID-1, ['name'] = t_selChars[p2Cell.CharID].name, ['displayname'] = t_selChars[p2Cell.CharID].displayname, ['path'] = t_selChars[p2Cell.CharID].char, ['pal'] = p2Cell.pal, ['up'] = p2Cell.up, ['rand'] = false}
			setMatchNo(matchNo)
			f_tourneyControls()
			if data.tourneyStgSel or matchNo == 1 then --Show Stage Select every FT 1
				f_tourneySelStage()
			else --Load First Stage Selected
				--f_randomRematch()
				f_loadStage()
				f_assignMusic()
			end
			f_matchInfo()
			f_orderSelect()
			f_selectVersus()
			sndStop()
			f_loading()
			f_setZoom()
			--inputs
			if data.coop then
				remapInput(3,2) --P2 controls assigned to P3 character
				--remapInput(2,3) --P3 controls assigned to P2 character
			end
			matchTime = os.clock()
			if data.songSelect then f_assignMusic() end
			setTourneyState(tourneyState)
			setP1matchWins(p1Wins)
			setP2matchWins(p2Wins)
			winner = game() --Get into the fight
			playBGM("")
			matchTime = os.clock() - matchTime
			clearTime = clearTime + matchTime
			selectTimer = selectSeconds*gameTick
			stageTimer = stageSeconds*gameTick
			rematchTimer = rematchSeconds*gameTick
			serviceTimer = serviceSeconds*gameTick
			--f_favoriteChar() --Store Favorite Character (WIP)
			--f_favoriteStage() --Store Favorite Stage (WIP)
			f_unlock(false)
			f_updateUnlocks()
		--Victory Screen
			commandBufReset(p1Cmd)
			commandBufReset(p2Cmd)
			data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
			if winner == 1 or winner == 2 then
				f_selectWin()
				if data.rosterMode == "tourney" then
					playBGM(bgmTourney)
				else
					if data.attractMode == true then playBGM(bgmTitle) else	f_menuMusic() end
				end
		--Back from Pause Menu (Give Up or Main Menu Options)
			elseif winner == -1 then
				assert(loadfile(saveTempPath))()
			--Back to Main Menu
				if data.tempBack == true then
					exitTourney = true
					data.tempBack = false
					f_saveTemp()
					f_resetMenuInputs()
					if data.attractMode == true then playBGM(bgmTitle) else	f_menuMusic() end
					break
			--Give Up
				else
				--P1 Give Up
					if data.p1Lose then
						winner = 2
				--P2 Give Up
					elseif data.p2Lose then
						winner = 1
				--CPU VS CPU Random Winner
					elseif data.AIskip then
						winner = math.random(1,2)
					end
					data.p1Lose = false
					data.p2Lose = false
					data.AIskip = false
					f_saveTemp()
					f_selectWin()
					if data.rosterMode == "tourney" then
						playBGM(bgmTourney)
					else
						if data.attractMode == true then playBGM(bgmTitle) else	f_menuMusic() end
					end
				end
			end
		end
		f_resetP2CoopInput()
		cmdInput()
		refresh()
	end
else
	f_invalidCells()
	return --back to main menu
end

end

--;===========================================================
--; TOURNAMENT CHAMPION SCREEN
--;===========================================================
function f_tourneyChampion()
	cmdInput()
	local screenTime = 0
	local timeLimit = 150
	local xPortScale = 0.9
	local yPortScale = 0.9
	local winner1 = nil
	local winner2 = nil
	if p1Wins == data.tourneyMatchsNum then
		winner1 = data.t_p1selected
		winner2 = data.t_p2selected
	elseif p2Wins == data.tourneyMatchsNum then
		winner1 = data.t_p2selected
		winner2 = data.t_p1selected
	end
	textImgSetText(txt_tourneyPlace1, f_getName(winner1[1].cel))
	textImgSetText(txt_tourneyPlace2, f_getName(winner2[1].cel))
	if data.tourney3rdPlace then
		--textImgSetText(txt_tourneyPlace3, f_getName(1)) TODO
	end
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	playBGM(bgmTourneyChampion)
	while true do
	--SKIP
		if btnPalNo(p1Cmd, true) > 0 or btnPalNo(p2Cmd, true) > 0 then
			exitTourney = true
			break
		end
		animDraw(f_animVelocity(commonBG0, -1, -1)) --Draw BG
	--Draw Character Portraits
		if data.portraitDisplay == "Portrait" or data.portraitDisplay == "Mixed" then
			if data.tourney3rdPlace then
				--drawWinPortrait(1, 207, 76, xPortScale, yPortScale) --Third Place
			end
			drawWinPortrait(winner2[1].cel, 6, 57, xPortScale, yPortScale) --Second Place
			drawWinPortrait(winner1[1].cel, 109.5, 32, xPortScale, yPortScale) --First Place
		end
	--Draw Character Sprite Animations
		if data.portraitDisplay == "Sprite" or data.portraitDisplay == "Mixed" then
		--First Place
			for j=#winner1, 1, -1 do
				f_drawCharAnim(t_selChars[winner1[j].cel+1], 'p1AnimWin', 179 - (2*j-1) * 18, 157, winner1[j].up)
			end
		--Second Place
			for j=#winner2, 1, -1 do
				f_drawCharAnim(t_selChars[winner2[j].cel+1], 'p1AnimWin', 78 - (2*j-1) * 18, 182, winner2[j].up)
			end
		--Third Place
			if data.tourney3rdPlace then
			--[[
				for j=#???, 1, -1 do
					f_drawCharAnim(1, 'p1AnimWin', 279 - (2*j-1) * 18, 201, true)
				end
			]]
			end
		end
		animDraw(tourneyAwards)
	--Draw Titles
		textImgDraw(txt_tourneyChampionTitle)
		textImgDraw(txt_tourneyPlace1)
		textImgDraw(txt_tourneyPlace2)
		if data.tourney3rdPlace then textImgDraw(txt_tourneyPlace3) end
	    animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		cmdInput()
		refresh()
	end
end

--;===========================================================
--; ABYSS SELECT MENU (Defeat way of enemies, strengthening your character along the way)
--;===========================================================
function f_abyssSelect()
	f_discordUpdate({details = "Abyss"})
	cmdInput()
	local cursorPosX = 1
	local moveTxt = 0
	local bufu = 0
	local bufd = 0
	local bufr = 0
	local bufl = 0
	local maxItems = 3
	local continueCursor = false
	local continueCheck = false
	init_abyssStats() --Reset Abyss Character Stats Data
	--f_saveStats()
	f_saveAbyss()
	f_sideReset()
	abyssSel = 1
	exitAbyss = false
	f_resetAbyssArrowsPos()
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	playBGM(bgmAbyss)
	while true do
	--Check if there is continue data available
		for i=1, #abyssDat.save do
			if abyssDat.save[i].player then
				continueCheck = true
			end
		end
		if not sideScreen then
		--Return Logic
			if esc() or commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') or exitAbyss then
				f_discordMainMenu()
				sndPlay(sndSys, 100, 2)
				data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
				f_menuMusic()
				f_resetMenuArrowsPos()
				break
			end
		--Continue Cursor
			if continueCheck and (commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u') or commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd')) then
				sndPlay(sndSys, 100, 0)
				if continueCursor then continueCursor = false else continueCursor = true end
			end
		--Cursor Actions
			if (btnPalNo(p1Cmd, true) > 0 or btnPalNo(p2Cmd, true) > 0) then
				sndPlay(sndSys, 100, 1)
			--Continue Game
				if continueCheck and continueCursor then
					f_abyssData("load") --Open Abyss Data Select
					if loadAbyssDat then
						abyssSel = abyssDat.nosave.abysslv
						abyssCfg()
						_G[abyssDat.nosave.sideselect]() --Load/Call Side Select Function
					end
			--New Game
				else
					f_abyssBoot() --Open Side Select
				end
			end
		--Abyss Level Select
			if not continueCursor then
				if commandGetState(p1Cmd, 'l') or commandGetState(p2Cmd, 'l') or ((commandGetState(p1Cmd, 'holdl') or commandGetState(p2Cmd, 'holdl')) and bufl >= 30) then
					sndPlay(sndSys, 100, 0)
					abyssSel = abyssSel - 1
				elseif commandGetState(p1Cmd, 'r') or commandGetState(p2Cmd, 'r') or ((commandGetState(p1Cmd, 'holdr') or commandGetState(p2Cmd, 'holdr')) and bufr >= 30) then
					sndPlay(sndSys, 100, 0)
					abyssSel = abyssSel + 1
				end
				if abyssSel < 1 then
					abyssSel = #t_abyssSel
					if #t_abyssSel > maxItems then
						cursorPosX = maxItems
					else
						cursorPosX = #t_abyssSel
					end
				elseif abyssSel > #t_abyssSel then
					abyssSel = 1
					cursorPosX = 1
				elseif ((commandGetState(p1Cmd, 'l') or commandGetState(p2Cmd, 'l')) or ((commandGetState(p1Cmd, 'holdl') or commandGetState(p2Cmd, 'holdl')) and bufl >= 30)) and cursorPosX > 1 then
					cursorPosX = cursorPosX - 1
				elseif ((commandGetState(p1Cmd, 'r') or commandGetState(p2Cmd, 'r')) or ((commandGetState(p1Cmd, 'holdr') or commandGetState(p2Cmd, 'holdr')) and bufr >= 30)) and cursorPosX < maxItems then
					cursorPosX = cursorPosX + 1
				end
				if cursorPosX == maxItems then
					moveTxt = (abyssSel - maxItems) * 104
				elseif cursorPosX == 1 then
					moveTxt = (abyssSel - 1) * 104
				end	
				if #t_abyssSel <= maxItems then
					maxabyssSel = #t_abyssSel
				elseif abyssSel - cursorPosX > 0 then
					maxabyssSel = abyssSel + maxItems - cursorPosX
				else
					maxabyssSel = maxItems
				end
			end
		end
	--Draw BG
		animDraw(abyssBG)
		animDraw(f_animVelocity(abyssFog, -1, -1))
	--Draw Title
		textImgDraw(txt_abyssSel)
		animPosDraw(abyssSelInfoBG, -56, 185) --Draw Info Text BG
		local abyssInfo = ""
		if continueCursor then abyssInfo = txt_abyssContinueInfo else abyssInfo = t_abyssSel[abyssSel].info end
		f_textRender(txt_abyssLvInfo, abyssInfo, 0, 159, 200, 10, 0, 100)
	--Draw Abyss Level Content Text
		for i=1, maxabyssSel do
			if i > abyssSel - cursorPosX then
				local txtDepth = ""
				if t_abyssSel[i].depth == -1 then txtDepth = "INFINITE" else txtDepth = t_abyssSel[i].depth end
				if t_abyssSel[i].id ~= nil then
					animPosDraw(abyssSelWindowBG, -94+i*104-moveTxt,50)
					textImgDraw(f_updateTextImg(t_abyssSel[i].id, font20, 4, 0, txtDepth, -50+i*104-moveTxt, 120))
					textImgSetPos(txt_abyssLv, -50+i*104-moveTxt, 75)
					textImgSetText(txt_abyssLv, "LEVEL "..i)
					textImgDraw(txt_abyssLv)
					textImgSetPos(txt_abyssDepth, -50+i*104-moveTxt, 105)
					textImgDraw(txt_abyssDepth)
				end
			end
		end
	--Draw Continue Box
		if continueCheck then
			animPosDraw(abyssContBG, 106, 147)
			textImgDraw(txt_abyssContinue)
			if continueCursor then
				animSetWindow(cursorBox, 106,147, 106,24)
				f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
				animDraw(f_animVelocity(cursorBox, -1, -1))
			end
		end
	--Draw Cursor
		if not continueCursor then
			animSetWindow(cursorBox, -94+cursorPosX*104,54, 89.5,78)
			f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
			animDraw(f_animVelocity(cursorBox, -1, -1))
		end
		if maxabyssSel > maxItems then
			animDraw(menuArrowLeft)
			animUpdate(menuArrowLeft)
		end
		if #t_abyssSel > maxItems and maxabyssSel < #t_abyssSel then
			animDraw(menuArrowRight)
			animUpdate(menuArrowRight)
		end
		if sideScreen then f_sideSelect() else drawAbyssSelInputHints() end
		if commandGetState(p1Cmd, 'holdl') or commandGetState(p2Cmd, 'holdl') then
			bufr = 0
			bufl = bufl + 1
		elseif commandGetState(p1Cmd, 'holdr') or commandGetState(p2Cmd, 'holdr') then
			bufl = 0
			bufr = bufr + 1
		else
			bufl = 0
			bufr = 0
		end
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		cmdInput()
		refresh()
	end
end

function f_abyssBoot()
	menuSelect = "abyss"
	sideScreen = true
end

--Load Common Settings for Abyss Modes
function abyssCfg()
	f_default()
	setRoundsToWin(1)
	setRoundTime(99*60)
	setGameMode('abyss')
	data.gameMode = "abyss"
	data.rosterMode = "abyss"
	data.victoryscreen = false
	data.stage = "stages/Mountainside Temple/Dark Corridor.def" --Abyss Initial Stage
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	sndPlay(sndSys, 100, 1)
end

--HUMAN VS CPU (fight against CPU controlled opponents from left side)
function abyssHumanvsCPU()
	abyssDat.nosave.sideselect = "abyssHumanvsCPU" --Save the name of this function to load data
	if P2overP1 then
		remapInput(1, 2)
		setPlayerSide('p2left')
	else
		setPlayerSide('p1left')
	end
	data.p1TeamMenu = {mode = 0, chars = 1}
	data.p2TeamMenu = {mode = 0, chars = 1}
	data.p2In = 1
	data.p2SelectMenu = false
	textImgSetText(txt_mainSelect, "ABYSS MODE [MAX DEPTH "..stats.modes.abyss.maxdepth.."]")
	f_selectAdvance()
	P2overP1 = false
end

--CPU VS HUMAN (fight against CPU controlled opponents from right side)
function abyssCPUvsHuman()
	abyssDat.nosave.sideselect = "abyssCPUvsHuman"
	remapInput(1, 2)
	if not P2overP1 then
		remapInput(2, 1)
		setPlayerSide('p1right')
	else
		setPlayerSide('p2right')
	end
	data.p1TeamMenu = {mode = 0, chars = 1}
	data.p2TeamMenu = {mode = 0, chars = 1}
	data.p1In = 2
	data.p2In = 2
	data.p1SelectMenu = false
	textImgSetText(txt_mainSelect, "ABYSS MODE [MAX DEPTH "..stats.modes.abyss.maxdepth.."]")
	f_selectAdvance()
	P2overP1 = false
end

--P1&P2 VS CPU [CO-OP MODE] (team up with another player from left side against CPU controlled opponents)
function abyssP1P2vsCPU()
	abyssDat.nosave.sideselect = "abyssP1P2vsCPU"
	data.p2In = 2
	data.p2Faces = true
	data.coop = true
	setPlayerSide('p1left')
	setGameMode('abysscoop')
	textImgSetText(txt_mainSelect, "ABYSS COOPERATIVE [MAX DEPTH "..stats.modes.abyss.maxdepth.."]")
	f_selectAdvance()
end

--CPU VS P1&P2 [CO-OP MODE] (team up with another player from right side against CPU controlled opponents)
function abyssCPUvsP1P2()
	f_comingSoon()
--[[
	abyssDat.nosave.sideselect = "abyssCPUvsP1P2"
	setPlayerSide('p1right')
	data.p1In = 2
	data.p2In = 2
	data.p2Faces = true
	data.coop = true
	setGameMode('abysscoop')
	textImgSetText(txt_mainSelect, "ABYSS COOPERATIVE [MAX DEPTH "..stats.modes.abyss.maxdepth.."]")
	f_selectAdvance()
]]
end

--CPU MODE (watch CPU fight in abyss)
function abyssCPUvsCPU()
	abyssDat.nosave.sideselect = "abyssCPUvsCPU"
	data.p1TeamMenu = {mode = 0, chars = 1}
	data.p2TeamMenu = {mode = 0, chars = 1}
	data.p2In = 1
	data.p2SelectMenu = false
	data.aiFight = true
	setPlayerSide('p1left')
	setGameMode('abysscpu')
	data.rosterMode = "cpu"
	textImgSetText(txt_mainSelect, "WATCH ABYSS [MAX DEPTH "..stats.modes.abyss.maxdepth.."]")
	f_selectAdvance()
end

--;===========================================================
--; ABYSS MAIN MENU
--;===========================================================
function f_abyssMenu()
	cmdInput()
	local cursorPosY = 1
	local moveTxt = 0
	local abyssMenu = 1
	local bufu = 0
	local bufd = 0
	local bufr = 0
	local bufl = 0
	local maxItems = 10
	local shop = false
	local buyDone = false
	local t_menuBackup = t_abyssMenu
	local backupCurrency = stats.money
	local itemName = nil
	local itemPrice = nil
	local itemInfo = nil
--Store Player Data
	local playerDat = nil
	if (data.p1In == 2 and data.p2In == 2) then --Player 1 in player 2 (right) side
		playerDat = data.t_p2selected
	else
		playerDat = data.t_p1selected
	end
	abyssDat.nosave.player = playerDat --Store all player data
	abyssDat.nosave.abysslv = abyssSel
--Check Shop Item Unlocks
	f_unlock(false)
	f_updateUnlocks()
	f_resetAbyss2ArrowsPos()
	f_confirmReset()
	f_abyssResetShop()
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	while true do
		if not confirmScreen then
			if esc() or commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then
				sndPlay(sndSys, 100, 2)
				if not shop then
					confirmScreen = true
				else
					t_abyssMenu = t_menuBackup
					shop = false
				end
			elseif commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u') or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30) then
				sndPlay(sndSys, 100, 0)
				abyssMenu = abyssMenu - 1
			elseif commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd') or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30) then
				sndPlay(sndSys, 100, 0)
				abyssMenu = abyssMenu + 1
		--Actions
			elseif (btnPalNo(p1Cmd, true) > 0 or btnPalNo(p2Cmd, true) > 0) then
			--Abyss Option Select
				if not shop then
					sndPlay(sndSys, 100, 1)
					if abyssMenu == 1 then
						t_abyssMenu = t_abyssShop
						shop = true
					elseif abyssMenu == 2 then
						abyssDat.nosave.expense = backupCurrency - stats.money --calculates the amount spent in the store to be displayed on the results screen
						f_setAbyssItems()
						break --Start Abyss Mode
					end
			--Abyss Shop
				else
				--Shop Item is unlocked/has been found and player have enough currency to buy it
					if (t_unlockLua.abyss[t_abyssMenu[abyssMenu].text] == nil) and stats.money >= t_abyssMenu[abyssMenu].price then
					--Shop Item is NOT sold out
						if not t_abyssMenu[abyssMenu].sold then
						--Attribute Assign
							if t_abyssMenu[abyssMenu].attack then
								buyDone = true
								setAbyssAttack(getAbyssAttack() + t_abyssMenu[abyssMenu].val)
							elseif t_abyssMenu[abyssMenu].defence then
								buyDone = true
								setAbyssDefence(getAbyssDefence() + t_abyssMenu[abyssMenu].val)
							elseif t_abyssMenu[abyssMenu].power then
								buyDone = true
								setAbyssPower(getAbyssPower() + t_abyssMenu[abyssMenu].val)
							elseif t_abyssMenu[abyssMenu].life then
								buyDone = true
								setAbyssLife(getAbyssLife() + t_abyssMenu[abyssMenu].val)
							elseif t_abyssMenu[abyssMenu].depth then
								buyDone = true
								setAbyssDepth(getAbyssDepth() + t_abyssMenu[abyssMenu].val)
						--Special Items Assign
							else
							--Special Items Slots are Full
								if abyssDat.nosave.itemslot[#abyssDat.nosave.itemslot] ~= "" then
									sndPlay(sndIkemen, 200, 0)
							--At least there is 1 Special Items Slot free
								else
									for slot=1, #abyssDat.nosave.itemslot do
										if abyssDat.nosave.itemslot[slot] == "" then
											abyssDat.nosave.itemslot[slot] = t_abyssMenu[abyssMenu].text
											break --Exit the loop once the assignment has been made for 1 slot (this avoid asign same item to all slots)
										end
									end
									buyDone = true
								end
							end
							if buyDone then
								sndPlay(sndIkemen, 700, 0)
								stats.money = stats.money - t_abyssMenu[abyssMenu].price
							--Save Data
								f_saveStats()
								t_abyssMenu[abyssMenu].sold = true --Item Sold out
								buyDone = false
							end
					--Shop Item is sold out
						else
							sndPlay(sndIkemen, 200, 0)
						end
				--Shop Item is locked/has not been discovered/is sold out or player NOT have enough currency to buy it
					else
						sndPlay(sndIkemen, 200, 0)
					end
				end
		--Refund
			elseif commandGetState(p1Cmd, 'q') or commandGetState(p2Cmd, 'q') then
				if shop and t_abyssMenu[abyssMenu].sold then
					sndPlay(sndSys, 100, 2)
					stats.money = stats.money + t_abyssMenu[abyssMenu].price
				--Attribute Refund
					if t_abyssMenu[abyssMenu].attack then
						setAbyssAttack(getAbyssAttack() - t_abyssMenu[abyssMenu].val)
					elseif t_abyssMenu[abyssMenu].defence then
						setAbyssDefence(getAbyssDefence() - t_abyssMenu[abyssMenu].val)
					elseif t_abyssMenu[abyssMenu].power then
						setAbyssPower(getAbyssPower() - t_abyssMenu[abyssMenu].val)
					elseif t_abyssMenu[abyssMenu].life then
						setAbyssLife(getAbyssLife() - t_abyssMenu[abyssMenu].val)
					elseif t_abyssMenu[abyssMenu].depth then
						setAbyssDepth(getAbyssDepth() - t_abyssMenu[abyssMenu].val)
				--Special Items Refund
					else
						for slot=1, #abyssDat.nosave.itemslot do
							if abyssDat.nosave.itemslot[slot] == t_abyssMenu[abyssMenu].text then
								abyssDat.nosave.itemslot[slot] = ""
								break
							end
						end
					end
					f_saveStats()
					t_abyssMenu[abyssMenu].sold = false --Item available again
				end
			end
			if exitAbyss then
				stats.money = backupCurrency --Restore money only if not start a game
				data.tempBack = true --To exit to Main Menu from Abyss Menu
				break
			end
			if abyssMenu < 1 then
				abyssMenu = #t_abyssMenu
				if #t_abyssMenu > maxItems then
					cursorPosY = maxItems
				else
					cursorPosY = #t_abyssMenu
				end
			elseif abyssMenu > #t_abyssMenu then
				abyssMenu = 1
				cursorPosY = 1
			elseif ((commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u')) or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30)) and cursorPosY > 1 then
				cursorPosY = cursorPosY - 1
			elseif ((commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd')) or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30)) and cursorPosY < maxItems then
				cursorPosY = cursorPosY + 1
			end
			if cursorPosY == maxItems then
				moveTxt = (abyssMenu - maxItems) * 15
			elseif cursorPosY == 1 then
				moveTxt = (abyssMenu - 1) * 15
			end	
			if #t_abyssMenu <= maxItems then
				maxabyssMenu = #t_abyssMenu
			elseif abyssMenu - cursorPosY > 0 then
				maxabyssMenu = abyssMenu + maxItems - cursorPosY
			else
				maxabyssMenu = maxItems
			end
		end
	--Draw BG
		animDraw(abyssBG)
		animDraw(f_animVelocity(abyssFog, -1, -1))
	--Draw Title
		if shop then
			textImgSetText(txt_abyssMain, "ABYSS SHOP")
		else
			textImgSetText(txt_abyssMain, "ABYSS MENU")
		end
		textImgDraw(txt_abyssMain)
	--Draw Menu Options BG
		animSetScale(abyssTBG, 240, maxabyssMenu*15)
		animSetWindow(abyssTBG, 2,20, 165,155)
		animDraw(abyssTBG)
	--Draw Cursor
		if not confirmScreen then
			animSetWindow(cursorBox, 2,10+cursorPosY*15, 165,15)
			f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
			animDraw(f_animVelocity(cursorBox, -1, -1))
		end
	--Draw Menu Options Text
		for i=1, maxabyssMenu do
			if i > abyssMenu - cursorPosY then
				if t_abyssMenu[i].id ~= nil then
					if shop then --SHOP MENU
						if t_unlockLua.abyss[t_abyssMenu[i].text] == nil then --Item is unlocked/has been found
							if t_abyssMenu[i].sold then --Item is sold out
								itemName = txt_abyssShopItemSold
								itemPrice = ""
							else --Item is NOT sold out
								itemName = t_abyssMenu[i].text
								itemPrice = t_abyssMenu[i].price
							end
						else --Item is locked/has not been discovered
							itemName = txt_abyssShopItemLock
							itemPrice = ""
						end
						textImgDraw(f_updateTextImg(t_abyssMenu[i].id, font2, 0, -1, itemPrice, 163, 20+i*15-moveTxt))
					else --NORMAL MENU
						itemName = t_abyssMenu[i].text
					end
					textImgDraw(f_updateTextImg(t_abyssMenu[i].id, font2, 0, 1, itemName, 5, 20+i*15-moveTxt))
				end
			end
		end
	--Draw Info Text Stuff
		animPosDraw(abyssSelInfoBG, -56, 195)
		if t_unlockLua.abyss[t_abyssMenu[abyssMenu].text] == nil then --Item is unlocked/has been found
			if t_abyssMenu[abyssMenu].sold then --Item is sold out
				itemInfo = txt_abyssShopInfoSold
			else --Item is NOT sold out
				itemInfo = t_abyssMenu[abyssMenu].info
			end
		else --Item is locked/has not been discovered
			itemInfo = txt_abyssShopInfoLock
		end
		f_textRender(txt_abyssLvInfo, itemInfo, 0, 159, 206, 10, 0, 40)
		f_drawQuickText(txt_abyssCurrency, font11, 0, -1, stats.money.." IKC", 315, 10, 1.2, 1.2)
		f_abyssProfile(false, false, 0, 1) --Draw Char Profile Box
		if maxabyssMenu > maxItems then
			animDraw(menuArrowUp)
			animUpdate(menuArrowUp)
		end
		if #t_abyssMenu > maxItems and maxabyssMenu < #t_abyssMenu then
			animDraw(menuArrowDown)
			animUpdate(menuArrowDown)
		end
		if confirmScreen then
			f_confirmMenu(txt_abyssConfirmShopBack, jgFnt, 0, 160, 96, 0.7, 0.7, 10, 100)
		else
			drawAbyssInputHints(shop, t_abyssMenu[abyssMenu].sold)
		end
		if commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu') then
			bufd = 0
			bufu = bufu + 1
		elseif commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd') then
			bufu = 0
			bufd = bufd + 1
		else
			bufu = 0
			bufd = 0
		end
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		cmdInput()
		refresh()
	end
end

--;===========================================================
--; ABYSS DATA MESSAGE SCREEN
--;===========================================================
function f_abyssDatMessage(mode, slot)
	cmdInput()
	local lastTxt = ""
	local option = nil
	if not abyssDatComplete then
	--Cursor Position
		if commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u') then
			sndPlay(sndSys, 100, 0)
			abyssDatConfirm = abyssDatConfirm - 1
		elseif commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd') then
			sndPlay(sndSys, 100, 0)
			abyssDatConfirm = abyssDatConfirm + 1
		end
		if abyssDatConfirm < 1 then
			abyssDatConfirm = 2
		elseif abyssDatConfirm > 2 then
			abyssDatConfirm = 1
		end
	else
		abyssDatConfirm = 2
		lastTxt = "OK"
		option = 2
	end
--Draw Fade BG
	animDraw(fadeWindowBG)
--Draw Menu BG
	animDraw(abyssConfirmWindowBG)
--Draw Title
	if mode == "save" then
		textImgSetText(txt_abyssDatConfirmTitle, "SAVE TO THIS DATA SLOT?")
		if abyssDatOverwrite then textImgSetText(txt_abyssDatConfirmTitle, "OVERWRITE DATA?") end
		if abyssDatComplete then textImgSetText(txt_abyssDatConfirmTitle, "SAVE COMPLETE!") end
	elseif mode == "load" then
		textImgSetText(txt_abyssDatConfirmTitle, "LOAD THIS DATA SLOT?")
	end
	if eraseAbyssDat then
		textImgSetText(txt_abyssDatConfirmTitle, "DELETE THIS DATA SLOT?")
		if abyssDatComplete then textImgSetText(txt_abyssDatConfirmTitle, "DATA WAS DELETED!") end
	end
	textImgDraw(txt_abyssDatConfirmTitle)
--Draw Table Text
	for i=1, #t_confirmMenu do
		if i == abyssDatConfirm then
			bank = 5
		else
			bank = 0
		end
		if not abyssDatComplete then
			option = i
			lastTxt = t_confirmMenu[i].text
		end
		textImgDraw(f_updateTextImg(t_confirmMenu[i].id, jgFnt, bank, 0, lastTxt, 159, 120+option*13))
	end
--Draw Cursor
	animSetWindow(cursorBox, 66.35,123+(abyssDatConfirm-1)*13, 188,13)
	f_dynamicAlpha(cursorBox, 20,100,5, 255,255,0)
	animDraw(f_animVelocity(cursorBox, -1, -1))
--Draw Input Hints Panel
	drawConfirmInputHints()
--Actions
	if esc() or commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then
		sndPlay(sndSys, 100, 2)
		f_abyssDatConfirmReset()
	elseif btnPalNo(p1Cmd, true) > 0 or btnPalNo(p2Cmd, true) > 0 then
	--YES
		if abyssDatConfirm == 1 then
			sndPlay(sndSys, 100, 1)
		--Delete Data (Replace data with default empty slot)
			if eraseAbyssDat then
				f_transferData(abyssDat.default, abyssDat.save[slot])
				f_saveAbyss()
				abyssDatComplete = true
			else
			--Save Data (Replace Slot Data with No save Data)
				if mode == "save" then
					f_transferData(abyssDat.nosave, abyssDat.save[slot])
					f_saveAbyss()
					abyssDatComplete = true
			--Load Data (Replace No Save Temp data with Slot Selected Data)
				else
					f_transferData(abyssDat.save[slot], abyssDat.nosave)
					f_saveAbyss()
					abyssDatEnd = true
					loadAbyssDat = true
				end
			end
	--NO/OK
		else
			sndPlay(sndSys, 100, 2)
			abyssDatEnd = true
			eraseAbyssDat = false
		end
	end
	if abyssDatEnd then f_abyssDatConfirmReset() end
end

function f_abyssDatConfirmReset()
	abyssDatConfirmScreen = false
	abyssDatConfirm = 2 --Cursor pos in NO
	abyssDatEnd = false
	abyssDatComplete = false
	abyssDatOverwrite = false
	eraseAbyssDat = false
end

--;===========================================================
--; ABYSS SAVE/LOAD MENU SCREEN
--;===========================================================
function f_abyssData(mode)
	cmdInput()
	local bufu = 0
	local bufd = 0
	local bufr = 0
	local bufl = 0
	local dataSel = 1
	local cursorPosY = 1
	local moveSlot = 0
	local maxItems = 2
	local done = false
	local t_data = abyssDat.save
	local menuMode = mode --It can be "save" or "load"
	local txt_menuTitle = ""
	loadAbyssDat = false
	if menuMode == "save" then
		txt_menuTitle = "SAVE DATA"
		playBGM(bgmAbyss)
	else
		txt_menuTitle = "LOAD DATA"
	end
	f_resetAbyssDatArrowsPos()
	f_abyssDatConfirmReset()
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	while true do
		if not abyssDatConfirmScreen then
			if done or loadAbyssDat then
				data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
				break
			end
		--Scroll Logic
			if commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u') or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30) then
				sndPlay(sndSys, 100, 0)
				dataSel = dataSel - 1
			elseif commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd') or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30) then
				sndPlay(sndSys, 100, 0)
				dataSel = dataSel + 1
		--Data Select
			elseif (btnPalNo(p1Cmd, true) > 0 or btnPalNo(p2Cmd, true) > 0) then
			--NO DATA TO LOAD
				if not abyssDat.save[dataSel].player and menuMode == "load" then
					sndPlay(sndIkemen, 200, 0)
			--DATA AVAILABLE TO SAVE/LOAD
				else
					sndPlay(sndSys, 100, 1)
					abyssDatConfirmScreen = true
				end
		--Delete Saved Data
			elseif commandGetState(p1Cmd, 'q') or commandGetState(p2Cmd, 'q') then	
			--NO DATA TO DELETE
				if not abyssDat.save[dataSel].player then
					sndPlay(sndIkemen, 200, 0)
			--DATA AVAILABLE TO DELETE
				else
					sndPlay(sndSys, 100, 1)
					eraseAbyssDat = true
					abyssDatConfirmScreen = true
				end
		--Close Menu
			elseif esc() or commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then
				sndPlay(sndSys, 100, 2)
				done = true
			end
			if dataSel < 1 then
				dataSel = #t_data
				if #t_data > maxItems then
					cursorPosY = maxItems
				else
					cursorPosY = #t_data
				end
			elseif dataSel > #t_data then
				dataSel = 1
				cursorPosY = 1
			elseif ((commandGetState(p1Cmd, 'u') or commandGetState(p2Cmd, 'u')) or ((commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu')) and bufu >= 30)) and cursorPosY > 1 then
				cursorPosY = cursorPosY - 1
			elseif ((commandGetState(p1Cmd, 'd') or commandGetState(p2Cmd, 'd')) or ((commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd')) and bufd >= 30)) and cursorPosY < maxItems then
				cursorPosY = cursorPosY + 1
			end
			if cursorPosY == maxItems then
				moveSlot = (dataSel - maxItems) * 105
			elseif cursorPosY == 1 then
				moveSlot = (dataSel - 1) * 105
			end	
			if #t_data <= maxItems then
				maxdataSel = #t_data
			elseif dataSel - cursorPosY > 0 then
				maxdataSel = dataSel + maxItems - cursorPosY
			else
				maxdataSel = maxItems
			end
		end
	--Draw BG
		animDraw(abyssBG)
		animDraw(f_animVelocity(abyssFog, -1, -1))
	--Draw Title
		textImgSetText(txt_abyssDatTitle, txt_menuTitle)
		textImgDraw(txt_abyssDatTitle)
		for slot=1, maxdataSel do
			if slot > dataSel - cursorPosY then
				f_abyssDatProfile(0, -120+slot*105-moveSlot, slot, abyssDat.save[slot])
			end
			if slot == dataSel then animPosDraw(abyssDatSlotCursor, 0, 40+(-120+slot*105-moveSlot)) end --Draw Cursor
		end
		if abyssDatConfirmScreen then f_abyssDatMessage(menuMode, dataSel) else drawAbyssDatInputHints() end
		if maxdataSel > maxItems then
			animDraw(menuArrowUp)
			animUpdate(menuArrowUp)
		end
		if #t_data > maxItems and maxdataSel < #t_data then
			animDraw(menuArrowDown)
			animUpdate(menuArrowDown)
		end
		if commandGetState(p1Cmd, 'holdu') or commandGetState(p2Cmd, 'holdu') then
			bufd = 0
			bufu = bufu + 1
		elseif commandGetState(p1Cmd, 'holdd') or commandGetState(p2Cmd, 'holdd') then
			bufu = 0
			bufd = bufd + 1
		else
			bufu = 0
			bufd = 0
		end
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		cmdInput()
		refresh()
	end
end

function f_loadAbyssStats()
	setAbyssLife(abyssDat.nosave.life) --set life points to show during abyss mode profile and which be apply to the player.
	setAbyssPower(abyssDat.nosave.power) --set power points to show during abyss mode profile and which be apply to the player.
	setAbyssAttack(abyssDat.nosave.attack) --set attack points to show during abyss mode profile and which be apply to the player.
	setAbyssDefence(abyssDat.nosave.defence) --set defence points to show during abyss mode profile and which be apply to the player.
	f_setAbyssItems()
	setAbyssReward(abyssDat.nosave.reward) --set reward to show during abyss mode match lifebar.
	setAbyssDepth(abyssDat.nosave.depth) --set depth level to show during abyss mode match lifebar.
	setAbyssDepthBoss(abyssDat.nosave.nextboss) --set next abyss NORMAL boss depth.
	setAbyssDepthBossSpecial(abyssDat.nosave.nextspecialboss) --set next abyss SPECIAL boss depth.
	abyssBossMatch = getAbyssDepthBoss()
	abyssSpecialBossCnt = abyssDat.nosave.specialbosscnt --Start count for Abyss Special Boss Matchs
	--setAbyssBossFight(0) --Set when player is inside abyss boss fight
	setLifePersistence(abyssDat.nosave.lifebarstate) --To store last life bar value when life is maintained after match
	winCnt = abyssDat.nosave.winsCnt --Restore victories
	data.stage = abyssDat.nosave.stage --Restore Last stage
	abyssNextCheckPoint = abyssDat.nosave.nextcheckpoint --Start count for Abyss Map Checkpoints
	--matchNo = getAbyssDepth()
end

--;===========================================================
--; ABYSS MAP MENU
--;===========================================================
function f_abyssMap()
	cmdInput()
	local currentDepth = getAbyssDepth() --From script.ssz
	local nextMultipleOf10 = math.ceil(currentDepth / 10) * 10 --Calculate the next multiple of 10 greater than the current depth
	local checkpoint = false
	local conquest = false
	if matchNo >= lastMatch then --if currentDepth >= lastMatch then
		conquest = true
	elseif currentDepth >= abyssNextCheckPoint then --Show Checkpoint Stuff
		if not loadAbyssDat then
			checkpoint = true
		end
	end
	loadAbyssDat = false
	f_confirmReset()
	data.fadeTitle = f_fadeAnim(MainFadeInTime, 'fadein', 'black', sprFade)
	if conquest or checkpoint then playBGM(bgmAbyss) end
	while true do
		if not confirmScreen then
		--Actions
			if checkpoint and (esc() or commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e')) then
				sndPlay(sndSys, 100, 2)
				confirmScreen = true
		--Continue
			elseif (btnPalNo(p1Cmd, true) > 0 or btnPalNo(p2Cmd, true) > 0) then
				sndPlay(sndSys, 100, 1)
				break
			end
		end
	--Exit from Abyss Via Checkpoint
		if exitAbyss then
			--TODO: Transition from down to up
			break
		end
	--Draw BG
		animPosDraw(abyssMapBG, -118, -currentDepth+16)
		animDraw(f_animVelocity(abyssFog, -1, -1))
	--Draw Depth Stuff
		animDraw(abyssMapDepthBG)
		textImgSetText(txt_abyssMapDepth, "DEPTH "..currentDepth)
		textImgDraw(txt_abyssMapDepth)
	--Draw Depth Levels
		for i=1, 10 do
			local depthLv = nextMultipleOf10 + (i-1)*10
			if depthLv <= t_abyssSel[abyssSel].depth and (currentDepth < depthLv or currentDepth > depthLv) then
				textImgSetText(txt_abyssMapDepthLv, depthLv)
				textImgSetPos(txt_abyssMapDepthLv, 42, 30+i*22)
				textImgDraw(txt_abyssMapDepthLv)
			end
		end
	--Draw Reward Text Stuff
		animDraw(abyssMapRewardBG)
		textImgSetText(txt_abyssMapReward, "REWARD "..getAbyssReward().." IKC")
		textImgDraw(txt_abyssMapReward)
		f_drawQuickText(txt_abyssCurrency, font11, 0, -1, stats.money.." IKC", 315, 30, 1.2, 1.2)
	--Draw Char Profile Box
		f_abyssProfile(false, false, 0, 24)
		if confirmScreen then
			f_confirmMenu(txt_abyssConfirmCheckpoint, jgFnt, 0, 160, 96, 0.65, 0.65, 10, 150)
		else
			drawAbyssMapInputHints(checkpoint)
		end
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		cmdInput()
		refresh()
	end
end

--;===========================================================
--; CREDITS SCREEN (play staff credits)
--;=========================================================== 
function f_playCredits()
	cmdInput()
	sndStop()
	local scroll = 0
	local speed = 0
	local speed1 = 0.5
	local speed2 = 2.2
	local skip = false
	local txtFont = font7--font14
	local txtBank = 0
	local txtAline = 0 --[1]= Align text left | [0]= Center Text | [-1]= Align text right
	local txtSpacing = 12 --spacing between lines (rendering Y position increasement for each line)
	local txtScaleX = 1
	local txtScaleY = 1
	local txtAlphaS = 255
	local txtAlphaD = 0
	local creditsTable = f_extractText(txt_creditsBox) --This returns a table with all text in the same written order
	data.fadeTitle = f_fadeAnim(50, 'fadein', 'black', sprFade)
	if data.rosterMode ~= "story" then playBGM(bgmCredits) end
	while true do
		if scroll > 2600 or commandGetState(p1Cmd, 'e') or commandGetState(p2Cmd, 'e') then break end --Credits Duration
	--Actions
		if (btnPalNo(p1Cmd, true) > 0 or btnPalNo(p2Cmd, true) > 0) then
			if not skip then
				skip = true
			else
				skip = false
			end
		end
		if not skip then speed = speed1 --Normal
		elseif skip then speed = speed2 --Faster
		end
	--Draw Text
		for i = 1, #creditsTable do
			textImgDraw(f_updateTextImg(textImgNew(), txtFont, txtBank, txtAline, creditsTable[i], 155, 260 + txtSpacing * (i - 1) - scroll, txtScaleX, txtScaleY, txtAlphaS, txtAlphaD))
		end
		if data.debugMode then
			f_drawQuickText(speedTest, font14, 0, 1, scroll, 50, 100) --Test Timer
		end
		scroll = scroll + speed
		animDraw(data.fadeTitle)
		animUpdate(data.fadeTitle)
		cmdInput()
		refresh()
	end
--When End
	data.fadeTitle = f_fadeAnim(50, 'fadein', 'black', sprFade)
	if data.attractMode then
		playBGM(bgmTitle)
	elseif data.rosterMode == "arcade" or data.rosterMode == "tower" then
		--Nothing because game over screen comes...
	else
		f_menuMusic()
	end
	if data.intermission then
		f_getIntermission() --Load t_secretChallenger
	--Conditions to enter in secret fight
		if #t_secretChallenger ~= 0 and stats.continueCount == 0 and data.difficulty >= 4 then
			f_intermission()
			f_secretFight()
		end
	end
	f_default()
end
--;===========================================================
--; HD SPRITES SUPPORT WARNING
--;===========================================================
t_sdlWarning = {
	{text = "In this version of I.K.E.M.E.N. ENGINE"},
	{text = "ONLY 8-Bit/Indexed sprites are currently supported."},
}
for i=1, #t_sdlWarning do
	t_sdlWarning[i]['id'] = createTextImg(font2, 0, 0, t_sdlWarning[i].text, 159, 65+i*15)
end
function f_sdlWarning()
	cmdInput()
	while true do
		if btnPalNo(p1Cmd, true) > 0 or btnPalNo(p2Cmd, true) > 0 then
			commandBufReset(p1Cmd)
			commandBufReset(p2Cmd)
			break
		end
		animDraw(f_animVelocity(commonBG0, -1, -1))
		--drawTextTTF("font/TTF/Open_Sans/OpenSans-SemiBoldItalic.ttf", 0, "Hello World from TTF", 160, 300)
		textImgDraw(txt_Warning)
		animSetScale(infoBG, 300, 111)
		animSetWindow(infoBG, 0,70, 296,#t_sdlWarning*15)
		animDraw(infoBG)
		for i=1, #t_sdlWarning do textImgDraw(t_sdlWarning[i].id) end
		drawInfoCfgInputHints()
		cmdInput()
		refresh()
	end
end
--;===========================================================
--; INITIALIZE LOOPS
--;===========================================================
f_loadLuaMods() --Load External Lua Modules
if not data.attractMode then f_sdlWarning() end
f_mainStart() --Start Menu