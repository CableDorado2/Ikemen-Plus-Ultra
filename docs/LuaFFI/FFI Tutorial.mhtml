From: <Saved by Blink>
Snapshot-Content-Location: http://luajit.org/ext_ffi_tutorial.html
Subject: FFI Tutorial
Date: Tue, 21 Oct 2025 11:30:34 -0400
MIME-Version: 1.0
Content-Type: multipart/related;
	type="text/html";
	boundary="----MultipartBoundary--UNHNiFu8N0xyo5auz0AGYNBZU9T1e1kIvASefPuPPz----"


------MultipartBoundary--UNHNiFu8N0xyo5auz0AGYNBZU9T1e1kIvASefPuPPz----
Content-Type: text/html
Content-ID: <frame-C5E63C34960B337CA795C3FC14B6925D@mhtml.blink>
Content-Transfer-Encoding: quoted-printable
Content-Location: http://luajit.org/ext_ffi_tutorial.html

<!DOCTYPE html><html><head><meta http-equiv=3D"Content-Type" content=3D"tex=
t/html; charset=3DUTF-8"><link rel=3D"stylesheet" type=3D"text/css" href=3D=
"cid:css-dec52598-675b-4c4a-b1d3-de615061060e@mhtml.blink" />
<title>FFI Tutorial</title>

<meta name=3D"Copyright" content=3D"Copyright (C) 2005-2025">
<meta name=3D"Language" content=3D"en">
<link rel=3D"stylesheet" type=3D"text/css" href=3D"http://luajit.org/bluequ=
ad.css" media=3D"screen">
<link rel=3D"stylesheet" type=3D"text/css" href=3D"http://luajit.org/bluequ=
ad-print.css" media=3D"print">
<meta name=3D"viewport" content=3D"width=3Ddevice-width, initial-scale=3D1,=
 maximum-scale=3D1.5">


</head>
<body>
<div id=3D"site">
<a href=3D"https://luajit.org/"><span>Lua<span id=3D"logo">JIT</span></span=
></a>
</div>
<div id=3D"head">
<h1>FFI Tutorial</h1>
</div>
<div id=3D"nav">
<ul><li>
<a href=3D"http://luajit.org/index.html">Home</a>
</li><li>
<a href=3D"http://luajit.org/luajit.html">LuaJIT</a>
<ul><li>
<a href=3D"http://luajit.org/download.html">Download =E2=87=A9</a>
</li><li>
<a href=3D"http://luajit.org/install.html">Installation</a>
</li><li>
<a href=3D"http://luajit.org/running.html">Running</a>
</li></ul>
</li><li>
<a href=3D"http://luajit.org/extensions.html">Extensions</a>
<ul><li>
<a href=3D"http://luajit.org/ext_ffi.html">FFI Library</a>
<ul><li>
<a class=3D"current" href=3D"http://luajit.org/ext_ffi_tutorial.html">FFI T=
utorial</a>
</li><li>
<a href=3D"http://luajit.org/ext_ffi_api.html">ffi.* API</a>
</li><li>
<a href=3D"http://luajit.org/ext_ffi_semantics.html">FFI Semantics</a>
</li></ul>
</li><li>
<a href=3D"http://luajit.org/ext_buffer.html">String Buffers</a>
</li><li>
<a href=3D"http://luajit.org/ext_jit.html">jit.* Library</a>
</li><li>
<a href=3D"http://luajit.org/ext_c_api.html">Lua/C API</a>
</li><li>
<a href=3D"http://luajit.org/ext_profiler.html">Profiler</a>
</li></ul>
</li><li>
<a href=3D"http://luajit.org/status.html">Status</a>
</li><li>
<a href=3D"http://luajit.org/faq.html">FAQ</a>
</li><li>
<a href=3D"http://luajit.org/list.html">Mailing List</a>
</li><li>
<a href=3D"http://luajit.org/sponsors.html">Sponsors</a>
</li></ul>
</div>
<div id=3D"main">
<p>
This page is intended to give you an overview of the features of the FFI
library by presenting a few use cases and guidelines.
</p>
<p>
This page makes no attempt to explain all of the FFI library, though.
You'll want to have a look at the <a href=3D"http://luajit.org/ext_ffi_api.=
html">ffi.* API
function reference</a> and the <a href=3D"http://luajit.org/ext_ffi_semanti=
cs.html">FFI
semantics</a> to learn more.
</p>

<h2 id=3D"load">Loading the FFI Library</h2>
<p>
The FFI library is built into LuaJIT by default, but it's not loaded
and initialized by default. The suggested way to use the FFI library
is to add the following to the start of every Lua file that needs one
of its functions:
</p>
<pre class=3D"code">local ffi =3D require("ffi")
</pre>
<p>
Please note, this doesn't define an <tt>ffi</tt> variable in the table
of globals =E2=80=94 you really need to use the local variable. The
<tt>require</tt> function ensures the library is only loaded once.
</p>
<p style=3D"font-size: 8pt;">
Note: If you want to experiment with the FFI from the interactive prompt
of the command line executable, omit the <tt>local</tt>, as it doesn't
preserve local variables across lines.
</p>

<h2 id=3D"sleep">Accessing Standard System Functions</h2>
<p>
The following code explains how to access standard system functions.
We slowly print two lines of dots by sleeping for 10&nbsp;milliseconds
after each dot:
</p>
<pre class=3D"code mark"><span class=3D"codemark">&nbsp;
=E2=91=A0





=E2=91=A1
=E2=91=A2
=E2=91=A3



=E2=91=A4





=E2=91=A5</span>local ffi =3D require("ffi")
ffi.cdef[[
<span style=3D"color:#00a000;">void Sleep(int ms);
int poll(struct pollfd *fds, unsigned long nfds, int timeout);</span>
]]

local sleep
if ffi.os =3D=3D "Windows" then
  function sleep(s)
    ffi.C.Sleep(s*1000)
  end
else
  function sleep(s)
    ffi.C.poll(nil, 0, s*1000)
  end
end

for i=3D1,160 do
  io.write("."); io.flush()
  sleep(0.01)
end
io.write("\n")
</pre>
<p>
Here's the step-by-step explanation:
</p>
<p>
<span class=3D"mark">=E2=91=A0</span> This defines the
C&nbsp;library functions we're going to use. The part inside the
double-brackets (in green) is just standard C&nbsp;syntax. You can
usually get this info from the C&nbsp;header files or the
documentation provided by each C&nbsp;library or C&nbsp;compiler.
</p>
<p>
<span class=3D"mark">=E2=91=A1</span> The difficulty we're
facing here, is that there are different standards to choose from.
Windows has a simple <tt>Sleep()</tt> function. On other systems there
are a variety of functions available to achieve sub-second sleeps, but
with no clear consensus. Thankfully <tt>poll()</tt> can be used for
this task, too, and it's present on most non-Windows systems. The
check for <tt>ffi.os</tt> makes sure we use the Windows-specific
function only on Windows systems.
</p>
<p>
<span class=3D"mark">=E2=91=A2</span> Here we're wrapping the
call to the C&nbsp;function in a Lua function. This isn't strictly
necessary, but it's helpful to deal with system-specific issues only
in one part of the code. The way we're wrapping it ensures the check
for the OS is only done during initialization and not for every call.
</p>
<p>
<span class=3D"mark">=E2=91=A3</span> A more subtle point is
that we defined our <tt>sleep()</tt> function (for the sake of this
example) as taking the number of seconds, but accepting fractional
seconds. Multiplying this by 1000 gets us milliseconds, but that still
leaves it a Lua number, which is a floating-point value. Alas, the
<tt>Sleep()</tt> function only accepts an integer value. Luckily for
us, the FFI library automatically performs the conversion when calling
the function (truncating the FP value towards zero, like in C).
</p>
<p style=3D"font-size: 8pt;">
Some readers will notice that <tt>Sleep()</tt> is part of
<tt>KERNEL32.DLL</tt> and is also a <tt>stdcall</tt> function. So how
can this possibly work? The FFI library provides the <tt>ffi.C</tt>
default C&nbsp;library namespace, which allows calling functions from
the default set of libraries, like a C&nbsp;compiler would. Also, the
FFI library automatically detects <tt>stdcall</tt> functions, so you
don't need to declare them as such.
</p>
<p>
<span class=3D"mark">=E2=91=A4</span> The <tt>poll()</tt>
function takes a couple more arguments we're not going to use. You can
simply use <tt>nil</tt> to pass a <tt>NULL</tt> pointer and <tt>0</tt>
for the <tt>nfds</tt> parameter. Please note, that the
number&nbsp;<tt>0</tt> <em>does not convert to a pointer value</em>,
unlike in C++. You really have to pass pointers to pointer arguments
and numbers to number arguments.
</p>
<p style=3D"font-size: 8pt;">
The page on <a href=3D"http://luajit.org/ext_ffi_semantics.html">FFI semant=
ics</a> has all
of the gory details about
<a href=3D"http://luajit.org/ext_ffi_semantics.html#convert">conversions be=
tween Lua
objects and C&nbsp;types</a>. For the most part you don't have to deal
with this, as it's performed automatically and it's carefully designed
to bridge the semantic differences between Lua and C.
</p>
<p>
<span class=3D"mark">=E2=91=A5</span> Now that we have defined
our own <tt>sleep()</tt> function, we can just call it from plain Lua
code. That wasn't so bad, huh? Turning these boring animated dots into
a fascinating best-selling game is left as an exercise for the reader.
:-)
</p>

<h2 id=3D"zlib">Accessing the zlib Compression Library</h2>
<p>
The following code shows how to access the <a href=3D"https://zlib.net/">zl=
ib</a> compression library from Lua code.
We'll define two convenience wrapper functions that take a string and
compress or uncompress it to another string:
</p>
<pre class=3D"code mark"><span class=3D"codemark">&nbsp;
=E2=91=A0






=E2=91=A1


=E2=91=A2

=E2=91=A3


=E2=91=A4


=E2=91=A5







=E2=91=A6</span>local ffi =3D require("ffi")
ffi.cdef[[
<span style=3D"color:#00a000;">unsigned long compressBound(unsigned long so=
urceLen);
int compress2(uint8_t *dest, unsigned long *destLen,
	      const uint8_t *source, unsigned long sourceLen, int level);
int uncompress(uint8_t *dest, unsigned long *destLen,
	       const uint8_t *source, unsigned long sourceLen);</span>
]]
local zlib =3D ffi.load(ffi.os =3D=3D "Windows" and "zlib1" or "z")

local function compress(txt)
  local n =3D zlib.compressBound(#txt)
  local buf =3D ffi.new("uint8_t[?]", n)
  local buflen =3D ffi.new("unsigned long[1]", n)
  local res =3D zlib.compress2(buf, buflen, txt, #txt, 9)
  assert(res =3D=3D 0)
  return ffi.string(buf, buflen[0])
end

local function uncompress(comp, n)
  local buf =3D ffi.new("uint8_t[?]", n)
  local buflen =3D ffi.new("unsigned long[1]", n)
  local res =3D zlib.uncompress(buf, buflen, comp, #comp)
  assert(res =3D=3D 0)
  return ffi.string(buf, buflen[0])
end

-- Simple test code.
local txt =3D string.rep("abcd", 1000)
print("Uncompressed size: ", #txt)
local c =3D compress(txt)
print("Compressed size: ", #c)
local txt2 =3D uncompress(c, #txt)
assert(txt2 =3D=3D txt)
</pre>
<p>
Here's the step-by-step explanation:
</p>
<p>
<span class=3D"mark">=E2=91=A0</span> This defines some of the
C&nbsp;functions provided by zlib. For the sake of this example, some
type indirections have been reduced and it uses the predefined
fixed-size integer types, while still adhering to the zlib API/ABI.
</p>
<p>
<span class=3D"mark">=E2=91=A1</span> This loads the zlib shared
library. On POSIX systems, it's named <tt>libz.so</tt> and usually
comes pre-installed. Since <tt>ffi.load()</tt> automatically adds any
missing standard prefixes/suffixes, we can simply load the
<tt>"z"</tt> library. On Windows it's named <tt>zlib1.dll</tt> and
you'll have to download it first from the
<a href=3D"https://zlib.net/">zlib site</a>. The check for
<tt>ffi.os</tt> makes sure we pass the right name to
<tt>ffi.load()</tt>.
</p>
<p>
<span class=3D"mark">=E2=91=A2</span> First, the maximum size of
the compression buffer is obtained by calling the
<tt>zlib.compressBound</tt> function with the length of the
uncompressed string. The next line allocates a byte buffer of this
size. The <tt>[?]</tt> in the type specification indicates a
variable-length array (VLA). The actual number of elements of this
array is given as the 2nd argument to <tt>ffi.new()</tt>.
</p>
<p>
<span class=3D"mark">=E2=91=A3</span> This may look strange at
first, but have a look at the declaration of the <tt>compress2</tt>
function from zlib: the destination length is defined as a pointer!
This is because you pass in the maximum buffer size and get back the
actual length that was used.
</p>
<p>
In C you'd pass in the address of a local variable
(<tt>&amp;buflen</tt>). But since there's no address-of operator in
Lua, we'll just pass in a one-element array. Conveniently, it can be
initialized with the maximum buffer size in one step. Calling the
actual <tt>zlib.compress2</tt> function is then straightforward.
</p>
<p>
<span class=3D"mark">=E2=91=A4</span> We want to return the
compressed data as a Lua string, so we'll use <tt>ffi.string()</tt>.
It needs a pointer to the start of the data and the actual length. The
length has been returned in the <tt>buflen</tt> array, so we'll just
get it from there.
</p>
<p style=3D"font-size: 8pt;">
Note that since the function returns now, the <tt>buf</tt> and
<tt>buflen</tt> variables will eventually be garbage collected. This
is fine, because <tt>ffi.string()</tt> has copied the contents to a
newly created (interned) Lua string. If you plan to call this function
lots of times, consider reusing the buffers and/or handing back the
results in buffers instead of strings. This will reduce the overhead
for garbage collection and string interning.
</p>
<p>
<span class=3D"mark">=E2=91=A5</span> The <tt>uncompress</tt>
functions does the exact opposite of the <tt>compress</tt> function.
The compressed data doesn't include the size of the original string,
so this needs to be passed in. Otherwise, no surprises here.
</p>
<p>
<span class=3D"mark">=E2=91=A6</span> The code, that makes use
of the functions we just defined, is just plain Lua code. It doesn't
need to know anything about the LuaJIT FFI =E2=80=94 the convenience
wrapper functions completely hide it.
</p>
<p>
One major advantage of the LuaJIT FFI is that you are now able to
write those wrappers <em>in Lua</em>. And at a fraction of the time it
would cost you to create an extra C&nbsp;module using the Lua/C API.
Many of the simpler C&nbsp;functions can probably be used directly
from your Lua code, without any wrappers.
</p>
<p style=3D"font-size: 8pt;">
Side note: the zlib API uses the <tt>long</tt> type for passing
lengths and sizes around. But all those zlib functions actually only
deal with 32&nbsp;bit values. This is an unfortunate choice for a
public API, but may be explained by zlib's history =E2=80=94 we'll just
have to deal with it.
</p>
<p style=3D"font-size: 8pt;">
First, you should know that a <tt>long</tt> is a 64&nbsp;bit type e.g.
on POSIX/x64 systems, but a 32&nbsp;bit type on Windows/x64 and on
32&nbsp;bit systems. Thus a <tt>long</tt> result can be either a plain
Lua number or a boxed 64&nbsp;bit integer cdata object, depending on
the target system.
</p>
<p style=3D"font-size: 8pt;">
Ok, so the <tt>ffi.*</tt> functions generally accept cdata objects
wherever you'd want to use a number. That's why we get a away with
passing <tt>n</tt> to <tt>ffi.string()</tt> above. But other Lua
library functions or modules don't know how to deal with this. So for
maximum portability, one needs to use <tt>tonumber()</tt> on returned
<tt>long</tt> results before passing them on. Otherwise the
application might work on some systems, but would fail in a POSIX/x64
environment.
</p>

<h2 id=3D"metatype">Defining Metamethods for a C&nbsp;Type</h2>
<p>
The following code explains how to define metamethods for a C type.
We define a simple point type and add some operations to it:
</p>
<pre class=3D"code mark"><span class=3D"codemark">&nbsp;
=E2=91=A0



=E2=91=A1

=E2=91=A2

=E2=91=A3



=E2=91=A4

=E2=91=A5</span>local ffi =3D require("ffi")
ffi.cdef[[
<span style=3D"color:#00a000;">typedef struct { double x, y; } point_t;</sp=
an>
]]

local point
local mt =3D {
  __add =3D function(a, b) return point(a.x+b.x, a.y+b.y) end,
  __len =3D function(a) return math.sqrt(a.x*a.x + a.y*a.y) end,
  __index =3D {
    area =3D function(a) return a.x*a.x + a.y*a.y end,
  },
}
point =3D ffi.metatype("point_t", mt)

local a =3D point(3, 4)
print(a.x, a.y)  --&gt; 3  4
print(#a)        --&gt; 5
print(a:area())  --&gt; 25
local b =3D a + point(0.5, 8)
print(#b)        --&gt; 12.5
</pre>
<p>
Here's the step-by-step explanation:
</p>
<p>
<span class=3D"mark">=E2=91=A0</span> This defines the C&nbsp;type for a
two-dimensional point object.
</p>
<p>
<span class=3D"mark">=E2=91=A1</span> We have to declare the variable
holding the point constructor first, because it's used inside of a
metamethod.
</p>
<p>
<span class=3D"mark">=E2=91=A2</span> Let's define an <tt>__add</tt>
metamethod which adds the coordinates of two points and creates a new
point object. For simplicity, this function assumes that both arguments
are points. But it could be any mix of objects, if at least one operand
is of the required type (e.g. adding a point plus a number or vice
versa). Our <tt>__len</tt> metamethod returns the distance of a point to
the origin.
</p>
<p>
<span class=3D"mark">=E2=91=A3</span> If we run out of operators, we can
define named methods, too. Here, the <tt>__index</tt> table defines an
<tt>area</tt> function. For custom indexing needs, one might want to
define <tt>__index</tt> and <tt>__newindex</tt> <em>functions</em> instead.
</p>
<p>
<span class=3D"mark">=E2=91=A4</span> This associates the metamethods with
our C&nbsp;type. This only needs to be done once. For convenience, a
constructor is returned by
<a href=3D"http://luajit.org/ext_ffi_api.html#ffi_metatype"><tt>ffi.metatyp=
e()</tt></a>.
We're not required to use it, though. The original C&nbsp;type can still
be used e.g. to create an array of points. The metamethods automatically
apply to any and all uses of this type.
</p>
<p>
Please note, that the association with a metatable is permanent and
<b>the metatable must not be modified afterwards!</b> Ditto for the
<tt>__index</tt> table.
</p>
<p>
<span class=3D"mark">=E2=91=A5</span> Here are some simple usage examples
for the point type and their expected results. The predefined
operations (such as <tt>a.x</tt>) can be freely mixed with the newly
defined metamethods. Note that <tt>area</tt> is a method and must be
called with the Lua syntax for methods: <tt>a:area()</tt>, not
<tt>a.area()</tt>.
</p>
<p>
The C&nbsp;type metamethod mechanism is most useful when used in
conjunction with C&nbsp;libraries that are written in an object-oriented
style. Creators return a pointer to a new instance, and methods take an
instance pointer as the first argument. Sometimes you can just point
<tt>__index</tt> to the library namespace and <tt>__gc</tt> to the
destructor and you're done. But often enough you'll want to add
convenience wrappers, e.g. to return actual Lua strings or when
returning multiple values.
</p>
<p>
Some C libraries only declare instance pointers as an opaque
<tt>void&nbsp;*</tt> type. In this case you can use a fake type for all
declarations, e.g. a pointer to a named (incomplete) struct will do:
<tt>typedef struct foo_type *foo_handle</tt>. The C&nbsp;side doesn't
know what you declare with the LuaJIT FFI, but as long as the underlying
types are compatible, everything still works.
</p>

<h2 id=3D"idioms">Translating C&nbsp;Idioms</h2>
<p>
Here's a list of common C&nbsp;idioms and their translation to the
LuaJIT FFI:
</p>
<table class=3D"idiomtable">
<tbody><tr class=3D"idiomhead">
<td class=3D"idiomdesc">Idiom</td>
<td class=3D"idiomc">C&nbsp;code</td>
<td class=3D"idiomlua">Lua code</td>
</tr>
<tr class=3D"odd separate">
<td class=3D"idiomdesc">Pointer dereference<br><tt>int *p;</tt></td><td cla=
ss=3D"idiomc"><tt>x =3D *p;<br>*p =3D y;</tt></td><td class=3D"idiomlua"><t=
t>x =3D <b>p[0]</b><br><b>p[0]</b> =3D y</tt></td></tr>
<tr class=3D"even">
<td class=3D"idiomdesc">Pointer indexing<br><tt>int i, *p;</tt></td><td cla=
ss=3D"idiomc"><tt>x =3D p[i];<br>p[i+1] =3D y;</tt></td><td class=3D"idioml=
ua"><tt>x =3D p[i]<br>p[i+1] =3D y</tt></td></tr>
<tr class=3D"odd">
<td class=3D"idiomdesc">Array indexing<br><tt>int i, a[];</tt></td><td clas=
s=3D"idiomc"><tt>x =3D a[i];<br>a[i+1] =3D y;</tt></td><td class=3D"idiomlu=
a"><tt>x =3D a[i]<br>a[i+1] =3D y</tt></td></tr>
<tr class=3D"even separate">
<td class=3D"idiomdesc"><tt>struct</tt>/<tt>union</tt> dereference<br><tt>s=
truct foo s;</tt></td><td class=3D"idiomc"><tt>x =3D s.field;<br>s.field =
=3D y;</tt></td><td class=3D"idiomlua"><tt>x =3D s.field<br>s.field =3D y</=
tt></td></tr>
<tr class=3D"odd">
<td class=3D"idiomdesc"><tt>struct</tt>/<tt>union</tt> pointer deref.<br><t=
t>struct foo *sp;</tt></td><td class=3D"idiomc"><tt>x =3D sp-&gt;field;<br>=
sp-&gt;field =3D y;</tt></td><td class=3D"idiomlua"><tt>x =3D <b>s.field</b=
><br><b>s.field</b> =3D y</tt></td></tr>
<tr class=3D"even separate">
<td class=3D"idiomdesc">Pointer arithmetic<br><tt>int i, *p;</tt></td><td c=
lass=3D"idiomc"><tt>x =3D p + i;<br>y =3D p - i;</tt></td><td class=3D"idio=
mlua"><tt>x =3D p + i<br>y =3D p - i</tt></td></tr>
<tr class=3D"odd">
<td class=3D"idiomdesc">Pointer difference<br><tt>int *p1, *p2;</tt></td><t=
d class=3D"idiomc"><tt>x =3D p1 - p2;</tt></td><td class=3D"idiomlua"><tt>x=
 =3D p1 - p2</tt></td></tr>
<tr class=3D"even">
<td class=3D"idiomdesc">Array element pointer<br><tt>int i, a[];</tt></td><=
td class=3D"idiomc"><tt>x =3D &amp;a[i];</tt></td><td class=3D"idiomlua"><t=
t>x =3D <b>a+i</b></tt></td></tr>
<tr class=3D"odd">
<td class=3D"idiomdesc">Cast pointer to address<br><tt>int *p;</tt></td><td=
 class=3D"idiomc"><tt>x =3D (intptr_t)p;</tt></td><td class=3D"idiomlua"><t=
t>x =3D <b>tonumber(<br>&nbsp;ffi.cast("intptr_t",<br>&nbsp;&nbsp;&nbsp;&nb=
sp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p))</b></tt></td></tr>
<tr class=3D"even separate">
<td class=3D"idiomdesc">Functions with outargs<br><tt>void foo(int *inoutle=
n);</tt></td><td class=3D"idiomc"><tt>int len =3D x;<br>foo(&amp;len);<br>y=
 =3D len;</tt></td><td class=3D"idiomlua"><tt><b>local len =3D<br>&nbsp;&nb=
sp;ffi.new("int[1]", x)<br>foo(len)<br>y =3D len[0]</b></tt></td></tr>
<tr class=3D"odd">
<td class=3D"idiomdesc"><a href=3D"http://luajit.org/ext_ffi_semantics.html=
#convert_vararg">Vararg conversions</a><br><tt>int printf(char *fmt, ...);<=
/tt></td><td class=3D"idiomc"><tt>printf("%g", 1.0);<br>printf("%d", 1);<br=
>&nbsp;</tt></td><td class=3D"idiomlua"><tt>printf("%g", 1);<br>printf("%d"=
,<br>&nbsp;&nbsp;<b>ffi.new("int", 1)</b>)</tt></td></tr>
</tbody></table>

<h2 id=3D"cache">To Cache or Not to Cache</h2>
<p>
It's a common Lua idiom to cache library functions in local variables
or upvalues, e.g.:
</p>
<pre class=3D"code">local byte, char =3D string.byte, string.char
local function foo(x)
  return char(byte(x)+1)
end
</pre>
<p>
This replaces several hash-table lookups with a (faster) direct use of
a local or an upvalue. This is less important with LuaJIT, since the
JIT compiler optimizes hash-table lookups a lot and is even able to
hoist most of them out of the inner loops. It can't eliminate
<em>all</em> of them, though, and it saves some typing for often-used
functions. So there's still a place for this, even with LuaJIT.
</p>
<p>
The situation is a bit different with C&nbsp;function calls via the
FFI library. The JIT compiler has special logic to eliminate <em>all
of the lookup overhead</em> for functions resolved from a
<a href=3D"http://luajit.org/ext_ffi_semantics.html#clib">C&nbsp;library na=
mespace</a>!
Thus it's not helpful and actually counter-productive to cache
individual C&nbsp;functions like this:
</p>
<pre class=3D"code">local <b>funca</b>, <b>funcb</b> =3D ffi.C.funca, ffi.C=
.funcb -- <span style=3D"color:#c00000;">Not helpful!</span>
local function foo(x, n)
  for i=3D1,n do <b>funcb</b>(<b>funca</b>(x, i), 1) end
end
</pre>
<p>
This turns them into indirect calls and generates bigger and slower
machine code. Instead, you'll want to cache the namespace itself and
rely on the JIT compiler to eliminate the lookups:
</p>
<pre class=3D"code">local <b>C</b> =3D ffi.C          -- <span style=3D"col=
or:#00a000;">Instead use this!</span>
local function foo(x, n)
  for i=3D1,n do <b>C.funcb</b>(<b>C.funca</b>(x, i), 1) end
end
</pre>
<p>
This generates both shorter and faster code. So <b>don't cache
C&nbsp;functions</b>, but <b>do</b> cache namespaces! Most often the
namespace is already in a local variable at an outer scope, e.g. from
<tt>local&nbsp;lib&nbsp;=3D&nbsp;ffi.load(...)</tt>. Note that copying
it to a local variable in the function scope is unnecessary.
</p>
<br class=3D"flush">
</div>
<div id=3D"foot">
<hr class=3D"hide">
Copyright =C2=A9 2005-2025
<span class=3D"noprint">
=C2=B7
<a href=3D"http://luajit.org/contact.html">Contact =E2=80=93 IMPRESSUM</a>
</span>
</div>


</body></html>
------MultipartBoundary--UNHNiFu8N0xyo5auz0AGYNBZU9T1e1kIvASefPuPPz----
Content-Type: text/css
Content-Transfer-Encoding: quoted-printable
Content-Location: http://luajit.org/bluequad-print.css

@charset "utf-8";

body { font-family: serif; font-size: 11pt; margin: 0px 3em; padding: 0px; =
border: none; }

a:link, a:visited, a:hover, a:active { text-decoration: none; background: t=
ransparent; color: rgb(0, 0, 255); }

h1, h2, h3 { font-family: sans-serif; font-weight: bold; text-align: left; =
margin: 0.5em 0px; padding: 0px; }

h1 { font-size: 200%; }

h2 { font-size: 150%; }

h3 { font-size: 125%; }

p { margin: 0px 0px 0.5em; padding: 0px; }

ul, ol { margin: 0.5em 0px; padding: 0px 0px 0px 2em; }

ul { list-style: outside square; }

ol { list-style: outside decimal; }

li { margin: 0px; padding: 0px; }

dl { margin: 1em 0px; padding: 1em; border: 1px solid black; }

dt { font-weight: bold; margin: 0px; padding: 0px; }

dt sup { float: right; margin-left: 1em; }

dd { margin: 0.5em 0px 0px 2em; padding: 0px; }

table { table-layout: fixed; width: 100%; margin: 1em 0px; padding: 0px; bo=
rder: 1px solid black; border-spacing: 0px; border-collapse: collapse; }

tr { margin: 0px; padding: 0px; border: none; }

td { text-align: left; margin: 0px; padding: 0.2em 0.5em; border-top: 1px s=
olid black; border-bottom: 1px solid black; }

tr.separate td { border-top: double; }

tt, pre, code, kbd, samp { font-family: monospace; font-size: 75%; }

kbd { font-weight: bolder; }

blockquote, pre { margin: 1em 2em; padding: 0px; }

img { border: none; vertical-align: baseline; margin: 0px; padding: 0px; }

img.left { float: left; margin: 0.5em 1em 0.5em 0px; }

img.right { float: right; margin: 0.5em 0px 0.5em 1em; }

.flush { clear: both; visibility: hidden; }

.hide, .noprint, #nav { display: none !important; }

.pagebreak { break-before: page; }

#site { text-align: right; font-family: sans-serif; font-weight: bold; marg=
in: 0px 1em; border-bottom: 1pt solid black; }

#site a { font-size: 1.2em; }

#site a:link, #site a:visited { text-decoration: none; font-weight: bold; b=
ackground: transparent; color: rgb(255, 255, 255); }

#logo { color: rgb(255, 128, 0); }

#head { clear: both; margin: 0px 1em; }

#main { line-height: 1.3; text-align: justify; margin: 1em; }

#foot { clear: both; font-size: 80%; text-align: center; margin: 0px 1.25em=
; padding: 0.5em 0px 0px; border-top: 1pt solid black; break-before: avoid;=
 break-after: avoid; }
------MultipartBoundary--UNHNiFu8N0xyo5auz0AGYNBZU9T1e1kIvASefPuPPz----
Content-Type: text/css
Content-Transfer-Encoding: quoted-printable
Content-Location: http://luajit.org/bluequad.css

@charset "utf-8";

body { font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 10pt;=
 margin: 0px; padding: 0px; border: none; background: rgb(224, 224, 224); c=
olor: rgb(0, 0, 0); }

a:link { text-decoration: none; background: transparent; color: rgb(33, 66,=
 191); }

a:visited { text-decoration: none; background: transparent; color: rgb(129,=
 34, 191); }

a:hover, a:active { text-decoration: underline; background: transparent; co=
lor: rgb(255, 0, 0); }

h1, h2, h3 { font-weight: bold; text-align: left; margin: 0.5em 0px; paddin=
g: 0px; background: transparent; }

h1 { font-size: 200%; line-height: 3em; margin: 0px; }

h2 { font-size: 150%; color: rgb(96, 96, 96); }

h3 { font-size: 125%; color: rgb(64, 64, 64); }

p { max-width: 600px; margin: 0px 0px 0.5em; padding: 0px; }

b { color: rgb(64, 64, 64); }

ul, ol { max-width: 600px; margin: 0.5em 0px; padding: 0px 0px 0px 2em; }

ul { list-style: outside square; }

ol { list-style: outside decimal; }

li { margin: 0px; padding: 0px; }

dl { max-width: 600px; margin: 1em 0px; padding: 1em; border: 1px solid rgb=
(191, 207, 255); background: rgb(240, 244, 255); }

dt { font-weight: bold; margin: 0px; padding: 0px; }

dt sup { float: right; margin-left: 1em; color: rgb(128, 128, 128); }

dt a:visited { text-decoration: none; color: rgb(33, 66, 191); }

dt a:hover, dt a:active { text-decoration: none; color: rgb(255, 0, 0); }

dd { margin: 0.5em 0px 0px 2em; padding: 0px; }

div.tablewrap { max-width: 600px; }

table { table-layout: fixed; border-spacing: 0px; border-collapse: collapse=
; max-width: 600px; width: 100%; margin: 1em 0px; padding: 0px; border: 1px=
 solid rgb(191, 207, 255); }

tr { margin: 0px; padding: 0px; border: none; }

tr.odd { background: rgb(240, 244, 255); }

tr.separate td { border-top: 1px solid rgb(191, 207, 255); }

td { text-align: left; margin: 0px; padding: 0.2em 0.5em; border: none; }

tt, code, kbd, samp { font-family: "Courier New", Courier, monospace; line-=
height: 1.2; font-size: 110%; }

kbd { font-weight: bolder; }

blockquote, pre { max-width: 600px; margin: 1em 2em; padding: 0px; }

pre { line-height: 1.1; }

pre.code { line-height: 1.4; margin: 0.5em 0px 1em 0.5em; padding: 0.5em 1e=
m; border: 1px solid rgb(191, 207, 255); background: rgb(240, 244, 255); }

pre.mark { padding-left: 2em; }

span.codemark { position: absolute; left: 16em; color: rgb(64, 64, 192); }

span.mark { color: rgb(64, 64, 192); font-family: "Courier New", Courier, m=
onospace; line-height: 1.1; }

img { border: none; vertical-align: baseline; margin: 0px; padding: 0px; }

img.left { float: left; margin: 0.5em 1em 0.5em 0px; }

img.right { float: right; margin: 0.5em 0px 0.5em 1em; }

.indent { padding-left: 1em; }

.flush { clear: both; visibility: hidden; }

.hide, .noscreen { display: none !important; }

.ext { color: rgb(255, 128, 0); }

.note { padding: 0.5em 1em; border-left: 3px solid rgb(191, 207, 255); }

#site { clear: both; float: left; width: 13em; text-align: center; font-wei=
ght: bold; margin: 0px; padding: 0px; background: transparent; color: rgb(2=
55, 255, 255); }

#site a { font-size: 200%; }

#site a:link, #site a:visited { text-decoration: none; font-weight: bold; b=
ackground: transparent; color: rgb(255, 255, 255); }

#site span { line-height: 3em; }

#logo { color: rgb(255, 179, 128); }

#head { margin: 0px; padding: 0px 0px 0px 2em; border-left: 13em solid rgb(=
65, 98, 191); border-right: 3em solid rgb(96, 120, 191); background: rgb(96=
, 120, 191); color: rgb(230, 236, 255); }

#nav { clear: both; float: left; overflow: hidden; text-align: left; line-h=
eight: 1.5; width: 13em; padding-top: 1em; background: transparent; }

#nav ul { list-style: outside none; margin: 0px; padding: 0px; }

#nav li { margin: 0px; padding: 0px; }

#nav a { display: block; text-decoration: none; font-weight: bold; margin: =
0px; padding: 2px 1em; border-top: 1px solid transparent; border-bottom: 1p=
x solid transparent; background: transparent; color: rgb(33, 66, 191); }

#nav a:hover, #nav a:active { text-decoration: none; border-top: 1px solid =
rgb(151, 167, 215); border-bottom: 1px solid rgb(230, 236, 255); background=
: rgb(185, 201, 249); color: rgb(255, 0, 0); }

#nav a.current, #nav a.current:hover, #nav a.current:active { border-top: 1=
px solid rgb(230, 236, 255); border-bottom: 1px solid rgb(151, 167, 215); b=
ackground: rgb(197, 213, 255); color: rgb(33, 66, 191); }

#nav ul ul a { padding: 0px 1em 0px 1.7em; }

#nav ul ul ul a { padding: 0px 0.5em 0px 2.4em; }

#main { line-height: 1.5; text-align: left; margin: 0px; padding: 1em 2em; =
border-left: 13em solid rgb(191, 207, 255); border-right: 3em solid rgb(230=
, 236, 255); background: rgb(230, 236, 255); }

#foot { clear: both; font-size: 80%; text-align: center; margin: 0px; paddi=
ng: 0.5em; background: rgb(96, 120, 191); color: rgb(255, 255, 255); }

#foot a:link, #foot a:visited { text-decoration: underline; background: tra=
nsparent; color: rgb(255, 255, 255); }

#foot a:hover, #foot a:active { text-decoration: underline; background: tra=
nsparent; color: rgb(191, 207, 255); }
------MultipartBoundary--UNHNiFu8N0xyo5auz0AGYNBZU9T1e1kIvASefPuPPz----
Content-Type: text/css
Content-Transfer-Encoding: quoted-printable
Content-Location: cid:css-dec52598-675b-4c4a-b1d3-de615061060e@mhtml.blink

@charset "utf-8";

table.idiomtable { font-size: 90%; line-height: 1.2; }

table.idiomtable tt { font-size: 100%; }

table.idiomtable td { vertical-align: top; }

tr.idiomhead td { font-weight: bold; }

td.idiomlua b { font-weight: normal; color: rgb(33, 66, 191); }
------MultipartBoundary--UNHNiFu8N0xyo5auz0AGYNBZU9T1e1kIvASefPuPPz------
