lib s = <string.ssz>;
lib consts = <consts.ssz>;
lib se = <alpha/sdlevent.ssz>;
lib sdl = <alpha/sdlplugin.ssz>;
lib m = <math.ssz>;
lib sff = "sff.ssz";
lib bg = "bg.ssz";
lib cmd = "command.ssz";
lib fnt = "font.ssz";
lib com = "common.ssz";
lib cfg = "config.ssz";
lib snd = "sound.ssz";
lib chr = "char.ssz";
lib lua = <alpha/lua.ssz>;
lib sys = "system.ssz";
lib sc = "script.ssz";
lib vid = "video.ssz";

^/char listenPort = .cfg.listenPort;
^/char UserName = .cfg.UserName;

.sdl.setVolume(.cfg.GlVol, .cfg.SEVol, .cfg.BGMVol);

public bool keyReset = false, p1PadReset = false, p2PadReset = false;
public int p1PadButtonID = 101, p2PadButtonID = 101;

public &sys.System syst;

public &TextImg
{
  ^/char text;
  ^&.fnt.Font fnt;
  &.sdl.Rect window;
  float winX, winY, winW, winH;
  int bank = 0, align = 0;
  float x = 0.0, y = 0.0;
  float xscl = 1.0, yscl = 1.0;
  int salpha = 255, dalpha = 0;
  float oldScale;
  new()
  {
  `window = .com.scrrect;
  `winX = (float)`window.x;
  `winY = (float)`window.y;
  `winW = (float)`window.w;
  `winH = (float)`window.h;
  `oldScale = .com.WidthScale;
  }
  public void setFont(^&.fnt.Font fo)
  {
    `fnt = fo;
  }
  public void draw()
  {
    if(.se.fskip || #`fnt == 0) ret;
	if(`oldScale != .com.WidthScale) `updateWindow();
    `fnt~drawText(`x, `y, `xscl, `yscl, `bank, `align, `text);
  }
  public float getTextWidth()
  {
    ret (float)(`fnt~textWidth(`text))*`xscl;
  }
  public void setText(^/char t)
  {
    `text = t;
  }
  public void setBank(int b)
  {
    `bank = b;
  }
  public void setAlpha(int as, int ad)
  {
    `salpha = as;
    `dalpha = ad;
  }
  public void setWindow(float x, float y, float w, float h)
  {
    `window.x = (int)((x+(float)(.com.GameWidth-320)/2.0)*.com.WidthScale);
    `window.y = (int)((y+(float)(.com.GameHeight-240))*.com.HeightScale);
    `window.w = (int)(w * .com.WidthScale + 0.5);
    `window.h = (int)(h * .com.HeightScale + 0.5);
    `winX = x;
    `winY = y;
    `winW = w;
    `winH = h;
  }
  public void updateWindow()
  {
    `window.x = (int)((`winX+(float)(.com.GameWidth-320)/2.0)*.com.WidthScale);
    `window.y = (int)((`winY+(float)(.com.GameHeight-240))*.com.HeightScale);
    `window.w = (int)(`winW * .com.WidthScale + 0.5);
    `window.h = (int)(`winH * .com.HeightScale + 0.5);
    `oldScale = .com.WidthScale;
  }
  public void setAlign(int a)
  {
    `align = a;
  }
  public void setPos(float x, float y)
  {
    `x = x;
    `y = y;
  }
  public void addPos(float x, float y)
  {
    `x = `x + x;
    `y = `y + y;
  }
  public void setScale(float x, float y)
  {
    `xscl = x;
    `yscl = y;
  }
}
void textImgNew(&.lua.State L=, int re=)
{
  re = 1;
  ^&.TextImg textImg.new(1);
  L.pushRef(textImg);
}
void textImgGetWidth(&.lua.State L=, int re=)
{
  int argc = 0, nret = 1;
  ^&.TextImg textImg = .sc.refArg!&.TextImg?(L=, re=, argc=, nret);
  if(re < 0) ret; 
  L.pushNumber((double)textImg~getTextWidth());
}
void textImgSetFont(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^&.TextImg textImg = .sc.refArg!&.TextImg?(L=, re=, argc=, nret);
  if(re < 0) ret;
  ^&.sc.Font font = .sc.refArg!&.sc.Font?(L=, re=, argc=, nret);
  if(re < 0) ret;
  textImg~setFont(font~getFont());
}
void textImgSetBank(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^&.TextImg textImg = .sc.refArg!&.TextImg?(L=, re=, argc=, nret);
  if(re < 0) ret;
  int b = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  textImg~setBank(b);
}
void textImgSetAlpha(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^&.TextImg textImg = .sc.refArg!&.TextImg?(L=, re=, argc=, nret);
  if(re < 0) ret;
  int as = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  int ad = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  textImg~setAlpha(as, ad);
}
void textImgSetWindow(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^&.TextImg textImg = .sc.refArg!&.TextImg?(L=, re=, argc=, nret);
  if(re < 0) ret;
  float x = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float y = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float w = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float h = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  textImg~setWindow(x, y, w, h);
}
void textImgSetAlign(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^&.TextImg textImg = .sc.refArg!&.TextImg?(L=, re=, argc=, nret);
  if(re < 0) ret;
  int a = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  textImg~setAlign(a);
}
void textImgSetText(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^&.TextImg textImg = .sc.refArg!&.TextImg?(L=, re=, argc=, nret);
  if(re < 0) ret;
  ^/char text = .sc.strArg(L=, re=, argc=, nret); if(re < 0) ret;
  textImg~setText(text);
}
void textImgSetPos(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^&.TextImg textImg = .sc.refArg!&.TextImg?(L=, re=, argc=, nret);
  if(re < 0) ret;
  float x = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float y = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  textImg~setPos(x, y);
}
void textImgAddPos(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^&.TextImg textImg = .sc.refArg!&.TextImg?(L=, re=, argc=, nret);
  if(re < 0) ret;
  float x = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float y = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  textImg~addPos(x, y);
}
void textImgSetScale(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^&.TextImg textImg = .sc.refArg!&.TextImg?(L=, re=, argc=, nret);
  if(re < 0) ret;
  float x = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float y = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  textImg~setScale(x, y);
}
void textImgDraw(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^&.TextImg textImg = .sc.refArg!&.TextImg?(L=, re=, argc=, nret);
  if(re < 0) ret;
  textImg~draw();
}


public &Anim
{
  ^&.sff.Anim!&.bg.Frame? ani;
  &.sdl.Rect window;
  float winX, winY, winW, winH;
  float x = 0.0, y = 0.0;
  float xscl = 1.0, yscl = 1.0;
  float oldScale;
  new()
  {
    `ani.new(1);
    `ani~mask = 0;
    `window = .com.scrrect;
	`winX = (float)`window.x;
    `winY = (float)`window.y;
    `winW = (float)`window.w;
    `winH = (float)`window.h;
    `oldScale = .com.WidthScale;
  }
  public void setSff(^&.sff.Sff sf)
  {
    `ani~sff = sf;
  }
  public bool setAction(^/char str)
  {
    ^^/char lines = .s.splitLines(str);
    index i = 0;
    &.bg.Action act;
    act.read(lines, i=);
    `ani~reset();
    `ani~setFrames(act.frames, act.loopstart);
    ret #act.frames > 0;
  }
  public int animTime()
  {
    ret `ani~animTime();
  }
  public void update()
  {
    `ani~action();
  }
  public void reset()
  {
    `ani~reset();
  }
  public void draw()
  {
    if(.se.fskip) ret;
	if(`oldScale != .com.WidthScale) `updateWindow();
    `ani~draw(
      `window=, `x + (float)(.com.GameWidth-320)/2.0,
      `y + (float)(.com.GameHeight-240), 1.0, 1.0,
      `xscl, `xscl, `yscl, 0.0, 0.0, .consts.null!&.com.PalFX?(), false); 
  }
  public void setPos(float x, float y)
  {
    `x = x;
    `y = y;
  }
  public void addPos(float x, float y)
  {
    `x += x;
    `y += y;
  }
  public void setScale(float x, float y)
  {
    `xscl = x;
    `yscl = y;
  }
  public void setTile(int x, int y)
  {
    `ani~tile.w = x;
    `ani~tile.h = y;
  }
  public void setColorKey(int ck)
  {
    `ani~mask = ck;
  }
  public void setAlpha(short sa, short da)
  {
    `ani~salpha = sa;
    `ani~dalpha = da;
  }
  public void setWindow(float x, float y, float w, float h)
  {
    `window.x = (int)((x+(float)(.com.GameWidth-320)/2.0)*.com.WidthScale);
    `window.y = (int)((y+(float)(.com.GameHeight-240))*.com.HeightScale);
    `window.w = (int)(w * .com.WidthScale + 0.5);
    `window.h = (int)(h * .com.HeightScale + 0.5);
	`winX = x;
    `winY = y;
    `winW = w;
    `winH = h;
  }
  public void updateWindow()
  {
    `window.x = (int)((`winX+(float)(.com.GameWidth-320)/2.0)*.com.WidthScale);
    `window.y = (int)((`winY+(float)(.com.GameHeight-240))*.com.HeightScale);
    `window.w = (int)(`winW * .com.WidthScale + 0.5);
    `window.h = (int)(`winH * .com.HeightScale + 0.5);
    `oldScale = .com.WidthScale;
  }
}
void animNew(&.lua.State L=, int re=)
{
  int argc = 0, nret = 1;
  ^&.Anim anim.new(1);
  ^&.sc.Sff sff = .sc.refArg!&.sc.Sff?(L=, re=, argc=, nret); if(re < 0) ret;
  ^/char action = .sc.strArg(L=, re=, argc=, nret); if(re < 0) ret;
  anim~setSff(sff~getSff());
  if(!anim~setAction(action)){
    L.pushString(
      \r\n + action[0..4096] + \r\n\r\n"Failed to load anim data.");
    re = -1;
    ret;
  }
  L.pushRef(anim);
}
void animSetPos(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^&.Anim anim = .sc.refArg!&.Anim?(L=, re=, argc=, nret); if(re < 0) ret;
  float x = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float y = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  anim~setPos(x, y);
}
void animAddPos(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^&.Anim anim = .sc.refArg!&.Anim?(L=, re=, argc=, nret); if(re < 0) ret;
  float x = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float y = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  anim~addPos(x, y);
}
void animSetTile(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^&.Anim anim = .sc.refArg!&.Anim?(L=, re=, argc=, nret); if(re < 0) ret;
  int x = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  int y = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  anim~setTile(x, y);
}
void animSetColorKey(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^&.Anim anim = .sc.refArg!&.Anim?(L=, re=, argc=, nret); if(re < 0) ret;
  int ck = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  anim~setColorKey(ck);
}
void animSetAlpha(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^&.Anim anim = .sc.refArg!&.Anim?(L=, re=, argc=, nret); if(re < 0) ret;
  int x = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  int y = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  anim~setAlpha(x, y);
}
void animSetScale(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^&.Anim anim = .sc.refArg!&.Anim?(L=, re=, argc=, nret); if(re < 0) ret;
  float x = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float y = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  anim~setScale(x, y);
}
void animSetWindow(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^&.Anim anim = .sc.refArg!&.Anim?(L=, re=, argc=, nret); if(re < 0) ret;
  float x = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float y = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float w = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float h = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  anim~setWindow(x, y, w, h);
}
void animGetFrame(&.lua.State L=, int re=)
{
  int argc = 0, nret = 1;
  ^&.Anim anim = .sc.refArg!&.Anim?(L=, re=, argc=, nret); if(re < 0) ret;
  branch{
  cond #anim > 0: L.pushNumber((double)anim~animTime());
  else: L.pushNumber((double)0);
  }
}
void animUpdate(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^&.Anim anim = .sc.refArg!&.Anim?(L=, re=, argc=, nret); if(re < 0) ret;
  anim~update();
}
void animReset(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^&.Anim anim = .sc.refArg!&.Anim?(L=, re=, argc=, nret); if(re < 0) ret;
  anim~reset();
}
void animDraw(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^&.Anim anim = .sc.refArg!&.Anim?(L=, re=, argc=, nret); if(re < 0) ret;
  anim~draw();
}

void enterNetPlay(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^/char host = .sc.strArg(L=, re=, argc=, nret); if(re < 0) ret;
  if(#.cmd.net > 0){
    L.pushString("Already communicating.");
    re = -1;
    ret;
  }
  .chr.chars.new(#.chr.chars);
  .cmd.net.new(1);
  .cmd.net~openReplayFile("saved/data.replay");
  branch{
  cond #host > 0:
    .cmd.net~connect(host, .listenPort);
  else:
    .cmd.net~accept(.listenPort);
  }
}

void exitNetPlay(&.lua.State L=, int re=)
{
  re = 0;
  .cmd.net.new(0);
}

void enterReplay(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^/char file = .sc.strArg(L=, re=, argc=, nret); if(re < 0) ret;
  .chr.chars.new(#.chr.chars);
  .cmd.replay.new(1);
  .cmd.replay~open(file);
}

void exitReplay(&.lua.State L=, int re=)
{
  re = 0;
  .cmd.replay.new(0);
}

void setCom(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  int pn = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  if(!.m.inRange!int?(1, #.chr.chars, pn)){
    L.pushString("Invalid player number.");
    re = -1;
    ret;
  }
  int ai = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  .m.limMin!int?(ai=, 0);
  .com.com[pn-1] = ai;
}

void setAutoLevel(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  bool b = .sc.blArg(L=, re=, argc=, nret); if(re < 0) ret;
  .com.autolevel = b;
}

void setGameType(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  int gm = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  .com.gameType = gm;
}

void setServiceType(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  int st = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  .com.serviceType = st;
}

void getListenPort(&.lua.State L=, int re=)
{
  re = 1;
  L.pushString(.listenPort);
}

void connected(&.lua.State L=, int re=)
{
  re = 1;
  L.pushBoolean(#.cmd.net > 0 && .cmd.net~isConnected());
}

void setListenPort(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^/char port = .sc.strArg(L=, re=, argc=, nret); if(re < 0) ret;
  if(#port > 0) .listenPort = port;
}

void getUserName(&.lua.State L=, int re=)
{
  re = 1;
  L.pushString(.UserName);
}

void setUserName(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^/char name = .sc.strArg(L=, re=, argc=, nret); if(re < 0) ret;
  .UserName = name;
}

void setVolume(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  float g = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float s = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float b = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  .sdl.setVolume(g, s, b);
}

void setPanStr(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  float p = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  .snd.panstr = p;
}

void synchronize(&.lua.State L=, int re=)
{
  re = 0;
  if(!.cmd.synchronize()){
    L.pushString("Synchronization error.");
    re = -1;
    ret;
  }
}

void getWidth(&.lua.State L=, int re=)
{
  re = 1;
  L.pushNumber((double).sdl.getWidth());
}

void getHeight(&.lua.State L=, int re=)
{
  re = 1;
  L.pushNumber((double).sdl.getHeight());
}

void setGameRes(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  int w = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  int h = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  .com.setSize(w,h);
  .sdl.windowSize(w,h);
}

void getScreenMode(&.lua.State L=, int re=)
{
  re = 1;
  L.pushBoolean(.se.full);
}

void setScreenMode(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  bool f = .sc.blArg(L=, re=, argc=, nret); if(re < 0) ret;
  if(.sdl.fullScreen(f)) .sdl.showCursor(!f);
  .se.full = f;
}

void swapGamepad(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  int jnP1 = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  int jnP2 = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  .cfg.in[2].jn = jnP1;
  .cfg.in[3].jn = jnP2;
  .cfg.in[12].jn = jnP1;
  .cfg.in[13].jn = jnP2;
}

void getInputKey(&.lua.State L=, int re=)
{
  re = 1;
  branch{
	cond .sdl.KeyState(:.se.sdle.key.keysym.scancode:) == true && .keyReset == false:
	  L.pushNumber((double).se.sdle.key.keysym.scancode);
	  //.keyReset = true;
	else:
	  L.pushNumber((double)0);
  }
  if(.sdl.KeyState(:.se.sdle.key.keysym.scancode:) == false && .keyReset == true) .keyReset = false;
}

void getInputID(&.lua.State L=, int re=)
{
  int argc = 0, nret = 1;
  int j = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  L.pushNumber((double)101); //Something outside the range we're checking.
    loop{index i = -100; while; do:
      if((int).sdl.JoystickButtonState(:j,i:) == 1){
        branch{ //Can't use a switch function here apparently.
        cond j == .cfg.in[2].jn:
          .p1PadButtonID = i;
          if(!.p1PadReset) L.pushNumber((double)i);
          .p1PadReset = true;
        cond j == .cfg.in[3].jn:
          .p2PadButtonID = i;
          if(!.p2PadReset) L.pushNumber((double)i);
          .p2PadReset = true;
        }
      }
      i++;
    while i <= 100:}
  branch{
  cond j == .cfg.in[2].jn:
    if((int).sdl.JoystickButtonState(:j,.p1PadButtonID:) == 0 && .p1PadReset) .p1PadReset = false;
  cond j == .cfg.in[3].jn:
    if((int).sdl.JoystickButtonState(:j,.p2PadButtonID:) == 0 && .p2PadReset) .p2PadReset = false;
  }
}

void inputReset(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  int c = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  branch{ //Not being able to use a switch here sucks.
  cond c == -1: .keyReset = true;
  cond c == .cfg.in[2].jn: .p1PadReset = true;
  cond c == .cfg.in[3].jn: .p2PadReset = true;	
  }
}

void setInputConfig(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  int pn = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  int cn = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  int u = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  int d = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  int l = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  int r = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  int a = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  int b = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  int c = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  int x = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  int y = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  int z = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  int se = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  int st = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  .cfg.in[pn].set(
    cn,
    u,
    d,
    l,
    r,
    a,
    b,
    c,
    x,
    y,
    z,
    se);
  .cfg.in[pn+10].set(
    cn,
    u,
    d,
    l,
    r,
    a,
    b,
    c,
    x,
    y,
    z,
    st);
}

void addChar(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^^/char lines = .s.splitLines(.sc.strArg(L=, re=, argc=, nret));
  if(re < 0) ret;
  loop{index i = 0; while; do:
    .syst.selinf.sel.addChar(lines[i]);
    i++;
  while i < #lines:}
}

void addStage(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^^/char lines = .s.splitLines(.sc.strArg(L=, re=, argc=, nret));
  if(re < 0) ret;
  loop{index i = 0; while; do:
    .syst.selinf.sel.addStage(lines[i]);
    i++;
  while i < #lines:}
}

void setRandomSpr(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^&.sc.Sff sff = .sc.refArg!&.sc.Sff?(L=, re=, argc=, nret); if(re < 0) ret;
  int g = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  int n = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float xs = .syst.selinf.sel.randxscl, ys = .syst.selinf.sel.randyscl;
  if(L.getTop() > argc){
    xs = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  }
  if(L.getTop() > argc){
    ys = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  }
  ^&.sff.Sff sf = sff~getSff();
  if(#sf > 0) .syst.selinf.sel.randomspr = sf~getOwnPalSprite(g, n);
  .syst.selinf.sel.randxscl = xs;
  .syst.selinf.sel.randyscl = ys;
}

void setSelColRow(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  int c = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  int r = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  .syst.selinf.sel.columns = c;
  .syst.selinf.sel.rows = r;
}

void setSelCellSize(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  float x = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float y = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  .syst.selinf.sel.cellsizex = x;
  .syst.selinf.sel.cellsizey = y;
}

void setSelCellScale(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  float x = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float y = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  .syst.selinf.sel.cellscalex = x;
  .syst.selinf.sel.cellscaley = y;
}

void numSelCells(&.lua.State L=, int re=)
{
  re = 1;
  L.pushNumber((double)#.syst.selinf.sel.charlist);
}

void setStage(&.lua.State L=, int re=)
{
  int argc = 0, nret = 1;
  int n = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  L.pushNumber((double).syst.selinf.sel.setStageNo(n));
}

void selectStage(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  int n = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  .syst.selinf.sel.selectStage(n);
}

void setTeamMode(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  int pn = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  if(!.m.inRange!int?(1, 2, pn)){
    L.pushString("Invalid team number.");
    re = -1;
    ret;
  }
  int tm = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  if(!.m.inRange!int?(0, 2, tm)){
    L.pushString("Invalid mode number.");
    re = -1;
    ret;
  }
  int nt = 1;
  if(tm >= 1){
    nt = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
    if(!.m.inRange!int?(1, 10, nt)){
      L.pushString("Incorrect team size.");
      re = -1;
      ret;
    }
  }
  .syst.selinf.p[pn-1].selchr.new(0);
  .com.tmode[pn-1] = tm;
  .com.numturns[pn-1] = .com.numSimul[pn-1] = nt;
  if(tm == 1 && nt == 1) .com.tmode[pn-1] = 0;
}

void getCharName(&.lua.State L=, int re=)
{
  int argc = 0, nret = 1;
  int n = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  ^&.sys.Select::Char c = .syst.selinf.sel.getChar(n);
  L.pushString(#c > 0 ? c~name : "");
}

void getCharFileName(&.lua.State L=, int re=)
{
  int argc = 0, nret = 1;
  int n = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  ^&.sys.Select::Char c = .syst.selinf.sel.getChar(n);
  L.pushString(#c > 0 ? c~def : "");
}

void selectChar(&.lua.State L=, int re=)
{
  int argc = 0, nret = 1;
  int pn = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  if(!.m.inRange!int?(1, 2, pn)){
    L.pushString("Invalid team number.");
    re = -1;
    ret;
  }
  int cn = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  int pl = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  int retval = 0;
  if(.m.inRange!int?(1, 12, pl) && .syst.selinf.addSelchr(pn-1, cn, pl)){
    switch(.com.tmode[pn-1]){
    case (int).com.TeamMode::Single:
      retval = 2;
    case (int).com.TeamMode::Simul:
      retval = #.syst.selinf.p[pn-1].selchr >= .com.numSimul[pn-1] ? 2 : 1;
    case (int).com.TeamMode::Turns:
      retval = #.syst.selinf.p[pn-1].selchr >= .com.numturns[pn-1] ? 2 : 1;
    }
  }
  L.pushNumber((double)retval);
}

void getStageName(&.lua.State L=, int re=)
{
  int argc = 0, nret = 1;
  int n = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  L.pushString(.syst.selinf.sel.getStageName(n));
}

void refresh(&.lua.State L=, int re=)
{
  re = 0;
  if(!.se.fskip){
  /?/*.cfg.OpenGL:
    .sdl.GlSwapBuffers(::);
  /*true:
    .sdl.flip();
    .com.screenFill(0x00000000);
  /*?*/
  }
  .snd.playSound();
  if(!.cmd.update()) .se.end = true;
  if(.se.end){
    L.pushString("<game end>");
    re = -1;
  }
}

void drawPortrait(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  index n = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float x = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float y = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float xscl = 1.0, yscl = 1.0;
  if(L.getTop() > argc){
    xscl = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  }
  if(L.getTop() > argc){
    yscl = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  }
  if(!.se.fskip){
    ^&.sys.Select::Char c = .syst.selinf.sel.getChar(n);
    if(#c > 0 && #c~lportrait > 0){
      c~lportrait~draw(x, y, xscl, yscl, c~lportrait~colorPallet);
    }
  }
}

void drawFace(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  float x = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  float y = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  int offset = 0;
  if(L.getTop() > argc){
    offset = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  }
  if(!.se.fskip) loop{
    int j = 0;
    ^&.sys.Select::Char c;
    while;
  do:
    loop{int i = 0; while; do:
      c = .syst.selinf.sel.getChar(offset++);
      if(#c > 0) branch{
      cond #c~sportrait > 0:
        c~sportrait~draw(
          x + (float)i*.syst.selinf.sel.cellsizex,
          y + (float)j*.syst.selinf.sel.cellsizey,
          .syst.selinf.sel.cellscalex, .syst.selinf.sel.cellscaley,
          c~sportrait~colorPallet);
      cond .s.equ(c~def, "randomselect") && #.syst.selinf.sel.randomspr > 0:
        .syst.selinf.sel.randomspr~draw(
          x + (float)i*.syst.selinf.sel.cellsizex,
          y + (float)j*.syst.selinf.sel.cellsizey,
          .syst.selinf.sel.randxscl, .syst.selinf.sel.randxscl,
          .syst.selinf.sel.randomspr~colorPallet);
      }
      i++;
    while i < .syst.selinf.sel.columns:}
    j++;
  while j < .syst.selinf.sel.rows:}
}

void loadLifebar(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^/char lifebar = .sc.strArg(L=, re=, argc=, nret); if(re < 0) ret;
  .syst.fig.new(1);
  ^/char error;
  if(#.syst.fig~load(lifebar)=>error > 0){
    L.pushString(error);
    re = -1;
    ret;
  }
}

void loadDebugFont(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^/char font = .sc.strArg(L=, re=, argc=, nret); if(re < 0) ret;
  .fnt.debugFont.new(1);
  .fnt.debugFont~loadFile(font);
}

void setDebugScript(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  ^/char dscript = .sc.strArg(L=, re=, argc=, nret); if(re < 0) ret;
  .com.debugScript = dscript;
}

void setLifeMul(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  float l = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  .com.life = l;
}

void setTeam1VS2Life(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  float t12 = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  .com.team1VS2Life = t12;
}

void setTurnsRecoveryRate(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  float tr = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  .com.turnsRecoveryRate = tr;
}

void setZoom(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  bool z = .sc.blArg(L=, re=, argc=, nret); if(re < 0) ret;
  .com.cam.zoom = z;
}

void setZoomMin(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  float zmi = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  .com.cam.zoomMin = zmi;
}

void setZoomMax(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  float zma = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  .com.cam.zoomMax = zma;
}

void setZoomSpeed(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  float zs = .sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  .com.cam.zoomSpeed = 12.0 - zs;
}

void resetRemapInput(&.lua.State L=, int re=)
{
  re = 0;
  .com.resetRemapInput();
}

void remapInput(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  int src = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  int dest = (int).sc.numArg(L=, re=, argc=, nret); if(re < 0) ret;
  if(
    !.m.inRange!int?(1, #.com.inputRemap, src)
    || !.m.inRange!int?(1, #.com.inputRemap, dest))
  {
    L.pushString("Invalid player number.");
    re = -1;
    ret;
  }
  .com.inputRemap[src-1] = dest-1;
}

void setSharedLife(&.lua.State L=, int re=)
{
  int argc = 0, nret = 0;
  bool b = .sc.blArg(L=, re=, argc=, nret); if(re < 0) ret;
  .com.sharedLife = b;
}

void setHUD(&.lua.State L=, int re=)//Search setHUD in main.lua
{
  int argc = 0, nret = 0;
  bool b = .sc.blArg(L=, re=, argc=, nret); if(re < 0) ret;
  .com.statusDraw = b;
}

public void init(&.lua.State L=)
{
  .sc.init(L=);
  L.register("textImgNew", .textImgNew);
  L.register("textImgGetWidth", .textImgGetWidth);
  L.register("textImgSetFont", .textImgSetFont);
  L.register("textImgSetBank", .textImgSetBank);
  L.register("textImgSetAlpha", .textImgSetAlpha);
  L.register("textImgSetWindow", .textImgSetWindow);
  L.register("textImgSetAlign", .textImgSetAlign);
  L.register("textImgSetText", .textImgSetText);
  L.register("textImgSetPos", .textImgSetPos);
  L.register("textImgAddPos", .textImgAddPos);
  L.register("textImgSetScale", .textImgSetScale);
  L.register("textImgDraw", .textImgDraw);
  L.register("animNew", .animNew);
  L.register("animSetPos", .animSetPos);
  L.register("animAddPos", .animAddPos);
  L.register("animSetTile", .animSetTile);
  L.register("animSetColorKey", .animSetColorKey);
  L.register("animSetAlpha", .animSetAlpha);
  L.register("animSetScale", .animSetScale);
  L.register("animSetWindow", .animSetWindow);
  L.register("animGetFrame", .animGetFrame);
  L.register("animUpdate", .animUpdate);
  L.register("animReset", .animReset);
  L.register("animDraw", .animDraw);
  L.register("enterNetPlay", .enterNetPlay);
  L.register("exitNetPlay", .exitNetPlay);
  L.register("enterReplay", .enterReplay);
  L.register("exitReplay", .exitReplay);
  L.register("setCom", .setCom);
  L.register("setAutoLevel", .setAutoLevel);
  L.register("setGameType", .setGameType);
  L.register("setServiceType", .setServiceType);
  L.register("getListenPort", .getListenPort);
  L.register("setListenPort", .setListenPort);
  L.register("getUserName", .getUserName);
  L.register("setUserName", .setUserName);
  L.register("setVolume", .setVolume);
  L.register("setPanStr", .setPanStr);
  L.register("getWidth", .getWidth);
  L.register("getHeight", .getHeight);
  L.register("setGameRes", .setGameRes);
  L.register("getScreenMode", .getScreenMode);
  L.register("setScreenMode", .setScreenMode); 
  L.register("connected", .connected);
  L.register("synchronize", .synchronize);
  L.register("addChar", .addChar);
  L.register("addStage", .addStage);
  L.register("setRandomSpr", .setRandomSpr);
  L.register("setSelColRow", .setSelColRow);
  L.register("setSelCellSize", .setSelCellSize);
  L.register("setSelCellScale", .setSelCellScale);
  L.register("numSelCells", .numSelCells);
  L.register("setStage", .setStage);
  L.register("selectStage", .selectStage);
  L.register("setTeamMode", .setTeamMode);
  L.register("getCharName", .getCharName);
  L.register("getCharFileName", .getCharFileName);
  L.register("selectChar", .selectChar);
  L.register("getStageName", .getStageName);
  L.register("refresh", .refresh);
  L.register("drawPortrait", .drawPortrait);
  L.register("drawFace", .drawFace);
  L.register("loadLifebar", .loadLifebar);
  L.register("loadDebugFont", .loadDebugFont);
  L.register("setDebugScript", .setDebugScript);
  L.register("setLifeMul", .setLifeMul);
  L.register("setTeam1VS2Life", .setTeam1VS2Life);
  L.register("setTurnsRecoveryRate", .setTurnsRecoveryRate);
  L.register("setZoom", .setZoom);
  L.register("setZoomMin", .setZoomMin);
  L.register("setZoomMax", .setZoomMax);
  L.register("setZoomSpeed", .setZoomSpeed);
  L.register("swapGamepad", .swapGamepad);
  L.register("getInputKey", .getInputKey);
  L.register("getInputID", .getInputID);
  L.register("inputReset", .inputReset);
  L.register("setInputConfig", .setInputConfig);  
  L.register("resetRemapInput", .resetRemapInput);
  L.register("remapInput", .remapInput);
  L.register("setSharedLife", .setSharedLife);
  L.register("setHUD", .setHUD);
}


